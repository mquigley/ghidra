INFO  Using log config file: file:/Users/matt.quigley/dev/projects/ghidra/Ghidra/Framework/Generic/bin/main/generic.log4jdev.xml   (LoggingInitialization.java:50) 
INFO  Using log file: /Users/matt.quigley/.ghidra/.ghidra_10.3_DEV_location_projects/application.log   (LoggingInitialization.java:51) 
INFO  Loading user preferences: /Users/matt.quigley/.ghidra/.ghidra_10.3_DEV_location_projects/preferences   (Preferences.java:117) 
INFO  Class search complete (1527 ms)   (ClassSearcher.java:276) 
INFO  User matt.quigley started Ghidra.   (GhidraRun.java:78) 
INFO  Packed database cache: /var/folders/cz/2dcg_2251dgdn6wqks1xlw580000gp/T/matt.quigley-Ghidra/packed-db-cache   (PackedDatabaseCache.java:64) 
DEBUG Using cached packed database: /Users/matt.quigley/dev/projects/ghidra/Ghidra/Features/Base/data/typeinfo/generic/generic_clib.gdt   (PackedDatabaseCache.java:364) 

Line ia.sinc:1691 :ADD rm8,Reg8      is vexMode=0 & byte=0x00; rm8 & Reg8 ...                 { addflags(  rm8,Reg8 );   rm8 =   rm8 +  Reg8; resultflags(  rm8); }
0: Constructor line ia.sinc:1691(id0.46) printpiece=[ADD,  ,  A, ,,  B]
Operands 0: rm8 : 1443  1: Reg8 : 1444  
Pattern id=46 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:00:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2389 :VPSHUFB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x00; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpshufb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2389(id0.1790) printpiece=[VPSHUFB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5618  1: vexVVVV_XmmReg : 5616  2: XmmReg1 : 5615  3: YmmReg1 : 5619  4: XmmReg2_m128 : 5617  
Pattern id=1790 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:00:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b1100:10] = CALLOTHER const[1a9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b1100:10]

Line avx2.sinc:583 :VPSHUFB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x00; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpshufb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:583(id0.1997) printpiece=[VPSHUFB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6591  1: vexVVVV_YmmReg : 6589  2: YmmReg1 : 6588  3: YmmReg2_m256 : 6590  
Pattern id=1997 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:00:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[23f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1080 :VPERMQ YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W1); byte=0x00; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpermq_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1080(id0.2055) printpiece=[VPERMQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: YmmReg1 : 6848  1: YmmReg2_m256 : 6849  2: imm8 : 6850  
Pattern id=2055 pattern=cmb:(ctx:SS:X3:XC:0[011x]:XX,ins:00:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:1692 :ADD rm16,Reg16    is vexMode=0 & opsize=0 & byte=0x1; rm16 & Reg16 ...     { addflags( rm16,Reg16);  rm16 =  rm16 + Reg16; resultflags( rm16); }
0: Constructor line ia.sinc:1692(id0.47) printpiece=[ADD,  ,  A, ,,  B]
Operands 0: rm16 : 1445  1: Reg16 : 1446  
Pattern id=47 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:01:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1693 :ADD rm32,Reg32    is vexMode=0 & opsize=1 & byte=0x1; rm32 & check_rm32_dest ... & Reg32 ...     { addflags( rm32,Reg32);  rm32 =  rm32 + Reg32; build check_rm32_dest; resultflags( rm32); }
0: Constructor line ia.sinc:1693(id0.48) printpiece=[ADD,  ,  A, ,,  C]
Operands 0: rm32 : 1447  1: check_rm32_dest : 1449  2: Reg32 : 1448  
Pattern id=48 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:01:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1973 :VPHADDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x01; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphaddw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1973(id0.1745) printpiece=[VPHADDW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5366  1: vexVVVV_XmmReg : 5364  2: XmmReg1 : 5363  3: YmmReg1 : 5367  4: XmmReg2_m128 : 5365  
Pattern id=1745 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:01:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[acd80:10] = CALLOTHER const[17b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[acd80:10]

Line avx2.sinc:255 :VPHADDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x01; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphaddw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:255(id0.1956) printpiece=[VPHADDW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6404  1: vexVVVV_YmmReg : 6402  2: YmmReg1 : 6401  3: YmmReg2_m256 : 6403  
Pattern id=1956 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:01:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[216:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1064 :VPERMPD YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W1); byte=0x01; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpermpd_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1064(id0.2053) printpiece=[VPERMPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: YmmReg1 : 6840  1: YmmReg2_m256 : 6841  2: imm8 : 6842  
Pattern id=2053 pattern=cmb:(ctx:SS:X3:XC:0[011x]:XX,ins:01:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:1697 :ADD Reg8,rm8      is vexMode=0 & byte=0x2; rm8 & Reg8 ...                             { addflags( Reg8,rm8  );  Reg8 =  Reg8 +   rm8; resultflags( Reg8); }
0: Constructor line ia.sinc:1697(id0.49) printpiece=[ADD,  ,  B, ,,  A]
Operands 0: rm8 : 1451  1: Reg8 : 1450  
Pattern id=49 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:02:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1982 :VPHADDD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x02; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphaddd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1982(id0.1746) printpiece=[VPHADDD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5372  1: vexVVVV_XmmReg : 5370  2: XmmReg1 : 5369  3: YmmReg1 : 5373  4: XmmReg2_m128 : 5371  
Pattern id=1746 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:02:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[acf00:10] = CALLOTHER const[17c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[acf00:10]

Line avx2.sinc:960 :VPBLENDD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x02; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpblendd_avx2( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:960(id0.2040) printpiece=[VPBLENDD,  ,  B, ,,  ,  A, ,,  ,  D, ,,  ,  E]
Operands 0: vexVVVV_XmmReg : 6795  1: XmmReg1 : 6794  2: YmmReg1 : 6798  3: XmmReg2_m128 : 6796  4: imm8 : 6797  
Pattern id=2040 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][011x]:XX,ins:02:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[bf900:10] = CALLOTHER const[262:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[bf900:10]

Line avx2.sinc:263 :VPHADDD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x02; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphaddd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:263(id0.1957) printpiece=[VPHADDD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6409  1: vexVVVV_YmmReg : 6407  2: YmmReg1 : 6406  3: YmmReg2_m256 : 6408  
Pattern id=1957 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:02:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[217:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:968 :VPBLENDD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x02; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpblendd_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:968(id0.2041) printpiece=[VPBLENDD,  ,  B, ,,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: vexVVVV_YmmReg : 6800  1: YmmReg1 : 6799  2: YmmReg2_m256 : 6801  3: imm8 : 6802  
Pattern id=2041 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][011x]:XX,ins:02:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[262:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:1698 :ADD Reg16,rm16    is vexMode=0 & opsize=0 & byte=0x3; rm16 & Reg16 ...     { addflags(Reg16,rm16 ); Reg16 = Reg16 +  rm16; resultflags(Reg16); }
0: Constructor line ia.sinc:1698(id0.50) printpiece=[ADD,  ,  B, ,,  A]
Operands 0: rm16 : 1453  1: Reg16 : 1452  
Pattern id=50 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:03:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1699 :ADD Reg32,rm32    is vexMode=0 & opsize=1 & byte=0x3; rm32 & Reg32 ... & check_Reg32_dest ...     { addflags(Reg32,rm32 ); Reg32 = Reg32 +  rm32; build check_Reg32_dest; resultflags(Reg32); }
0: Constructor line ia.sinc:1699(id0.51) printpiece=[ADD,  ,  B, ,,  A]
Operands 0: rm32 : 1455  1: Reg32 : 1454  2: check_Reg32_dest : 1456  
Pattern id=51 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:03:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[2:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1991 :VPHADDSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x03; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphaddsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1991(id0.1747) printpiece=[VPHADDSW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5378  1: vexVVVV_XmmReg : 5376  2: XmmReg1 : 5375  3: YmmReg1 : 5379  4: XmmReg2_m128 : 5377  
Pattern id=1747 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:03:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ad080:10] = CALLOTHER const[17d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ad080:10]

Line avx2.sinc:271 :VPHADDSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x03; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphaddsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:271(id0.1958) printpiece=[VPHADDSW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6414  1: vexVVVV_YmmReg : 6412  2: YmmReg1 : 6411  3: YmmReg2_m256 : 6413  
Pattern id=1958 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:03:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[218:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1674 :ADD AL,imm8		is vexMode=0 & byte=0x4; AL & imm8					{ addflags(   AL,imm8 );    AL =    AL +  imm8; resultflags(   AL); }
0: Constructor line ia.sinc:1674(id0.38) printpiece=[ADD,  ,  A, ,,  B]
Operands 0: AL : 1424  1: imm8 : 1425  
Pattern id=38 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:04:XX:XX:XX)
Template
	0: register[200:1] = INT_CARRY register[0:1], [handle:space][[handle:offset]:1]
	1: register[20b:1] = INT_SCARRY register[0:1], [handle:space][[handle:offset]:1]
	2: register[0:1] = INT_ADD register[0:1], [handle:space][[handle:offset]:1]
	3: register[207:1] = INT_SLESS register[0:1], const[0:1]
	4: register[206:1] = INT_EQUAL register[0:1], const[0:1]
	5: unique[dc80:1] = INT_AND register[0:1], const[ff:1]
	6: unique[dd00:1] = POPCOUNT unique[dc80:1]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2074 :VPMADDUBSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x04; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaddubsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2074(id0.1755) printpiece=[VPMADDUBSW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5426  1: vexVVVV_XmmReg : 5424  2: XmmReg1 : 5423  3: YmmReg1 : 5427  4: XmmReg2_m128 : 5425  
Pattern id=1755 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:04:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[adc80:10] = CALLOTHER const[186:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[adc80:10]

Line avx.sinc:3253 :VPERMILPS XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x04; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpermilps_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3253(id0.1896) printpiece=[VPERMILPS,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: XmmReg1 : 6139  1: YmmReg1 : 6142  2: XmmReg2_m128 : 6140  3: imm8 : 6141  
Pattern id=1896 pattern=cmb:(ctx:SS:X2:X8:0[011x]:XX,ins:04:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[b8100:10] = CALLOTHER const[1f0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b8100:10]

Line avx2.sinc:303 :VPMADDUBSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x04; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaddubsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:303(id0.1962) printpiece=[VPMADDUBSW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6434  1: vexVVVV_YmmReg : 6432  2: YmmReg1 : 6431  3: YmmReg2_m256 : 6433  
Pattern id=1962 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:04:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[21c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3268 :VPERMILPS YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x04; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpermilps_avx( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3268(id0.1898) printpiece=[VPERMILPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: YmmReg1 : 6146  1: YmmReg2_m256 : 6147  2: imm8 : 6148  
Pattern id=1898 pattern=cmb:(ctx:SS:X2:XC:0[011x]:XX,ins:04:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1f0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:1675 :ADD AX,imm16		is vexMode=0 & opsize=0 & byte=0x5; AX & imm16			{ addflags(   AX,imm16);    AX =    AX + imm16; resultflags(   AX); }
0: Constructor line ia.sinc:1675(id0.39) printpiece=[ADD,  ,  A, ,,  B]
Operands 0: AX : 1426  1: imm16 : 1427  
Pattern id=39 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:05:XX:XX:XX)
Template
	0: register[200:1] = INT_CARRY register[0:2], [handle:space][[handle:offset]:2]
	1: register[20b:1] = INT_SCARRY register[0:2], [handle:space][[handle:offset]:2]
	2: register[0:2] = INT_ADD register[0:2], [handle:space][[handle:offset]:2]
	3: register[207:1] = INT_SLESS register[0:2], const[0:2]
	4: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	5: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	6: unique[dd00:1] = POPCOUNT unique[dc80:2]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1676 :ADD EAX,imm32		is vexMode=0 & opsize=1 & byte=0x5; EAX & check_EAX_dest & imm32			{ addflags(  EAX,imm32);   EAX =   EAX + imm32; build check_EAX_dest; resultflags(  EAX); }
0: Constructor line ia.sinc:1676(id0.40) printpiece=[ADD,  ,  A, ,,  C]
Operands 0: EAX : 1428  1: check_EAX_dest : 1430  2: imm32 : 1429  
Pattern id=40 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:05:XX:XX:XX)
Template
	0: register[200:1] = INT_CARRY register[0:4], [handle:space][[handle:offset]:4]
	1: register[20b:1] = INT_SCARRY register[0:4], [handle:space][[handle:offset]:4]
	2: register[0:4] = INT_ADD register[0:4], [handle:space][[handle:offset]:4]
	3: MULTIEQUAL const[1:4]
	4: register[207:1] = INT_SLESS register[0:4], const[0:4]
	5: register[206:1] = INT_EQUAL register[0:4], const[0:4]
	6: unique[dc80:4] = INT_AND register[0:4], const[ff:4]
	7: unique[dd00:1] = POPCOUNT unique[dc80:4]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2009 :VPHSUBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x05; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphsubw_avx( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2009(id0.1749) printpiece=[VPHSUBW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5389  1: vexVVVV_XmmReg : 5387  2: XmmReg1 : 5386  3: YmmReg1 : 5390  4: XmmReg2_m128 : 5388  
Pattern id=1749 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:05:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ad380:10] = CALLOTHER const[17f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ad380:10]

Line avx.sinc:3229 :VPERMILPD XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x05; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpermilpd_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3229(id0.1893) printpiece=[VPERMILPD,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: XmmReg1 : 6127  1: YmmReg1 : 6130  2: XmmReg2_m128 : 6128  3: imm8 : 6129  
Pattern id=1893 pattern=cmb:(ctx:SS:X2:X8:0[011x]:XX,ins:05:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[b7d80:10] = CALLOTHER const[1ef:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b7d80:10]

Line avx2.sinc:279 :VPHSUBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x05; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphsubw_avx2( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:279(id0.1959) printpiece=[VPHSUBW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6419  1: vexVVVV_YmmReg : 6417  2: YmmReg1 : 6416  3: YmmReg2_m256 : 6418  
Pattern id=1959 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:05:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[219:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3237 :VPERMILPD YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x05; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpermilpd_avx( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3237(id0.1894) printpiece=[VPERMILPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: YmmReg1 : 6131  1: YmmReg2_m256 : 6132  2: imm8 : 6133  
Pattern id=1894 pattern=cmb:(ctx:SS:X2:XC:0[011x]:XX,ins:05:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ef:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3378 :PUSH ES        is vexMode=0 & addrsize=0 & byte=0x6 & ES               { push22(ES); }
0: Constructor line ia.sinc:3378(id0.422) printpiece=[PUSH,  ,  A]
Operands 0: ES : 2100  
Pattern id=422 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:06:XX:XX:XX)
Template
	0: unique[9400:2] = COPY register[100:2]
	1: register[10:2] = INT_SUB register[10:2], const[2:2]
	2: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	3: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3379 :PUSH ES        is vexMode=0 & addrsize=1 & byte=0x6 & ES               { pushseg44(ES); }
0: Constructor line ia.sinc:3379(id0.423) printpiece=[PUSH,  ,  A]
Operands 0: ES : 2101  
Pattern id=423 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:06:XX:XX:XX)
Template
	0: register[10:4] = INT_SUB register[10:4], const[4:4]
	1: STORE const[ram:8], register[10:4], register[100:2]

Line avx.sinc:2018 :VPHSUBD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x06; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphsubd_avx( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2018(id0.1750) printpiece=[VPHSUBD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5395  1: vexVVVV_XmmReg : 5393  2: XmmReg1 : 5392  3: YmmReg1 : 5396  4: XmmReg2_m128 : 5394  
Pattern id=1750 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:06:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ad500:10] = CALLOTHER const[180:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ad500:10]

Line avx2.sinc:287 :VPHSUBD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x06; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphsubd_avx2( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:287(id0.1960) printpiece=[VPHSUBD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6424  1: vexVVVV_YmmReg : 6422  2: YmmReg1 : 6421  3: YmmReg2_m256 : 6423  
Pattern id=1960 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:06:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[21a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3206 :VPERM2F128 YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x06; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vperm2f128_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3206(id0.1890) printpiece=[VPERM2F128,  ,  B, ,,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: vexVVVV_YmmReg : 6116  1: YmmReg1 : 6115  2: YmmReg2_m256 : 6117  3: imm8 : 6118  
Pattern id=1890 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][011x]:XX,ins:06:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ee:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3290 :POP ES         is vexMode=0 & addrsize=0 & byte=0x7 & ES               { pop22(ES); }
0: Constructor line ia.sinc:3290(id0.375) printpiece=[POP,  ,  A]
Operands 0: ES : 2059  
Pattern id=375 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:07:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[100:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]

Line ia.sinc:3291 :POP ES         is vexMode=0 & addrsize=1 & byte=0x7 & ES               { popseg44(ES); }
0: Constructor line ia.sinc:3291(id0.376) printpiece=[POP,  ,  A]
Operands 0: ES : 2060  
Pattern id=376 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:07:XX:XX:XX)
Template
	0: register[100:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]

Line avx.sinc:2027 :VPHSUBSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x07; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphsubsw_avx( XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2027(id0.1751) printpiece=[VPHSUBSW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5401  1: vexVVVV_XmmReg : 5399  2: XmmReg1 : 5398  3: YmmReg1 : 5402  4: XmmReg2_m128 : 5400  
Pattern id=1751 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:07:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ad680:10] = CALLOTHER const[181:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ad680:10]

Line avx2.sinc:295 :VPHSUBSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x07; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vphsubsw_avx2( YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:295(id0.1961) printpiece=[VPHSUBSW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6429  1: vexVVVV_YmmReg : 6427  2: YmmReg1 : 6426  3: YmmReg2_m256 : 6428  
Pattern id=1961 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:07:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[21b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3243 :OR  rm8,Reg8      is vexMode=0 & byte=0x8; rm8 & Reg8 ...                  { logicalflags();   rm8 =   rm8 |  Reg8; resultflags(  rm8); }
0: Constructor line ia.sinc:3243(id0.348) printpiece=[OR,  ,  A, ,,  B]
Operands 0: rm8 : 2011  1: Reg8 : 2012  
Pattern id=348 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:08:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2425 :VPSIGNB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x08; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsignb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2425(id0.1794) printpiece=[VPSIGNB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5642  1: vexVVVV_XmmReg : 5640  2: XmmReg1 : 5639  3: YmmReg1 : 5643  4: XmmReg2_m128 : 5641  
Pattern id=1794 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:08:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b1700:10] = CALLOTHER const[1ad:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b1700:10]

Line avx.sinc:2795 :VROUNDPS XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x08; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vroundps_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2795(id0.1839) printpiece=[VROUNDPS,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 5884  1: XmmReg1 : 5881  2: YmmReg1 : 5885  3: XmmReg2_m128 : 5882  4: imm8 : 5883  
Pattern id=1839 pattern=cmb:(ctx:SS:X[001x]:X8:0[011x]:XX,ins:08:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b4b80:10] = CALLOTHER const[1cf:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4b80:10]

Line avx2.sinc:615 :VPSIGNB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x08; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsignb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:615(id0.2001) printpiece=[VPSIGNB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6611  1: vexVVVV_YmmReg : 6609  2: YmmReg1 : 6608  3: YmmReg2_m256 : 6610  
Pattern id=2001 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:08:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[243:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2803 :VROUNDPS YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x08; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vroundps_avx( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2803(id0.1840) printpiece=[VROUNDPS,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5889  1: YmmReg1 : 5886  2: YmmReg2_m256 : 5887  3: imm8 : 5888  
Pattern id=1840 pattern=cmb:(ctx:SS:X[001x]:XC:0[011x]:XX,ins:08:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1cf:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3244 :OR  rm16,Reg16        is vexMode=0 & opsize=0 & byte=0x9; rm16 & Reg16 ...     { logicalflags();  rm16 =  rm16 | Reg16; resultflags( rm16); }
0: Constructor line ia.sinc:3244(id0.349) printpiece=[OR,  ,  A, ,,  B]
Operands 0: rm16 : 2013  1: Reg16 : 2014  
Pattern id=349 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:09:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3245 :OR  rm32,Reg32        is vexMode=0 & opsize=1 & byte=0x9; rm32 & check_rm32_dest ... & Reg32 ...     { logicalflags();  rm32 =  rm32 | Reg32; build check_rm32_dest; resultflags( rm32); }
0: Constructor line ia.sinc:3245(id0.350) printpiece=[OR,  ,  A, ,,  C]
Operands 0: rm32 : 2015  1: check_rm32_dest : 2017  2: Reg32 : 2016  
Pattern id=350 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:09:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2434 :VPSIGNW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x09; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsignw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2434(id0.1795) printpiece=[VPSIGNW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5648  1: vexVVVV_XmmReg : 5646  2: XmmReg1 : 5645  3: YmmReg1 : 5649  4: XmmReg2_m128 : 5647  
Pattern id=1795 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:09:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b1880:10] = CALLOTHER const[1ae:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b1880:10]

Line avx.sinc:2779 :VROUNDPD XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x09; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vroundpd_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2779(id0.1837) printpiece=[VROUNDPD,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 5874  1: XmmReg1 : 5871  2: YmmReg1 : 5875  3: XmmReg2_m128 : 5872  4: imm8 : 5873  
Pattern id=1837 pattern=cmb:(ctx:SS:X[001x]:X8:0[011x]:XX,ins:09:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b4980:10] = CALLOTHER const[1ce:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4980:10]

Line avx2.sinc:623 :VPSIGNW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x09; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsignw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:623(id0.2002) printpiece=[VPSIGNW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6616  1: vexVVVV_YmmReg : 6614  2: YmmReg1 : 6613  3: YmmReg2_m256 : 6615  
Pattern id=2002 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:09:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[244:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2787 :VROUNDPD YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x09; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vroundpd_avx( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2787(id0.1838) printpiece=[VROUNDPD,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5879  1: YmmReg1 : 5876  2: YmmReg2_m256 : 5877  3: imm8 : 5878  
Pattern id=1838 pattern=cmb:(ctx:SS:X[001x]:XC:0[011x]:XX,ins:09:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ce:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3249 :OR  Reg8,rm8      is vexMode=0 & byte=0xa; rm8 & Reg8 ...                             { logicalflags();  Reg8 =  Reg8 |   rm8; resultflags( Reg8); }
0: Constructor line ia.sinc:3249(id0.351) printpiece=[OR,  ,  B, ,,  A]
Operands 0: rm8 : 2019  1: Reg8 : 2018  
Pattern id=351 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0A:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2443 :VPSIGND XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsignd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2443(id0.1796) printpiece=[VPSIGND,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5654  1: vexVVVV_XmmReg : 5652  2: XmmReg1 : 5651  3: YmmReg1 : 5655  4: XmmReg2_m128 : 5653  
Pattern id=1796 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:0A:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b1a00:10] = CALLOTHER const[1af:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b1a00:10]

Line avx2.sinc:631 :VPSIGND YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0A; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsignd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:631(id0.2003) printpiece=[VPSIGND,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6621  1: vexVVVV_YmmReg : 6619  2: YmmReg1 : 6618  3: YmmReg2_m256 : 6620  
Pattern id=2003 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:0A:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[245:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2820 :VROUNDSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32, imm8 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0A; (XmmReg1 & YmmReg1) ... & XmmReg2_m32; imm8
{
	local tmp:16 = vroundss_avx( vexVVVV_XmmReg, XmmReg2_m32, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2820(id0.1842) printpiece=[VROUNDSS,  ,  D, ,,  ,  C, ,,  ,  F, ,,  ,  G]
Operands 0: vexL : 5903  1: rexWprefix : 5904  2: vexVVVV_XmmReg : 5900  3: XmmReg1 : 5899  4: YmmReg1 : 5905  5: XmmReg2_m32 : 5901  6: imm8 : 5902  
Pattern id=1842 pattern=cmb:(ctx:SS:X[001x]:X[1xxx]:[xx00][011x]:XX,ins:0A:XX:XX:XX)
Template
	0: MULTIEQUAL const[4:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[3:4]
	3: unique[b4f00:10] = CALLOTHER const[1d1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4f00:10]

Line ia.sinc:3250 :OR  Reg16,rm16        is vexMode=0 & opsize=0 & byte=0xb; rm16 & Reg16 ...     { logicalflags(); Reg16 = Reg16 |  rm16; resultflags(Reg16); }
0: Constructor line ia.sinc:3250(id0.352) printpiece=[OR,  ,  B, ,,  A]
Operands 0: rm16 : 2021  1: Reg16 : 2020  
Pattern id=352 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0B:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3251 :OR  Reg32,rm32        is vexMode=0 & opsize=1 & byte=0xb; rm32 & Reg32 ... & check_Reg32_dest ...    { logicalflags(); Reg32 = Reg32 |  rm32; build check_Reg32_dest; resultflags(Reg32); }
0: Constructor line ia.sinc:3251(id0.353) printpiece=[OR,  ,  B, ,,  A]
Operands 0: rm32 : 2023  1: Reg32 : 2022  2: check_Reg32_dest : 2024  
Pattern id=353 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0B:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[2:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2317 :VPMULHRSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmulhrsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2317(id0.1782) printpiece=[VPMULHRSW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5570  1: vexVVVV_XmmReg : 5568  2: XmmReg1 : 5567  3: YmmReg1 : 5571  4: XmmReg2_m128 : 5569  
Pattern id=1782 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:0B:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b0500:10] = CALLOTHER const[1a1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0500:10]

Line avx2.sinc:519 :VPMULHRSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmulhrsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:519(id0.1989) printpiece=[VPMULHRSW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6551  1: vexVVVV_YmmReg : 6549  2: YmmReg1 : 6548  3: YmmReg2_m256 : 6550  
Pattern id=1989 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:0B:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[237:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2811 :VROUNDSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64, imm8 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0B; (XmmReg1 & YmmReg1) ... & XmmReg2_m64; imm8
{
	local tmp:16 = vroundsd_avx( vexVVVV_XmmReg, XmmReg2_m64, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2811(id0.1841) printpiece=[VROUNDSD,  ,  D, ,,  ,  C, ,,  ,  F, ,,  ,  G]
Operands 0: vexL : 5895  1: rexWprefix : 5896  2: vexVVVV_XmmReg : 5892  3: XmmReg1 : 5891  4: YmmReg1 : 5897  5: XmmReg2_m64 : 5893  6: imm8 : 5894  
Pattern id=1841 pattern=cmb:(ctx:SS:X[001x]:X[1xxx]:[xx00][011x]:XX,ins:0B:XX:XX:XX)
Template
	0: MULTIEQUAL const[4:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[3:4]
	3: unique[b4d80:10] = CALLOTHER const[1d0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4d80:10]

Line ia.sinc:3226 :OR  AL,imm8       is vexMode=0 & byte=0x0c; AL & imm8                                 { logicalflags();    AL =    AL |  imm8; resultflags(   AL); }
0: Constructor line ia.sinc:3226(id0.340) printpiece=[OR,  ,  A, ,,  B]
Operands 0: AL : 1992  1: imm8 : 1993  
Pattern id=340 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0C:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: register[0:1] = INT_OR register[0:1], [handle:space][[handle:offset]:1]
	3: register[207:1] = INT_SLESS register[0:1], const[0:1]
	4: register[206:1] = INT_EQUAL register[0:1], const[0:1]
	5: unique[dc80:1] = INT_AND register[0:1], const[ff:1]
	6: unique[dd00:1] = POPCOUNT unique[dc80:1]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3245 :VPERMILPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x0C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpermilps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3245(id0.1895) printpiece=[VPERMILPS,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6136  1: XmmReg1 : 6135  2: YmmReg1 : 6138  3: XmmReg2_m128 : 6137  
Pattern id=1895 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:0C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b7f80:10] = CALLOTHER const[1f0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b7f80:10]

Line avx.sinc:169 :VBLENDPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vblendps_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:169(id0.1569) printpiece=[VBLENDPS,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 4504  1: vexVVVV_XmmReg : 4501  2: XmmReg1 : 4500  3: YmmReg1 : 4505  4: XmmReg2_m128 : 4502  5: imm8 : 4503  
Pattern id=1569 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a1280:10] = CALLOTHER const[107:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a1280:10]

Line avx.sinc:3261 :VPERMILPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x0C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpermilps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3261(id0.1897) printpiece=[VPERMILPS,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6144  1: YmmReg1 : 6143  2: YmmReg2_m256 : 6145  
Pattern id=1897 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:0C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1f0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:177 :VBLENDPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0C; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vblendps_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:177(id0.1570) printpiece=[VBLENDPS,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 4510  1: vexVVVV_YmmReg : 4507  2: YmmReg1 : 4506  3: YmmReg2_m256 : 4508  4: imm8 : 4509  
Pattern id=1570 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[107:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3227 :OR  AX,imm16      is vexMode=0 & opsize=0 & byte=0xd; AX & imm16           { logicalflags();    AX =    AX | imm16; resultflags(   AX); }
0: Constructor line ia.sinc:3227(id0.341) printpiece=[OR,  ,  A, ,,  B]
Operands 0: AX : 1994  1: imm16 : 1995  
Pattern id=341 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0D:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: register[0:2] = INT_OR register[0:2], [handle:space][[handle:offset]:2]
	3: register[207:1] = INT_SLESS register[0:2], const[0:2]
	4: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	5: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	6: unique[dd00:1] = POPCOUNT unique[dc80:2]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3228 :OR  EAX,imm32     is vexMode=0 & opsize=1 & byte=0xd; EAX & check_EAX_dest & imm32          { logicalflags();   EAX =   EAX | imm32; build check_EAX_dest; resultflags(  EAX); }
0: Constructor line ia.sinc:3228(id0.342) printpiece=[OR,  ,  A, ,,  C]
Operands 0: EAX : 1996  1: check_EAX_dest : 1998  2: imm32 : 1997  
Pattern id=342 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0D:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: register[0:4] = INT_OR register[0:4], [handle:space][[handle:offset]:4]
	3: MULTIEQUAL const[1:4]
	4: register[207:1] = INT_SLESS register[0:4], const[0:4]
	5: register[206:1] = INT_EQUAL register[0:4], const[0:4]
	6: unique[dc80:4] = INT_AND register[0:4], const[ff:4]
	7: unique[dd00:1] = POPCOUNT unique[dc80:4]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3214 :VPERMILPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x0D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpermilpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3214(id0.1891) printpiece=[VPERMILPD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6121  1: XmmReg1 : 6120  2: YmmReg1 : 6123  3: XmmReg2_m128 : 6122  
Pattern id=1891 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:0D:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b7b80:10] = CALLOTHER const[1ef:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b7b80:10]

Line avx.sinc:153 :VBLENDPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8_3_0 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8_3_0
{
	local tmp:16 = vblendpd_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8_3_0:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:153(id0.1567) printpiece=[VBLENDPD,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 4492  1: vexVVVV_XmmReg : 4489  2: XmmReg1 : 4488  3: YmmReg1 : 4493  4: XmmReg2_m128 : 4490  5: imm8_3_0 : 4491  
Pattern id=1567 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a1080:10] = CALLOTHER const[106:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a1080:10]

Line avx.sinc:3222 :VPERMILPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x0D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpermilpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3222(id0.1892) printpiece=[VPERMILPD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6125  1: YmmReg1 : 6124  2: YmmReg2_m256 : 6126  
Pattern id=1892 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:0D:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ef:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:161 :VBLENDPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8_3_0 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0D; YmmReg1 ... & YmmReg2_m256; imm8_3_0
{
	YmmReg1 = vblendpd_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8_3_0:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:161(id0.1568) printpiece=[VBLENDPD,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 4498  1: vexVVVV_YmmReg : 4495  2: YmmReg1 : 4494  3: YmmReg2_m256 : 4496  4: imm8_3_0 : 4497  
Pattern id=1568 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[106:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3372 :PUSH CS        is vexMode=0 & addrsize=0 & byte=0xe & CS               { push22(CS); }
0: Constructor line ia.sinc:3372(id0.416) printpiece=[PUSH,  ,  A]
Operands 0: CS : 2094  
Pattern id=416 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:0E:XX:XX:XX)
Template
	0: unique[9400:2] = COPY register[102:2]
	1: register[10:2] = INT_SUB register[10:2], const[2:2]
	2: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	3: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3373 :PUSH CS        is vexMode=0 & addrsize=1 & byte=0xe & CS               { pushseg44(CS); }
0: Constructor line ia.sinc:3373(id0.417) printpiece=[PUSH,  ,  A]
Operands 0: CS : 2095  
Pattern id=417 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:0E:XX:XX:XX)
Template
	0: register[10:4] = INT_SUB register[10:4], const[4:4]
	1: STORE const[ram:8], register[10:4], register[102:2]

Line avx.sinc:3276 :VTESTPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0E; XmmReg1 ... & XmmReg2_m128
{
	vtestps_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3276(id0.1899) printpiece=[VTESTPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6150  1: XmmReg2_m128 : 6151  
Pattern id=1899 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0E:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1827 :VPBLENDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpblendw_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1827(id0.1729) printpiece=[VPBLENDW,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5284  1: vexVVVV_XmmReg : 5281  2: XmmReg1 : 5280  3: YmmReg1 : 5285  4: XmmReg2_m128 : 5282  5: imm8 : 5283  
Pattern id=1729 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0E:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[abf80:10] = CALLOTHER const[16b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[abf80:10]

Line avx.sinc:3283 :VTESTPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0E; YmmReg1 ... & YmmReg2_m256
{
	vtestps_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3283(id0.1900) printpiece=[VTESTPS,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6152  1: YmmReg2_m256 : 6153  
Pattern id=1900 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0E:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:191 :VPBLENDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0E; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpblendw_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:191(id0.1948) printpiece=[VPBLENDW,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6364  1: vexVVVV_YmmReg : 6361  2: YmmReg1 : 6360  3: YmmReg2_m256 : 6362  4: imm8 : 6363  
Pattern id=1948 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0E:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[20e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3742 :SLDT rm16      is vexMode=0 & opsize=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=0 ...
{
	rm16 = LocalDescriptorTableRegister();
}
0: Constructor line ia.sinc:3742(id0.554) printpiece=[SLDT,  ,  A]
Operands 0: rm16 : 2348  
Pattern id=554 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:00:[xx00][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3d:4]

Line ia.sinc:3746 :SLDT rm32      is vexMode=0 & opsize=1 & byte=0xf; byte=0x0; rm32 & reg_opcode=0 ...
{
	rm32 = LocalDescriptorTableRegister();
}
0: Constructor line ia.sinc:3746(id0.555) printpiece=[SLDT,  ,  A]
Operands 0: rm32 : 2349  
Pattern id=555 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:00:[xx00][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3d:4]

Line ia.sinc:3781 :STR rm16       is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=1 ... { rm16 = TaskRegister(); }
0: Constructor line ia.sinc:3781(id0.567) printpiece=[STR,  ,  A]
Operands 0: rm16 : 2362  
Pattern id=567 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:00:[xx00][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3f:4]

Line ia.sinc:2972 :LLDT rm16      is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=2 ...
{
	LocalDescriptorTableRegister(rm16);
}
0: Constructor line ia.sinc:2972(id0.261) printpiece=[LLDT,  ,  A]
Operands 0: rm16 : 1841  
Pattern id=261 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:00:[xx01][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3d:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3041 :LTR rm16       is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=3 ... { TaskRegister(rm16); }
0: Constructor line ia.sinc:3041(id0.275) printpiece=[LTR,  ,  A]
Operands 0: rm16 : 1864  
Pattern id=275 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:00:[xx01][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3f:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3860 :VERR rm16      is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=4 ...      { ZF = verr(); }
0: Constructor line ia.sinc:3860(id0.600) printpiece=[VERR,  ,  A]
Operands 0: rm16 : 2421  
Pattern id=600 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:00:[xx10][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[206:1] = CALLOTHER const[4a:4]

Line ia.sinc:3861 :VERW rm16      is vexMode=0 & byte=0xf; byte=0x0; rm16 & reg_opcode=5 ...      { ZF = verw(); }
0: Constructor line ia.sinc:3861(id0.601) printpiece=[VERW,  ,  A]
Operands 0: rm16 : 2422  
Pattern id=601 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:00:[xx10][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[206:1] = CALLOTHER const[4b:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3617 :SGDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=0 ) ... & m16
{
	m16 = GlobalDescriptorTableRegister();
}
0: Constructor line ia.sinc:3617(id0.523) printpiece=[SGDT,  ,  A]
Operands 0: m16 : 2272  
Pattern id=523 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:0[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3b:4]

Line ia.sinc:3622 :SGDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=0 ) ... & m32
{
	m32 = GlobalDescriptorTableRegister();
}
0: Constructor line ia.sinc:3622(id0.524) printpiece=[SGDT,  ,  A]
Operands 0: m32 : 2273  
Pattern id=524 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:0[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3b:4]

Line ia.sinc:3617 :SGDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=0 ) ... & m16
{
	m16 = GlobalDescriptorTableRegister();
}
0: Constructor line ia.sinc:3617(id0.523) printpiece=[SGDT,  ,  A]
Operands 0: m16 : 2272  
Pattern id=523 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:4[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3b:4]

Line ia.sinc:3622 :SGDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=0 ) ... & m32
{
	m32 = GlobalDescriptorTableRegister();
}
0: Constructor line ia.sinc:3622(id0.524) printpiece=[SGDT,  ,  A]
Operands 0: m32 : 2273  
Pattern id=524 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:4[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3b:4]

Line ia.sinc:3617 :SGDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=0 ) ... & m16
{
	m16 = GlobalDescriptorTableRegister();
}
0: Constructor line ia.sinc:3617(id0.523) printpiece=[SGDT,  ,  A]
Operands 0: m16 : 2272  
Pattern id=523 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:8[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3b:4]

Line ia.sinc:3622 :SGDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=0 ) ... & m32
{
	m32 = GlobalDescriptorTableRegister();
}
0: Constructor line ia.sinc:3622(id0.524) printpiece=[SGDT,  ,  A]
Operands 0: m32 : 2273  
Pattern id=524 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:8[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3b:4]

Line ia.sinc:3919 :VMXOFF         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc4                           { vmxoff(); }
0: Constructor line ia.sinc:3919(id0.616) printpiece=[VMXOFF]
Operands 
Pattern id=616 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:C4:XX)
Template
	0: CALLOTHER const[23:4]

Line ia.sinc:3893 :VMCALL         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc1                          { vmcall(); }
0: Constructor line ia.sinc:3893(id0.608) printpiece=[VMCALL]
Operands 
Pattern id=608 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:C1:XX)
Template
	0: CALLOTHER const[1a:4]

Line ia.sinc:3900 :VMLAUNCH       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc2                          { vmlaunch(); }
0: Constructor line ia.sinc:3900(id0.610) printpiece=[VMLAUNCH]
Operands 
Pattern id=610 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:C2:XX)
Template
	0: CALLOTHER const[1d:4]

Line ia.sinc:3902 :VMRESUME       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc3                          { vmresume(); }
0: Constructor line ia.sinc:3902(id0.611) printpiece=[VMRESUME]
Operands 
Pattern id=611 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:C3:XX)
Template
	0: CALLOTHER const[1e:4]

Line ia.sinc:3723 :SIDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=1 ) ... & m16
{
	m16 = InterruptDescriptorTableRegister();
}
0: Constructor line ia.sinc:3723(id0.551) printpiece=[SIDT,  ,  A]
Operands 0: m16 : 2344  
Pattern id=551 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:0[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3c:4]

Line ia.sinc:3728 :SIDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=1 ) ... & m32
{
	m32 = InterruptDescriptorTableRegister();
}
0: Constructor line ia.sinc:3728(id0.552) printpiece=[SIDT,  ,  A]
Operands 0: m32 : 2345  
Pattern id=552 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:0[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3c:4]

Line ia.sinc:3723 :SIDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=1 ) ... & m16
{
	m16 = InterruptDescriptorTableRegister();
}
0: Constructor line ia.sinc:3723(id0.551) printpiece=[SIDT,  ,  A]
Operands 0: m16 : 2344  
Pattern id=551 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:4[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3c:4]

Line ia.sinc:3728 :SIDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=1 ) ... & m32
{
	m32 = InterruptDescriptorTableRegister();
}
0: Constructor line ia.sinc:3728(id0.552) printpiece=[SIDT,  ,  A]
Operands 0: m32 : 2345  
Pattern id=552 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:4[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3c:4]

Line ia.sinc:3723 :SIDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=1 ) ... & m16
{
	m16 = InterruptDescriptorTableRegister();
}
0: Constructor line ia.sinc:3723(id0.551) printpiece=[SIDT,  ,  A]
Operands 0: m16 : 2344  
Pattern id=551 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:8[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3c:4]

Line ia.sinc:3728 :SIDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=1 ) ... & m32
{
	m32 = InterruptDescriptorTableRegister();
}
0: Constructor line ia.sinc:3728(id0.552) printpiece=[SIDT,  ,  A]
Operands 0: m32 : 2345  
Pattern id=552 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:8[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[3c:4]

Line ia.sinc:3200 :MONITOR        is vexMode=0 & byte=0x0f; byte=0x01; byte=0xC8              { monitor(); }
0: Constructor line ia.sinc:3200(id0.324) printpiece=[MONITOR]
Operands 
Pattern id=324 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:C8:XX)
Template
	0: CALLOTHER const[e:4]

Line ia.sinc:3198 :MWAIT          is vexMode=0 & byte=0x0f; byte=0x01; byte=0xC9              { mwait(); }
0: Constructor line ia.sinc:3198(id0.322) printpiece=[MWAIT]
Operands 
Pattern id=322 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:C9:XX)
Template
	0: CALLOTHER const[c:4]

Line ia.sinc:2168 :CLAC           is vexMode=0 & byte=0x0F; byte=0x01; byte=0xCA { AC = 0; }
0: Constructor line ia.sinc:2168(id0.123) printpiece=[CLAC]
Operands 
Pattern id=123 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:CA:XX)
Template
	0: register[211:1] = COPY const[0:1]

Line ia.sinc:3763 :STAC           is vexMode=0 & byte=0x0f; byte=0x01; byte=0xcb  { AC = 1; }
0: Constructor line ia.sinc:3763(id0.558) printpiece=[STAC]
Operands 
Pattern id=558 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:CB:XX)
Template
	0: register[211:1] = COPY const[1:1]

Line ia.sinc:2937 :LGDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=2 ) ... & m16
{
	GlobalDescriptorTableRegister(m16);
}
0: Constructor line ia.sinc:2937(id0.257) printpiece=[LGDT,  ,  A]
Operands 0: m16 : 1835  
Pattern id=257 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:1[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3b:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2942 :LGDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=2 ) ... & m32
{
	GlobalDescriptorTableRegister(m32);
}
0: Constructor line ia.sinc:2942(id0.258) printpiece=[LGDT,  ,  A]
Operands 0: m32 : 1836  
Pattern id=258 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:1[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3b:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2937 :LGDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=2 ) ... & m16
{
	GlobalDescriptorTableRegister(m16);
}
0: Constructor line ia.sinc:2937(id0.257) printpiece=[LGDT,  ,  A]
Operands 0: m16 : 1835  
Pattern id=257 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:5[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3b:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2942 :LGDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=2 ) ... & m32
{
	GlobalDescriptorTableRegister(m32);
}
0: Constructor line ia.sinc:2942(id0.258) printpiece=[LGDT,  ,  A]
Operands 0: m32 : 1836  
Pattern id=258 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:5[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3b:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2937 :LGDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=2 ) ... & m16
{
	GlobalDescriptorTableRegister(m16);
}
0: Constructor line ia.sinc:2937(id0.257) printpiece=[LGDT,  ,  A]
Operands 0: m16 : 1835  
Pattern id=257 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:9[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3b:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2942 :LGDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=2 ) ... & m32
{
	GlobalDescriptorTableRegister(m32);
}
0: Constructor line ia.sinc:2942(id0.258) printpiece=[LGDT,  ,  A]
Operands 0: m32 : 1836  
Pattern id=258 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:9[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3b:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4012 :XGETBV         is vexMode=0 & byte=0x0F; byte=0x01; byte=0xD0  { local tmp = XCR0 >> 32; EDX = tmp:4;  EAX = XCR0:4; }
0: Constructor line ia.sinc:4012(id0.650) printpiece=[XGETBV]
Operands 
Pattern id=650 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:D0:XX)
Template
	0: unique[44300:8] = INT_RIGHT register[600:8], const[20:4]
	1: register[8:4] = SUBPIECE unique[44300:8], const[0:4]
	2: register[0:4] = COPY register[600:4]

Line ia.sinc:4013 :XSETBV         is vexMode=0 & byte=0x0F; byte=0x01; byte=0xD1  { XCR0 = (zext(EDX) << 32) | zext(EAX); }
0: Constructor line ia.sinc:4013(id0.651) printpiece=[XSETBV]
Operands 
Pattern id=651 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:D1:XX)
Template
	0: unique[44400:8] = INT_ZEXT register[8:4]
	1: unique[44480:8] = INT_LEFT unique[44400:8], const[20:4]
	2: unique[44500:8] = INT_ZEXT register[0:4]
	3: register[600:8] = INT_OR unique[44480:8], unique[44500:8]

Line ia.sinc:3898 :VMFUNC EAX     is vexMode=0 & byte=0x0f; byte=0x01; byte=0xd4 & EAX                         { vmfunc(EAX); }
0: Constructor line ia.sinc:3898(id0.609) printpiece=[VMFUNC,  ,  A]
Operands 0: EAX : 2430  
Pattern id=609 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:D4:XX)
Template
	0: CALLOTHER const[1c:4], register[0:4]

Line ia.sinc:3961 :XEND            is vexMode=0 & byte=0x0f; byte=0x01; byte=0xd5     { xend(); }
0: Constructor line ia.sinc:3961(id0.628) printpiece=[XEND]
Operands 
Pattern id=628 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:D5:XX)
Template
	0: CALLOTHER const[50:4]

Line ia.sinc:4059 :XTEST          is byte=0x0F; byte=0x01; byte=0xD6       { ZF = xtest(); }
0: Constructor line ia.sinc:4059(id0.658) printpiece=[XTEST]
Operands 
Pattern id=658 pattern=ins:0F:01:D6:XX
Template
	0: register[206:1] = CALLOTHER const[5d:4]

Line ia.sinc:2955 :LIDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=3 ) ... & m16
{
	InterruptDescriptorTableRegister(m16);
}
0: Constructor line ia.sinc:2955(id0.259) printpiece=[LIDT,  ,  A]
Operands 0: m16 : 1838  
Pattern id=259 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:1[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3c:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2960 :LIDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=3 ) ... & m32
{
	InterruptDescriptorTableRegister(m32);
}
0: Constructor line ia.sinc:2960(id0.260) printpiece=[LIDT,  ,  A]
Operands 0: m32 : 1839  
Pattern id=260 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:1[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3c:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2955 :LIDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=3 ) ... & m16
{
	InterruptDescriptorTableRegister(m16);
}
0: Constructor line ia.sinc:2955(id0.259) printpiece=[LIDT,  ,  A]
Operands 0: m16 : 1838  
Pattern id=259 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:5[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3c:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2960 :LIDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=3 ) ... & m32
{
	InterruptDescriptorTableRegister(m32);
}
0: Constructor line ia.sinc:2960(id0.260) printpiece=[LIDT,  ,  A]
Operands 0: m32 : 1839  
Pattern id=260 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:5[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3c:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2955 :LIDT m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=3 ) ... & m16
{
	InterruptDescriptorTableRegister(m16);
}
0: Constructor line ia.sinc:2955(id0.259) printpiece=[LIDT,  ,  A]
Operands 0: m16 : 1838  
Pattern id=259 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:9[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3c:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2960 :LIDT m32       is vexMode=0 & opsize=1 & byte=0xf; byte=0x1; ( mod != 0b11 & reg_opcode=3 ) ... & m32
{
	InterruptDescriptorTableRegister(m32);
}
0: Constructor line ia.sinc:2960(id0.260) printpiece=[LIDT,  ,  A]
Operands 0: m32 : 1839  
Pattern id=260 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:9[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[3c:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3872 :VMRUN EAX      is vexMode=0 & addrsize=1 & byte=0x0f; byte=0x01; byte=0xd8 & EAX       { vmrun(EAX); }
0: Constructor line ia.sinc:3872(id0.604) printpiece=[VMRUN,  ,  A]
Operands 0: EAX : 2424  
Pattern id=604 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:0F:01:D8:XX)
Template
	0: CALLOTHER const[16:4], register[0:4]

Line ia.sinc:3870 :VMMCALL        is vexMode=0 & byte=0x0f; byte=0x01; byte=0xd9          { vmmcall(); }
0: Constructor line ia.sinc:3870(id0.603) printpiece=[VMMCALL]
Operands 
Pattern id=603 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:D9:XX)
Template
	0: CALLOTHER const[15:4]

Line ia.sinc:3866 :VMLOAD EAX     is vexMode=0 & addrsize=1 & byte=0x0f; byte=0x01; byte=0xda & EAX       { vmload(EAX); }
0: Constructor line ia.sinc:3866(id0.602) printpiece=[VMLOAD,  ,  A]
Operands 0: EAX : 2423  
Pattern id=602 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:0F:01:DA:XX)
Template
	0: CALLOTHER const[14:4], register[0:4]

Line ia.sinc:3877 :VMSAVE EAX     is vexMode=0 & addrsize=1 & byte=0x0f; byte=0x01; byte=0xdb & EAX       { vmsave(EAX); }
0: Constructor line ia.sinc:3877(id0.605) printpiece=[VMSAVE,  ,  A]
Operands 0: EAX : 2425  
Pattern id=605 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:0F:01:DB:XX)
Template
	0: CALLOTHER const[17:4], register[0:4]

Line ia.sinc:3769 :STGI           is vexMode=0 & byte=0x0f; byte=0x01; byte=0xdc              { stgi(); }
0: Constructor line ia.sinc:3769(id0.561) printpiece=[STGI]
Operands 
Pattern id=561 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:DC:XX)
Template
	0: CALLOTHER const[13:4]

Line ia.sinc:2175 :CLGI                   is vexMode=0 & byte=0x0f; byte=0x01; byte=0xDD                      { clgi(); }
0: Constructor line ia.sinc:2175(id0.126) printpiece=[CLGI]
Operands 
Pattern id=126 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:DD:XX)
Template
	0: CALLOTHER const[12:4]

Line ia.sinc:3740 :SKINIT EAX     is vexMode=0 & byte=0x0f; byte=0x01; byte=0xde & EAX { skinit(EAX); }
0: Constructor line ia.sinc:3740(id0.553) printpiece=[SKINIT,  ,  A]
Operands 0: EAX : 2347  
Pattern id=553 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:DE:XX)
Template
	0: CALLOTHER const[48:4], register[0:4]

Line ia.sinc:2810 :INVLPGA        is vexMode=0 & addrsize=0 & byte=0xf; byte=0x1; byte=0xDF                   { invlpga(AX,ECX); }
0: Constructor line ia.sinc:2810(id0.213) printpiece=[INVLPGA]
Operands 
Pattern id=213 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:0F:01:DF:XX)
Template
	0: CALLOTHER const[9:4], register[0:2], register[4:4]

Line ia.sinc:2811 :INVLPGA        is vexMode=0 & addrsize=1 & byte=0xf; byte=0x1; byte=0xDF                   { invlpga(EAX,ECX); }
0: Constructor line ia.sinc:2811(id0.214) printpiece=[INVLPGA]
Operands 
Pattern id=214 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:0F:01:DF:XX)
Template
	0: CALLOTHER const[9:4], register[0:4], register[4:4]

Line ia.sinc:3757 :SMSW rm16      is vexMode=0 & opsize=0 & byte=0xf; byte=0x01; rm16 & reg_opcode=4 ...  { rm16 = CR0:2; }
0: Constructor line ia.sinc:3757(id0.556) printpiece=[SMSW,  ,  A]
Operands 0: rm16 : 2350  
Pattern id=556 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:[xx10][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[320:2]

Line ia.sinc:3758 :SMSW rm32      is vexMode=0 & opsize=1 & byte=0xf; byte=0x01; rm32 & reg_opcode=4 ...  { rm32 = zext(CR0:2); }
0: Constructor line ia.sinc:3758(id0.557) printpiece=[SMSW,  ,  A]
Operands 0: rm32 : 2351  
Pattern id=557 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:[xx10][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT register[320:2]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:01:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:01:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:01:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:01:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:01:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:01:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:01:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:01:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:01:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:01:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:01:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:40 :RSTORSSP m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; ( mod != 0b11 & reg_opcode=5 ) ... & m64 {
    tmp_SSP:8 = m64;
    SSP = tmp_SSP & ~0x01;
}
0: Constructor line cet.sinc:40(id0.2141) printpiece=[RSTORSSP,  ,  A]
Operands 0: m64 : 7215  
Pattern id=2141 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:01:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d1000:8] = INT_NEGATE const[1:8]
	2: register[7c0:8] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[d1000:8]

Line cet.sinc:70 :SETSSBSY is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xe8 {
   SSP = markShadowStackBusy(IA32_PL0_SSP);
}
0: Constructor line cet.sinc:70(id0.2144) printpiece=[SETSSBSY]
Operands 
Pattern id=2144 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:01:E8:XX)
Template
	0: register[7c0:8] = CALLOTHER const[293:4], register[7d8:8]

Line cet.sinc:70 :SETSSBSY is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xe8 {
   SSP = markShadowStackBusy(IA32_PL0_SSP);
}
0: Constructor line cet.sinc:70(id0.2144) printpiece=[SETSSBSY]
Operands 
Pattern id=2144 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:01:E8:XX)
Template
	0: register[7c0:8] = CALLOTHER const[293:4], register[7d8:8]

Line cet.sinc:70 :SETSSBSY is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xe8 {
   SSP = markShadowStackBusy(IA32_PL0_SSP);
}
0: Constructor line cet.sinc:70(id0.2144) printpiece=[SETSSBSY]
Operands 
Pattern id=2144 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:01:E8:XX)
Template
	0: register[7c0:8] = CALLOTHER const[293:4], register[7d8:8]

Line cet.sinc:70 :SETSSBSY is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xe8 {
   SSP = markShadowStackBusy(IA32_PL0_SSP);
}
0: Constructor line cet.sinc:70(id0.2144) printpiece=[SETSSBSY]
Operands 
Pattern id=2144 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:01:E8:XX)
Template
	0: register[7c0:8] = CALLOTHER const[293:4], register[7d8:8]

Line cet.sinc:33 :SAVEPREVSSP  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xea {
    tmp:8 = SSP;
    SSP = SSP & ~0x7;
    ShadowStackPush8B(tmp);
}
0: Constructor line cet.sinc:33(id0.2140) printpiece=[SAVEPREVSSP]
Operands 
Pattern id=2140 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:01:EA:XX)
Template
	0: unique[d0e00:8] = COPY register[7c0:8]
	1: unique[d0e80:8] = INT_NEGATE const[7:8]
	2: register[7c0:8] = INT_AND register[7c0:8], unique[d0e80:8]
	3: CALLOTHER const[28d:4], unique[d0e00:8]

Line cet.sinc:33 :SAVEPREVSSP  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xea {
    tmp:8 = SSP;
    SSP = SSP & ~0x7;
    ShadowStackPush8B(tmp);
}
0: Constructor line cet.sinc:33(id0.2140) printpiece=[SAVEPREVSSP]
Operands 
Pattern id=2140 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:01:EA:XX)
Template
	0: unique[d0e00:8] = COPY register[7c0:8]
	1: unique[d0e80:8] = INT_NEGATE const[7:8]
	2: register[7c0:8] = INT_AND register[7c0:8], unique[d0e80:8]
	3: CALLOTHER const[28d:4], unique[d0e00:8]

Line cet.sinc:33 :SAVEPREVSSP  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xea {
    tmp:8 = SSP;
    SSP = SSP & ~0x7;
    ShadowStackPush8B(tmp);
}
0: Constructor line cet.sinc:33(id0.2140) printpiece=[SAVEPREVSSP]
Operands 
Pattern id=2140 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:01:EA:XX)
Template
	0: unique[d0e00:8] = COPY register[7c0:8]
	1: unique[d0e80:8] = INT_NEGATE const[7:8]
	2: register[7c0:8] = INT_AND register[7c0:8], unique[d0e80:8]
	3: CALLOTHER const[28d:4], unique[d0e00:8]

Line cet.sinc:33 :SAVEPREVSSP  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x01; byte=0xea {
    tmp:8 = SSP;
    SSP = SSP & ~0x7;
    ShadowStackPush8B(tmp);
}
0: Constructor line cet.sinc:33(id0.2140) printpiece=[SAVEPREVSSP]
Operands 
Pattern id=2140 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:01:EA:XX)
Template
	0: unique[d0e00:8] = COPY register[7c0:8]
	1: unique[d0e80:8] = INT_NEGATE const[7:8]
	2: register[7c0:8] = INT_AND register[7c0:8], unique[d0e80:8]
	3: CALLOTHER const[28d:4], unique[d0e00:8]

Line ia.sinc:3459 :RDPKRU         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xee { EAX = rdpkru_u32(); }
0: Constructor line ia.sinc:3459(id0.456) printpiece=[RDPKRU]
Operands 
Pattern id=456 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:EE:XX)
Template
	0: register[0:4] = CALLOTHER const[44:4]

Line ia.sinc:3939 :WRPKRU         is byte=0x0F; byte=0x01; byte=0xEF              { wrpkru(EAX); }
0: Constructor line ia.sinc:3939(id0.620) printpiece=[WRPKRU]
Operands 
Pattern id=620 pattern=ins:0F:01:EF:XX
Template
	0: CALLOTHER const[4c:4], register[0:4]

Line ia.sinc:2983 :LMSW rm16      is vexMode=0 & byte=0xf; byte=0x01; rm16 & reg_opcode=6 ...
{
  CR0 = (CR0 & 0xFFFFFFF0) | zext(rm16 & 0x000F);
}
0: Constructor line ia.sinc:2983(id0.262) printpiece=[LMSW,  ,  A]
Operands 0: rm16 : 1842  
Pattern id=262 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2cc80:4] = INT_AND register[320:4], const[fffffff0:4]
	2: unique[2cd00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[f:[handle:size]]
	3: unique[2cd80:4] = INT_ZEXT unique[2cd00:[handle:size]]
	4: register[320:4] = INT_OR unique[2cc80:4], unique[2cd80:4]

Line ia.sinc:3830 :SWAPGS             is vexMode=0 & bit64=1 & byte=0x0f; byte=0x01; byte=0xf8   { swapgs(); }
0: Constructor line ia.sinc:3830(id0.586) printpiece=[SWAPGS]
Operands 
Pattern id=586 pattern=cmb:(ctx:X[1xxx]:XX:X[0xxx]:XX,ins:0F:01:F8:XX)
Template
	0: CALLOTHER const[7:4]

Line ia.sinc:2808 :INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }
1: Constructor line ia.sinc:2808(id0.212) printpiece=[INVLPG,  ,  A]
Operands 0: Mem : 1769  
Pattern id=212 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[8:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3832 :RDTSCP             is vexMode=0 & bit64=1 & byte=0x0f; byte=0x01; byte=0xf9   { rdtscp(); }
0: Constructor line ia.sinc:3832(id0.587) printpiece=[RDTSCP]
Operands 
Pattern id=587 pattern=cmb:(ctx:X[1xxx]:XX:X[0xxx]:XX,ins:0F:01:F9:XX)
Template
	0: CALLOTHER const[b:4]

Line ia.sinc:2808 :INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }
1: Constructor line ia.sinc:2808(id0.212) printpiece=[INVLPG,  ,  A]
Operands 0: Mem : 1769  
Pattern id=212 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[8:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3201 :MONITORX       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xFA              { monitorx(); }
0: Constructor line ia.sinc:3201(id0.325) printpiece=[MONITORX]
Operands 
Pattern id=325 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:FA:XX)
Template
	0: CALLOTHER const[f:4]

Line ia.sinc:2808 :INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }
1: Constructor line ia.sinc:2808(id0.212) printpiece=[INVLPG,  ,  A]
Operands 0: Mem : 1769  
Pattern id=212 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[8:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3199 :MWAITX         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xFB              { mwaitx(); }
0: Constructor line ia.sinc:3199(id0.323) printpiece=[MWAITX]
Operands 
Pattern id=323 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:FB:XX)
Template
	0: CALLOTHER const[d:4]

Line ia.sinc:2808 :INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }
1: Constructor line ia.sinc:2808(id0.212) printpiece=[INVLPG,  ,  A]
Operands 0: Mem : 1769  
Pattern id=212 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[8:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2182 :CLZERO        is vexMode=0 & opsize=0 & byte=0x0F; byte=0x01; byte=0xFC { clzero(AX); }
0: Constructor line ia.sinc:2182(id0.129) printpiece=[CLZERO]
Operands 
Pattern id=129 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:01:FC:XX)
Template
	0: CALLOTHER const[27:4], register[0:2]

Line ia.sinc:2808 :INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }
1: Constructor line ia.sinc:2808(id0.212) printpiece=[INVLPG,  ,  A]
Operands 0: Mem : 1769  
Pattern id=212 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[8:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2183 :CLZERO        is vexMode=0 & opsize=1 & byte=0x0F; byte=0x01; byte=0xFC { clzero(EAX); }
0: Constructor line ia.sinc:2183(id0.130) printpiece=[CLZERO]
Operands 
Pattern id=130 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:01:FC:XX)
Template
	0: CALLOTHER const[27:4], register[0:4]

Line ia.sinc:2808 :INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }
1: Constructor line ia.sinc:2808(id0.212) printpiece=[INVLPG,  ,  A]
Operands 0: Mem : 1769  
Pattern id=212 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[8:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2808 :INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }
0: Constructor line ia.sinc:2808(id0.212) printpiece=[INVLPG,  ,  A]
Operands 0: Mem : 1769  
Pattern id=212 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[8:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2808 :INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }
0: Constructor line ia.sinc:2808(id0.212) printpiece=[INVLPG,  ,  A]
Operands 0: Mem : 1769  
Pattern id=212 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[8:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2808 :INVLPG Mem     is vexMode=0 & byte=0xf; byte=0x1; ( reg_opcode=7 ) ... & Mem     { invlpg(Mem); }
0: Constructor line ia.sinc:2808(id0.212) printpiece=[INVLPG,  ,  A]
Operands 0: Mem : 1769  
Pattern id=212 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:01:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[8:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4059 :XTEST          is byte=0x0F; byte=0x01; byte=0xD6       { ZF = xtest(); }
0: Constructor line ia.sinc:4059(id0.658) printpiece=[XTEST]
Operands 
Pattern id=658 pattern=ins:0F:01:D6:XX
Template
	0: register[206:1] = CALLOTHER const[5d:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
1: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3939 :WRPKRU         is byte=0x0F; byte=0x01; byte=0xEF              { wrpkru(EAX); }
0: Constructor line ia.sinc:3939(id0.620) printpiece=[WRPKRU]
Operands 
Pattern id=620 pattern=ins:0F:01:EF:XX
Template
	0: CALLOTHER const[4c:4], register[0:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
1: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4059 :XTEST          is byte=0x0F; byte=0x01; byte=0xD6       { ZF = xtest(); }
0: Constructor line ia.sinc:4059(id0.658) printpiece=[XTEST]
Operands 
Pattern id=658 pattern=ins:0F:01:D6:XX
Template
	0: register[206:1] = CALLOTHER const[5d:4]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line ia.sinc:3939 :WRPKRU         is byte=0x0F; byte=0x01; byte=0xEF              { wrpkru(EAX); }
0: Constructor line ia.sinc:3939(id0.620) printpiece=[WRPKRU]
Operands 
Pattern id=620 pattern=ins:0F:01:EF:XX
Template
	0: CALLOTHER const[4c:4], register[0:4]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line ia.sinc:4059 :XTEST          is byte=0x0F; byte=0x01; byte=0xD6       { ZF = xtest(); }
0: Constructor line ia.sinc:4059(id0.658) printpiece=[XTEST]
Operands 
Pattern id=658 pattern=ins:0F:01:D6:XX
Template
	0: register[206:1] = CALLOTHER const[5d:4]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
1: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3939 :WRPKRU         is byte=0x0F; byte=0x01; byte=0xEF              { wrpkru(EAX); }
0: Constructor line ia.sinc:3939(id0.620) printpiece=[WRPKRU]
Operands 
Pattern id=620 pattern=ins:0F:01:EF:XX
Template
	0: CALLOTHER const[4c:4], register[0:4]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
1: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4059 :XTEST          is byte=0x0F; byte=0x01; byte=0xD6       { ZF = xtest(); }
0: Constructor line ia.sinc:4059(id0.658) printpiece=[XTEST]
Operands 
Pattern id=658 pattern=ins:0F:01:D6:XX
Template
	0: register[206:1] = CALLOTHER const[5d:4]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3939 :WRPKRU         is byte=0x0F; byte=0x01; byte=0xEF              { wrpkru(EAX); }
0: Constructor line ia.sinc:3939(id0.620) printpiece=[WRPKRU]
Operands 
Pattern id=620 pattern=ins:0F:01:EF:XX
Template
	0: CALLOTHER const[4c:4], register[0:4]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:2877 :LAR Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0x2; rm16 & Reg16 ...  { Reg16 = rm16 & 0xff00; ZF=1; }
0: Constructor line ia.sinc:2877(id0.238) printpiece=[LAR,  ,  B, ,,  A]
Operands 0: rm16 : 1795  1: Reg16 : 1794  
Pattern id=238 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:02:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff00:[handle:size]]
	3: register[206:1] = COPY const[1:1]

Line ia.sinc:2878 :LAR Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0x2; rm32 & Reg32 ... & check_Reg32_dest ... { Reg32 = rm32 & 0xffff00; build check_Reg32_dest; ZF=1; }
0: Constructor line ia.sinc:2878(id0.239) printpiece=[LAR,  ,  B, ,,  A]
Operands 0: rm32 : 1797  1: Reg32 : 1796  2: check_Reg32_dest : 1798  
Pattern id=239 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:02:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ffff00:[handle:size]]
	3: MULTIEQUAL const[2:4]
	4: register[206:1] = COPY const[1:1]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3017 :LSL Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0x3; rm16 & Reg16 ...
{
  tmp:3 = SegmentLimit(rm16);
  Reg16 = tmp:2;
  ZF = tmp[16,1];
}
0: Constructor line ia.sinc:3017(id0.273) printpiece=[LSL,  ,  B, ,,  A]
Operands 0: rm16 : 1860  1: Reg16 : 1859  
Pattern id=273 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:03:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2d900:3] = CALLOTHER const[3e:4], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2d900:3], const[0:4]
	4: unique[2da00:1] = SUBPIECE unique[2d900:3], const[2:4]
	5: register[206:1] = INT_AND unique[2da00:1], const[1:1]

Line ia.sinc:3024 :LSL Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0x3; rm32 & Reg32 ...
{
  tmp:3 = SegmentLimit(rm32);
  Reg32 = zext(tmp:2);
  ZF = tmp[16,1];
}
0: Constructor line ia.sinc:3024(id0.274) printpiece=[LSL,  ,  B, ,,  A]
Operands 0: rm32 : 1862  1: Reg32 : 1861  
Pattern id=274 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:03:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2db80:3] = CALLOTHER const[3e:4], [handle:space][[handle:offset]:[handle:size]]
	3: unique[2dc00:2] = SUBPIECE unique[2db80:3], const[0:4]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[2dc00:2]
	5: unique[2dd00:1] = SUBPIECE unique[2db80:3], const[2:4]
	6: register[206:1] = INT_AND unique[2dd00:1], const[1:1]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3820 :SYSCALL            is vexMode=0 & byte=0x0f; byte=0x05                     { syscall(); }
0: Constructor line ia.sinc:3820(id0.584) printpiece=[SYSCALL]
Operands 
Pattern id=584 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:05:XX:XX)
Template
	0: CALLOTHER const[5:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:2178 :CLTS			is vexMode=0 & byte=0x0f; byte=0x06				{ CR0 = CR0 & ~(0x8); }
0: Constructor line ia.sinc:2178(id0.128) printpiece=[CLTS]
Operands 
Pattern id=128 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:06:XX:XX)
Template
	0: unique[1de00:4] = INT_NEGATE const[8:4]
	1: register[320:4] = INT_AND register[320:4], unique[1de00:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3824 :SYSRET             is vexMode=0 & byte=0x0f; byte=0x07                     { sysret();
@ifdef IA64
                                                                  RIP=RCX; return [RIP];
@endif
                                                                }
0: Constructor line ia.sinc:3824(id0.585) printpiece=[SYSRET]
Operands 
Pattern id=585 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:07:XX:XX)
Template
	0: CALLOTHER const[6:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:2807 :INVD           is vexMode=0 & byte=0xf; byte=0x8                   {}
0: Constructor line ia.sinc:2807(id0.211) printpiece=[INVD]
Operands 
Pattern id=211 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:08:XX:XX)
Template

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3926 :WBINVD         is vexMode=0 & byte=0xf; byte=0x9                   { }
0: Constructor line ia.sinc:3926(id0.619) printpiece=[WBINVD]
Operands 
Pattern id=619 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:09:XX:XX)
Template

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3856 :UD2              is vexMode=0 & byte=0xf; byte=0xb                               { invalidInstructionException(); goto inst_start; }
0: Constructor line ia.sinc:3856(id0.599) printpiece=[UD2]
Operands 
Pattern id=599 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:0B:XX:XX)
Template
	0: CALLOTHER const[49:4]
	1: BRANCH [curspace][[start]:[curspace_size]]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3319 :PREFETCH     m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=0 ... { }
0: Constructor line ia.sinc:3319(id0.391) printpiece=[PREFETCH,  ,  A]
Operands 0: m8 : 2067  
Pattern id=391 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:0D:[xx00][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3320 :PREFETCH     m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode   ... { }  # rest aliased to /0
:PREFETCHW    m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=1 ... { }
1: Constructor line ia.sinc:3320(id0.392) printpiece=[PREFETCH,  ,  A]
Operands 0: m8 : 2068  1: reg_opcode : 2069  
Pattern id=392 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:0D:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3321 :PREFETCHW    m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=1 ... { }
0: Constructor line ia.sinc:3321(id0.393) printpiece=[PREFETCHW,  ,  A]
Operands 0: m8 : 2070  
Pattern id=393 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:0D:[xx00][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3320 :PREFETCH     m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode   ... { }  # rest aliased to /0
:PREFETCHW    m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=1 ... { }
1: Constructor line ia.sinc:3320(id0.392) printpiece=[PREFETCH,  ,  A]
Operands 0: m8 : 2068  1: reg_opcode : 2069  
Pattern id=392 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:0D:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3322 :PREFETCHWT1  m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=2 ... { }
0: Constructor line ia.sinc:3322(id0.394) printpiece=[PREFETCHWT1,  ,  A]
Operands 0: m8 : 2071  
Pattern id=394 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:0D:[xx01][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3320 :PREFETCH     m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode   ... { }  # rest aliased to /0
:PREFETCHW    m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=1 ... { }
1: Constructor line ia.sinc:3320(id0.392) printpiece=[PREFETCH,  ,  A]
Operands 0: m8 : 2068  1: reg_opcode : 2069  
Pattern id=392 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:0D:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3320 :PREFETCH     m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode   ... { }  # rest aliased to /0
:PREFETCHW    m8  is vexMode=0 & byte=0x0f; byte=0x0d; m8 & reg_opcode=1 ... { }
0: Constructor line ia.sinc:3320(id0.392) printpiece=[PREFETCH,  ,  A]
Operands 0: m8 : 2068  1: reg_opcode : 2069  
Pattern id=392 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:0D:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:8792 :FEMMS         is vexMode=0 & byte=0x0F; byte=0x0E    { FastExitMediaState(); }
0: Constructor line ia.sinc:8792(id0.1537) printpiece=[FEMMS]
Operands 
Pattern id=1537 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:0E:XX:XX)
Template
	0: CALLOTHER const[f5:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8725 :PFCMPGE mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x90 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingCompareGE(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8725(id0.1504) printpiece=[PFCMPGE,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4292  1: mmxreg2 : 4293  
Pattern id=1504 pattern=cmb:(ctx:SS:X[000x]:X4:8[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8724 :PFCMPGE mmxreg, m64      is vexMode=0 & suffix3D=0x90 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingCompareGE(mmxreg, m64); }
3: Constructor line ia.sinc:8724(id0.1503) printpiece=[PFCMPGE,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4290  1: m64 : 4291  
Pattern id=1503 pattern=cmb:(ctx:SS:X[000x]:X4:8[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8729 :PFCMPGT mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xA0 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingCompareGT(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8729(id0.1506) printpiece=[PFCMPGT,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4297  1: mmxreg2 : 4298  
Pattern id=1506 pattern=cmb:(ctx:SS:X[000x]:X5:0[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8728 :PFCMPGT mmxreg, m64      is vexMode=0 & suffix3D=0xA0 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingCompareGT(mmxreg, m64); }
3: Constructor line ia.sinc:8728(id0.1505) printpiece=[PFCMPGT,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4295  1: m64 : 4296  
Pattern id=1505 pattern=cmb:(ctx:SS:X[000x]:X5:0[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8733 :PFCMPEQ mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xB0 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingCompareEQ(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8733(id0.1508) printpiece=[PFCMPEQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4302  1: mmxreg2 : 4303  
Pattern id=1508 pattern=cmb:(ctx:SS:X[000x]:X5:8[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8732 :PFCMPEQ mmxreg, m64      is vexMode=0 & suffix3D=0xB0 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingCompareEQ(mmxreg, m64); }
3: Constructor line ia.sinc:8732(id0.1507) printpiece=[PFCMPEQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4300  1: m64 : 4301  
Pattern id=1507 pattern=cmb:(ctx:SS:X[000x]:X5:8[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
2: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
2: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
2: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
2: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8812 :PFNACC mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x8A & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingNegAccumulate(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8812(id0.1543) printpiece=[PFNACC,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4388  1: mmxreg2 : 4389  
Pattern id=1543 pattern=cmb:(ctx:SS:X[000x]:X4:5[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8811 :PFNACC mmxreg, m64      is vexMode=0 & suffix3D=0x8A & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingNegAccumulate(mmxreg, m64); }
3: Constructor line ia.sinc:8811(id0.1542) printpiece=[PFNACC,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4386  1: m64 : 4387  
Pattern id=1542 pattern=cmb:(ctx:SS:X[000x]:X4:5[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8745 :PFSUB mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x9A & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingSUB(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8745(id0.1514) printpiece=[PFSUB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4317  1: mmxreg2 : 4318  
Pattern id=1514 pattern=cmb:(ctx:SS:X[000x]:X4:D[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8744 :PFSUB mmxreg, m64      is vexMode=0 & suffix3D=0x9A & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingSUB(mmxreg, m64); }
3: Constructor line ia.sinc:8744(id0.1513) printpiece=[PFSUB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4315  1: m64 : 4316  
Pattern id=1513 pattern=cmb:(ctx:SS:X[000x]:X4:D[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8749 :PFSUBR mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xAA & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingSUBR(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8749(id0.1516) printpiece=[PFSUBR,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4322  1: mmxreg2 : 4323  
Pattern id=1516 pattern=cmb:(ctx:SS:X[000x]:X5:5[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ea:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8748 :PFSUBR mmxreg, m64      is vexMode=0 & suffix3D=0xAA & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingSUBR(mmxreg, m64); }
3: Constructor line ia.sinc:8748(id0.1515) printpiece=[PFSUBR,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4320  1: m64 : 4321  
Pattern id=1515 pattern=cmb:(ctx:SS:X[000x]:X5:5[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ea:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8820 :PSWAPD mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xBB & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedSwapDWords(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8820(id0.1547) printpiece=[PSWAPD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4398  1: mmxreg2 : 4399  
Pattern id=1547 pattern=cmb:(ctx:SS:X[000x]:X5:D[1xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[fa:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8819 :PSWAPD mmxreg, m64      is vexMode=0 & suffix3D=0xBB & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedSwapDWords(mmxreg, m64); }
3: Constructor line ia.sinc:8819(id0.1546) printpiece=[PSWAPD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4396  1: m64 : 4397  
Pattern id=1546 pattern=cmb:(ctx:SS:X[000x]:X5:D[1xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[fa:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8808 :PI2FW mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x0C & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedIntToFloatingWord(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8808(id0.1541) printpiece=[PI2FW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4383  1: mmxreg2 : 4384  
Pattern id=1541 pattern=cmb:(ctx:SS:X[000x]:X0:6[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8807 :PI2FW mmxreg, m64      is vexMode=0 & suffix3D=0x0C & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedIntToFloatingWord(mmxreg, m64); }
3: Constructor line ia.sinc:8807(id0.1540) printpiece=[PI2FW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4381  1: m64 : 4382  
Pattern id=1540 pattern=cmb:(ctx:SS:X[000x]:X0:6[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8753 :PFMIN mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x94 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingMIN(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8753(id0.1518) printpiece=[PFMIN,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4327  1: mmxreg2 : 4328  
Pattern id=1518 pattern=cmb:(ctx:SS:X[000x]:X4:A[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[eb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8752 :PFMIN mmxreg, m64      is vexMode=0 & suffix3D=0x94 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingMIN(mmxreg, m64); }
3: Constructor line ia.sinc:8752(id0.1517) printpiece=[PFMIN,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4325  1: m64 : 4326  
Pattern id=1517 pattern=cmb:(ctx:SS:X[000x]:X4:A[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[eb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8804 :PF2IW mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x1C & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingToIntWord(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8804(id0.1539) printpiece=[PF2IW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4378  1: mmxreg2 : 4379  
Pattern id=1539 pattern=cmb:(ctx:SS:X[000x]:X0:E[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8803 :PF2IW mmxreg, m64      is vexMode=0 & suffix3D=0x1C & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingToIntWord(mmxreg, m64); }
3: Constructor line ia.sinc:8803(id0.1538) printpiece=[PF2IW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4376  1: m64 : 4377  
Pattern id=1538 pattern=cmb:(ctx:SS:X[000x]:X0:E[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8757 :PFMAX mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xA4 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingMAX(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8757(id0.1520) printpiece=[PFMAX,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4332  1: mmxreg2 : 4333  
Pattern id=1520 pattern=cmb:(ctx:SS:X[000x]:X5:2[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ec:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8756 :PFMAX mmxreg, m64      is vexMode=0 & suffix3D=0xA4 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingMAX(mmxreg, m64); }
3: Constructor line ia.sinc:8756(id0.1519) printpiece=[PFMAX,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4330  1: m64 : 4331  
Pattern id=1519 pattern=cmb:(ctx:SS:X[000x]:X5:2[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ec:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8761 :PFMUL mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xB4 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingMUL(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8761(id0.1522) printpiece=[PFMUL,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4337  1: mmxreg2 : 4338  
Pattern id=1522 pattern=cmb:(ctx:SS:X[000x]:X5:A[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ed:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8760 :PFMUL mmxreg, m64      is vexMode=0 & suffix3D=0xB4 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingMUL(mmxreg, m64); }
3: Constructor line ia.sinc:8760(id0.1521) printpiece=[PFMUL,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4335  1: m64 : 4336  
Pattern id=1521 pattern=cmb:(ctx:SS:X[000x]:X5:A[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ed:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8717 :PI2FD mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x0D & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedIntToFloatingDwordConv(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8717(id0.1500) printpiece=[PI2FD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4282  1: mmxreg2 : 4283  
Pattern id=1500 pattern=cmb:(ctx:SS:X[000x]:X0:6[1xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8716 :PI2FD mmxreg, m64      is vexMode=0 & suffix3D=0x0D & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedIntToFloatingDwordConv(mmxreg, m64); }
3: Constructor line ia.sinc:8716(id0.1499) printpiece=[PI2FD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4280  1: m64 : 4281  
Pattern id=1499 pattern=cmb:(ctx:SS:X[000x]:X0:6[1xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8721 :PF2ID mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x1D & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingToIntDwordConv(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8721(id0.1502) printpiece=[PF2ID,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4287  1: mmxreg2 : 4288  
Pattern id=1502 pattern=cmb:(ctx:SS:X[000x]:X0:E[1xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8720 :PF2ID mmxreg, m64      is vexMode=0 & suffix3D=0x1D & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingToIntDwordConv(mmxreg, m64); }
3: Constructor line ia.sinc:8720(id0.1501) printpiece=[PF2ID,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4285  1: m64 : 4286  
Pattern id=1501 pattern=cmb:(ctx:SS:X[000x]:X0:E[1xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8816 :PFPNACC mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x8E & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingPosNegAccumulate(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8816(id0.1545) printpiece=[PFPNACC,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4393  1: mmxreg2 : 4394  
Pattern id=1545 pattern=cmb:(ctx:SS:X[000x]:X4:7[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8815 :PFPNACC mmxreg, m64      is vexMode=0 & suffix3D=0x8E & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingPosNegAccumulate(mmxreg, m64); }
3: Constructor line ia.sinc:8815(id0.1544) printpiece=[PFPNACC,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4391  1: m64 : 4392  
Pattern id=1544 pattern=cmb:(ctx:SS:X[000x]:X4:7[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8765 :PFRCP mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x96 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = FloatingReciprocalAprox(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8765(id0.1524) printpiece=[PFRCP,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4342  1: mmxreg2 : 4343  
Pattern id=1524 pattern=cmb:(ctx:SS:X[000x]:X4:B[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ee:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8764 :PFRCP mmxreg, m64      is vexMode=0 & suffix3D=0x96 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = FloatingReciprocalAprox(mmxreg, m64); }
3: Constructor line ia.sinc:8764(id0.1523) printpiece=[PFRCP,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4340  1: m64 : 4341  
Pattern id=1523 pattern=cmb:(ctx:SS:X[000x]:X4:B[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ee:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8741 :PFADD mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x9E & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingADD(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8741(id0.1512) printpiece=[PFADD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4312  1: mmxreg2 : 4313  
Pattern id=1512 pattern=cmb:(ctx:SS:X[000x]:X4:F[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8740 :PFADD mmxreg, m64      is vexMode=0 & suffix3D=0x9E & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64  { mmxreg = PackedFloatingADD(mmxreg, m64); }
3: Constructor line ia.sinc:8740(id0.1511) printpiece=[PFADD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4310  1: m64 : 4311  
Pattern id=1511 pattern=cmb:(ctx:SS:X[000x]:X4:F[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8773 :PFRCPIT1 mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xA6 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingReciprocalIter1(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8773(id0.1528) printpiece=[PFRCPIT1,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4352  1: mmxreg2 : 4353  
Pattern id=1528 pattern=cmb:(ctx:SS:X[000x]:X5:3[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8772 :PFRCPIT1 mmxreg, m64      is vexMode=0 & suffix3D=0xA6 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingReciprocalIter1(mmxreg, m64); }
3: Constructor line ia.sinc:8772(id0.1527) printpiece=[PFRCPIT1,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4350  1: m64 : 4351  
Pattern id=1527 pattern=cmb:(ctx:SS:X[000x]:X5:3[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8737 :PFACC mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xAE & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingAccumulate(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8737(id0.1510) printpiece=[PFACC,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4307  1: mmxreg2 : 4308  
Pattern id=1510 pattern=cmb:(ctx:SS:X[000x]:X5:7[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8736 :PFACC mmxreg, m64      is vexMode=0 & suffix3D=0xAE & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64   { mmxreg = PackedFloatingAccumulate(mmxreg, m64); }
3: Constructor line ia.sinc:8736(id0.1509) printpiece=[PFACC,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4305  1: m64 : 4306  
Pattern id=1509 pattern=cmb:(ctx:SS:X[000x]:X5:7[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8781 :PFRCPIT2 mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xB6 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingReciprocalIter2(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8781(id0.1532) printpiece=[PFRCPIT2,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4362  1: mmxreg2 : 4363  
Pattern id=1532 pattern=cmb:(ctx:SS:X[000x]:X5:B[0xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8780 :PFRCPIT2 mmxreg, m64      is vexMode=0 & suffix3D=0xB6 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingReciprocalIter2(mmxreg, m64); }
3: Constructor line ia.sinc:8780(id0.1531) printpiece=[PFRCPIT2,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4360  1: m64 : 4361  
Pattern id=1531 pattern=cmb:(ctx:SS:X[000x]:X5:B[0xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8769 :PFRSQRT mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0x97 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingReciprocalSQRAprox(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8769(id0.1526) printpiece=[PFRSQRT,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4347  1: mmxreg2 : 4348  
Pattern id=1526 pattern=cmb:(ctx:SS:X[000x]:X4:B[1xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ef:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8768 :PFRSQRT mmxreg, m64      is vexMode=0 & suffix3D=0x97 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingReciprocalSQRAprox(mmxreg, m64); }
3: Constructor line ia.sinc:8768(id0.1525) printpiece=[PFRSQRT,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4345  1: m64 : 4346  
Pattern id=1525 pattern=cmb:(ctx:SS:X[000x]:X4:B[1xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ef:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8777 :PFRSQIT1 mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xA7 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedFloatingReciprocalSQRIter1(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8777(id0.1530) printpiece=[PFRSQIT1,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4357  1: mmxreg2 : 4358  
Pattern id=1530 pattern=cmb:(ctx:SS:X[000x]:X5:3[1xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8776 :PFRSQIT1 mmxreg, m64      is vexMode=0 & suffix3D=0xA7 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedFloatingReciprocalSQRIter1(mmxreg, m64); }
3: Constructor line ia.sinc:8776(id0.1529) printpiece=[PFRSQIT1,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4355  1: m64 : 4356  
Pattern id=1529 pattern=cmb:(ctx:SS:X[000x]:X5:3[1xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8789 :PMULHRW mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xB7 & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedAverageHighRoundedWord(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8789(id0.1536) printpiece=[PMULHRW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4372  1: mmxreg2 : 4373  
Pattern id=1536 pattern=cmb:(ctx:SS:X[000x]:X5:B[1xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8788 :PMULHRW mmxreg, m64      is vexMode=0 & suffix3D=0xB7 & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedAverageHighRoundedWord(mmxreg, m64); }
3: Constructor line ia.sinc:8788(id0.1535) printpiece=[PMULHRW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4370  1: m64 : 4371  
Pattern id=1535 pattern=cmb:(ctx:SS:X[000x]:X5:B[1xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1634 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; mmxmod=3; Suffix3D) ... & instruction ...         [ instrPhase=1; ] { }
0: Constructor line ia.sinc:1634(id0.19) printpiece=[ B]
Operands 0: Suffix3D : 1388  1: instruction : 1387  
Pattern id=19 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1633 :^instruction is instrPhase=0 & (byte=0x0f; byte=0x0f; XmmReg ... & m64; Suffix3D) ... & instruction ... [ instrPhase=1; ] { }
1: Constructor line ia.sinc:1633(id0.18) printpiece=[ D]
Operands 0: XmmReg : 1384  1: m64 : 1385  2: Suffix3D : 1386  3: instruction : 1383  
Pattern id=18 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]

Line ia.sinc:8785 :PAVGUSB mmxreg1, mmxreg2 is vexMode=0 & suffix3D=0xBF & mandover=0 & byte=0x0F; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2   { mmxreg1 = PackedAverageUnsignedBytes(mmxreg1, mmxreg2); }
2: Constructor line ia.sinc:8785(id0.1534) printpiece=[PAVGUSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4367  1: mmxreg2 : 4368  
Pattern id=1534 pattern=cmb:(ctx:SS:X[000x]:X5:F[1xxx]:XX,ins:0F:0F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8784 :PAVGUSB mmxreg, m64      is vexMode=0 & suffix3D=0xBF & mandover=0 & byte=0x0F; byte=0x0F; mmxreg ... & m64    { mmxreg = PackedAverageUnsignedBytes(mmxreg, m64); }
3: Constructor line ia.sinc:8784(id0.1533) printpiece=[PAVGUSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 4365  1: m64 : 4366  
Pattern id=1533 pattern=cmb:(ctx:SS:X[000x]:X5:F[1xxx]:XX,ins:0F:0F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[f3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5848 :MOVSD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x10; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg2[0,64];
}
0: Constructor line ia.sinc:5848(id0.981) printpiece=[MOVSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3040  1: XmmReg2 : 3041  
Pattern id=981 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:10:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:5842 :MOVSD        XmmReg, m64      is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x10; m64 & XmmReg ...
{
    XmmReg[0,64] = m64;
    XmmReg[64,64] = 0;
}
1: Constructor line ia.sinc:5842(id0.980) printpiece=[MOVSD,  ,  B, ,,  ,  A]
Operands 0: m64 : 3039  1: XmmReg : 3038  
Pattern id=980 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:10:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+80008]:8] = COPY const[0:8]

Line ia.sinc:5871 :MOVSS        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x10; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[0,32];
}
2: Constructor line ia.sinc:5871(id0.985) printpiece=[MOVSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3048  1: XmmReg2 : 3049  
Pattern id=985 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:10:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:5863 :MOVSS        XmmReg, m32      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x10; m32 & XmmReg ...
{
    XmmReg[0,32] = m32;
    XmmReg[32,32] = 0;
    XmmReg[64,32] = 0;
    XmmReg[96,32] = 0;
}
3: Constructor line ia.sinc:5863(id0.984) printpiece=[MOVSS,  ,  B, ,,  ,  A]
Operands 0: m32 : 3047  1: XmmReg : 3046  
Pattern id=984 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:10:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+40004]:4] = COPY const[0:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5893 :MOVUPD       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x10; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg2[64,64];
}
4: Constructor line ia.sinc:5893(id0.989) printpiece=[MOVUPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3056  1: XmmReg2 : 3057  
Pattern id=989 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:10:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5886 :MOVUPD       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x10; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = m[0,64];
    XmmReg[64,64] = m[64,64];
}
5: Constructor line ia.sinc:5886(id0.988) printpiece=[MOVUPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3055  1: XmmReg : 3054  
Pattern id=988 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:10:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[62280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:8] = SUBPIECE unique[62280:10], const[0:4]
	4: [handle:space][[handle:offset+80008]:8] = SUBPIECE unique[62280:10], const[8:4]

Line ia.sinc:5929 :MOVUPS       XmmReg1, XmmReg2 is vexMode=0 &  byte=0x0F; byte=0x10; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg2[96,32];
}
6: Constructor line ia.sinc:5929(id0.993) printpiece=[MOVUPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3064  1: XmmReg2 : 3065  
Pattern id=993 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:10:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5920 :MOVUPS       XmmReg, m128     is vexMode=0 &  byte=0x0F; byte=0x10; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = m[0,32];
    XmmReg[32,32] = m[32,32];
    XmmReg[64,32] = m[64,32];
    XmmReg[96,32] = m[96,32];
}
7: Constructor line ia.sinc:5920(id0.992) printpiece=[MOVUPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 3063  1: XmmReg : 3062  
Pattern id=992 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:10:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[62400:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:4] = SUBPIECE unique[62400:10], const[0:4]
	4: [handle:space][[handle:offset+40004]:4] = SUBPIECE unique[62400:10], const[4:4]
	5: [handle:space][[handle:offset+80008]:4] = SUBPIECE unique[62400:10], const[8:4]
	6: [handle:space][[handle:offset+c000c]:4] = SUBPIECE unique[62400:10], const[c:4]

Line ia.sinc:5942 :MOVUPS       XmmReg2, XmmReg1 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,32] = XmmReg1[0,32];
    XmmReg2[32,32] = XmmReg1[32,32];
    XmmReg2[64,32] = XmmReg1[64,32];
    XmmReg2[96,32] = XmmReg1[96,32];
}
0: Constructor line ia.sinc:5942(id0.995) printpiece=[MOVUPS,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 3069  1: XmmReg2 : 3068  
Pattern id=995 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:11:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5937 :MOVUPS       m128, XmmReg     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x11; m128 & XmmReg ...
{
    m128 = XmmReg;
}
1: Constructor line ia.sinc:5937(id0.994) printpiece=[MOVUPS,  ,  A, ,,  ,  B]
Operands 0: m128 : 3066  1: XmmReg : 3067  
Pattern id=994 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:11:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5904 :MOVUPD       XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,64] = XmmReg1[0,64];
    XmmReg2[64,64] = XmmReg1[64,64];
}
0: Constructor line ia.sinc:5904(id0.991) printpiece=[MOVUPD,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 3061  1: XmmReg2 : 3060  
Pattern id=991 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:11:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5899 :MOVUPD       m128, XmmReg     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x11; m128 & XmmReg ...
{
    m128 = XmmReg;
}
1: Constructor line ia.sinc:5899(id0.990) printpiece=[MOVUPD,  ,  A, ,,  ,  B]
Operands 0: m128 : 3058  1: XmmReg : 3059  
Pattern id=990 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:11:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5881 :MOVSS        XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,32] = XmmReg1[0,32];
}
0: Constructor line ia.sinc:5881(id0.987) printpiece=[MOVSS,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 3053  1: XmmReg2 : 3052  
Pattern id=987 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:11:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:5876 :MOVSS        m32, XmmReg      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x11; m32 & XmmReg ...
{
    m32 = XmmReg[0,32];
}
1: Constructor line ia.sinc:5876(id0.986) printpiece=[MOVSS,  ,  A, ,,  ,  B]
Operands 0: m32 : 3050  1: XmmReg : 3051  
Pattern id=986 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:11:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:5904 :MOVUPD       XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,64] = XmmReg1[0,64];
    XmmReg2[64,64] = XmmReg1[64,64];
}
2: Constructor line ia.sinc:5904(id0.991) printpiece=[MOVUPD,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 3061  1: XmmReg2 : 3060  
Pattern id=991 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:11:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5899 :MOVUPD       m128, XmmReg     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x11; m128 & XmmReg ...
{
    m128 = XmmReg;
}
3: Constructor line ia.sinc:5899(id0.990) printpiece=[MOVUPD,  ,  A, ,,  ,  B]
Operands 0: m128 : 3058  1: XmmReg : 3059  
Pattern id=990 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:11:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5858 :MOVSD        XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,64] = XmmReg1[0,64];
}
0: Constructor line ia.sinc:5858(id0.983) printpiece=[MOVSD,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 3045  1: XmmReg2 : 3044  
Pattern id=983 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:11:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:5853 :MOVSD        m64, XmmReg      is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x11; m64 & XmmReg ...
{
    m64 = XmmReg[0,64];
}
1: Constructor line ia.sinc:5853(id0.982) printpiece=[MOVSD,  ,  A, ,,  ,  B]
Operands 0: m64 : 3042  1: XmmReg : 3043  
Pattern id=982 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:11:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:5881 :MOVSS        XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,32] = XmmReg1[0,32];
}
2: Constructor line ia.sinc:5881(id0.987) printpiece=[MOVSS,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 3053  1: XmmReg2 : 3052  
Pattern id=987 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:11:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:5876 :MOVSS        m32, XmmReg      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x11; m32 & XmmReg ...
{
    m32 = XmmReg[0,32];
}
3: Constructor line ia.sinc:5876(id0.986) printpiece=[MOVSS,  ,  A, ,,  ,  B]
Operands 0: m32 : 3050  1: XmmReg : 3051  
Pattern id=986 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:11:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:5904 :MOVUPD       XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x11; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,64] = XmmReg1[0,64];
    XmmReg2[64,64] = XmmReg1[64,64];
}
4: Constructor line ia.sinc:5904(id0.991) printpiece=[MOVUPD,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 3061  1: XmmReg2 : 3060  
Pattern id=991 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:11:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5899 :MOVUPD       m128, XmmReg     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x11; m128 & XmmReg ...
{
    m128 = XmmReg;
}
5: Constructor line ia.sinc:5899(id0.990) printpiece=[MOVUPD,  ,  A, ,,  ,  B]
Operands 0: m128 : 3058  1: XmmReg : 3059  
Pattern id=990 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:11:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5777 :MOVHLPS      XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x12; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,64] = XmmReg2[64,64]; }
0: Constructor line ia.sinc:5777(id0.955) printpiece=[MOVHLPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2986  1: XmmReg2 : 2987  
Pattern id=955 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:12:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5793 :MOVLPS       XmmReg, m64         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x12; XmmReg ... & m64 { XmmReg[0,64] = m64; }
1: Constructor line ia.sinc:5793(id0.963) printpiece=[MOVLPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3002  1: m64 : 3003  
Pattern id=963 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:12:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5789 :MOVLPD       XmmReg, m64         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x12; XmmReg ... & m64 { XmmReg[0,64] = m64; }
0: Constructor line ia.sinc:5789(id0.961) printpiece=[MOVLPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2998  1: m64 : 2999  
Pattern id=961 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:12:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5754 :MOVSLDUP     XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x12; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg2[0,32];
    XmmReg1[64,32] = XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg2[64,32];
}
0: Constructor line ia.sinc:5754(id0.945) printpiece=[MOVSLDUP,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2965  1: XmmReg2 : 2966  
Pattern id=945 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:12:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+0]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+80008]:4]

Line ia.sinc:5745 :MOVSLDUP     XmmReg, m128        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x12; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = m[0,32];
    XmmReg[32,32] = m[0,32];
    XmmReg[64,32] = m[64,32];
    XmmReg[96,32] = m[64,32];
}
1: Constructor line ia.sinc:5745(id0.944) printpiece=[MOVSLDUP,  ,  B, ,,  ,  A]
Operands 0: m128 : 2964  1: XmmReg : 2963  
Pattern id=944 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:12:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[61c80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:4] = SUBPIECE unique[61c80:10], const[0:4]
	4: [handle:space][[handle:offset+40004]:4] = SUBPIECE unique[61c80:10], const[0:4]
	5: [handle:space][[handle:offset+80008]:4] = SUBPIECE unique[61c80:10], const[8:4]
	6: [handle:space][[handle:offset+c000c]:4] = SUBPIECE unique[61c80:10], const[8:4]

Line ia.sinc:5789 :MOVLPD       XmmReg, m64         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x12; XmmReg ... & m64 { XmmReg[0,64] = m64; }
2: Constructor line ia.sinc:5789(id0.961) printpiece=[MOVLPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2998  1: m64 : 2999  
Pattern id=961 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:12:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5722 :MOVDDUP      XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x12; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg2[0,64];
}
0: Constructor line ia.sinc:5722(id0.941) printpiece=[MOVDDUP,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2957  1: XmmReg2 : 2958  
Pattern id=941 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:12:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:5716 :MOVDDUP      XmmReg, m64         is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x12; m64 & XmmReg ...
{
    XmmReg[0,64] = m64;
    XmmReg[64,64] = m64;
}
1: Constructor line ia.sinc:5716(id0.940) printpiece=[MOVDDUP,  ,  B, ,,  ,  A]
Operands 0: m64 : 2956  1: XmmReg : 2955  
Pattern id=940 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:12:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5754 :MOVSLDUP     XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x12; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg2[0,32];
    XmmReg1[64,32] = XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg2[64,32];
}
2: Constructor line ia.sinc:5754(id0.945) printpiece=[MOVSLDUP,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2965  1: XmmReg2 : 2966  
Pattern id=945 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:12:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+0]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+80008]:4]

Line ia.sinc:5745 :MOVSLDUP     XmmReg, m128        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x12; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = m[0,32];
    XmmReg[32,32] = m[0,32];
    XmmReg[64,32] = m[64,32];
    XmmReg[96,32] = m[64,32];
}
3: Constructor line ia.sinc:5745(id0.944) printpiece=[MOVSLDUP,  ,  B, ,,  ,  A]
Operands 0: m128 : 2964  1: XmmReg : 2963  
Pattern id=944 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:12:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[61c80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:4] = SUBPIECE unique[61c80:10], const[0:4]
	4: [handle:space][[handle:offset+40004]:4] = SUBPIECE unique[61c80:10], const[0:4]
	5: [handle:space][[handle:offset+80008]:4] = SUBPIECE unique[61c80:10], const[8:4]
	6: [handle:space][[handle:offset+c000c]:4] = SUBPIECE unique[61c80:10], const[8:4]

Line ia.sinc:5789 :MOVLPD       XmmReg, m64         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x12; XmmReg ... & m64 { XmmReg[0,64] = m64; }
4: Constructor line ia.sinc:5789(id0.961) printpiece=[MOVLPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2998  1: m64 : 2999  
Pattern id=961 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:12:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5795 :MOVLPS       m64, XmmReg         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x13; XmmReg ... & m64 { m64 = XmmReg[0,64]; }
0: Constructor line ia.sinc:5795(id0.964) printpiece=[MOVLPS,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 3005  1: m64 : 3004  
Pattern id=964 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:13:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:5791 :MOVLPD       m64, XmmReg         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x13; XmmReg ... & m64 { m64 = XmmReg[0,64]; }
0: Constructor line ia.sinc:5791(id0.962) printpiece=[MOVLPD,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 3001  1: m64 : 3000  
Pattern id=962 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:13:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:8222 :UNPCKLPS        XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x14; xmmmod=3 & XmmReg1 & XmmReg2
{
#   XmmReg1[0,32] = XmmReg1[0,32]; superfluous
    XmmReg1[64,32] = XmmReg1[32,32];
    XmmReg1[96,32] = XmmReg2[32,32];
    XmmReg1[32,32] = XmmReg2[0,32]; # XmmReg1 and XmmReg2 could be the same register, preserve Db till last
}
0: Constructor line ia.sinc:8222(id0.1371) printpiece=[UNPCKLPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3922  1: XmmReg2 : 3923  
Pattern id=1371 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:14:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+40004]:4]
	3: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:8213 :UNPCKLPS        XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x14; m128 & XmmReg ...
{
    local m:16 = m128;
#   XmmReg[0,32] = XmmReg[0,32]; superfluous
    XmmReg[64,32] = XmmReg[32,32];
    XmmReg[32,32] = m[0,32];
    XmmReg[96,32] = m[32,32];
}
1: Constructor line ia.sinc:8213(id0.1370) printpiece=[UNPCKLPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 3921  1: XmmReg : 3920  
Pattern id=1370 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:14:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[99500:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+40004]:4] = SUBPIECE unique[99500:10], const[0:4]
	5: [handle:space][[handle:offset+c000c]:4] = SUBPIECE unique[99500:10], const[4:4]

Line ia.sinc:8207 :UNPCKLPD        XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x14; xmmmod=3 & XmmReg1 & XmmReg2
{
#   XmmReg1[0,64] = XmmReg1[0,64]; superfluous
    XmmReg1[64,64] = XmmReg2[0,64];
}
0: Constructor line ia.sinc:8207(id0.1369) printpiece=[UNPCKLPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3918  1: XmmReg2 : 3919  
Pattern id=1369 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:14:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:8201 :UNPCKLPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x14; m128 & XmmReg ...
{
#   XmmReg[0,64] = XmmReg[0,64]; superfluous
    XmmReg[64,64] = m128[0,64];
}
1: Constructor line ia.sinc:8201(id0.1368) printpiece=[UNPCKLPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3917  1: XmmReg : 3916  
Pattern id=1368 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:14:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:8193 :UNPCKHPS        XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x15; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[64,32];
    XmmReg1[32,32] = XmmReg2[64,32];
    XmmReg1[64,32] = XmmReg1[96,32];  # XmmReg1 and XmmReg2 could be the same register, preserve XmmReg1[64,32] till later
    XmmReg1[96,32] = XmmReg2[96,32];
}
0: Constructor line ia.sinc:8193(id0.1367) printpiece=[UNPCKHPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3914  1: XmmReg2 : 3915  
Pattern id=1367 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:15:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+80008]:4]
	3: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+80008]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+c000c]:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:8184 :UNPCKHPS        XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x15; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[64,32];
    XmmReg[64,32] = XmmReg[96,32];
    XmmReg[32,32] = m[64,32];
    XmmReg[96,32] = m[96,32];
}
1: Constructor line ia.sinc:8184(id0.1366) printpiece=[UNPCKHPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 3913  1: XmmReg : 3912  
Pattern id=1366 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:15:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[99380:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+80008]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+c000c]:4]
	5: [handle:space][[handle:offset+40004]:4] = SUBPIECE unique[99380:10], const[8:4]
	6: [handle:space][[handle:offset+c000c]:4] = SUBPIECE unique[99380:10], const[c:4]

Line ia.sinc:8178 :UNPCKHPD        XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x15; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[64,64];
    XmmReg1[64,64] = XmmReg2[64,64];
}
0: Constructor line ia.sinc:8178(id0.1365) printpiece=[UNPCKHPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3910  1: XmmReg2 : 3911  
Pattern id=1365 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:15:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+80008]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:8172 :UNPCKHPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x15; m128 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[64,64];
    XmmReg[64,64] = m128[64,64];
}
1: Constructor line ia.sinc:8172(id0.1364) printpiece=[UNPCKHPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3909  1: XmmReg : 3908  
Pattern id=1364 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:15:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+80008]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5787 :MOVLHPS      XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x16; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[64,64] = XmmReg2[0,64]; }
0: Constructor line ia.sinc:5787(id0.960) printpiece=[MOVLHPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2996  1: XmmReg2 : 2997  
Pattern id=960 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:16:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:5783 :MOVHPS       XmmReg, m64         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x16; XmmReg ... & m64 { XmmReg[64,64] = m64; }
1: Constructor line ia.sinc:5783(id0.958) printpiece=[MOVHPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2992  1: m64 : 2993  
Pattern id=958 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:16:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5779 :MOVHPD       XmmReg, m64         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x16; XmmReg ... & m64 { XmmReg[64,64] = m64; }
0: Constructor line ia.sinc:5779(id0.956) printpiece=[MOVHPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2988  1: m64 : 2989  
Pattern id=956 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:16:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5737 :MOVSHDUP     XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x16; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[32,32];
    XmmReg1[32,32] = XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg2[96,32];
    XmmReg1[96,32] = XmmReg2[96,32];
}
0: Constructor line ia.sinc:5737(id0.943) printpiece=[MOVSHDUP,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2961  1: XmmReg2 : 2962  
Pattern id=943 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:16:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+40004]:4]
	3: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+c000c]:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5728 :MOVSHDUP     XmmReg, m128        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x16; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = m[32,32];
    XmmReg[32,32] = m[32,32];
    XmmReg[64,32] = m[96,32];
    XmmReg[96,32] = m[96,32];
}
1: Constructor line ia.sinc:5728(id0.942) printpiece=[MOVSHDUP,  ,  B, ,,  ,  A]
Operands 0: m128 : 2960  1: XmmReg : 2959  
Pattern id=942 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:16:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[61a00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:4] = SUBPIECE unique[61a00:10], const[4:4]
	4: [handle:space][[handle:offset+40004]:4] = SUBPIECE unique[61a00:10], const[4:4]
	5: [handle:space][[handle:offset+80008]:4] = SUBPIECE unique[61a00:10], const[c:4]
	6: [handle:space][[handle:offset+c000c]:4] = SUBPIECE unique[61a00:10], const[c:4]

Line ia.sinc:5779 :MOVHPD       XmmReg, m64         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x16; XmmReg ... & m64 { XmmReg[64,64] = m64; }
2: Constructor line ia.sinc:5779(id0.956) printpiece=[MOVHPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2988  1: m64 : 2989  
Pattern id=956 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:16:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5785 :MOVHPS       m64, XmmReg         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x17; XmmReg ... & m64 { m64 = XmmReg[64,64]; }
0: Constructor line ia.sinc:5785(id0.959) printpiece=[MOVHPS,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 2995  1: m64 : 2994  
Pattern id=959 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:17:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5781 :MOVHPD       m64, XmmReg         is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x17; XmmReg ... & m64 { m64 = XmmReg[64,64]; }
0: Constructor line ia.sinc:5781(id0.957) printpiece=[MOVHPD,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 2991  1: m64 : 2990  
Pattern id=957 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:17:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3327 :PREFETCHNTA m8 is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=0 ) ... & m8 { }
1: Constructor line ia.sinc:3327(id0.398) printpiece=[PREFETCHNTA,  ,  A]
Operands 0: m8 : 2075  
Pattern id=398 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:0[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3327 :PREFETCHNTA m8 is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=0 ) ... & m8 { }
1: Constructor line ia.sinc:3327(id0.398) printpiece=[PREFETCHNTA,  ,  A]
Operands 0: m8 : 2075  
Pattern id=398 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:0[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3324 :PREFETCHT0 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=1 ) ... & m8 { }
1: Constructor line ia.sinc:3324(id0.395) printpiece=[PREFETCHT0,  ,  A]
Operands 0: m8 : 2072  
Pattern id=395 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:0[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3324 :PREFETCHT0 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=1 ) ... & m8 { }
1: Constructor line ia.sinc:3324(id0.395) printpiece=[PREFETCHT0,  ,  A]
Operands 0: m8 : 2072  
Pattern id=395 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:0[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3325 :PREFETCHT1 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=2 ) ... & m8 { }
1: Constructor line ia.sinc:3325(id0.396) printpiece=[PREFETCHT1,  ,  A]
Operands 0: m8 : 2073  
Pattern id=396 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:1[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3325 :PREFETCHT1 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=2 ) ... & m8 { }
1: Constructor line ia.sinc:3325(id0.396) printpiece=[PREFETCHT1,  ,  A]
Operands 0: m8 : 2073  
Pattern id=396 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:1[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3326 :PREFETCHT2 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=3 ) ... & m8 { }
1: Constructor line ia.sinc:3326(id0.397) printpiece=[PREFETCHT2,  ,  A]
Operands 0: m8 : 2074  
Pattern id=397 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:1[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3326 :PREFETCHT2 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=3 ) ... & m8 { }
1: Constructor line ia.sinc:3326(id0.397) printpiece=[PREFETCHT2,  ,  A]
Operands 0: m8 : 2074  
Pattern id=397 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:1[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3327 :PREFETCHNTA m8 is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=0 ) ... & m8 { }
1: Constructor line ia.sinc:3327(id0.398) printpiece=[PREFETCHNTA,  ,  A]
Operands 0: m8 : 2075  
Pattern id=398 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:4[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3327 :PREFETCHNTA m8 is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=0 ) ... & m8 { }
1: Constructor line ia.sinc:3327(id0.398) printpiece=[PREFETCHNTA,  ,  A]
Operands 0: m8 : 2075  
Pattern id=398 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:4[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3324 :PREFETCHT0 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=1 ) ... & m8 { }
1: Constructor line ia.sinc:3324(id0.395) printpiece=[PREFETCHT0,  ,  A]
Operands 0: m8 : 2072  
Pattern id=395 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:4[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3324 :PREFETCHT0 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=1 ) ... & m8 { }
1: Constructor line ia.sinc:3324(id0.395) printpiece=[PREFETCHT0,  ,  A]
Operands 0: m8 : 2072  
Pattern id=395 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:4[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3325 :PREFETCHT1 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=2 ) ... & m8 { }
1: Constructor line ia.sinc:3325(id0.396) printpiece=[PREFETCHT1,  ,  A]
Operands 0: m8 : 2073  
Pattern id=396 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:5[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3325 :PREFETCHT1 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=2 ) ... & m8 { }
1: Constructor line ia.sinc:3325(id0.396) printpiece=[PREFETCHT1,  ,  A]
Operands 0: m8 : 2073  
Pattern id=396 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:5[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3326 :PREFETCHT2 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=3 ) ... & m8 { }
1: Constructor line ia.sinc:3326(id0.397) printpiece=[PREFETCHT2,  ,  A]
Operands 0: m8 : 2074  
Pattern id=397 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:5[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3326 :PREFETCHT2 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=3 ) ... & m8 { }
1: Constructor line ia.sinc:3326(id0.397) printpiece=[PREFETCHT2,  ,  A]
Operands 0: m8 : 2074  
Pattern id=397 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:5[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3327 :PREFETCHNTA m8 is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=0 ) ... & m8 { }
1: Constructor line ia.sinc:3327(id0.398) printpiece=[PREFETCHNTA,  ,  A]
Operands 0: m8 : 2075  
Pattern id=398 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:8[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3327 :PREFETCHNTA m8 is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=0 ) ... & m8 { }
1: Constructor line ia.sinc:3327(id0.398) printpiece=[PREFETCHNTA,  ,  A]
Operands 0: m8 : 2075  
Pattern id=398 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:8[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3324 :PREFETCHT0 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=1 ) ... & m8 { }
1: Constructor line ia.sinc:3324(id0.395) printpiece=[PREFETCHT0,  ,  A]
Operands 0: m8 : 2072  
Pattern id=395 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:8[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3324 :PREFETCHT0 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=1 ) ... & m8 { }
1: Constructor line ia.sinc:3324(id0.395) printpiece=[PREFETCHT0,  ,  A]
Operands 0: m8 : 2072  
Pattern id=395 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:8[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3325 :PREFETCHT1 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=2 ) ... & m8 { }
1: Constructor line ia.sinc:3325(id0.396) printpiece=[PREFETCHT1,  ,  A]
Operands 0: m8 : 2073  
Pattern id=396 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:9[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3325 :PREFETCHT1 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=2 ) ... & m8 { }
1: Constructor line ia.sinc:3325(id0.396) printpiece=[PREFETCHT1,  ,  A]
Operands 0: m8 : 2073  
Pattern id=396 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:9[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3326 :PREFETCHT2 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=3 ) ... & m8 { }
1: Constructor line ia.sinc:3326(id0.397) printpiece=[PREFETCHT2,  ,  A]
Operands 0: m8 : 2074  
Pattern id=397 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:9[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3326 :PREFETCHT2 m8  is vexMode=0 & byte=0x0f; byte=0x18; ( mod != 0b11 & reg_opcode=3 ) ... & m8 { }
1: Constructor line ia.sinc:3326(id0.397) printpiece=[PREFETCHT2,  ,  A]
Operands 0: m8 : 2074  
Pattern id=397 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:18:9[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3214 :NOP^"/reserved" rm16 is vexMode=0 & mandover & opsize=0 & byte=0x0f; byte=0x18; rm16 & reg_opcode_hb=1 ...    { }
0: Constructor line ia.sinc:3214(id0.333) printpiece=[NOP/reserved,  ,  B]
Operands 0: mandover : 1981  1: rm16 : 1980  
Pattern id=333 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:18:[xx1x]X:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
1: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3215 :NOP^"/reserved" rm32 is vexMode=0 & mandover & opsize=1 & byte=0x0f; byte=0x18; rm32 & reg_opcode_hb=1 ...    { }
0: Constructor line ia.sinc:3215(id0.334) printpiece=[NOP/reserved,  ,  B]
Operands 0: mandover : 1983  1: rm32 : 1982  
Pattern id=334 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:18:[xx1x]X:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
1: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line mpx.sinc:141 :BNDCL bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_lb & Rmr32 {
#   if (reg < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
0: Constructor line mpx.sinc:141(id0.2100) printpiece=[BNDCL,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7065  1: bnd1_lb : 7067  2: Rmr32 : 7066  
Pattern id=2100 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cb780:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cb800:1] = INT_LESS unique[cb780:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[cb880:1] = BOOL_NEGATE unique[cb800:1]
	4: CBRANCH const[[rel:0]:4], unique[cb880:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:149 :BNDCL bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_lb) ... & Mem {
#   if (LEA(mem) < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
1: Constructor line mpx.sinc:149(id0.2101) printpiece=[BNDCL,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7068  1: bnd1_lb : 7070  2: Mem : 7069  
Pattern id=2101 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cb900:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cb980:1] = INT_LESS unique[cb900:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[cba00:1] = BOOL_NEGATE unique[cb980:1]
	4: CBRANCH const[[rel:0]:4], unique[cba00:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:157 :BNDCU bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
2: Constructor line mpx.sinc:157(id0.2102) printpiece=[BNDCU,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7071  1: bnd1_ub : 7073  2: Rmr32 : 7072  
Pattern id=2102 pattern=cmb:(ctx:X[xx00]:X[1xxx]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbb00:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: unique[cba80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[cbb80:1] = INT_LESS unique[cbb00:[handle:size]], unique[cba80:[handle:size]]
	4: unique[cbc00:1] = BOOL_NEGATE unique[cbb80:1]
	5: CBRANCH const[[rel:0]:4], unique[cbc00:1]
	6: register[710:8] = COPY const[1:8]
	7: CALLOTHER const[27a:4]
	8: PTRADD const[0:4]

Line mpx.sinc:165 :BNDCU bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
3: Constructor line mpx.sinc:165(id0.2103) printpiece=[BNDCU,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7074  1: bnd1_ub : 7076  2: Mem : 7075  
Pattern id=2103 pattern=cmb:(ctx:X[xx00]:X[1xxx]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbd00:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: unique[cbc80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[cbd80:1] = INT_LESS unique[cbd00:[handle:size]], unique[cbc80:[handle:size]]
	4: unique[cbe00:1] = BOOL_NEGATE unique[cbd80:1]
	5: CBRANCH const[[rel:0]:4], unique[cbe00:1]
	6: register[710:8] = COPY const[1:8]
	7: CALLOTHER const[27a:4]
	8: PTRADD const[0:4]

Line mpx.sinc:214 :BNDMOV bnd1, bnd2      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd2 {
	bnd1 = bnd2;
}
4: Constructor line mpx.sinc:214(id0.2109) printpiece=[BNDMOV,  ,  A, ,,  ,  B]
Operands 0: bnd1 : 7096  1: bnd2 : 7097  
Pattern id=2109 pattern=cmb:(ctx:X[xx00]:X[xx1x]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:207 :BNDMOV bnd1, m64      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	tmp:8 = m64;
	bnd1_lb = zext(tmp:4);
    tmp2:4 = tmp(4);
    bnd1_ub = zext(tmp2);
}
5: Constructor line mpx.sinc:207(id0.2108) printpiece=[BNDMOV,  ,  A, ,,  ,  D]
Operands 0: bnd1 : 7092  1: bnd1_lb : 7094  2: bnd1_ub : 7095  3: m64 : 7093  
Pattern id=2108 pattern=cmb:(ctx:X[xx00]:X[xx1x]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc600:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc680:4] = SUBPIECE unique[cc600:8], const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc680:4]
	4: unique[cc800:4] = SUBPIECE unique[cc600:8], const[4:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc800:4]

Line mpx.sinc:190 :BNDLDX bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndldx_status( Mem, BNDCFGS, BNDCFGU );
#	bnd1      = bndldx( Mem, BNDCFGS, BNDCFGU );
	
# core implementation
   tmp:8 = *:8 Mem;
   bnd1_lb = zext(tmp:4);
   tmp2:4 = tmp(4);
   bnd1_ub = zext(tmp2);
}
6: Constructor line mpx.sinc:190(id0.2106) printpiece=[BNDLDX,  ,  A, ,,  ,  D]
Operands 0: bnd1 : 7083  1: bnd1_lb : 7085  2: bnd1_ub : 7086  3: Mem : 7084  
Pattern id=2106 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc200:8] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc280:4] = SUBPIECE unique[cc200:8], const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc280:4]
	4: unique[cc400:4] = SUBPIECE unique[cc200:8], const[4:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc400:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
7: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line mpx.sinc:141 :BNDCL bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_lb & Rmr32 {
#   if (reg < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
0: Constructor line mpx.sinc:141(id0.2100) printpiece=[BNDCL,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7065  1: bnd1_lb : 7067  2: Rmr32 : 7066  
Pattern id=2100 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cb780:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cb800:1] = INT_LESS unique[cb780:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[cb880:1] = BOOL_NEGATE unique[cb800:1]
	4: CBRANCH const[[rel:0]:4], unique[cb880:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:149 :BNDCL bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_lb) ... & Mem {
#   if (LEA(mem) < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
1: Constructor line mpx.sinc:149(id0.2101) printpiece=[BNDCL,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7068  1: bnd1_lb : 7070  2: Mem : 7069  
Pattern id=2101 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cb900:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cb980:1] = INT_LESS unique[cb900:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[cba00:1] = BOOL_NEGATE unique[cb980:1]
	4: CBRANCH const[[rel:0]:4], unique[cba00:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:157 :BNDCU bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
2: Constructor line mpx.sinc:157(id0.2102) printpiece=[BNDCU,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7071  1: bnd1_ub : 7073  2: Rmr32 : 7072  
Pattern id=2102 pattern=cmb:(ctx:X[xx01]:X[1xxx]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbb00:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: unique[cba80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[cbb80:1] = INT_LESS unique[cbb00:[handle:size]], unique[cba80:[handle:size]]
	4: unique[cbc00:1] = BOOL_NEGATE unique[cbb80:1]
	5: CBRANCH const[[rel:0]:4], unique[cbc00:1]
	6: register[710:8] = COPY const[1:8]
	7: CALLOTHER const[27a:4]
	8: PTRADD const[0:4]

Line mpx.sinc:165 :BNDCU bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
3: Constructor line mpx.sinc:165(id0.2103) printpiece=[BNDCU,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7074  1: bnd1_ub : 7076  2: Mem : 7075  
Pattern id=2103 pattern=cmb:(ctx:X[xx01]:X[1xxx]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbd00:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: unique[cbc80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[cbd80:1] = INT_LESS unique[cbd00:[handle:size]], unique[cbc80:[handle:size]]
	4: unique[cbe00:1] = BOOL_NEGATE unique[cbd80:1]
	5: CBRANCH const[[rel:0]:4], unique[cbe00:1]
	6: register[710:8] = COPY const[1:8]
	7: CALLOTHER const[27a:4]
	8: PTRADD const[0:4]

Line mpx.sinc:214 :BNDMOV bnd1, bnd2      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd2 {
	bnd1 = bnd2;
}
4: Constructor line mpx.sinc:214(id0.2109) printpiece=[BNDMOV,  ,  A, ,,  ,  B]
Operands 0: bnd1 : 7096  1: bnd2 : 7097  
Pattern id=2109 pattern=cmb:(ctx:X[xx01]:X[xx1x]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:207 :BNDMOV bnd1, m64      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	tmp:8 = m64;
	bnd1_lb = zext(tmp:4);
    tmp2:4 = tmp(4);
    bnd1_ub = zext(tmp2);
}
5: Constructor line mpx.sinc:207(id0.2108) printpiece=[BNDMOV,  ,  A, ,,  ,  D]
Operands 0: bnd1 : 7092  1: bnd1_lb : 7094  2: bnd1_ub : 7095  3: m64 : 7093  
Pattern id=2108 pattern=cmb:(ctx:X[xx01]:X[xx1x]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc600:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc680:4] = SUBPIECE unique[cc600:8], const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc680:4]
	4: unique[cc800:4] = SUBPIECE unique[cc600:8], const[4:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc800:4]

Line mpx.sinc:190 :BNDLDX bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndldx_status( Mem, BNDCFGS, BNDCFGU );
#	bnd1      = bndldx( Mem, BNDCFGS, BNDCFGU );
	
# core implementation
   tmp:8 = *:8 Mem;
   bnd1_lb = zext(tmp:4);
   tmp2:4 = tmp(4);
   bnd1_ub = zext(tmp2);
}
6: Constructor line mpx.sinc:190(id0.2106) printpiece=[BNDLDX,  ,  A, ,,  ,  D]
Operands 0: bnd1 : 7083  1: bnd1_lb : 7085  2: bnd1_ub : 7086  3: Mem : 7084  
Pattern id=2106 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc200:8] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc280:4] = SUBPIECE unique[cc200:8], const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc280:4]
	4: unique[cc400:4] = SUBPIECE unique[cc200:8], const[4:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc400:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
7: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line mpx.sinc:141 :BNDCL bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_lb & Rmr32 {
#   if (reg < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
0: Constructor line mpx.sinc:141(id0.2100) printpiece=[BNDCL,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7065  1: bnd1_lb : 7067  2: Rmr32 : 7066  
Pattern id=2100 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cb780:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cb800:1] = INT_LESS unique[cb780:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[cb880:1] = BOOL_NEGATE unique[cb800:1]
	4: CBRANCH const[[rel:0]:4], unique[cb880:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:149 :BNDCL bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_lb) ... & Mem {
#   if (LEA(mem) < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
1: Constructor line mpx.sinc:149(id0.2101) printpiece=[BNDCL,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7068  1: bnd1_lb : 7070  2: Mem : 7069  
Pattern id=2101 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cb900:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cb980:1] = INT_LESS unique[cb900:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[cba00:1] = BOOL_NEGATE unique[cb980:1]
	4: CBRANCH const[[rel:0]:4], unique[cba00:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:157 :BNDCU bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
2: Constructor line mpx.sinc:157(id0.2102) printpiece=[BNDCU,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7071  1: bnd1_ub : 7073  2: Rmr32 : 7072  
Pattern id=2102 pattern=cmb:(ctx:X[xx10]:X[1xxx]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbb00:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: unique[cba80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[cbb80:1] = INT_LESS unique[cbb00:[handle:size]], unique[cba80:[handle:size]]
	4: unique[cbc00:1] = BOOL_NEGATE unique[cbb80:1]
	5: CBRANCH const[[rel:0]:4], unique[cbc00:1]
	6: register[710:8] = COPY const[1:8]
	7: CALLOTHER const[27a:4]
	8: PTRADD const[0:4]

Line mpx.sinc:165 :BNDCU bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
3: Constructor line mpx.sinc:165(id0.2103) printpiece=[BNDCU,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7074  1: bnd1_ub : 7076  2: Mem : 7075  
Pattern id=2103 pattern=cmb:(ctx:X[xx10]:X[1xxx]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbd00:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: unique[cbc80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[cbd80:1] = INT_LESS unique[cbd00:[handle:size]], unique[cbc80:[handle:size]]
	4: unique[cbe00:1] = BOOL_NEGATE unique[cbd80:1]
	5: CBRANCH const[[rel:0]:4], unique[cbe00:1]
	6: register[710:8] = COPY const[1:8]
	7: CALLOTHER const[27a:4]
	8: PTRADD const[0:4]

Line mpx.sinc:214 :BNDMOV bnd1, bnd2      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd2 {
	bnd1 = bnd2;
}
4: Constructor line mpx.sinc:214(id0.2109) printpiece=[BNDMOV,  ,  A, ,,  ,  B]
Operands 0: bnd1 : 7096  1: bnd2 : 7097  
Pattern id=2109 pattern=cmb:(ctx:X[xx10]:X[xx1x]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:207 :BNDMOV bnd1, m64      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	tmp:8 = m64;
	bnd1_lb = zext(tmp:4);
    tmp2:4 = tmp(4);
    bnd1_ub = zext(tmp2);
}
5: Constructor line mpx.sinc:207(id0.2108) printpiece=[BNDMOV,  ,  A, ,,  ,  D]
Operands 0: bnd1 : 7092  1: bnd1_lb : 7094  2: bnd1_ub : 7095  3: m64 : 7093  
Pattern id=2108 pattern=cmb:(ctx:X[xx10]:X[xx1x]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc600:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc680:4] = SUBPIECE unique[cc600:8], const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc680:4]
	4: unique[cc800:4] = SUBPIECE unique[cc600:8], const[4:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc800:4]

Line mpx.sinc:190 :BNDLDX bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndldx_status( Mem, BNDCFGS, BNDCFGU );
#	bnd1      = bndldx( Mem, BNDCFGS, BNDCFGU );
	
# core implementation
   tmp:8 = *:8 Mem;
   bnd1_lb = zext(tmp:4);
   tmp2:4 = tmp(4);
   bnd1_ub = zext(tmp2);
}
6: Constructor line mpx.sinc:190(id0.2106) printpiece=[BNDLDX,  ,  A, ,,  ,  D]
Operands 0: bnd1 : 7083  1: bnd1_lb : 7085  2: bnd1_ub : 7086  3: Mem : 7084  
Pattern id=2106 pattern=cmb:(ctx:X[xx10]:XX:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc200:8] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc280:4] = SUBPIECE unique[cc200:8], const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc280:4]
	4: unique[cc400:4] = SUBPIECE unique[cc200:8], const[4:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc400:4]

Line mpx.sinc:141 :BNDCL bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_lb & Rmr32 {
#   if (reg < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
0: Constructor line mpx.sinc:141(id0.2100) printpiece=[BNDCL,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7065  1: bnd1_lb : 7067  2: Rmr32 : 7066  
Pattern id=2100 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cb780:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cb800:1] = INT_LESS unique[cb780:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[cb880:1] = BOOL_NEGATE unique[cb800:1]
	4: CBRANCH const[[rel:0]:4], unique[cb880:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:149 :BNDCL bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_lb) ... & Mem {
#   if (LEA(mem) < BND.LB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) < bnd1_lb) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
1: Constructor line mpx.sinc:149(id0.2101) printpiece=[BNDCL,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7068  1: bnd1_lb : 7070  2: Mem : 7069  
Pattern id=2101 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cb900:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cb980:1] = INT_LESS unique[cb900:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[cba00:1] = BOOL_NEGATE unique[cb980:1]
	4: CBRANCH const[[rel:0]:4], unique[cba00:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:157 :BNDCU bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
2: Constructor line mpx.sinc:157(id0.2102) printpiece=[BNDCU,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7071  1: bnd1_ub : 7073  2: Rmr32 : 7072  
Pattern id=2102 pattern=cmb:(ctx:X[xx11]:X[1xxx]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbb00:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: unique[cba80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[cbb80:1] = INT_LESS unique[cbb00:[handle:size]], unique[cba80:[handle:size]]
	4: unique[cbc00:1] = BOOL_NEGATE unique[cbb80:1]
	5: CBRANCH const[[rel:0]:4], unique[cbc00:1]
	6: register[710:8] = COPY const[1:8]
	7: CALLOTHER const[27a:4]
	8: PTRADD const[0:4]

Line mpx.sinc:165 :BNDCU bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1A; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > ~(BND.UB)) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > ~bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
3: Constructor line mpx.sinc:165(id0.2103) printpiece=[BNDCU,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7074  1: bnd1_ub : 7076  2: Mem : 7075  
Pattern id=2103 pattern=cmb:(ctx:X[xx11]:X[1xxx]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbd00:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: unique[cbc80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[cbd80:1] = INT_LESS unique[cbd00:[handle:size]], unique[cbc80:[handle:size]]
	4: unique[cbe00:1] = BOOL_NEGATE unique[cbd80:1]
	5: CBRANCH const[[rel:0]:4], unique[cbe00:1]
	6: register[710:8] = COPY const[1:8]
	7: CALLOTHER const[27a:4]
	8: PTRADD const[0:4]

Line mpx.sinc:214 :BNDMOV bnd1, bnd2      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; mod=3 & bnd1 & bnd2 {
	bnd1 = bnd2;
}
4: Constructor line mpx.sinc:214(id0.2109) printpiece=[BNDMOV,  ,  A, ,,  ,  B]
Operands 0: bnd1 : 7096  1: bnd2 : 7097  
Pattern id=2109 pattern=cmb:(ctx:X[xx11]:X[xx1x]:X[0xxx]:XX,ins:0F:1A:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:207 :BNDMOV bnd1, m64      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	tmp:8 = m64;
	bnd1_lb = zext(tmp:4);
    tmp2:4 = tmp(4);
    bnd1_ub = zext(tmp2);
}
5: Constructor line mpx.sinc:207(id0.2108) printpiece=[BNDMOV,  ,  A, ,,  ,  D]
Operands 0: bnd1 : 7092  1: bnd1_lb : 7094  2: bnd1_ub : 7095  3: m64 : 7093  
Pattern id=2108 pattern=cmb:(ctx:X[xx11]:X[xx1x]:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc600:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc680:4] = SUBPIECE unique[cc600:8], const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc680:4]
	4: unique[cc800:4] = SUBPIECE unique[cc600:8], const[4:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc800:4]

Line mpx.sinc:190 :BNDLDX bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1A; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndldx_status( Mem, BNDCFGS, BNDCFGU );
#	bnd1      = bndldx( Mem, BNDCFGS, BNDCFGU );
	
# core implementation
   tmp:8 = *:8 Mem;
   bnd1_lb = zext(tmp:4);
   tmp2:4 = tmp(4);
   bnd1_ub = zext(tmp2);
}
6: Constructor line mpx.sinc:190(id0.2106) printpiece=[BNDLDX,  ,  A, ,,  ,  D]
Operands 0: bnd1 : 7083  1: bnd1_lb : 7085  2: bnd1_ub : 7086  3: Mem : 7084  
Pattern id=2106 pattern=cmb:(ctx:X[xx11]:XX:X[0xxx]:XX,ins:0F:1A:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc200:8] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc280:4] = SUBPIECE unique[cc200:8], const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc280:4]
	4: unique[cc400:4] = SUBPIECE unique[cc200:8], const[4:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[cc400:4]

Line mpx.sinc:173 :BNDCN bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
0: Constructor line mpx.sinc:173(id0.2104) printpiece=[BNDCN,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7077  1: bnd1_ub : 7079  2: Rmr32 : 7078  
Pattern id=2104 pattern=cmb:(ctx:X[xx00]:X[1xxx]:X[0xxx]:XX,ins:0F:1B:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbe80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cbf00:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], unique[cbe80:[handle:size]]
	3: unique[cbf80:1] = BOOL_NEGATE unique[cbf00:1]
	4: CBRANCH const[[rel:0]:4], unique[cbf80:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:181 :BNDCN bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
1: Constructor line mpx.sinc:181(id0.2105) printpiece=[BNDCN,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7080  1: bnd1_ub : 7082  2: Mem : 7081  
Pattern id=2105 pattern=cmb:(ctx:X[xx00]:X[1xxx]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cc000:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc080:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], unique[cc000:[handle:size]]
	3: unique[cc100:1] = BOOL_NEGATE unique[cc080:1]
	4: CBRANCH const[[rel:0]:4], unique[cc100:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:201 :BNDMK bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & ( bndmk_addr32 & Mem ) {
#   BND.LB and BND.UB set from m32
	bnd1_lb = zext(bndmk_addr32);
	bnd1_ub = zext(Mem);
}
2: Constructor line mpx.sinc:201(id0.2107) printpiece=[BNDMK,  ,  A, ,,  ,  E]
Operands 0: bnd1 : 7087  1: bnd1_lb : 7089  2: bnd1_ub : 7090  3: bndmk_addr32 : 7091  4: Mem : 7088  
Pattern id=2107 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:222 :BNDMOV bnd2, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd2 {
	bnd2 = bnd1;
}
3: Constructor line mpx.sinc:222(id0.2111) printpiece=[BNDMOV,  ,  B, ,,  ,  A]
Operands 0: bnd1 : 7103  1: bnd2 : 7102  
Pattern id=2111 pattern=cmb:(ctx:X[xx00]:X[xx1x]:X[0xxx]:XX,ins:0F:1B:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:218 :BNDMOV m64, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	m64 = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}
4: Constructor line mpx.sinc:218(id0.2110) printpiece=[BNDMOV,  ,  D, ,,  ,  A]
Operands 0: bnd1 : 7099  1: bnd1_lb : 7100  2: bnd1_ub : 7101  3: m64 : 7098  
Pattern id=2110 pattern=cmb:(ctx:X[xx00]:X[xx1x]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc900:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: unique[cc980:[handle:size]] = INT_LEFT unique[cc900:[handle:size]], const[20:4]
	3: unique[cca00:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[cc980:[handle:size]], unique[cca00:[handle:size]]

Line mpx.sinc:227 :BNDSTX Mem, bnd1      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndstx_status( bnd1, BNDCFGS, BNDCFGU );
#	Mem       = bndstx( bnd1, BNDCFGS, BNDCFGU );

# core implementation
   *:8 Mem = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}
5: Constructor line mpx.sinc:227(id0.2112) printpiece=[BNDSTX,  ,  D, ,,  ,  A]
Operands 0: bnd1 : 7105  1: bnd1_lb : 7106  2: bnd1_ub : 7107  3: Mem : 7104  
Pattern id=2112 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[ccb00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: unique[ccb80:8] = INT_LEFT unique[ccb00:8], const[20:4]
	3: unique[ccc00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: unique[ccc80:8] = INT_OR unique[ccb80:8], unique[ccc00:8]
	5: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], unique[ccc80:8]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
6: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line mpx.sinc:173 :BNDCN bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
0: Constructor line mpx.sinc:173(id0.2104) printpiece=[BNDCN,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7077  1: bnd1_ub : 7079  2: Rmr32 : 7078  
Pattern id=2104 pattern=cmb:(ctx:X[xx01]:X[1xxx]:X[0xxx]:XX,ins:0F:1B:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbe80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cbf00:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], unique[cbe80:[handle:size]]
	3: unique[cbf80:1] = BOOL_NEGATE unique[cbf00:1]
	4: CBRANCH const[[rel:0]:4], unique[cbf80:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:181 :BNDCN bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
1: Constructor line mpx.sinc:181(id0.2105) printpiece=[BNDCN,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7080  1: bnd1_ub : 7082  2: Mem : 7081  
Pattern id=2105 pattern=cmb:(ctx:X[xx01]:X[1xxx]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cc000:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc080:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], unique[cc000:[handle:size]]
	3: unique[cc100:1] = BOOL_NEGATE unique[cc080:1]
	4: CBRANCH const[[rel:0]:4], unique[cc100:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:201 :BNDMK bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & ( bndmk_addr32 & Mem ) {
#   BND.LB and BND.UB set from m32
	bnd1_lb = zext(bndmk_addr32);
	bnd1_ub = zext(Mem);
}
2: Constructor line mpx.sinc:201(id0.2107) printpiece=[BNDMK,  ,  A, ,,  ,  E]
Operands 0: bnd1 : 7087  1: bnd1_lb : 7089  2: bnd1_ub : 7090  3: bndmk_addr32 : 7091  4: Mem : 7088  
Pattern id=2107 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:222 :BNDMOV bnd2, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd2 {
	bnd2 = bnd1;
}
3: Constructor line mpx.sinc:222(id0.2111) printpiece=[BNDMOV,  ,  B, ,,  ,  A]
Operands 0: bnd1 : 7103  1: bnd2 : 7102  
Pattern id=2111 pattern=cmb:(ctx:X[xx01]:X[xx1x]:X[0xxx]:XX,ins:0F:1B:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:218 :BNDMOV m64, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	m64 = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}
4: Constructor line mpx.sinc:218(id0.2110) printpiece=[BNDMOV,  ,  D, ,,  ,  A]
Operands 0: bnd1 : 7099  1: bnd1_lb : 7100  2: bnd1_ub : 7101  3: m64 : 7098  
Pattern id=2110 pattern=cmb:(ctx:X[xx01]:X[xx1x]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc900:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: unique[cc980:[handle:size]] = INT_LEFT unique[cc900:[handle:size]], const[20:4]
	3: unique[cca00:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[cc980:[handle:size]], unique[cca00:[handle:size]]

Line mpx.sinc:227 :BNDSTX Mem, bnd1      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndstx_status( bnd1, BNDCFGS, BNDCFGU );
#	Mem       = bndstx( bnd1, BNDCFGS, BNDCFGU );

# core implementation
   *:8 Mem = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}
5: Constructor line mpx.sinc:227(id0.2112) printpiece=[BNDSTX,  ,  D, ,,  ,  A]
Operands 0: bnd1 : 7105  1: bnd1_lb : 7106  2: bnd1_ub : 7107  3: Mem : 7104  
Pattern id=2112 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[ccb00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: unique[ccb80:8] = INT_LEFT unique[ccb00:8], const[20:4]
	3: unique[ccc00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: unique[ccc80:8] = INT_OR unique[ccb80:8], unique[ccc00:8]
	5: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], unique[ccc80:8]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
6: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line mpx.sinc:173 :BNDCN bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
0: Constructor line mpx.sinc:173(id0.2104) printpiece=[BNDCN,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7077  1: bnd1_ub : 7079  2: Rmr32 : 7078  
Pattern id=2104 pattern=cmb:(ctx:X[xx10]:X[1xxx]:X[0xxx]:XX,ins:0F:1B:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbe80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cbf00:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], unique[cbe80:[handle:size]]
	3: unique[cbf80:1] = BOOL_NEGATE unique[cbf00:1]
	4: CBRANCH const[[rel:0]:4], unique[cbf80:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:181 :BNDCN bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
1: Constructor line mpx.sinc:181(id0.2105) printpiece=[BNDCN,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7080  1: bnd1_ub : 7082  2: Mem : 7081  
Pattern id=2105 pattern=cmb:(ctx:X[xx10]:X[1xxx]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cc000:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc080:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], unique[cc000:[handle:size]]
	3: unique[cc100:1] = BOOL_NEGATE unique[cc080:1]
	4: CBRANCH const[[rel:0]:4], unique[cc100:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:201 :BNDMK bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & ( bndmk_addr32 & Mem ) {
#   BND.LB and BND.UB set from m32
	bnd1_lb = zext(bndmk_addr32);
	bnd1_ub = zext(Mem);
}
2: Constructor line mpx.sinc:201(id0.2107) printpiece=[BNDMK,  ,  A, ,,  ,  E]
Operands 0: bnd1 : 7087  1: bnd1_lb : 7089  2: bnd1_ub : 7090  3: bndmk_addr32 : 7091  4: Mem : 7088  
Pattern id=2107 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:222 :BNDMOV bnd2, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd2 {
	bnd2 = bnd1;
}
3: Constructor line mpx.sinc:222(id0.2111) printpiece=[BNDMOV,  ,  B, ,,  ,  A]
Operands 0: bnd1 : 7103  1: bnd2 : 7102  
Pattern id=2111 pattern=cmb:(ctx:X[xx10]:X[xx1x]:X[0xxx]:XX,ins:0F:1B:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:218 :BNDMOV m64, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	m64 = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}
4: Constructor line mpx.sinc:218(id0.2110) printpiece=[BNDMOV,  ,  D, ,,  ,  A]
Operands 0: bnd1 : 7099  1: bnd1_lb : 7100  2: bnd1_ub : 7101  3: m64 : 7098  
Pattern id=2110 pattern=cmb:(ctx:X[xx10]:X[xx1x]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc900:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: unique[cc980:[handle:size]] = INT_LEFT unique[cc900:[handle:size]], const[20:4]
	3: unique[cca00:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[cc980:[handle:size]], unique[cca00:[handle:size]]

Line mpx.sinc:227 :BNDSTX Mem, bnd1      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndstx_status( bnd1, BNDCFGS, BNDCFGU );
#	Mem       = bndstx( bnd1, BNDCFGS, BNDCFGU );

# core implementation
   *:8 Mem = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}
5: Constructor line mpx.sinc:227(id0.2112) printpiece=[BNDSTX,  ,  D, ,,  ,  A]
Operands 0: bnd1 : 7105  1: bnd1_lb : 7106  2: bnd1_ub : 7107  3: Mem : 7104  
Pattern id=2112 pattern=cmb:(ctx:X[xx10]:XX:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[ccb00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: unique[ccb80:8] = INT_LEFT unique[ccb00:8], const[20:4]
	3: unique[ccc00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: unique[ccc80:8] = INT_OR unique[ccb80:8], unique[ccc00:8]
	5: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], unique[ccc80:8]

Line mpx.sinc:173 :BNDCN bnd1, Rmr32      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd1_ub & Rmr32 {
#   if (reg > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Rmr32) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
0: Constructor line mpx.sinc:173(id0.2104) printpiece=[BNDCN,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7077  1: bnd1_ub : 7079  2: Rmr32 : 7078  
Pattern id=2104 pattern=cmb:(ctx:X[xx11]:X[1xxx]:X[0xxx]:XX,ins:0F:1B:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cbe80:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cbf00:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], unique[cbe80:[handle:size]]
	3: unique[cbf80:1] = BOOL_NEGATE unique[cbf00:1]
	4: CBRANCH const[[rel:0]:4], unique[cbf80:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:181 :BNDCN bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x1B; (bnd1 & bnd1_ub) ... & Mem {
#   if (LEA(mem) > BND.UB) then BNDSTATUS = 01H; AND BOUND EXCEPTION
   if !(zext(Mem) > bnd1_ub) goto <done>;
      BNDSTATUS = 0x01;
      br_exception();
 <done>
}
1: Constructor line mpx.sinc:181(id0.2105) printpiece=[BNDCN,  ,  A, ,,  ,  C]
Operands 0: bnd1 : 7080  1: bnd1_ub : 7082  2: Mem : 7081  
Pattern id=2105 pattern=cmb:(ctx:X[xx11]:X[1xxx]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cc000:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[cc080:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], unique[cc000:[handle:size]]
	3: unique[cc100:1] = BOOL_NEGATE unique[cc080:1]
	4: CBRANCH const[[rel:0]:4], unique[cc100:1]
	5: register[710:8] = COPY const[1:8]
	6: CALLOTHER const[27a:4]
	7: PTRADD const[0:4]

Line mpx.sinc:201 :BNDMK bnd1, Mem      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & ( bndmk_addr32 & Mem ) {
#   BND.LB and BND.UB set from m32
	bnd1_lb = zext(bndmk_addr32);
	bnd1_ub = zext(Mem);
}
2: Constructor line mpx.sinc:201(id0.2107) printpiece=[BNDMK,  ,  A, ,,  ,  E]
Operands 0: bnd1 : 7087  1: bnd1_lb : 7089  2: bnd1_ub : 7090  3: bndmk_addr32 : 7091  4: Mem : 7088  
Pattern id=2107 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:222 :BNDMOV bnd2, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; mod=3 & bnd1 & bnd2 {
	bnd2 = bnd1;
}
3: Constructor line mpx.sinc:222(id0.2111) printpiece=[BNDMOV,  ,  B, ,,  ,  A]
Operands 0: bnd1 : 7103  1: bnd2 : 7102  
Pattern id=2111 pattern=cmb:(ctx:X[xx11]:X[xx1x]:X[0xxx]:XX,ins:0F:1B:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line mpx.sinc:218 :BNDMOV m64, bnd1      is $(LONGMODE_OFF) & vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & m64 {
	m64 = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}
4: Constructor line mpx.sinc:218(id0.2110) printpiece=[BNDMOV,  ,  D, ,,  ,  A]
Operands 0: bnd1 : 7099  1: bnd1_lb : 7100  2: bnd1_ub : 7101  3: m64 : 7098  
Pattern id=2110 pattern=cmb:(ctx:X[xx11]:X[xx1x]:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[cc900:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: unique[cc980:[handle:size]] = INT_LEFT unique[cc900:[handle:size]], const[20:4]
	3: unique[cca00:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[cc980:[handle:size]], unique[cca00:[handle:size]]

Line mpx.sinc:227 :BNDSTX Mem, bnd1      is $(LONGMODE_OFF) & vexMode=0 & byte=0x0F; byte=0x1B; ( bnd1 & bnd1_lb & bnd1_ub ) ... & Mem {
#	BNDSTATUS = bndstx_status( bnd1, BNDCFGS, BNDCFGU );
#	Mem       = bndstx( bnd1, BNDCFGS, BNDCFGU );

# core implementation
   *:8 Mem = (zext(bnd1_ub:4) << 32) | zext(bnd1_lb:4);
}
5: Constructor line mpx.sinc:227(id0.2112) printpiece=[BNDSTX,  ,  D, ,,  ,  A]
Operands 0: bnd1 : 7105  1: bnd1_lb : 7106  2: bnd1_ub : 7107  3: Mem : 7104  
Pattern id=2112 pattern=cmb:(ctx:X[xx11]:XX:X[0xxx]:XX,ins:0F:1B:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: unique[ccb00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: unique[ccb80:8] = INT_LEFT unique[ccb00:8], const[20:4]
	3: unique[ccc00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: unique[ccc80:8] = INT_OR unique[ccb80:8], unique[ccc00:8]
	5: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], unique[ccc80:8]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
0: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
0: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line cet.sinc:24 :RDSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; mod=3 & reg_opcode=1 & r32 {
    r32 = SSP:4;
}
0: Constructor line cet.sinc:24(id0.2139) printpiece=[RDSSPD,  ,  A]
Operands 0: r32 : 7214  
Pattern id=2139 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:1E:C[1xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY register[7c0:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
1: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line cet.sinc:79 :ENDBR32  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; byte=0xfb {}
0: Constructor line cet.sinc:79(id0.2146) printpiece=[ENDBR32]
Operands 
Pattern id=2146 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:1E:FB:XX)
Template

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
1: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line cet.sinc:24 :RDSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; mod=3 & reg_opcode=1 & r32 {
    r32 = SSP:4;
}
0: Constructor line cet.sinc:24(id0.2139) printpiece=[RDSSPD,  ,  A]
Operands 0: r32 : 7214  
Pattern id=2139 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:1E:C[1xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY register[7c0:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
1: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line cet.sinc:79 :ENDBR32  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; byte=0xfb {}
0: Constructor line cet.sinc:79(id0.2146) printpiece=[ENDBR32]
Operands 
Pattern id=2146 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:1E:FB:XX)
Template

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
1: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line cet.sinc:24 :RDSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; mod=3 & reg_opcode=1 & r32 {
    r32 = SSP:4;
}
0: Constructor line cet.sinc:24(id0.2139) printpiece=[RDSSPD,  ,  A]
Operands 0: r32 : 7214  
Pattern id=2139 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:1E:C[1xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY register[7c0:4]

Line cet.sinc:79 :ENDBR32  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; byte=0xfb {}
0: Constructor line cet.sinc:79(id0.2146) printpiece=[ENDBR32]
Operands 
Pattern id=2146 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:1E:FB:XX)
Template

Line cet.sinc:24 :RDSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; mod=3 & reg_opcode=1 & r32 {
    r32 = SSP:4;
}
0: Constructor line cet.sinc:24(id0.2139) printpiece=[RDSSPD,  ,  A]
Operands 0: r32 : 7214  
Pattern id=2139 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:1E:C[1xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY register[7c0:4]

Line cet.sinc:79 :ENDBR32  is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0x1e; byte=0xfb {}
0: Constructor line cet.sinc:79(id0.2146) printpiece=[ENDBR32]
Operands 
Pattern id=2146 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:1E:FB:XX)
Template

Line ia.sinc:3216 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; byte=0x1f; rm16 & reg_opcode=0 ... { }
0: Constructor line ia.sinc:3216(id0.335) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1985  1: rm16 : 1984  
Pattern id=335 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1F:[xx00][0xxx]:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3212 :NOP rm16       is vexMode=0 & mandover & opsize=0 & byte=0x0f; high5=3; rm16  ...    { }
1: Constructor line ia.sinc:3212(id0.331) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1977  1: rm16 : 1976  
Pattern id=331 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3217 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; byte=0x1f; rm32 & reg_opcode=0 ... { }
0: Constructor line ia.sinc:3217(id0.336) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1987  1: rm32 : 1986  
Pattern id=336 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1F:[xx00][0xxx]:XX)
Template
	0: MULTIEQUAL const[1:4]

Line ia.sinc:3213 :NOP rm32       is vexMode=0 & mandover & opsize=1 & byte=0x0f; high5=3; rm32  ...    { }
1: Constructor line ia.sinc:3213(id0.332) printpiece=[NOP,  ,  B]
Operands 0: mandover : 1979  1: rm32 : 1978  
Pattern id=332 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3104 :MOV Rmr32, creg_x      is vexMode=0 &           rexRprefix=1 & byte=0xf; byte=0x20; Rmr32 & creg_x     { Rmr32 = creg_x:4; }
0: Constructor line ia.sinc:3104(id0.300) printpiece=[MOV,  ,  A, ,,  ,  B]
Operands 0: Rmr32 : 1917  1: creg_x : 1918  
Pattern id=300 pattern=cmb:(ctx:SS:SS:[1xxx][0xxx]:XX:XX:XX,ins:0F:20:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:4]

Line ia.sinc:3097 :MOV Rmr32, creg        is vexMode=0 &           byte=0xf; byte=0x20; Rmr32 & creg      {
@ifdef IA64
    Rmr32 = creg:4;
@else
    Rmr32 = creg;
@endif
}
1: Constructor line ia.sinc:3097(id0.299) printpiece=[MOV,  ,  A, ,,  ,  B]
Operands 0: Rmr32 : 1915  1: creg : 1916  
Pattern id=299 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:20:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3116 :MOV Rmr32, debugreg_x  is vexMode=0 &           rexRprefix=1 & byte=0xf; byte=0x21; Rmr32 & debugreg_x     { Rmr32 = debugreg_x:4; }
0: Constructor line ia.sinc:3116(id0.302) printpiece=[MOV,  ,  A, ,,  ,  B]
Operands 0: Rmr32 : 1921  1: debugreg_x : 1922  
Pattern id=302 pattern=cmb:(ctx:SS:SS:[1xxx][0xxx]:XX:XX:XX,ins:0F:21:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:4]

Line ia.sinc:3109 :MOV Rmr32, debugreg    is vexMode=0 &           byte=0xf; byte=0x21; Rmr32 & debugreg      {
@ifdef IA64
    Rmr32 = debugreg:4;
@else
    Rmr32 = debugreg;
@endif
}
1: Constructor line ia.sinc:3109(id0.301) printpiece=[MOV,  ,  A, ,,  ,  B]
Operands 0: Rmr32 : 1919  1: debugreg : 1920  
Pattern id=301 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:21:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3085 :MOV creg, Rmr32        is vexMode=0 &           byte=0xf; byte=0x22; Rmr32 & creg      {
@ifdef IA64
    creg=zext(Rmr32);
@else
    creg=Rmr32;
@endif
}
0: Constructor line ia.sinc:3085(id0.298) printpiece=[MOV,  ,  B, ,,  ,  A]
Operands 0: Rmr32 : 1914  1: creg : 1913  
Pattern id=298 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:22:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3121 :MOV debugreg, Rmr32    is vexMode=0 &           byte=0xf; byte=0x23; Rmr32 & debugreg      {
@ifdef IA64
    debugreg = zext(Rmr32);
@else
    debugreg = Rmr32;
@endif
}
0: Constructor line ia.sinc:3121(id0.303) printpiece=[MOV,  ,  B, ,,  ,  A]
Operands 0: Rmr32 : 1924  1: debugreg : 1923  
Pattern id=303 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:23:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5684 :MOVAPS       XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x28; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg2[96,32];
}
0: Constructor line ia.sinc:5684(id0.933) printpiece=[MOVAPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2939  1: XmmReg2 : 2940  
Pattern id=933 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:28:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5675 :MOVAPS       XmmReg, m128        is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x28; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = m[0,32];
    XmmReg[32,32] = m[32,32];
    XmmReg[64,32] = m[64,32];
    XmmReg[96,32] = m[96,32];
}
1: Constructor line ia.sinc:5675(id0.932) printpiece=[MOVAPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2938  1: XmmReg : 2937  
Pattern id=932 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:28:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[61580:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:4] = SUBPIECE unique[61580:10], const[0:4]
	4: [handle:space][[handle:offset+40004]:4] = SUBPIECE unique[61580:10], const[4:4]
	5: [handle:space][[handle:offset+80008]:4] = SUBPIECE unique[61580:10], const[8:4]
	6: [handle:space][[handle:offset+c000c]:4] = SUBPIECE unique[61580:10], const[c:4]

Line ia.sinc:5658 :MOVAPD       XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x28; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg2[64,64];
}
0: Constructor line ia.sinc:5658(id0.929) printpiece=[MOVAPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2931  1: XmmReg2 : 2932  
Pattern id=929 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:28:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5651 :MOVAPD       XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x28; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = m[0,64];
    XmmReg[64,64] = m[64,64];
}
1: Constructor line ia.sinc:5651(id0.928) printpiece=[MOVAPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 2930  1: XmmReg : 2929  
Pattern id=928 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:28:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[61400:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:8] = SUBPIECE unique[61400:10], const[0:4]
	4: [handle:space][[handle:offset+80008]:8] = SUBPIECE unique[61400:10], const[8:4]

Line ia.sinc:5697 :MOVAPS       XmmReg2, XmmReg1    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x29; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,32] = XmmReg1[0,32];
    XmmReg2[32,32] = XmmReg1[32,32];
    XmmReg2[64,32] = XmmReg1[64,32];
    XmmReg2[96,32] = XmmReg1[96,32];
}
0: Constructor line ia.sinc:5697(id0.935) printpiece=[MOVAPS,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 2944  1: XmmReg2 : 2943  
Pattern id=935 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:29:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5692 :MOVAPS       m128, XmmReg        is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x29; m128 & XmmReg ...
{
    m128 = XmmReg;
}
1: Constructor line ia.sinc:5692(id0.934) printpiece=[MOVAPS,  ,  A, ,,  ,  B]
Operands 0: m128 : 2941  1: XmmReg : 2942  
Pattern id=934 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:29:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5669 :MOVAPD       XmmReg2, XmmReg1    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x29; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg2[0,64] = XmmReg1[0,64];
    XmmReg2[64,64] = XmmReg1[64,64];
}
0: Constructor line ia.sinc:5669(id0.931) printpiece=[MOVAPD,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 2936  1: XmmReg2 : 2935  
Pattern id=931 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:29:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5664 :MOVAPD       m128, XmmReg        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x29; m128 & XmmReg ...
{
    m128 = XmmReg;
}
1: Constructor line ia.sinc:5664(id0.930) printpiece=[MOVAPD,  ,  A, ,,  ,  B]
Operands 0: m128 : 2933  1: XmmReg : 2934  
Pattern id=930 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:29:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5236 :CVTPI2PS     XmmReg1, mmxreg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2A; xmmmod=3 & XmmReg1 & mmxreg2
{
  XmmReg1[0,32] = int2float(mmxreg2[0,32]);
  XmmReg1[32,32] = int2float(mmxreg2[32,32]);
}
0: Constructor line ia.sinc:5236(id0.864) printpiece=[CVTPI2PS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2795  1: mmxreg2 : 2796  
Pattern id=864 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset+0]:4] = INT2FLOAT [handle:space][[handle:offset+0]:4]
	2: [handle:space][[handle:offset+40004]:4] = INT2FLOAT [handle:space][[handle:offset+40004]:4]

Line ia.sinc:5229 :CVTPI2PS     XmmReg, m64       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2A; m64 & XmmReg ...
{
  local m:8 = m64;
  XmmReg[0,32] = int2float(m[0,32]);
  XmmReg[32,32] = int2float(m[32,32]);
}
1: Constructor line ia.sinc:5229(id0.863) printpiece=[CVTPI2PS,  ,  B, ,,  ,  A]
Operands 0: m64 : 2794  1: XmmReg : 2793  
Pattern id=863 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5c700:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5c780:4] = SUBPIECE unique[5c700:8], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = INT2FLOAT unique[5c780:4]
	5: unique[5c880:4] = SUBPIECE unique[5c700:8], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = INT2FLOAT unique[5c880:4]

Line ia.sinc:5331 :CVTSI2SS     XmmReg, rm32    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x2A; rm32 & XmmReg ...
{
  XmmReg[0,32] = int2float(rm32);
}
0: Constructor line ia.sinc:5331(id0.876) printpiece=[CVTSI2SS,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2820  1: XmmReg : 2819  
Pattern id=876 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5319 :CVTSI2SD     XmmReg, rm32    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x2A; rm32 & XmmReg ...
{
  XmmReg[0,64] = int2float(rm32);
}
0: Constructor line ia.sinc:5319(id0.875) printpiece=[CVTSI2SD,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2818  1: XmmReg : 2817  
Pattern id=875 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:2A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5331 :CVTSI2SS     XmmReg, rm32    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x2A; rm32 & XmmReg ...
{
  XmmReg[0,32] = int2float(rm32);
}
1: Constructor line ia.sinc:5331(id0.876) printpiece=[CVTSI2SS,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2820  1: XmmReg : 2819  
Pattern id=876 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5223 :CVTPI2PD     XmmReg1, mmxreg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2A; xmmmod=3 & XmmReg1 & mmxreg2
{
  XmmReg1[0,64] = int2float(mmxreg2[0,32]);
  XmmReg1[64,64] = int2float(mmxreg2[32,32]);
}
0: Constructor line ia.sinc:5223(id0.862) printpiece=[CVTPI2PD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2791  1: mmxreg2 : 2792  
Pattern id=862 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset+0]:8] = INT2FLOAT [handle:space][[handle:offset+0]:4]
	2: [handle:space][[handle:offset+80008]:8] = INT2FLOAT [handle:space][[handle:offset+40004]:4]

Line ia.sinc:5216 :CVTPI2PD     XmmReg, m64       is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2A; m64 & XmmReg ...
{
  local m:8 = m64;
  XmmReg[0,64] =  int2float(m[0,32]);
  XmmReg[64,64] =  int2float(m[32,32]);
}
1: Constructor line ia.sinc:5216(id0.861) printpiece=[CVTPI2PD,  ,  B, ,,  ,  A]
Operands 0: m64 : 2790  1: XmmReg : 2789  
Pattern id=861 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5c380:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5c400:4] = SUBPIECE unique[5c380:8], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = INT2FLOAT unique[5c400:4]
	5: unique[5c500:4] = SUBPIECE unique[5c380:8], const[4:4]
	6: [handle:space][[handle:offset+80008]:8] = INT2FLOAT unique[5c500:4]

Line ia.sinc:5319 :CVTSI2SD     XmmReg, rm32    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x2A; rm32 & XmmReg ...
{
  XmmReg[0,64] = int2float(rm32);
}
2: Constructor line ia.sinc:5319(id0.875) printpiece=[CVTSI2SD,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2818  1: XmmReg : 2817  
Pattern id=875 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:2A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5331 :CVTSI2SS     XmmReg, rm32    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x2A; rm32 & XmmReg ...
{
  XmmReg[0,32] = int2float(rm32);
}
3: Constructor line ia.sinc:5331(id0.876) printpiece=[CVTSI2SS,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2820  1: XmmReg : 2819  
Pattern id=876 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5809 :MOVNTPS      m128, XmmReg     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2B; XmmReg ... & m128 { m128 = XmmReg; }
0: Constructor line ia.sinc:5809(id0.970) printpiece=[MOVNTPS,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 3019  1: m128 : 3018  
Pattern id=970 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2B:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5807 :MOVNTPD      m128, XmmReg     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2B; XmmReg ... & m128  { m128 = XmmReg; }
0: Constructor line ia.sinc:5807(id0.969) printpiece=[MOVNTPD,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 3017  1: m128 : 3016  
Pattern id=969 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2B:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5432 :CVTTPS2PI    mmxreg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2C; xmmmod=3 & mmxreg1 & XmmReg2
{
  mmxreg1[0,32] = trunc(XmmReg2[0,32]);
  mmxreg1[32,32] = trunc(XmmReg2[32,32]);
  FPUTagWord = 0x0000;         
}
0: Constructor line ia.sinc:5432(id0.888) printpiece=[CVTTPS2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 2843  1: XmmReg2 : 2844  
Pattern id=888 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:4]
	2: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+40004]:4]
	3: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5424 :CVTTPS2PI    mmxreg, m64         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2C; mmxreg ... & m64
{
  local m:8 = m64;
  mmxreg[0,32] = trunc(m[0,32]);
  mmxreg[32,32] = trunc(m[32,32]);
  FPUTagWord = 0x0000;         
}
1: Constructor line ia.sinc:5424(id0.887) printpiece=[CVTTPS2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 2841  1: m64 : 2842  
Pattern id=887 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[5eb80:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[5ec00:4] = SUBPIECE unique[5eb80:8], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = TRUNC unique[5ec00:4]
	4: unique[5ed00:4] = SUBPIECE unique[5eb80:8], const[4:4]
	5: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5ed00:4]
	6: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5383 :CVTTPD2PI    mmxreg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2C; xmmmod=3 & mmxreg1 & XmmReg2
{
  mmxreg1[0,32] = trunc(XmmReg2[0,64]);
  mmxreg1[32,32] = trunc(XmmReg2[64,64]);
  FPUTagWord = 0x0000;         
}
0: Constructor line ia.sinc:5383(id0.882) printpiece=[CVTTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 2831  1: XmmReg2 : 2832  
Pattern id=882 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:8]
	2: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+80008]:8]
	3: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5375 :CVTTPD2PI    mmxreg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2C; mmxreg ... & m128
{
  local m:16 = m128;
  mmxreg[0,32] = trunc(m[0,64]);
  mmxreg[32,32] = trunc(m[64,64]);
  FPUTagWord = 0x0000;         
}
1: Constructor line ia.sinc:5375(id0.881) printpiece=[CVTTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 2829  1: m128 : 2830  
Pattern id=881 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[5de00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[5de80:8] = SUBPIECE unique[5de00:10], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = TRUNC unique[5de80:8]
	4: unique[5df80:8] = SUBPIECE unique[5de00:10], const[8:4]
	5: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5df80:8]
	6: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5383 :CVTTPD2PI    mmxreg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2C; xmmmod=3 & mmxreg1 & XmmReg2
{
  mmxreg1[0,32] = trunc(XmmReg2[0,64]);
  mmxreg1[32,32] = trunc(XmmReg2[64,64]);
  FPUTagWord = 0x0000;         
}
0: Constructor line ia.sinc:5383(id0.882) printpiece=[CVTTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 2831  1: XmmReg2 : 2832  
Pattern id=882 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:8]
	2: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+80008]:8]
	3: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5375 :CVTTPD2PI    mmxreg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2C; mmxreg ... & m128
{
  local m:16 = m128;
  mmxreg[0,32] = trunc(m[0,64]);
  mmxreg[32,32] = trunc(m[64,64]);
  FPUTagWord = 0x0000;         
}
1: Constructor line ia.sinc:5375(id0.881) printpiece=[CVTTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 2829  1: m128 : 2830  
Pattern id=881 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[5de00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[5de80:8] = SUBPIECE unique[5de00:10], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = TRUNC unique[5de80:8]
	4: unique[5df80:8] = SUBPIECE unique[5de00:10], const[8:4]
	5: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5df80:8]
	6: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5466 :CVTTSS2SI    Reg32, XmmReg2  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2C; xmmmod=3 & Reg32 & XmmReg2
{
  Reg32 = trunc(XmmReg2[0,32]);
}
2: Constructor line ia.sinc:5466(id0.892) printpiece=[CVTTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2851  1: XmmReg2 : 2852  
Pattern id=892 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC [handle:space][[handle:offset+0]:4]

Line ia.sinc:5461 :CVTTSS2SI    Reg32, m32  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2C; Reg32 ... & m32
{
  Reg32 = trunc(m32);
}
3: Constructor line ia.sinc:5461(id0.891) printpiece=[CVTTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2849  1: m32 : 2850  
Pattern id=891 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5383 :CVTTPD2PI    mmxreg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2C; xmmmod=3 & mmxreg1 & XmmReg2
{
  mmxreg1[0,32] = trunc(XmmReg2[0,64]);
  mmxreg1[32,32] = trunc(XmmReg2[64,64]);
  FPUTagWord = 0x0000;         
}
0: Constructor line ia.sinc:5383(id0.882) printpiece=[CVTTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 2831  1: XmmReg2 : 2832  
Pattern id=882 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:8]
	2: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+80008]:8]
	3: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5375 :CVTTPD2PI    mmxreg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2C; mmxreg ... & m128
{
  local m:16 = m128;
  mmxreg[0,32] = trunc(m[0,64]);
  mmxreg[32,32] = trunc(m[64,64]);
  FPUTagWord = 0x0000;         
}
1: Constructor line ia.sinc:5375(id0.881) printpiece=[CVTTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 2829  1: m128 : 2830  
Pattern id=881 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[5de00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[5de80:8] = SUBPIECE unique[5de00:10], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = TRUNC unique[5de80:8]
	4: unique[5df80:8] = SUBPIECE unique[5de00:10], const[8:4]
	5: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5df80:8]
	6: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5444 :CVTTSD2SI    Reg32, XmmReg2  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x2C; xmmmod=3 & Reg32 & XmmReg2
{
  Reg32 = trunc(XmmReg2[0,64]);
}
2: Constructor line ia.sinc:5444(id0.890) printpiece=[CVTTSD2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2847  1: XmmReg2 : 2848  
Pattern id=890 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:2C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC [handle:space][[handle:offset+0]:8]

Line ia.sinc:5439 :CVTTSD2SI    Reg32, m64  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x2C; Reg32 ... & m64
{
  Reg32 = trunc(m64);
}
3: Constructor line ia.sinc:5439(id0.889) printpiece=[CVTTSD2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2845  1: m64 : 2846  
Pattern id=889 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:2C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5466 :CVTTSS2SI    Reg32, XmmReg2  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2C; xmmmod=3 & Reg32 & XmmReg2
{
  Reg32 = trunc(XmmReg2[0,32]);
}
4: Constructor line ia.sinc:5466(id0.892) printpiece=[CVTTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2851  1: XmmReg2 : 2852  
Pattern id=892 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC [handle:space][[handle:offset+0]:4]

Line ia.sinc:5461 :CVTTSS2SI    Reg32, m32  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2C; Reg32 ... & m32
{
  Reg32 = trunc(m32);
}
5: Constructor line ia.sinc:5461(id0.891) printpiece=[CVTTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2849  1: m32 : 2850  
Pattern id=891 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5280 :CVTPS2PI     mmxreg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2D; xmmmod=3 & mmxreg1 & XmmReg2
{
  mmxreg1[0,32] = round(XmmReg2[0,32]);
  mmxreg1[32,32] = round(XmmReg2[32,32]);
  FPUTagWord = 0x0000;         
}
0: Constructor line ia.sinc:5280(id0.870) printpiece=[CVTPS2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 2807  1: XmmReg2 : 2808  
Pattern id=870 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = ROUND [handle:space][[handle:offset+0]:4]
	2: [handle:space][[handle:offset+40004]:4] = ROUND [handle:space][[handle:offset+40004]:4]
	3: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5272 :CVTPS2PI     mmxreg, m64         is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2D; mmxreg ... & m64
{
  local m:8 = m64;
  mmxreg[0,32] = round(m[0,32]);
  mmxreg[32,32] = round(m[32,32]);
  FPUTagWord = 0x0000;         
}
1: Constructor line ia.sinc:5272(id0.869) printpiece=[CVTPS2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 2805  1: m64 : 2806  
Pattern id=869 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[5d480:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[5d500:4] = SUBPIECE unique[5d480:8], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = ROUND unique[5d500:4]
	4: unique[5d600:4] = SUBPIECE unique[5d480:8], const[4:4]
	5: [handle:space][[handle:offset+40004]:4] = ROUND unique[5d600:4]
	6: register[10a4:2] = COPY const[0:2]

Line ia.sinc:5193 :CVTPD2PI     mmxreg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2D; xmmmod=3 & mmxreg1 & XmmReg2
{
    mmxreg1[0,32] = trunc( XmmReg2[0,64] );
    mmxreg1[32,32] = trunc( XmmReg2[64,64] );
}
0: Constructor line ia.sinc:5193(id0.858) printpiece=[CVTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 2783  1: XmmReg2 : 2784  
Pattern id=858 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:8]
	2: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5186 :CVTPD2PI     mmxreg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2D; mmxreg ... & m128
{
    local m:16 = m128;
    mmxreg[0,32] = trunc( m[0,64] );
    mmxreg[32,32] = trunc( m[64,64] );
}
1: Constructor line ia.sinc:5186(id0.857) printpiece=[CVTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 2781  1: m128 : 2782  
Pattern id=857 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[5bc80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[5bd00:8] = SUBPIECE unique[5bc80:10], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = TRUNC unique[5bd00:8]
	4: unique[5be00:8] = SUBPIECE unique[5bc80:10], const[8:4]
	5: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5be00:8]

Line ia.sinc:5193 :CVTPD2PI     mmxreg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2D; xmmmod=3 & mmxreg1 & XmmReg2
{
    mmxreg1[0,32] = trunc( XmmReg2[0,64] );
    mmxreg1[32,32] = trunc( XmmReg2[64,64] );
}
0: Constructor line ia.sinc:5193(id0.858) printpiece=[CVTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 2783  1: XmmReg2 : 2784  
Pattern id=858 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:8]
	2: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5186 :CVTPD2PI     mmxreg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2D; mmxreg ... & m128
{
    local m:16 = m128;
    mmxreg[0,32] = trunc( m[0,64] );
    mmxreg[32,32] = trunc( m[64,64] );
}
1: Constructor line ia.sinc:5186(id0.857) printpiece=[CVTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 2781  1: m128 : 2782  
Pattern id=857 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[5bc80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[5bd00:8] = SUBPIECE unique[5bc80:10], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = TRUNC unique[5bd00:8]
	4: unique[5be00:8] = SUBPIECE unique[5bc80:10], const[8:4]
	5: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5be00:8]

Line ia.sinc:5358 :CVTSS2SI     Reg32, XmmReg2 is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2D; xmmmod=3 & Reg32 & XmmReg2
{
  Reg32 = round(XmmReg2[0,32]);
}
2: Constructor line ia.sinc:5358(id0.880) printpiece=[CVTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2827  1: XmmReg2 : 2828  
Pattern id=880 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = ROUND [handle:space][[handle:offset+0]:4]

Line ia.sinc:5353 :CVTSS2SI     Reg32, m32    is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2D; Reg32 ... & m32
{
  Reg32 = round(m32);
}
3: Constructor line ia.sinc:5353(id0.879) printpiece=[CVTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2825  1: m32 : 2826  
Pattern id=879 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = ROUND [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5193 :CVTPD2PI     mmxreg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2D; xmmmod=3 & mmxreg1 & XmmReg2
{
    mmxreg1[0,32] = trunc( XmmReg2[0,64] );
    mmxreg1[32,32] = trunc( XmmReg2[64,64] );
}
0: Constructor line ia.sinc:5193(id0.858) printpiece=[CVTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 2783  1: XmmReg2 : 2784  
Pattern id=858 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:8]
	2: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5186 :CVTPD2PI     mmxreg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2D; mmxreg ... & m128
{
    local m:16 = m128;
    mmxreg[0,32] = trunc( m[0,64] );
    mmxreg[32,32] = trunc( m[64,64] );
}
1: Constructor line ia.sinc:5186(id0.857) printpiece=[CVTPD2PI,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 2781  1: m128 : 2782  
Pattern id=857 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[5bc80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[5bd00:8] = SUBPIECE unique[5bc80:10], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = TRUNC unique[5bd00:8]
	4: unique[5be00:8] = SUBPIECE unique[5bc80:10], const[8:4]
	5: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5be00:8]

Line ia.sinc:5292 :CVTSD2SI     Reg32, XmmReg2 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x2D; xmmmod=3 & Reg32 & XmmReg2
{
  Reg32 = trunc(round(XmmReg2[0,64]));
}
2: Constructor line ia.sinc:5292(id0.872) printpiece=[CVTSD2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2811  1: XmmReg2 : 2812  
Pattern id=872 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:2D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[5d900:8] = ROUND [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[5d900:8]

Line ia.sinc:5287 :CVTSD2SI     Reg32, m64    is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x2D; Reg32 ... & m64
{
  Reg32 = trunc(round(m64));
}
3: Constructor line ia.sinc:5287(id0.871) printpiece=[CVTSD2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2809  1: m64 : 2810  
Pattern id=871 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:2D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[5d800:[handle:size]] = ROUND [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[5d800:[handle:size]]

Line ia.sinc:5358 :CVTSS2SI     Reg32, XmmReg2 is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2D; xmmmod=3 & Reg32 & XmmReg2
{
  Reg32 = round(XmmReg2[0,32]);
}
4: Constructor line ia.sinc:5358(id0.880) printpiece=[CVTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2827  1: XmmReg2 : 2828  
Pattern id=880 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = ROUND [handle:space][[handle:offset+0]:4]

Line ia.sinc:5353 :CVTSS2SI     Reg32, m32    is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x2D; Reg32 ... & m32
{
  Reg32 = round(m32);
}
5: Constructor line ia.sinc:5353(id0.879) printpiece=[CVTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2825  1: m32 : 2826  
Pattern id=879 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:2D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = ROUND [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8167 :UCOMISS         XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x2E; xmmmod=3 & XmmReg1 & XmmReg2
{
    fucompe(XmmReg1[0,32], XmmReg2[0,32]);
}
0: Constructor line ia.sinc:8167(id0.1363) printpiece=[UCOMISS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3906  1: XmmReg2 : 3907  
Pattern id=1363 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[13300:1] = FLOAT_NAN [handle:space][[handle:offset+0]:4]
	3: unique[13380:1] = FLOAT_NAN [handle:space][[handle:offset+0]:4]
	4: register[202:1] = BOOL_OR unique[13300:1], unique[13380:1]
	5: unique[13480:1] = FLOAT_EQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	6: register[206:1] = INT_OR register[202:1], unique[13480:1]
	7: unique[13580:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	8: register[200:1] = INT_OR register[202:1], unique[13580:1]
	9: register[20b:1] = COPY const[0:1]
	10: register[204:1] = COPY const[0:1]
	11: register[207:1] = COPY const[0:1]

Line ia.sinc:8162 :UCOMISS         XmmReg, m32      is vexMode=0 & mandover=0 & byte=0x0F; byte=0x2E; m32 & XmmReg ...
{
    fucompe(XmmReg[0,32], m32);
}
1: Constructor line ia.sinc:8162(id0.1362) printpiece=[UCOMISS,  ,  B, ,,  ,  A]
Operands 0: m32 : 3905  1: XmmReg : 3904  
Pattern id=1362 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2E:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[13300:1] = FLOAT_NAN [handle:space][[handle:offset+0]:4]
	3: unique[13380:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	4: register[202:1] = BOOL_OR unique[13300:1], unique[13380:1]
	5: unique[13480:1] = FLOAT_EQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	6: register[206:1] = INT_OR register[202:1], unique[13480:1]
	7: unique[13580:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	8: register[200:1] = INT_OR register[202:1], unique[13580:1]
	9: register[20b:1] = COPY const[0:1]
	10: register[204:1] = COPY const[0:1]
	11: register[207:1] = COPY const[0:1]

Line ia.sinc:8147 :UCOMISD         XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x2E; xmmmod=3 & XmmReg1 & XmmReg2
{
	fucompe(XmmReg1[0,64], XmmReg2[0,64]);
}
0: Constructor line ia.sinc:8147(id0.1361) printpiece=[UCOMISD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3902  1: XmmReg2 : 3903  
Pattern id=1361 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[13300:1] = FLOAT_NAN [handle:space][[handle:offset+0]:8]
	3: unique[13380:1] = FLOAT_NAN [handle:space][[handle:offset+0]:8]
	4: register[202:1] = BOOL_OR unique[13300:1], unique[13380:1]
	5: unique[13480:1] = FLOAT_EQUAL [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	6: register[206:1] = INT_OR register[202:1], unique[13480:1]
	7: unique[13580:1] = FLOAT_LESS [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	8: register[200:1] = INT_OR register[202:1], unique[13580:1]
	9: register[20b:1] = COPY const[0:1]
	10: register[204:1] = COPY const[0:1]
	11: register[207:1] = COPY const[0:1]

Line ia.sinc:8142 :UCOMISD         XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x2E; m64 & XmmReg ...
{
	fucompe(XmmReg[0,64], m64);
}
1: Constructor line ia.sinc:8142(id0.1360) printpiece=[UCOMISD,  ,  B, ,,  ,  A]
Operands 0: m64 : 3901  1: XmmReg : 3900  
Pattern id=1360 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2E:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[13300:1] = FLOAT_NAN [handle:space][[handle:offset+0]:8]
	3: unique[13380:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	4: register[202:1] = BOOL_OR unique[13300:1], unique[13380:1]
	5: unique[13480:1] = FLOAT_EQUAL [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:[handle:size]]
	6: register[206:1] = INT_OR register[202:1], unique[13480:1]
	7: unique[13580:1] = FLOAT_LESS [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:[handle:size]]
	8: register[200:1] = INT_OR register[202:1], unique[13580:1]
	9: register[20b:1] = COPY const[0:1]
	10: register[204:1] = COPY const[0:1]
	11: register[207:1] = COPY const[0:1]

Line ia.sinc:5134 :COMISS       XmmReg1, XmmReg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2F; xmmmod=3 & XmmReg1 & XmmReg2
{
  fucompe(XmmReg1[0,32], XmmReg2[0,32]);
}
0: Constructor line ia.sinc:5134(id0.850) printpiece=[COMISS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2767  1: XmmReg2 : 2768  
Pattern id=850 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[13300:1] = FLOAT_NAN [handle:space][[handle:offset+0]:4]
	3: unique[13380:1] = FLOAT_NAN [handle:space][[handle:offset+0]:4]
	4: register[202:1] = BOOL_OR unique[13300:1], unique[13380:1]
	5: unique[13480:1] = FLOAT_EQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	6: register[206:1] = INT_OR register[202:1], unique[13480:1]
	7: unique[13580:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	8: register[200:1] = INT_OR register[202:1], unique[13580:1]
	9: register[20b:1] = COPY const[0:1]
	10: register[204:1] = COPY const[0:1]
	11: register[207:1] = COPY const[0:1]

Line ia.sinc:5129 :COMISS       XmmReg, m32       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x2F; m32 & XmmReg ...
{
  fucompe(XmmReg[0,32], m32);
}
1: Constructor line ia.sinc:5129(id0.849) printpiece=[COMISS,  ,  B, ,,  ,  A]
Operands 0: m32 : 2766  1: XmmReg : 2765  
Pattern id=849 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:2F:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[13300:1] = FLOAT_NAN [handle:space][[handle:offset+0]:4]
	3: unique[13380:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	4: register[202:1] = BOOL_OR unique[13300:1], unique[13380:1]
	5: unique[13480:1] = FLOAT_EQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	6: register[206:1] = INT_OR register[202:1], unique[13480:1]
	7: unique[13580:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	8: register[200:1] = INT_OR register[202:1], unique[13580:1]
	9: register[20b:1] = COPY const[0:1]
	10: register[204:1] = COPY const[0:1]
	11: register[207:1] = COPY const[0:1]

Line ia.sinc:5124 :COMISD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2F; xmmmod=3 & XmmReg1 & XmmReg2
{
  fucompe(XmmReg1[0,64], XmmReg2[0,64]);
}
0: Constructor line ia.sinc:5124(id0.848) printpiece=[COMISD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2763  1: XmmReg2 : 2764  
Pattern id=848 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[13300:1] = FLOAT_NAN [handle:space][[handle:offset+0]:8]
	3: unique[13380:1] = FLOAT_NAN [handle:space][[handle:offset+0]:8]
	4: register[202:1] = BOOL_OR unique[13300:1], unique[13380:1]
	5: unique[13480:1] = FLOAT_EQUAL [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	6: register[206:1] = INT_OR register[202:1], unique[13480:1]
	7: unique[13580:1] = FLOAT_LESS [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	8: register[200:1] = INT_OR register[202:1], unique[13580:1]
	9: register[20b:1] = COPY const[0:1]
	10: register[204:1] = COPY const[0:1]
	11: register[207:1] = COPY const[0:1]

Line ia.sinc:5119 :COMISD       XmmReg, m64   is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x2F; m64 & XmmReg ...
{
  fucompe(XmmReg[0,64], m64);
}
1: Constructor line ia.sinc:5119(id0.847) printpiece=[COMISD,  ,  B, ,,  ,  A]
Operands 0: m64 : 2762  1: XmmReg : 2761  
Pattern id=847 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:2F:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[13300:1] = FLOAT_NAN [handle:space][[handle:offset+0]:8]
	3: unique[13380:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	4: register[202:1] = BOOL_OR unique[13300:1], unique[13380:1]
	5: unique[13480:1] = FLOAT_EQUAL [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:[handle:size]]
	6: register[206:1] = INT_OR register[202:1], unique[13480:1]
	7: unique[13580:1] = FLOAT_LESS [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:[handle:size]]
	8: register[200:1] = INT_OR register[202:1], unique[13580:1]
	9: register[20b:1] = COPY const[0:1]
	10: register[204:1] = COPY const[0:1]
	11: register[207:1] = COPY const[0:1]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3942 :WRMSR is vexMode=0 & byte=0xf; byte=0x30 { tmp:8 = (zext(EDX) << 32) | zext(EAX); wrmsr(ECX,tmp); }
0: Constructor line ia.sinc:3942(id0.621) printpiece=[WRMSR]
Operands 
Pattern id=621 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:30:XX:XX)
Template
	0: unique[42f00:8] = INT_ZEXT register[8:4]
	1: unique[42f80:8] = INT_LEFT unique[42f00:8], const[20:4]
	2: unique[43000:8] = INT_ZEXT register[0:4]
	3: unique[43100:8] = INT_OR unique[42f80:8], unique[43000:8]
	4: CALLOTHER const[4d:4], register[4:4], unique[43100:8]

Line ia.sinc:3465 :RDTSC          is vexMode=0 & byte=0xf; byte=0x31                  { tmp:8 = rdtsc(); EDX = tmp(4); EAX = tmp(0); }
0: Constructor line ia.sinc:3465(id0.458) printpiece=[RDTSC]
Operands 
Pattern id=458 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:31:XX:XX)
Template
	0: unique[37400:8] = CALLOTHER const[46:4]
	1: register[8:4] = SUBPIECE unique[37400:8], const[4:4]
	2: register[0:4] = SUBPIECE unique[37400:8], const[0:4]

Line ia.sinc:3446 :RDMSR          is vexMode=0 & byte=0xf; byte=0x32 & check_EAX_dest & check_EDX_dest {
	tmp:8 = rdmsr(ECX);
	EDX = tmp(4); build check_EDX_dest;
	EAX = tmp(0); build check_EAX_dest;
}
0: Constructor line ia.sinc:3446(id0.454) printpiece=[RDMSR]
Operands 0: check_EAX_dest : 2149  1: check_EDX_dest : 2150  
Pattern id=454 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:32:XX:XX)
Template
	0: unique[36f00:8] = CALLOTHER const[42:4], register[4:4]
	1: register[8:4] = SUBPIECE unique[36f00:8], const[4:4]
	2: MULTIEQUAL const[1:4]
	3: register[0:4] = SUBPIECE unique[36f00:8], const[0:4]
	4: MULTIEQUAL const[0:4]

Line ia.sinc:3462 :RDPMC          is vexMode=0 & byte=0xf; byte=0x33 { tmp:8 = rdpmc(ECX); EDX = tmp(4); EAX = tmp:4; }
0: Constructor line ia.sinc:3462(id0.457) printpiece=[RDPMC]
Operands 
Pattern id=457 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:33:XX:XX)
Template
	0: unique[37200:8] = CALLOTHER const[45:4], register[4:4]
	1: register[8:4] = SUBPIECE unique[37200:8], const[4:4]
	2: register[0:4] = SUBPIECE unique[37200:8], const[0:4]

Line ia.sinc:3813 :SYSENTER           is vexMode=0 & byte=0x0f; byte=0x34                     { sysenter(); }
0: Constructor line ia.sinc:3813(id0.582) printpiece=[SYSENTER]
Operands 
Pattern id=582 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:34:XX:XX)
Template
	0: CALLOTHER const[3:4]

Line ia.sinc:3814 :SYSEXIT            is vexMode=0 & byte=0x0f; byte=0x35                     { sysexit();
@ifdef IA64
                                                                  RIP=RCX; return [RIP];
@endif
                                                                }
0: Constructor line ia.sinc:3814(id0.583) printpiece=[SYSEXIT]
Operands 
Pattern id=583 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:35:XX:XX)
Template
	0: CALLOTHER const[4:4]

Line smx.sinc:14 :GETSEC          is vexMode=0 & byte=0x0f; byte=0x37  {

	if ( EAX != 0x0 ) goto <leaf_1>;
	    EAX = 0;
	    if ( EBX != 0x0 ) goto <done>;
		EAX = getsec_capabilities( EBX );
		goto <done>;
		
	<leaf_1>
	if ( EAX != 0x2 ) goto <leaf_2>;
		getsec_enteraccs( EBX, ECX );
		goto <done>;

	<leaf_2>
	if ( EAX != 0x3 ) goto <leaf_3>;
@ifdef IA64
	    getsec_exitac( RBX, EDX );
@else
	    getsec_exitac( EBX, EDX );
@endif
		goto <done>;

	<leaf_3>
	if ( EAX != 0x4 ) goto <leaf_4>;
	    getsec_senter( EBX, ECX, EDX);
		goto <done>;

	<leaf_4>
	if ( EAX != 0x5 ) goto <leaf_5>;
	    getsec_sexit();
		goto <done>;

	<leaf_5>
	if ( EAX != 0x6 ) goto <leaf_6>;
	    EAX = getsec_parameters_EAX( EBX );
	    ECX = getsec_parameters_ECX( EBX );
	    EBX = getsec_parameters_EBX( EBX );
		goto <done>;

	<leaf_6>
	if ( EAX != 0x7 ) goto <leaf_7>;
	    getsec_smctrl(EBX);
		goto <done>;

	<leaf_7>
	if ( EAX != 0x8 ) goto <unknown>;
	    getsec_wakeup();
		goto <done>;

	<unknown>
		getsec_unknown();

	<done>		
}
0: Constructor line smx.sinc:14(id0.2137) printpiece=[GETSEC]
Operands 
Pattern id=2137 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:37:XX:XX)
Template
	0: unique[d0600:1] = INT_NOTEQUAL register[0:4], const[0:4]
	1: CBRANCH const[[rel:0]:4], unique[d0600:1]
	2: register[0:4] = COPY const[0:4]
	3: unique[d0680:1] = INT_NOTEQUAL register[c:4], const[0:4]
	4: CBRANCH const[[rel:1]:4], unique[d0680:1]
	5: register[0:4] = CALLOTHER const[282:4], register[c:4]
	6: BRANCH const[[rel:1]:4]
	7: PTRADD const[0:4]
	8: unique[d0780:1] = INT_NOTEQUAL register[0:4], const[2:4]
	9: CBRANCH const[[rel:2]:4], unique[d0780:1]
	10: CALLOTHER const[283:4], register[c:4], register[4:4]
	11: BRANCH const[[rel:1]:4]
	12: PTRADD const[2:4]
	13: unique[d0800:1] = INT_NOTEQUAL register[0:4], const[3:4]
	14: CBRANCH const[[rel:3]:4], unique[d0800:1]
	15: CALLOTHER const[284:4], register[c:4], register[8:4]
	16: BRANCH const[[rel:1]:4]
	17: PTRADD const[3:4]
	18: unique[d0880:1] = INT_NOTEQUAL register[0:4], const[4:4]
	19: CBRANCH const[[rel:4]:4], unique[d0880:1]
	20: CALLOTHER const[285:4], register[c:4], register[4:4], register[8:4]
	21: BRANCH const[[rel:1]:4]
	22: PTRADD const[4:4]
	23: unique[d0900:1] = INT_NOTEQUAL register[0:4], const[5:4]
	24: CBRANCH const[[rel:5]:4], unique[d0900:1]
	25: CALLOTHER const[286:4]
	26: BRANCH const[[rel:1]:4]
	27: PTRADD const[5:4]
	28: unique[d0980:1] = INT_NOTEQUAL register[0:4], const[6:4]
	29: CBRANCH const[[rel:6]:4], unique[d0980:1]
	30: register[0:4] = CALLOTHER const[287:4], register[c:4]
	31: register[4:4] = CALLOTHER const[289:4], register[c:4]
	32: register[c:4] = CALLOTHER const[288:4], register[c:4]
	33: BRANCH const[[rel:1]:4]
	34: PTRADD const[6:4]
	35: unique[d0b80:1] = INT_NOTEQUAL register[0:4], const[7:4]
	36: CBRANCH const[[rel:7]:4], unique[d0b80:1]
	37: CALLOTHER const[28a:4], register[c:4]
	38: BRANCH const[[rel:1]:4]
	39: PTRADD const[7:4]
	40: unique[d0c00:1] = INT_NOTEQUAL register[0:4], const[8:4]
	41: CBRANCH const[[rel:8]:4], unique[d0c00:1]
	42: CALLOTHER const[28b:4]
	43: BRANCH const[[rel:1]:4]
	44: PTRADD const[8:4]
	45: CALLOTHER const[28c:4]
	46: PTRADD const[1:4]

Line ia.sinc:7178 :PSHUFB         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x00; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=pshufb(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:7178(id0.1195) printpiece=[PSHUFB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3510  1: mmxreg2 : 3511  
Pattern id=1195 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:00:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7177 :PSHUFB         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x00; mmxreg ... & m64                          { mmxreg=pshufb(mmxreg,m64); }
1: Constructor line ia.sinc:7177(id0.1194) printpiece=[PSHUFB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3508  1: m64 : 3509  
Pattern id=1194 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:00:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7180 :PSHUFB         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x00; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pshufb(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:7180(id0.1197) printpiece=[PSHUFB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3514  1: XmmReg2 : 3515  
Pattern id=1197 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:00:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7179 :PSHUFB         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x00; XmmReg ... & m128              { XmmReg=pshufb(XmmReg,m128); }
1: Constructor line ia.sinc:7179(id0.1196) printpiece=[PSHUFB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3512  1: m128 : 3513  
Pattern id=1196 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:00:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6838 :PHADDW        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x01; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phaddw(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6838(id0.1117) printpiece=[PHADDW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3334  1: mmxreg2 : 3335  
Pattern id=1117 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:01:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[81:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6837 :PHADDW        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x01; mmxreg ... & m64                          { mmxreg=phaddw(mmxreg,m64); }
1: Constructor line ia.sinc:6837(id0.1116) printpiece=[PHADDW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3332  1: m64 : 3333  
Pattern id=1116 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:01:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[81:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6840 :PHADDW        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x01; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phaddw(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6840(id0.1119) printpiece=[PHADDW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3338  1: XmmReg2 : 3339  
Pattern id=1119 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:01:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[81:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6839 :PHADDW        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x01; XmmReg ... & m128              { XmmReg=phaddw(XmmReg,m128); }
1: Constructor line ia.sinc:6839(id0.1118) printpiece=[PHADDW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3336  1: m128 : 3337  
Pattern id=1118 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:01:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[81:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6832 :PHADDD        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x02; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phaddd(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6832(id0.1113) printpiece=[PHADDD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3325  1: mmxreg2 : 3326  
Pattern id=1113 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:02:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[80:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6831 :PHADDD        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x02; mmxreg ... & m64                          { mmxreg=phaddd(mmxreg,m64); }
1: Constructor line ia.sinc:6831(id0.1112) printpiece=[PHADDD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3323  1: m64 : 3324  
Pattern id=1112 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:02:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[80:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6834 :PHADDD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x02; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phaddd(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6834(id0.1115) printpiece=[PHADDD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3329  1: XmmReg2 : 3330  
Pattern id=1115 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:02:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[80:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6833 :PHADDD        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x02; XmmReg ... & m128              { XmmReg=phaddd(XmmReg,m128); }
1: Constructor line ia.sinc:6833(id0.1114) printpiece=[PHADDD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3327  1: m128 : 3328  
Pattern id=1114 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:02:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[80:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6844 :PHADDSW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x03; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phaddsw(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6844(id0.1121) printpiece=[PHADDSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3343  1: mmxreg2 : 3344  
Pattern id=1121 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:03:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[82:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6843 :PHADDSW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x03; mmxreg ... & m64                          { mmxreg=phaddsw(mmxreg,m64); }
1: Constructor line ia.sinc:6843(id0.1120) printpiece=[PHADDSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3341  1: m64 : 3342  
Pattern id=1120 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:03:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[82:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6846 :PHADDSW       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x03; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phaddsw(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6846(id0.1123) printpiece=[PHADDSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3347  1: XmmReg2 : 3348  
Pattern id=1123 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:03:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[82:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6845 :PHADDSW       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x03; XmmReg ... & m128              { XmmReg=phaddsw(XmmReg,m128); }
1: Constructor line ia.sinc:6845(id0.1122) printpiece=[PHADDSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3345  1: m128 : 3346  
Pattern id=1122 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:03:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[82:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6874 :PMADDUBSW     mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x04; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=pmaddubsw(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6874(id0.1141) printpiece=[PMADDUBSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3392  1: mmxreg2 : 3393  
Pattern id=1141 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:04:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[87:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6873 :PMADDUBSW     mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x04; mmxreg ... & m64                          { mmxreg=pmaddubsw(mmxreg,m64); }
1: Constructor line ia.sinc:6873(id0.1140) printpiece=[PMADDUBSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3390  1: m64 : 3391  
Pattern id=1140 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:04:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[87:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6876 :PMADDUBSW     XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x04; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pmaddubsw(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6876(id0.1143) printpiece=[PMADDUBSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3396  1: XmmReg2 : 3397  
Pattern id=1143 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:04:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[87:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6875 :PMADDUBSW     XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x04; XmmReg ... & m128              { XmmReg=pmaddubsw(XmmReg,m128); }
1: Constructor line ia.sinc:6875(id0.1142) printpiece=[PMADDUBSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3394  1: m128 : 3395  
Pattern id=1142 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:04:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[87:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6856 :PHSUBW        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x05; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phsubw(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6856(id0.1129) printpiece=[PHSUBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3361  1: mmxreg2 : 3362  
Pattern id=1129 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:05:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[84:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6855 :PHSUBW        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x05; mmxreg ... & m64                          { mmxreg=phsubw(mmxreg,m64); }
1: Constructor line ia.sinc:6855(id0.1128) printpiece=[PHSUBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3359  1: m64 : 3360  
Pattern id=1128 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:05:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[84:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6858 :PHSUBW        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x05; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phsubw(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6858(id0.1131) printpiece=[PHSUBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3365  1: XmmReg2 : 3366  
Pattern id=1131 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:05:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[84:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6857 :PHSUBW        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x05; XmmReg ... & m128              { XmmReg=phsubw(XmmReg,m128); }
1: Constructor line ia.sinc:6857(id0.1130) printpiece=[PHSUBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3363  1: m128 : 3364  
Pattern id=1130 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:05:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[84:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6850 :PHSUBD        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x06; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phsubd(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6850(id0.1125) printpiece=[PHSUBD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3352  1: mmxreg2 : 3353  
Pattern id=1125 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:06:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[83:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6849 :PHSUBD        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x06; mmxreg ... & m64                          { mmxreg=phsubd(mmxreg,m64); }
1: Constructor line ia.sinc:6849(id0.1124) printpiece=[PHSUBD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3350  1: m64 : 3351  
Pattern id=1124 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:06:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[83:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6852 :PHSUBD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x06; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phsubd(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6852(id0.1127) printpiece=[PHSUBD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3356  1: XmmReg2 : 3357  
Pattern id=1127 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:06:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[83:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6851 :PHSUBD        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x06; XmmReg ... & m128              { XmmReg=phsubd(XmmReg,m128); }
1: Constructor line ia.sinc:6851(id0.1126) printpiece=[PHSUBD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3354  1: m128 : 3355  
Pattern id=1126 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:06:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[83:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6862 :PHSUBSW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x07; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=phsubsw(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6862(id0.1133) printpiece=[PHSUBSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3370  1: mmxreg2 : 3371  
Pattern id=1133 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:07:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[85:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6861 :PHSUBSW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x07; mmxreg ... & m64                          { mmxreg=phsubsw(mmxreg,m64); }
1: Constructor line ia.sinc:6861(id0.1132) printpiece=[PHSUBSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3368  1: m64 : 3369  
Pattern id=1132 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:07:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[85:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6864 :PHSUBSW       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x07; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=phsubsw(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6864(id0.1135) printpiece=[PHSUBSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3374  1: XmmReg2 : 3375  
Pattern id=1135 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:07:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[85:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6863 :PHSUBSW       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x07; XmmReg ... & m128              { XmmReg=phsubsw(XmmReg,m128); }
1: Constructor line ia.sinc:6863(id0.1134) printpiece=[PHSUBSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3372  1: m128 : 3373  
Pattern id=1134 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:07:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[85:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7232 :PSIGNB         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x08; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=psignb(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:7232(id0.1207) printpiece=[PSIGNB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3566  1: mmxreg2 : 3567  
Pattern id=1207 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:08:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[93:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7231 :PSIGNB         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x08; mmxreg ... & m64                          { mmxreg=psignb(mmxreg,m64); }
1: Constructor line ia.sinc:7231(id0.1206) printpiece=[PSIGNB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3564  1: m64 : 3565  
Pattern id=1206 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:08:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[93:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7234 :PSIGNB         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x08; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=psignb(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:7234(id0.1209) printpiece=[PSIGNB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3570  1: XmmReg2 : 3571  
Pattern id=1209 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:08:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[93:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7233 :PSIGNB         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x08; XmmReg ... & m128              { XmmReg=psignb(XmmReg,m128); }
1: Constructor line ia.sinc:7233(id0.1208) printpiece=[PSIGNB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3568  1: m128 : 3569  
Pattern id=1208 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:08:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[93:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7238 :PSIGNW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x09; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=psignw(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:7238(id0.1211) printpiece=[PSIGNW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3575  1: mmxreg2 : 3576  
Pattern id=1211 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:09:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[94:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7237 :PSIGNW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x09; mmxreg ... & m64                          { mmxreg=psignw(mmxreg,m64); }
1: Constructor line ia.sinc:7237(id0.1210) printpiece=[PSIGNW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3573  1: m64 : 3574  
Pattern id=1210 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:09:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[94:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7240 :PSIGNW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x09; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=psignw(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:7240(id0.1213) printpiece=[PSIGNW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3579  1: XmmReg2 : 3580  
Pattern id=1213 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:09:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[94:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7239 :PSIGNW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x09; XmmReg ... & m128              { XmmReg=psignw(XmmReg,m128); }
1: Constructor line ia.sinc:7239(id0.1212) printpiece=[PSIGNW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3577  1: m128 : 3578  
Pattern id=1212 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:09:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[94:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7244 :PSIGND         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x0a; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=psignd(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:7244(id0.1215) printpiece=[PSIGND,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3584  1: mmxreg2 : 3585  
Pattern id=1215 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:0A:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[95:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7243 :PSIGND         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x0a; mmxreg ... & m64                          { mmxreg=psignd(mmxreg,m64); }
1: Constructor line ia.sinc:7243(id0.1214) printpiece=[PSIGND,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3582  1: m64 : 3583  
Pattern id=1214 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:0A:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[95:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7246 :PSIGND         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x0a; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=psignd(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:7246(id0.1217) printpiece=[PSIGND,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3588  1: XmmReg2 : 3589  
Pattern id=1217 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:0A:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[95:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7245 :PSIGND         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x0a; XmmReg ... & m128              { XmmReg=psignd(XmmReg,m128); }
1: Constructor line ia.sinc:7245(id0.1216) printpiece=[PSIGND,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3586  1: m128 : 3587  
Pattern id=1216 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:0A:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[95:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7076 :PMULHRSW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x0B; mmxmod = 3 & mmxreg1 & mmxreg2            { mmxreg1=pmulhrsw(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:7076(id0.1167) printpiece=[PMULHRSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3450  1: mmxreg2 : 3451  
Pattern id=1167 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:0B:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7075 :PMULHRSW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x0B; mmxreg ... & m64                          { mmxreg=pmulhrsw(mmxreg,m64); }
1: Constructor line ia.sinc:7075(id0.1166) printpiece=[PMULHRSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3448  1: m64 : 3449  
Pattern id=1166 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:0B:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7078 :PMULHRSW       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x0B; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pmulhrsw(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:7078(id0.1169) printpiece=[PMULHRSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3454  1: XmmReg2 : 3455  
Pattern id=1169 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:0B:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7077 :PMULHRSW       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x0B; XmmReg ... & m128              { XmmReg=pmulhrsw(XmmReg,m128); }
1: Constructor line ia.sinc:7077(id0.1168) printpiece=[PMULHRSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3452  1: m128 : 3453  
Pattern id=1168 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:0B:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8366 :PBLENDVB XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x10; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pblendvb(XmmReg1, XmmReg2, XMM0); }
0: Constructor line ia.sinc:8366(id0.1407) printpiece=[PBLENDVB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4005  1: XmmReg2 : 4006  
Pattern id=1407 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:10:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], register[1200:10]

Line ia.sinc:8365 :PBLENDVB XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x10; XmmReg ... & m128 { XmmReg = pblendvb(XmmReg, m128, XMM0); }
1: Constructor line ia.sinc:8365(id0.1406) printpiece=[PBLENDVB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4003  1: m128 : 4004  
Pattern id=1406 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:10:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], register[1200:10]

Line ia.sinc:8358 :BLENDVPS XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x14; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = blendvps(XmmReg1, XmmReg2, XMM0); }
0: Constructor line ia.sinc:8358(id0.1403) printpiece=[BLENDVPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3995  1: XmmReg2 : 3996  
Pattern id=1403 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:14:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], register[1200:10]

Line ia.sinc:8357 :BLENDVPS XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x14; XmmReg ... & m128 { XmmReg = blendvps(XmmReg, m128, XMM0); }
1: Constructor line ia.sinc:8357(id0.1402) printpiece=[BLENDVPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3993  1: m128 : 3994  
Pattern id=1402 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:14:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], register[1200:10]

Line ia.sinc:8362 :BLENDVPD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x15; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = blendvpd(XmmReg1, XmmReg2, XMM0); }
0: Constructor line ia.sinc:8362(id0.1405) printpiece=[BLENDVPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4000  1: XmmReg2 : 4001  
Pattern id=1405 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:15:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], register[1200:10]

Line ia.sinc:8361 :BLENDVPD XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x15; XmmReg ... & m128 { XmmReg = blendvpd(XmmReg, m128, XMM0); }
1: Constructor line ia.sinc:8361(id0.1404) printpiece=[BLENDVPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3998  1: m128 : 3999  
Pattern id=1404 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:15:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], register[1200:10]

Line ia.sinc:8574 :PTEST XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x17; xmmmod=3 & XmmReg1 & XmmReg2 {
    local tmp = XmmReg2 & XmmReg1;
    ZF = tmp == 0;
    local tmp2 = XmmReg2 & ~XmmReg1;
    CF = tmp2 == 0;
    AF = 0;
    OF = 0;
    PF = 0;
    SF = 0;
}
0: Constructor line ia.sinc:8574(id0.1466) printpiece=[PTEST,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4169  1: XmmReg2 : 4170  
Pattern id=1466 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:17:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[9c900:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[206:1] = INT_EQUAL unique[9c900:[handle:size]], const[0:[handle:size]]
	4: unique[9ca00:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	5: unique[9cb00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[9ca00:[handle:size]]
	6: register[200:1] = INT_EQUAL unique[9cb00:[handle:size]], const[0:[handle:size]]
	7: register[204:1] = COPY const[0:1]
	8: register[20b:1] = COPY const[0:1]
	9: register[202:1] = COPY const[0:1]
	10: register[207:1] = COPY const[0:1]

Line ia.sinc:8563 :PTEST XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x17; XmmReg ... & m128 {
    local tmp = m128 & XmmReg;
    ZF = tmp == 0;
    local tmp2 = m128 & ~XmmReg;
    CF = tmp2 == 0;
    AF = 0;
    OF = 0;
    PF = 0;
    SF = 0;
}
1: Constructor line ia.sinc:8563(id0.1465) printpiece=[PTEST,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4167  1: m128 : 4168  
Pattern id=1465 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:17:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[9c580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[206:1] = INT_EQUAL unique[9c580:[handle:size]], const[0:[handle:size]]
	4: unique[9c680:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	5: unique[9c780:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[9c680:[handle:size]]
	6: register[200:1] = INT_EQUAL unique[9c780:[handle:size]], const[0:[handle:size]]
	7: register[204:1] = COPY const[0:1]
	8: register[20b:1] = COPY const[0:1]
	9: register[202:1] = COPY const[0:1]
	10: register[207:1] = COPY const[0:1]

Line ia.sinc:6156 :PABSB         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1c; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1=pabsb(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6156(id0.1021) printpiece=[PABSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3123  1: mmxreg2 : 3124  
Pattern id=1021 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:1C:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[77:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6155 :PABSB         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1c; mmxreg ... & m64					{ mmxreg=pabsb(mmxreg,m64); }
1: Constructor line ia.sinc:6155(id0.1020) printpiece=[PABSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3121  1: m64 : 3122  
Pattern id=1020 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:1C:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[77:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6158 :PABSB         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1c; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pabsb(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6158(id0.1023) printpiece=[PABSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3127  1: XmmReg2 : 3128  
Pattern id=1023 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:1C:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[77:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6157 :PABSB         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1c; XmmReg ... & m128              { XmmReg=pabsb(XmmReg,m128); }
1: Constructor line ia.sinc:6157(id0.1022) printpiece=[PABSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3125  1: m128 : 3126  
Pattern id=1022 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:1C:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[77:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6162 :PABSW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1d; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1=pabsw(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6162(id0.1025) printpiece=[PABSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3132  1: mmxreg2 : 3133  
Pattern id=1025 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:1D:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[78:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6161 :PABSW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1d; mmxreg ... & m64					{ mmxreg=pabsw(mmxreg,m64); }
1: Constructor line ia.sinc:6161(id0.1024) printpiece=[PABSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3130  1: m64 : 3131  
Pattern id=1024 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:1D:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[78:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6164 :PABSW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1d; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pabsw(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6164(id0.1027) printpiece=[PABSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3136  1: XmmReg2 : 3137  
Pattern id=1027 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:1D:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[78:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6163 :PABSW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1d; XmmReg ... & m128              { XmmReg=pabsw(XmmReg,m128); }
1: Constructor line ia.sinc:6163(id0.1026) printpiece=[PABSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3134  1: m128 : 3135  
Pattern id=1026 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:1D:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[78:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6168 :PABSD         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1e; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1=pabsd(mmxreg1,mmxreg2); }
0: Constructor line ia.sinc:6168(id0.1029) printpiece=[PABSD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3141  1: mmxreg2 : 3142  
Pattern id=1029 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:1E:[11xx]X)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[79:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6167 :PABSD         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x38; byte=0x1e; mmxreg ... & m64					{ mmxreg=pabsd(mmxreg,m64); }
1: Constructor line ia.sinc:6167(id0.1028) printpiece=[PABSD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3139  1: m64 : 3140  
Pattern id=1028 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:38:1E:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[79:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6170 :PABSD         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1e; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1=pabsd(XmmReg1,XmmReg2); }
0: Constructor line ia.sinc:6170(id0.1031) printpiece=[PABSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3145  1: XmmReg2 : 3146  
Pattern id=1031 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:1E:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[79:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6169 :PABSD         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x38; byte=0x1e; XmmReg ... & m128              { XmmReg=pabsd(XmmReg,m128); }
1: Constructor line ia.sinc:6169(id0.1030) printpiece=[PABSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3143  1: m128 : 3144  
Pattern id=1030 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:1E:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[79:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8517 :PMOVSXBW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x20; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxbw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8517(id0.1442) printpiece=[PMOVSXBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4110  1: XmmReg2 : 4111  
Pattern id=1442 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:20:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8516 :PMOVSXBW XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x20; XmmReg ... & m64 { XmmReg = pmovsxbw(XmmReg, m64); }
1: Constructor line ia.sinc:8516(id0.1441) printpiece=[PMOVSXBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4108  1: m64 : 4109  
Pattern id=1441 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:20:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8521 :PMOVSXBD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x21; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxbd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8521(id0.1444) printpiece=[PMOVSXBD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4115  1: XmmReg2 : 4116  
Pattern id=1444 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:21:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8520 :PMOVSXBD XmmReg, m32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x21; XmmReg ... & m32 { XmmReg = pmovsxbd(XmmReg, m32); }
1: Constructor line ia.sinc:8520(id0.1443) printpiece=[PMOVSXBD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4113  1: m32 : 4114  
Pattern id=1443 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:21:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8525 :PMOVSXBQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x22; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxbq(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8525(id0.1446) printpiece=[PMOVSXBQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4120  1: XmmReg2 : 4121  
Pattern id=1446 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:22:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ca:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8524 :PMOVSXBQ XmmReg, m16      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x22; XmmReg ... & m16 { XmmReg = pmovsxbq(XmmReg, m16); }
1: Constructor line ia.sinc:8524(id0.1445) printpiece=[PMOVSXBQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4118  1: m16 : 4119  
Pattern id=1445 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:22:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ca:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8529 :PMOVSXWD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x23; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxwd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8529(id0.1448) printpiece=[PMOVSXWD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4125  1: XmmReg2 : 4126  
Pattern id=1448 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:23:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[cb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8528 :PMOVSXWD XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x23; XmmReg ... & m64 { XmmReg = pmovsxwd(XmmReg, m64); }
1: Constructor line ia.sinc:8528(id0.1447) printpiece=[PMOVSXWD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4123  1: m64 : 4124  
Pattern id=1447 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:23:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[cb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8533 :PMOVSXWQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x24; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxwq(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8533(id0.1450) printpiece=[PMOVSXWQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4130  1: XmmReg2 : 4131  
Pattern id=1450 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:24:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[cc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8532 :PMOVSXWQ XmmReg, m32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x24; XmmReg ... & m32 { XmmReg = pmovsxwq(XmmReg, m32); }
1: Constructor line ia.sinc:8532(id0.1449) printpiece=[PMOVSXWQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4128  1: m32 : 4129  
Pattern id=1449 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:24:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[cc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8537 :PMOVSXDQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x25; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovsxdq(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8537(id0.1452) printpiece=[PMOVSXDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4135  1: XmmReg2 : 4136  
Pattern id=1452 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:25:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[cd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8536 :PMOVSXDQ XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x25; XmmReg ... & m64 { XmmReg = pmovsxdq(XmmReg, m64); }
1: Constructor line ia.sinc:8536(id0.1451) printpiece=[PMOVSXDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4133  1: m64 : 4134  
Pattern id=1451 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:25:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[cd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8334 :PMULDQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x28; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmuldq(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8334(id0.1391) printpiece=[PMULDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3957  1: XmmReg2 : 3958  
Pattern id=1391 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:28:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8333 :PMULDQ XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x28; XmmReg ... & m128 { XmmReg = pmuldq(XmmReg, m128); }
1: Constructor line ia.sinc:8333(id0.1390) printpiece=[PMULDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3955  1: m128 : 3956  
Pattern id=1390 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:28:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8590 :PCMPEQQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x29; xmmmod=3 & XmmReg1 & XmmReg2 
{ 
	XmmReg1[0,64] = zext(XmmReg1[0,64] == XmmReg2[0,64]) * 0xffffffffffffffff:8;
	XmmReg1[64,64] = zext(XmmReg1[64,64] == XmmReg2[64,64]) * 0xffffffffffffffff:8;
}
0: Constructor line ia.sinc:8590(id0.1468) printpiece=[PCMPEQQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4173  1: XmmReg2 : 4174  
Pattern id=1468 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:29:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[9cf00:1] = INT_EQUAL [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: unique[9cf80:8] = INT_ZEXT unique[9cf00:1]
	4: [handle:space][[handle:offset+0]:8] = INT_MULT unique[9cf80:8], const[ffffffffffffffff:8]
	5: unique[9d080:1] = INT_EQUAL [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]
	6: unique[9d100:8] = INT_ZEXT unique[9d080:1]
	7: [handle:space][[handle:offset+80008]:8] = INT_MULT unique[9d100:8], const[ffffffffffffffff:8]

Line ia.sinc:8585 :PCMPEQQ XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x29; XmmReg ... & m128 
{ 
	XmmReg[0,64] = zext(XmmReg[0,64] == m128[0,64]) * 0xffffffffffffffff:8;
	XmmReg[64,64] = zext(XmmReg[64,64] == m128[64,64]) * 0xffffffffffffffff:8;
}
1: Constructor line ia.sinc:8585(id0.1467) printpiece=[PCMPEQQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4171  1: m128 : 4172  
Pattern id=1467 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:29:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[9cc00:1] = INT_EQUAL [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: unique[9cc80:8] = INT_ZEXT unique[9cc00:1]
	4: [handle:space][[handle:offset+0]:8] = INT_MULT unique[9cc80:8], const[ffffffffffffffff:8]
	5: unique[9cd80:1] = INT_EQUAL [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]
	6: unique[9ce00:8] = INT_ZEXT unique[9cd80:1]
	7: [handle:space][[handle:offset+80008]:8] = INT_MULT unique[9ce00:8], const[ffffffffffffffff:8]

Line ia.sinc:8601 :MOVNTDQA XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x2A; XmmReg ... & m128 { XmmReg = movntdqa(XmmReg, m128); }
0: Constructor line ia.sinc:8601(id0.1471) printpiece=[MOVNTDQA,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4181  1: m128 : 4182  
Pattern id=1471 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:2A:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8598 :PACKUSDW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x2B; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = packusdw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8598(id0.1470) printpiece=[PACKUSDW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4178  1: XmmReg2 : 4179  
Pattern id=1470 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:2B:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8597 :PACKUSDW XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x2B; XmmReg ... & m128 { XmmReg = packusdw(XmmReg, m128); }
1: Constructor line ia.sinc:8597(id0.1469) printpiece=[PACKUSDW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4176  1: m128 : 4177  
Pattern id=1469 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:2B:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8541 :PMOVZXBW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x30; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxbw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8541(id0.1454) printpiece=[PMOVZXBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4140  1: XmmReg2 : 4141  
Pattern id=1454 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:30:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ce:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8540 :PMOVZXBW XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x30; XmmReg ... & m64 { XmmReg = pmovzxbw(XmmReg, m64); }
1: Constructor line ia.sinc:8540(id0.1453) printpiece=[PMOVZXBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4138  1: m64 : 4139  
Pattern id=1453 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:30:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ce:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8545 :PMOVZXBD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x31; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxbd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8545(id0.1456) printpiece=[PMOVZXBD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4145  1: XmmReg2 : 4146  
Pattern id=1456 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:31:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[cf:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8544 :PMOVZXBD XmmReg, m32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x31; XmmReg ... & m32 { XmmReg = pmovzxbd(XmmReg, m32); }
1: Constructor line ia.sinc:8544(id0.1455) printpiece=[PMOVZXBD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4143  1: m32 : 4144  
Pattern id=1455 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:31:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[cf:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8549 :PMOVZXBQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x32; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxbq(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8549(id0.1458) printpiece=[PMOVZXBQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4150  1: XmmReg2 : 4151  
Pattern id=1458 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:32:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8548 :PMOVZXBQ XmmReg, m16      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x32; XmmReg ... & m16 { XmmReg = pmovzxbq(XmmReg, m16); }
1: Constructor line ia.sinc:8548(id0.1457) printpiece=[PMOVZXBQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4148  1: m16 : 4149  
Pattern id=1457 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:32:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8553 :PMOVZXWD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x33; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxwd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8553(id0.1460) printpiece=[PMOVZXWD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4155  1: XmmReg2 : 4156  
Pattern id=1460 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:33:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8552 :PMOVZXWD XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x33; XmmReg ... & m64 { XmmReg = pmovzxwd(XmmReg, m64); }
1: Constructor line ia.sinc:8552(id0.1459) printpiece=[PMOVZXWD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4153  1: m64 : 4154  
Pattern id=1459 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:33:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8557 :PMOVZXWQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x34; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxwq(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8557(id0.1462) printpiece=[PMOVZXWQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4160  1: XmmReg2 : 4161  
Pattern id=1462 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:34:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8556 :PMOVZXWQ XmmReg, m32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x34; XmmReg ... & m32 { XmmReg = pmovzxwq(XmmReg, m32); }
1: Constructor line ia.sinc:8556(id0.1461) printpiece=[PMOVZXWQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4158  1: m32 : 4159  
Pattern id=1461 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:34:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8561 :PMOVZXDQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x35; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmovzxdq(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8561(id0.1464) printpiece=[PMOVZXDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4165  1: XmmReg2 : 4166  
Pattern id=1464 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:35:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8560 :PMOVZXDQ XmmReg, m64      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x35; XmmReg ... & m64 { XmmReg = pmovzxdq(XmmReg, m64); }
1: Constructor line ia.sinc:8560(id0.1463) printpiece=[PMOVZXDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4163  1: m64 : 4164  
Pattern id=1463 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:35:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8635 :PCMPGTQ XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x37; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pcmpgtq(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8635(id0.1484) printpiece=[PCMPGTQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4224  1: XmmReg2 : 4225  
Pattern id=1484 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:37:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[db:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8634 :PCMPGTQ XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x37; XmmReg ... & m128 { XmmReg = pcmpgtq(XmmReg, m128); }
1: Constructor line ia.sinc:8634(id0.1483) printpiece=[PCMPGTQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4222  1: m128 : 4223  
Pattern id=1483 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:37:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[db:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8374 :PMINSB XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x38; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pminsb(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8374(id0.1411) printpiece=[PMINSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4017  1: XmmReg2 : 4018  
Pattern id=1411 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:38:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ba:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8373 :PMINSB XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x38; XmmReg ... & m128 { XmmReg = pminsb(XmmReg, m128); }
1: Constructor line ia.sinc:8373(id0.1410) printpiece=[PMINSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4015  1: m128 : 4016  
Pattern id=1410 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:38:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ba:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8416 :PMINSD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x39; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pminsd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8416(id0.1417) printpiece=[PMINSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4030  1: XmmReg2 : 4031  
Pattern id=1417 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:39:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[bb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8415 :PMINSD XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x39; XmmReg ... & m128 { XmmReg = pminsd(XmmReg, m128); }
1: Constructor line ia.sinc:8415(id0.1416) printpiece=[PMINSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4028  1: m128 : 4029  
Pattern id=1416 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:39:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[bb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8387 :PMINUW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3A; xmmmod=3 & XmmReg1 & XmmReg2 
{ 
    assignUnsignedLesser(XmmReg1[0,16],XmmReg1[0,16],XmmReg2[0,16]);
	assignUnsignedLesser(XmmReg1[16,16],XmmReg1[16,16],XmmReg2[16,16]);
	assignUnsignedLesser(XmmReg1[32,16],XmmReg1[32,16],XmmReg2[32,16]);
	assignUnsignedLesser(XmmReg1[48,16],XmmReg1[48,16],XmmReg2[48,16]);
	assignUnsignedLesser(XmmReg1[64,16],XmmReg1[64,16],XmmReg2[64,16]);
	assignUnsignedLesser(XmmReg1[80,16],XmmReg1[80,16],XmmReg2[80,16]);
	assignUnsignedLesser(XmmReg1[96,16],XmmReg1[96,16],XmmReg2[96,16]);
	assignUnsignedLesser(XmmReg1[112,16],XmmReg1[112,16],XmmReg2[112,16]);
}
0: Constructor line ia.sinc:8387(id0.1413) printpiece=[PMINUW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4021  1: XmmReg2 : 4022  
Pattern id=1413 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3A:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: unique[83600:2] = INT_ZEXT unique[83580:1]
	4: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+0]:2]
	5: unique[83700:1] = INT_LESS [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	6: unique[83780:2] = INT_ZEXT unique[83700:1]
	7: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+0]:2]
	8: [handle:space][[handle:offset+0]:2] = INT_ADD unique[83680:2], unique[83800:2]
	9: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	10: unique[83600:2] = INT_ZEXT unique[83580:1]
	11: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+20002]:2]
	12: unique[83700:1] = INT_LESS [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	13: unique[83780:2] = INT_ZEXT unique[83700:1]
	14: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+20002]:2]
	15: [handle:space][[handle:offset+20002]:2] = INT_ADD unique[83680:2], unique[83800:2]
	16: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	17: unique[83600:2] = INT_ZEXT unique[83580:1]
	18: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+40004]:2]
	19: unique[83700:1] = INT_LESS [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	20: unique[83780:2] = INT_ZEXT unique[83700:1]
	21: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+40004]:2]
	22: [handle:space][[handle:offset+40004]:2] = INT_ADD unique[83680:2], unique[83800:2]
	23: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	24: unique[83600:2] = INT_ZEXT unique[83580:1]
	25: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+60006]:2]
	26: unique[83700:1] = INT_LESS [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	27: unique[83780:2] = INT_ZEXT unique[83700:1]
	28: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+60006]:2]
	29: [handle:space][[handle:offset+60006]:2] = INT_ADD unique[83680:2], unique[83800:2]
	30: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	31: unique[83600:2] = INT_ZEXT unique[83580:1]
	32: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+80008]:2]
	33: unique[83700:1] = INT_LESS [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	34: unique[83780:2] = INT_ZEXT unique[83700:1]
	35: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+80008]:2]
	36: [handle:space][[handle:offset+80008]:2] = INT_ADD unique[83680:2], unique[83800:2]
	37: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	38: unique[83600:2] = INT_ZEXT unique[83580:1]
	39: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+a000a]:2]
	40: unique[83700:1] = INT_LESS [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	41: unique[83780:2] = INT_ZEXT unique[83700:1]
	42: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+a000a]:2]
	43: [handle:space][[handle:offset+a000a]:2] = INT_ADD unique[83680:2], unique[83800:2]
	44: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	45: unique[83600:2] = INT_ZEXT unique[83580:1]
	46: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+c000c]:2]
	47: unique[83700:1] = INT_LESS [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	48: unique[83780:2] = INT_ZEXT unique[83700:1]
	49: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+c000c]:2]
	50: [handle:space][[handle:offset+c000c]:2] = INT_ADD unique[83680:2], unique[83800:2]
	51: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	52: unique[83600:2] = INT_ZEXT unique[83580:1]
	53: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+e000e]:2]
	54: unique[83700:1] = INT_LESS [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	55: unique[83780:2] = INT_ZEXT unique[83700:1]
	56: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+e000e]:2]
	57: [handle:space][[handle:offset+e000e]:2] = INT_ADD unique[83680:2], unique[83800:2]

Line ia.sinc:8376 :PMINUW XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3A; XmmReg ... & m128 
{ 
    assignUnsignedLesser(XmmReg[0,16],XmmReg[0,16],m128[0,16]);
	assignUnsignedLesser(XmmReg[16,16],XmmReg[16,16],m128[16,16]);
	assignUnsignedLesser(XmmReg[32,16],XmmReg[32,16],m128[32,16]);
	assignUnsignedLesser(XmmReg[48,16],XmmReg[48,16],m128[48,16]);
	assignUnsignedLesser(XmmReg[64,16],XmmReg[64,16],m128[64,16]);
	assignUnsignedLesser(XmmReg[80,16],XmmReg[80,16],m128[80,16]);
	assignUnsignedLesser(XmmReg[96,16],XmmReg[96,16],m128[96,16]);
	assignUnsignedLesser(XmmReg[112,16],XmmReg[112,16],m128[112,16]);	
}
1: Constructor line ia.sinc:8376(id0.1412) printpiece=[PMINUW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4019  1: m128 : 4020  
Pattern id=1412 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3A:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: unique[83600:2] = INT_ZEXT unique[83580:1]
	4: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+0]:2]
	5: unique[83700:1] = INT_LESS [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	6: unique[83780:2] = INT_ZEXT unique[83700:1]
	7: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+0]:2]
	8: [handle:space][[handle:offset+0]:2] = INT_ADD unique[83680:2], unique[83800:2]
	9: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	10: unique[83600:2] = INT_ZEXT unique[83580:1]
	11: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+20002]:2]
	12: unique[83700:1] = INT_LESS [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	13: unique[83780:2] = INT_ZEXT unique[83700:1]
	14: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+20002]:2]
	15: [handle:space][[handle:offset+20002]:2] = INT_ADD unique[83680:2], unique[83800:2]
	16: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	17: unique[83600:2] = INT_ZEXT unique[83580:1]
	18: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+40004]:2]
	19: unique[83700:1] = INT_LESS [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	20: unique[83780:2] = INT_ZEXT unique[83700:1]
	21: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+40004]:2]
	22: [handle:space][[handle:offset+40004]:2] = INT_ADD unique[83680:2], unique[83800:2]
	23: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	24: unique[83600:2] = INT_ZEXT unique[83580:1]
	25: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+60006]:2]
	26: unique[83700:1] = INT_LESS [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	27: unique[83780:2] = INT_ZEXT unique[83700:1]
	28: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+60006]:2]
	29: [handle:space][[handle:offset+60006]:2] = INT_ADD unique[83680:2], unique[83800:2]
	30: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	31: unique[83600:2] = INT_ZEXT unique[83580:1]
	32: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+80008]:2]
	33: unique[83700:1] = INT_LESS [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	34: unique[83780:2] = INT_ZEXT unique[83700:1]
	35: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+80008]:2]
	36: [handle:space][[handle:offset+80008]:2] = INT_ADD unique[83680:2], unique[83800:2]
	37: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	38: unique[83600:2] = INT_ZEXT unique[83580:1]
	39: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+a000a]:2]
	40: unique[83700:1] = INT_LESS [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	41: unique[83780:2] = INT_ZEXT unique[83700:1]
	42: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+a000a]:2]
	43: [handle:space][[handle:offset+a000a]:2] = INT_ADD unique[83680:2], unique[83800:2]
	44: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	45: unique[83600:2] = INT_ZEXT unique[83580:1]
	46: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+c000c]:2]
	47: unique[83700:1] = INT_LESS [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	48: unique[83780:2] = INT_ZEXT unique[83700:1]
	49: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+c000c]:2]
	50: [handle:space][[handle:offset+c000c]:2] = INT_ADD unique[83680:2], unique[83800:2]
	51: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	52: unique[83600:2] = INT_ZEXT unique[83580:1]
	53: unique[83680:2] = INT_MULT unique[83600:2], [handle:space][[handle:offset+e000e]:2]
	54: unique[83700:1] = INT_LESS [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	55: unique[83780:2] = INT_ZEXT unique[83700:1]
	56: unique[83800:2] = INT_MULT unique[83780:2], [handle:space][[handle:offset+e000e]:2]
	57: [handle:space][[handle:offset+e000e]:2] = INT_ADD unique[83680:2], unique[83800:2]

Line ia.sinc:8406 :PMINUD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3B; xmmmod=3 & XmmReg1 & XmmReg2 
{ 
	assignUnsignedLesser(XmmReg1[0,32],XmmReg1[0,32],XmmReg2[0,32]);
	assignUnsignedLesser(XmmReg1[32,32],XmmReg1[32,32],XmmReg2[32,32]);
	assignUnsignedLesser(XmmReg1[64,32],XmmReg1[64,32],XmmReg2[64,32]);
	assignUnsignedLesser(XmmReg1[96,32],XmmReg1[96,32],XmmReg2[96,32]);
}
0: Constructor line ia.sinc:8406(id0.1415) printpiece=[PMINUD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4025  1: XmmReg2 : 4026  
Pattern id=1415 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3B:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: unique[83600:4] = INT_ZEXT unique[83580:1]
	4: unique[83680:4] = INT_MULT unique[83600:4], [handle:space][[handle:offset+0]:4]
	5: unique[83700:1] = INT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	6: unique[83780:4] = INT_ZEXT unique[83700:1]
	7: unique[83800:4] = INT_MULT unique[83780:4], [handle:space][[handle:offset+0]:4]
	8: [handle:space][[handle:offset+0]:4] = INT_ADD unique[83680:4], unique[83800:4]
	9: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	10: unique[83600:4] = INT_ZEXT unique[83580:1]
	11: unique[83680:4] = INT_MULT unique[83600:4], [handle:space][[handle:offset+40004]:4]
	12: unique[83700:1] = INT_LESS [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	13: unique[83780:4] = INT_ZEXT unique[83700:1]
	14: unique[83800:4] = INT_MULT unique[83780:4], [handle:space][[handle:offset+40004]:4]
	15: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[83680:4], unique[83800:4]
	16: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	17: unique[83600:4] = INT_ZEXT unique[83580:1]
	18: unique[83680:4] = INT_MULT unique[83600:4], [handle:space][[handle:offset+80008]:4]
	19: unique[83700:1] = INT_LESS [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	20: unique[83780:4] = INT_ZEXT unique[83700:1]
	21: unique[83800:4] = INT_MULT unique[83780:4], [handle:space][[handle:offset+80008]:4]
	22: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[83680:4], unique[83800:4]
	23: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	24: unique[83600:4] = INT_ZEXT unique[83580:1]
	25: unique[83680:4] = INT_MULT unique[83600:4], [handle:space][[handle:offset+c000c]:4]
	26: unique[83700:1] = INT_LESS [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	27: unique[83780:4] = INT_ZEXT unique[83700:1]
	28: unique[83800:4] = INT_MULT unique[83780:4], [handle:space][[handle:offset+c000c]:4]
	29: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[83680:4], unique[83800:4]

Line ia.sinc:8399 :PMINUD XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3B; XmmReg ... & m128 
{ 
	assignUnsignedLesser(XmmReg[0,32],XmmReg[0,32],m128[0,32]);
	assignUnsignedLesser(XmmReg[32,32],XmmReg[32,32],m128[32,32]);
	assignUnsignedLesser(XmmReg[64,32],XmmReg[64,32],m128[64,32]);
	assignUnsignedLesser(XmmReg[96,32],XmmReg[96,32],m128[96,32]);
}
1: Constructor line ia.sinc:8399(id0.1414) printpiece=[PMINUD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4023  1: m128 : 4024  
Pattern id=1414 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3B:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: unique[83600:4] = INT_ZEXT unique[83580:1]
	4: unique[83680:4] = INT_MULT unique[83600:4], [handle:space][[handle:offset+0]:4]
	5: unique[83700:1] = INT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	6: unique[83780:4] = INT_ZEXT unique[83700:1]
	7: unique[83800:4] = INT_MULT unique[83780:4], [handle:space][[handle:offset+0]:4]
	8: [handle:space][[handle:offset+0]:4] = INT_ADD unique[83680:4], unique[83800:4]
	9: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	10: unique[83600:4] = INT_ZEXT unique[83580:1]
	11: unique[83680:4] = INT_MULT unique[83600:4], [handle:space][[handle:offset+40004]:4]
	12: unique[83700:1] = INT_LESS [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	13: unique[83780:4] = INT_ZEXT unique[83700:1]
	14: unique[83800:4] = INT_MULT unique[83780:4], [handle:space][[handle:offset+40004]:4]
	15: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[83680:4], unique[83800:4]
	16: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	17: unique[83600:4] = INT_ZEXT unique[83580:1]
	18: unique[83680:4] = INT_MULT unique[83600:4], [handle:space][[handle:offset+80008]:4]
	19: unique[83700:1] = INT_LESS [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	20: unique[83780:4] = INT_ZEXT unique[83700:1]
	21: unique[83800:4] = INT_MULT unique[83780:4], [handle:space][[handle:offset+80008]:4]
	22: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[83680:4], unique[83800:4]
	23: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	24: unique[83600:4] = INT_ZEXT unique[83580:1]
	25: unique[83680:4] = INT_MULT unique[83600:4], [handle:space][[handle:offset+c000c]:4]
	26: unique[83700:1] = INT_LESS [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	27: unique[83780:4] = INT_ZEXT unique[83700:1]
	28: unique[83800:4] = INT_MULT unique[83780:4], [handle:space][[handle:offset+c000c]:4]
	29: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[83680:4], unique[83800:4]

Line ia.sinc:8420 :PMAXSB XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3C; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmaxsb(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8420(id0.1419) printpiece=[PMAXSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4035  1: XmmReg2 : 4036  
Pattern id=1419 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3C:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[bc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8419 :PMAXSB XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3C; XmmReg ... & m128 { XmmReg = pmaxsb(XmmReg, m128); }
1: Constructor line ia.sinc:8419(id0.1418) printpiece=[PMAXSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4033  1: m128 : 4034  
Pattern id=1418 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3C:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[bc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8465 :PMAXSD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3D; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmaxsd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8465(id0.1425) printpiece=[PMAXSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4048  1: XmmReg2 : 4049  
Pattern id=1425 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3D:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[bd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8464 :PMAXSD XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3D; XmmReg ... & m128 { XmmReg = pmaxsd(XmmReg, m128); }
1: Constructor line ia.sinc:8464(id0.1424) printpiece=[PMAXSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4046  1: m128 : 4047  
Pattern id=1424 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3D:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[bd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8435 :PMAXUW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3E; xmmmod=3 & XmmReg1 & XmmReg2 
{ 
	assignUnsignedGreater(XmmReg1[0,16],XmmReg1[0,16],XmmReg2[0,16]);
	assignUnsignedGreater(XmmReg1[16,16],XmmReg1[16,16],XmmReg2[16,16]);
	assignUnsignedGreater(XmmReg1[32,16],XmmReg1[32,16],XmmReg2[32,16]);
	assignUnsignedGreater(XmmReg1[48,16],XmmReg1[48,16],XmmReg2[48,16]);
	assignUnsignedGreater(XmmReg1[64,16],XmmReg1[64,16],XmmReg2[64,16]);
	assignUnsignedGreater(XmmReg1[80,16],XmmReg1[80,16],XmmReg2[80,16]);
	assignUnsignedGreater(XmmReg1[96,16],XmmReg1[96,16],XmmReg2[96,16]);
	assignUnsignedGreater(XmmReg1[112,16],XmmReg1[112,16],XmmReg2[112,16]);
}
0: Constructor line ia.sinc:8435(id0.1421) printpiece=[PMAXUW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4039  1: XmmReg2 : 4040  
Pattern id=1421 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3E:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: unique[83080:2] = INT_ZEXT unique[83000:1]
	4: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+0]:2]
	5: unique[83180:1] = INT_LESS [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	6: unique[83200:2] = INT_ZEXT unique[83180:1]
	7: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+0]:2]
	8: [handle:space][[handle:offset+0]:2] = INT_ADD unique[83100:2], unique[83280:2]
	9: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	10: unique[83080:2] = INT_ZEXT unique[83000:1]
	11: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+20002]:2]
	12: unique[83180:1] = INT_LESS [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	13: unique[83200:2] = INT_ZEXT unique[83180:1]
	14: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+20002]:2]
	15: [handle:space][[handle:offset+20002]:2] = INT_ADD unique[83100:2], unique[83280:2]
	16: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	17: unique[83080:2] = INT_ZEXT unique[83000:1]
	18: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+40004]:2]
	19: unique[83180:1] = INT_LESS [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	20: unique[83200:2] = INT_ZEXT unique[83180:1]
	21: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+40004]:2]
	22: [handle:space][[handle:offset+40004]:2] = INT_ADD unique[83100:2], unique[83280:2]
	23: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	24: unique[83080:2] = INT_ZEXT unique[83000:1]
	25: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+60006]:2]
	26: unique[83180:1] = INT_LESS [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	27: unique[83200:2] = INT_ZEXT unique[83180:1]
	28: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+60006]:2]
	29: [handle:space][[handle:offset+60006]:2] = INT_ADD unique[83100:2], unique[83280:2]
	30: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	31: unique[83080:2] = INT_ZEXT unique[83000:1]
	32: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+80008]:2]
	33: unique[83180:1] = INT_LESS [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	34: unique[83200:2] = INT_ZEXT unique[83180:1]
	35: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+80008]:2]
	36: [handle:space][[handle:offset+80008]:2] = INT_ADD unique[83100:2], unique[83280:2]
	37: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	38: unique[83080:2] = INT_ZEXT unique[83000:1]
	39: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+a000a]:2]
	40: unique[83180:1] = INT_LESS [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	41: unique[83200:2] = INT_ZEXT unique[83180:1]
	42: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+a000a]:2]
	43: [handle:space][[handle:offset+a000a]:2] = INT_ADD unique[83100:2], unique[83280:2]
	44: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	45: unique[83080:2] = INT_ZEXT unique[83000:1]
	46: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+c000c]:2]
	47: unique[83180:1] = INT_LESS [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	48: unique[83200:2] = INT_ZEXT unique[83180:1]
	49: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+c000c]:2]
	50: [handle:space][[handle:offset+c000c]:2] = INT_ADD unique[83100:2], unique[83280:2]
	51: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	52: unique[83080:2] = INT_ZEXT unique[83000:1]
	53: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+e000e]:2]
	54: unique[83180:1] = INT_LESS [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	55: unique[83200:2] = INT_ZEXT unique[83180:1]
	56: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+e000e]:2]
	57: [handle:space][[handle:offset+e000e]:2] = INT_ADD unique[83100:2], unique[83280:2]

Line ia.sinc:8423 :PMAXUW XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3E; XmmReg ... & m128 
{ 
	assignUnsignedGreater(XmmReg[0,16],XmmReg[0,16],m128[0,16]);
	assignUnsignedGreater(XmmReg[16,16],XmmReg[16,16],m128[16,16]);
	assignUnsignedGreater(XmmReg[32,16],XmmReg[32,16],m128[32,16]);
	assignUnsignedGreater(XmmReg[48,16],XmmReg[48,16],m128[48,16]);
	assignUnsignedGreater(XmmReg[64,16],XmmReg[64,16],m128[64,16]);
	assignUnsignedGreater(XmmReg[80,16],XmmReg[80,16],m128[80,16]);
	assignUnsignedGreater(XmmReg[96,16],XmmReg[96,16],m128[96,16]);
	assignUnsignedGreater(XmmReg[112,16],XmmReg[112,16],m128[112,16]);
}
1: Constructor line ia.sinc:8423(id0.1420) printpiece=[PMAXUW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4037  1: m128 : 4038  
Pattern id=1420 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3E:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: unique[83080:2] = INT_ZEXT unique[83000:1]
	4: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+0]:2]
	5: unique[83180:1] = INT_LESS [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	6: unique[83200:2] = INT_ZEXT unique[83180:1]
	7: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+0]:2]
	8: [handle:space][[handle:offset+0]:2] = INT_ADD unique[83100:2], unique[83280:2]
	9: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	10: unique[83080:2] = INT_ZEXT unique[83000:1]
	11: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+20002]:2]
	12: unique[83180:1] = INT_LESS [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	13: unique[83200:2] = INT_ZEXT unique[83180:1]
	14: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+20002]:2]
	15: [handle:space][[handle:offset+20002]:2] = INT_ADD unique[83100:2], unique[83280:2]
	16: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	17: unique[83080:2] = INT_ZEXT unique[83000:1]
	18: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+40004]:2]
	19: unique[83180:1] = INT_LESS [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	20: unique[83200:2] = INT_ZEXT unique[83180:1]
	21: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+40004]:2]
	22: [handle:space][[handle:offset+40004]:2] = INT_ADD unique[83100:2], unique[83280:2]
	23: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	24: unique[83080:2] = INT_ZEXT unique[83000:1]
	25: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+60006]:2]
	26: unique[83180:1] = INT_LESS [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	27: unique[83200:2] = INT_ZEXT unique[83180:1]
	28: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+60006]:2]
	29: [handle:space][[handle:offset+60006]:2] = INT_ADD unique[83100:2], unique[83280:2]
	30: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	31: unique[83080:2] = INT_ZEXT unique[83000:1]
	32: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+80008]:2]
	33: unique[83180:1] = INT_LESS [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	34: unique[83200:2] = INT_ZEXT unique[83180:1]
	35: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+80008]:2]
	36: [handle:space][[handle:offset+80008]:2] = INT_ADD unique[83100:2], unique[83280:2]
	37: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	38: unique[83080:2] = INT_ZEXT unique[83000:1]
	39: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+a000a]:2]
	40: unique[83180:1] = INT_LESS [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	41: unique[83200:2] = INT_ZEXT unique[83180:1]
	42: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+a000a]:2]
	43: [handle:space][[handle:offset+a000a]:2] = INT_ADD unique[83100:2], unique[83280:2]
	44: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	45: unique[83080:2] = INT_ZEXT unique[83000:1]
	46: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+c000c]:2]
	47: unique[83180:1] = INT_LESS [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	48: unique[83200:2] = INT_ZEXT unique[83180:1]
	49: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+c000c]:2]
	50: [handle:space][[handle:offset+c000c]:2] = INT_ADD unique[83100:2], unique[83280:2]
	51: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	52: unique[83080:2] = INT_ZEXT unique[83000:1]
	53: unique[83100:2] = INT_MULT unique[83080:2], [handle:space][[handle:offset+e000e]:2]
	54: unique[83180:1] = INT_LESS [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	55: unique[83200:2] = INT_ZEXT unique[83180:1]
	56: unique[83280:2] = INT_MULT unique[83200:2], [handle:space][[handle:offset+e000e]:2]
	57: [handle:space][[handle:offset+e000e]:2] = INT_ADD unique[83100:2], unique[83280:2]

Line ia.sinc:8455 :PMAXUD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3F; xmmmod=3 & XmmReg1 & XmmReg2 
{ 
	assignUnsignedGreater(XmmReg1[0,32],XmmReg1[0,32],XmmReg2[0,32]);
	assignUnsignedGreater(XmmReg1[32,32],XmmReg1[32,32],XmmReg2[32,32]);
	assignUnsignedGreater(XmmReg1[64,32],XmmReg1[64,32],XmmReg2[64,32]);
	assignUnsignedGreater(XmmReg1[96,32],XmmReg1[96,32],XmmReg2[96,32]);
}
0: Constructor line ia.sinc:8455(id0.1423) printpiece=[PMAXUD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4043  1: XmmReg2 : 4044  
Pattern id=1423 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3F:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: unique[83080:4] = INT_ZEXT unique[83000:1]
	4: unique[83100:4] = INT_MULT unique[83080:4], [handle:space][[handle:offset+0]:4]
	5: unique[83180:1] = INT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	6: unique[83200:4] = INT_ZEXT unique[83180:1]
	7: unique[83280:4] = INT_MULT unique[83200:4], [handle:space][[handle:offset+0]:4]
	8: [handle:space][[handle:offset+0]:4] = INT_ADD unique[83100:4], unique[83280:4]
	9: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	10: unique[83080:4] = INT_ZEXT unique[83000:1]
	11: unique[83100:4] = INT_MULT unique[83080:4], [handle:space][[handle:offset+40004]:4]
	12: unique[83180:1] = INT_LESS [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	13: unique[83200:4] = INT_ZEXT unique[83180:1]
	14: unique[83280:4] = INT_MULT unique[83200:4], [handle:space][[handle:offset+40004]:4]
	15: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[83100:4], unique[83280:4]
	16: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	17: unique[83080:4] = INT_ZEXT unique[83000:1]
	18: unique[83100:4] = INT_MULT unique[83080:4], [handle:space][[handle:offset+80008]:4]
	19: unique[83180:1] = INT_LESS [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	20: unique[83200:4] = INT_ZEXT unique[83180:1]
	21: unique[83280:4] = INT_MULT unique[83200:4], [handle:space][[handle:offset+80008]:4]
	22: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[83100:4], unique[83280:4]
	23: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	24: unique[83080:4] = INT_ZEXT unique[83000:1]
	25: unique[83100:4] = INT_MULT unique[83080:4], [handle:space][[handle:offset+c000c]:4]
	26: unique[83180:1] = INT_LESS [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	27: unique[83200:4] = INT_ZEXT unique[83180:1]
	28: unique[83280:4] = INT_MULT unique[83200:4], [handle:space][[handle:offset+c000c]:4]
	29: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[83100:4], unique[83280:4]

Line ia.sinc:8447 :PMAXUD XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x3F; XmmReg ... & m128 
{ 
	assignUnsignedGreater(XmmReg[0,32],XmmReg[0,32],m128[0,32]);
	assignUnsignedGreater(XmmReg[32,32],XmmReg[32,32],m128[32,32]);
	assignUnsignedGreater(XmmReg[64,32],XmmReg[64,32],m128[64,32]);
	assignUnsignedGreater(XmmReg[96,32],XmmReg[96,32],m128[96,32]);
}
1: Constructor line ia.sinc:8447(id0.1422) printpiece=[PMAXUD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 4041  1: m128 : 4042  
Pattern id=1422 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:3F:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: unique[83080:4] = INT_ZEXT unique[83000:1]
	4: unique[83100:4] = INT_MULT unique[83080:4], [handle:space][[handle:offset+0]:4]
	5: unique[83180:1] = INT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	6: unique[83200:4] = INT_ZEXT unique[83180:1]
	7: unique[83280:4] = INT_MULT unique[83200:4], [handle:space][[handle:offset+0]:4]
	8: [handle:space][[handle:offset+0]:4] = INT_ADD unique[83100:4], unique[83280:4]
	9: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	10: unique[83080:4] = INT_ZEXT unique[83000:1]
	11: unique[83100:4] = INT_MULT unique[83080:4], [handle:space][[handle:offset+40004]:4]
	12: unique[83180:1] = INT_LESS [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	13: unique[83200:4] = INT_ZEXT unique[83180:1]
	14: unique[83280:4] = INT_MULT unique[83200:4], [handle:space][[handle:offset+40004]:4]
	15: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[83100:4], unique[83280:4]
	16: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	17: unique[83080:4] = INT_ZEXT unique[83000:1]
	18: unique[83100:4] = INT_MULT unique[83080:4], [handle:space][[handle:offset+80008]:4]
	19: unique[83180:1] = INT_LESS [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	20: unique[83200:4] = INT_ZEXT unique[83180:1]
	21: unique[83280:4] = INT_MULT unique[83200:4], [handle:space][[handle:offset+80008]:4]
	22: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[83100:4], unique[83280:4]
	23: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	24: unique[83080:4] = INT_ZEXT unique[83000:1]
	25: unique[83100:4] = INT_MULT unique[83080:4], [handle:space][[handle:offset+c000c]:4]
	26: unique[83180:1] = INT_LESS [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	27: unique[83200:4] = INT_ZEXT unique[83180:1]
	28: unique[83280:4] = INT_MULT unique[83200:4], [handle:space][[handle:offset+c000c]:4]
	29: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[83100:4], unique[83280:4]

Line ia.sinc:8338 :PMULLD XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x40; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = pmulld(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8338(id0.1393) printpiece=[PMULLD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3962  1: XmmReg2 : 3963  
Pattern id=1393 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:40:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8337 :PMULLD XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x40; XmmReg ... & m128 { XmmReg = pmulld(XmmReg, m128); }
1: Constructor line ia.sinc:8337(id0.1392) printpiece=[PMULLD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3960  1: m128 : 3961  
Pattern id=1392 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:40:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8330 :PHMINPOSUW XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x41; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = phminposuw(XmmReg2); }
0: Constructor line ia.sinc:8330(id0.1389) printpiece=[PHMINPOSUW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3952  1: XmmReg2 : 3953  
Pattern id=1389 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:41:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[af:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8329 :PHMINPOSUW XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x41; XmmReg ... & m128 { XmmReg = phminposuw(m128); }
1: Constructor line ia.sinc:8329(id0.1388) printpiece=[PHMINPOSUW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3950  1: m128 : 3951  
Pattern id=1388 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:41:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[af:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3888 :INVEPT Reg32, m128  is vexMode=0 & bit64=0 & $(PRE_66) & byte=0x0f; byte=0x38; byte=0x80; Reg32 ... & m128 { invept(Reg32, m128); }
0: Constructor line ia.sinc:3888(id0.606) printpiece=[INVEPT,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2426  1: m128 : 2427  
Pattern id=606 pattern=cmb:(ctx:X[0xxx]:X[xx1x]:X[0xxx]:XX,ins:0F:38:80:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[18:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3892 :INVVPID Reg32, m128 is vexMode=0 & bit64=0 & $(PRE_66) & byte=0x0f; byte=0x38; byte=0x81; Reg32 ... & m128 { invvpid(Reg32, m128); }
0: Constructor line ia.sinc:3892(id0.607) printpiece=[INVVPID,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 2428  1: m128 : 2429  
Pattern id=607 pattern=cmb:(ctx:X[0xxx]:X[xx1x]:X[0xxx]:XX,ins:0F:38:81:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[19:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2816 :INVPCID r32, m128     is vexMode=0 & addrsize=1 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0x82; r32 ... & m128    { invpcid(r32, m128); }
0: Constructor line ia.sinc:2816(id0.215) printpiece=[INVPCID,  ,  A, ,,  ,  B]
Operands 0: r32 : 1770  1: m128 : 1771  
Pattern id=215 pattern=cmb:(ctx:X[x1xx]:X[xx1x]:X[0xxx]:XX,ins:0F:38:82:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: CALLOTHER const[a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line sha.sinc:14 :SHA1NEXTE XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xC8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha1nexte_sha( XmmReg1, XmmReg2_m128 );
}
0: Constructor line sha.sinc:14(id0.2131) printpiece=[SHA1NEXTE,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 7174  1: YmmReg1 : 7176  2: XmmReg2_m128 : 7175  
Pattern id=2131 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:38:C8:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[27c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line sha.sinc:21 :SHA1MSG1 XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xC9; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha1msg1_sha( XmmReg1, XmmReg2_m128 );
}
0: Constructor line sha.sinc:21(id0.2132) printpiece=[SHA1MSG1,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 7178  1: YmmReg1 : 7180  2: XmmReg2_m128 : 7179  
Pattern id=2132 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:38:C9:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[27d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line sha.sinc:28 :SHA1MSG2 XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xCA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha1msg2_sha( XmmReg1, XmmReg2_m128 );
}
0: Constructor line sha.sinc:28(id0.2133) printpiece=[SHA1MSG2,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 7182  1: YmmReg1 : 7184  2: XmmReg2_m128 : 7183  
Pattern id=2133 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:38:CA:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[27e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line sha.sinc:35 :SHA256RNDS2 XmmReg1, XmmReg2_m128, XMM0 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xCB; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 & XMM0
{
	XmmReg1 = sha256rnds2_sha( XmmReg1, XmmReg2_m128, XMM0 );
}
0: Constructor line sha.sinc:35(id0.2134) printpiece=[SHA256RNDS2,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: XmmReg1 : 7186  1: YmmReg1 : 7189  2: XmmReg2_m128 : 7187  3: XMM0 : 7188  
Pattern id=2134 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:38:CB:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[27f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], register[1200:10]

Line sha.sinc:42 :SHA256MSG1 XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xCC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha256msg1_sha( XmmReg1, XmmReg2_m128 );
}
0: Constructor line sha.sinc:42(id0.2135) printpiece=[SHA256MSG1,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 7191  1: YmmReg1 : 7193  2: XmmReg2_m128 : 7192  
Pattern id=2135 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:38:CC:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[280:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line sha.sinc:49 :SHA256MSG2 XmmReg1, XmmReg2_m128 is vexMode=0 & byte=0x0F; byte=0x38; byte=0xCD; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1 = sha256msg2_sha( XmmReg1, XmmReg2_m128 );
}
0: Constructor line sha.sinc:49(id0.2136) printpiece=[SHA256MSG2,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 7195  1: YmmReg1 : 7197  2: XmmReg2_m128 : 7196  
Pattern id=2136 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:38:CD:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[281:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8692 :AESIMC XmmReg1, XmmReg2_m128  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xdb; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesimc(XmmReg2_m128);
}
0: Constructor line ia.sinc:8692(id0.1495) printpiece=[AESIMC,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4264  1: XmmReg2_m128 : 4265  
Pattern id=1495 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:DB:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e0:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8674 :AESENC XmmReg1, XmmReg2_m128 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xdc; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesenc(XmmReg1, XmmReg2_m128);
}
0: Constructor line ia.sinc:8674(id0.1491) printpiece=[AESENC,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4248  1: XmmReg2_m128 : 4249  
Pattern id=1491 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:DC:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[de:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8683 :AESENCLAST  XmmReg1, XmmReg2_m128 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xdd; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesenclast(XmmReg1, XmmReg2_m128);
}
0: Constructor line ia.sinc:8683(id0.1493) printpiece=[AESENCLAST,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4256  1: XmmReg2_m128 : 4257  
Pattern id=1493 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:DD:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[df:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8656 :AESDEC XmmReg1, XmmReg2_m128 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xde; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesdec(XmmReg1, XmmReg2_m128);
}
0: Constructor line ia.sinc:8656(id0.1487) printpiece=[AESDEC,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4232  1: XmmReg2_m128 : 4233  
Pattern id=1487 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:DE:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[dc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8665 :AESDECLAST  XmmReg1, XmmReg2_m128 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xdf; XmmReg1 ... & XmmReg2_m128 {
	XmmReg1 = aesdeclast(XmmReg1, XmmReg2_m128);
}
0: Constructor line ia.sinc:8665(id0.1489) printpiece=[AESDECLAST,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 4240  1: XmmReg2_m128 : 4241  
Pattern id=1489 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:DF:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[dd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3143 :MOVBE Reg16, m16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x38; byte=0xf0; Reg16 ... & m16  { Reg16 = swap_bytes( m16 ); }
0: Constructor line ia.sinc:3143(id0.304) printpiece=[MOVBE,  ,  A, ,,  ,  B]
Operands 0: Reg16 : 1926  1: m16 : 1927  
Pattern id=304 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:38:F0:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[40:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8608 :CRC32 Reg32, rm8  is vexMode=0 &            $(PRE_F2) &            byte=0x0F; byte=0x38; byte=0xF0; Reg32 ... & check_Reg32_dest ... & rm8  { Reg32 = crc32(Reg32, rm8);  build check_Reg32_dest; }
1: Constructor line ia.sinc:8608(id0.1472) printpiece=[CRC32,  ,  A, ,,  ,  C]
Operands 0: Reg32 : 4184  1: check_Reg32_dest : 4186  2: rm8 : 4185  
Pattern id=1472 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:38:F0:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:3144 :MOVBE Reg32, m32       is vexMode=0 & opsize=1 & mandover=0 & byte=0xf; byte=0x38; byte=0xf0; Reg32 ... & m32  { Reg32 = swap_bytes( m32 ); }
0: Constructor line ia.sinc:3144(id0.305) printpiece=[MOVBE,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 1928  1: m32 : 1929  
Pattern id=305 pattern=cmb:(ctx:X[xx01]:X[000x]:X[0xxx]:XX,ins:0F:38:F0:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[40:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8608 :CRC32 Reg32, rm8  is vexMode=0 &            $(PRE_F2) &            byte=0x0F; byte=0x38; byte=0xF0; Reg32 ... & check_Reg32_dest ... & rm8  { Reg32 = crc32(Reg32, rm8);  build check_Reg32_dest; }
0: Constructor line ia.sinc:8608(id0.1472) printpiece=[CRC32,  ,  A, ,,  ,  C]
Operands 0: Reg32 : 4184  1: check_Reg32_dest : 4186  2: rm8 : 4185  
Pattern id=1472 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:38:F0:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:8609 :CRC32 Reg32, rm16 is vexMode=0 & opsize=0 & $(PRE_F2) &            byte=0x0F; byte=0x38; byte=0xF1; Reg32 ... & check_Reg32_dest ... & rm16 { Reg32 = crc32(Reg32, rm16); build check_Reg32_dest; }
0: Constructor line ia.sinc:8609(id0.1473) printpiece=[CRC32,  ,  A, ,,  ,  C]
Operands 0: Reg32 : 4187  1: check_Reg32_dest : 4189  2: rm16 : 4188  
Pattern id=1473 pattern=cmb:(ctx:X[xx00]:X[1xxx]:X[0xxx]:XX,ins:0F:38:F1:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:3145 :MOVBE m16, Reg16       is vexMode=0 & opsize=0 & byte=0xf; byte=0x38; byte=0xf1; Reg16 ... & m16  { m16 = swap_bytes( Reg16 ); }
1: Constructor line ia.sinc:3145(id0.306) printpiece=[MOVBE,  ,  B, ,,  ,  A]
Operands 0: Reg16 : 1931  1: m16 : 1930  
Pattern id=306 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:38:F1:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[40:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3146 :MOVBE m32, Reg32       is vexMode=0 & opsize=1 & mandover=0 & byte=0xf; byte=0x38; byte=0xf1; Reg32 ... & m32  { m32 = swap_bytes( Reg32 ); }
0: Constructor line ia.sinc:3146(id0.307) printpiece=[MOVBE,  ,  B, ,,  ,  A]
Operands 0: Reg32 : 1933  1: m32 : 1932  
Pattern id=307 pattern=cmb:(ctx:X[xx01]:X[000x]:X[0xxx]:XX,ins:0F:38:F1:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[40:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8610 :CRC32 Reg32, rm32 is vexMode=0 & opsize=1 & $(PRE_F2) &            byte=0x0F; byte=0x38; byte=0xF1; Reg32 ... & check_Reg32_dest ... & rm32 { Reg32 = crc32(Reg32, rm32); build check_Reg32_dest; }
0: Constructor line ia.sinc:8610(id0.1474) printpiece=[CRC32,  ,  A, ,,  ,  C]
Operands 0: Reg32 : 4190  1: check_Reg32_dest : 4192  2: rm32 : 4191  
Pattern id=1474 pattern=cmb:(ctx:X[xx01]:X[1xxx]:X[0xxx]:XX,ins:0F:38:F1:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[d6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]

Line cet.sinc:58 :WRUSSD rm32,Reg32 is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x38; byte=0xf5; rm32 & Reg32 ... { 
    writeToUserShadowStack(rm32, Reg32);
}
0: Constructor line cet.sinc:58(id0.2143) printpiece=[WRUSSD,  ,  A, ,,  B]
Operands 0: rm32 : 7220  1: Reg32 : 7221  
Pattern id=2143 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:F5:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[292:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line adx.sinc:1 :ADCX Reg32, rm32      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x38; byte=0xF6; rm32 & Reg32 ... & check_Reg32_dest ... {
	tmp:5 = zext(Reg32) + zext(rm32) + zext(CF);
	tmpCF:1 = tmp(4); # just the carry byte 
	CF = tmpCF != 0;
	Reg32 = tmp:4;
	build check_Reg32_dest;
}
0: Constructor line adx.sinc:1(id0.2085) printpiece=[ADCX,  ,  B, ,,  ,  A]
Operands 0: rm32 : 6966  1: Reg32 : 6965  2: check_Reg32_dest : 6967  
Pattern id=2085 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:38:F6:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[c8580:5] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[c8600:5] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[c8680:5] = INT_ADD unique[c8580:5], unique[c8600:5]
	5: unique[c8700:5] = INT_ZEXT register[200:1]
	6: unique[c8800:5] = INT_ADD unique[c8680:5], unique[c8700:5]
	7: unique[c8900:1] = SUBPIECE unique[c8800:5], const[4:4]
	8: register[200:1] = INT_NOTEQUAL unique[c8900:1], const[0:1]
	9: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[c8800:5], const[0:4]
	10: MULTIEQUAL const[2:4]

Line adx.sinc:18 :ADOX Reg32, rm32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x38; byte=0xF6; rm32 & Reg32 ... & check_Reg32_dest ... {
	tmp:5 = zext(Reg32) + zext(rm32) + zext(OF);
	tmpOF:1 = tmp(4); # just the carry byte 
	OF = tmpOF != 0;
	Reg32 = tmp:4;
	build check_Reg32_dest;
}
1: Constructor line adx.sinc:18(id0.2086) printpiece=[ADOX,  ,  B, ,,  ,  A]
Operands 0: rm32 : 6969  1: Reg32 : 6968  2: check_Reg32_dest : 6970  
Pattern id=2086 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:38:F6:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[c8a80:5] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[c8b00:5] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[c8b80:5] = INT_ADD unique[c8a80:5], unique[c8b00:5]
	5: unique[c8c00:5] = INT_ZEXT register[20b:1]
	6: unique[c8d00:5] = INT_ADD unique[c8b80:5], unique[c8c00:5]
	7: unique[c8e00:1] = SUBPIECE unique[c8d00:5], const[4:4]
	8: register[20b:1] = INT_NOTEQUAL unique[c8e00:1], const[0:1]
	9: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[c8d00:5], const[0:4]
	10: MULTIEQUAL const[2:4]

Line cet.sinc:49 :WRSSD rm32,Reg32 is vexMode=0 & byte=0x0f; byte=0x38; byte=0xf6; rm32 & Reg32 ... { 
    writeToShadowStack(rm32, Reg32);
}
2: Constructor line cet.sinc:49(id0.2142) printpiece=[WRSSD,  ,  A, ,,  B]
Operands 0: rm32 : 7218  1: Reg32 : 7219  
Pattern id=2142 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:38:F6:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[291:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8469 :ROUNDPS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x08; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = roundps(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8469(id0.1427) printpiece=[ROUNDPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4054  1: XmmReg2 : 4055  2: imm8 : 4056  
Pattern id=1427 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:08:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[be:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8468 :ROUNDPS XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x08; XmmReg ... & m128; imm8 { XmmReg = roundps(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8468(id0.1426) printpiece=[ROUNDPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4051  1: m128 : 4052  2: imm8 : 4053  
Pattern id=1426 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:08:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[be:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8477 :ROUNDPD XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x09; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = roundpd(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8477(id0.1431) printpiece=[ROUNDPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4068  1: XmmReg2 : 4069  2: imm8 : 4070  
Pattern id=1431 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:09:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8476 :ROUNDPD XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x09; XmmReg ... & m128; imm8 { XmmReg = roundpd(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8476(id0.1430) printpiece=[ROUNDPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4065  1: m128 : 4066  2: imm8 : 4067  
Pattern id=1430 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:09:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8473 :ROUNDSS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0A; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = roundss(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8473(id0.1429) printpiece=[ROUNDSS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4061  1: XmmReg2 : 4062  2: imm8 : 4063  
Pattern id=1429 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0A:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[bf:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8472 :ROUNDSS XmmReg, m32, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0A; XmmReg ... & m32; imm8 { XmmReg = roundss(XmmReg, m32, imm8:8); }
1: Constructor line ia.sinc:8472(id0.1428) printpiece=[ROUNDSS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4058  1: m32 : 4059  2: imm8 : 4060  
Pattern id=1428 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0A:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[bf:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8481 :ROUNDSD XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0B; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = roundsd(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8481(id0.1433) printpiece=[ROUNDSD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4075  1: XmmReg2 : 4076  2: imm8 : 4077  
Pattern id=1433 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0B:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8480 :ROUNDSD XmmReg, m64, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0B; XmmReg ... & m64; imm8 { XmmReg = roundsd(XmmReg, m64, imm8:8); }
1: Constructor line ia.sinc:8480(id0.1432) printpiece=[ROUNDSD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4072  1: m64 : 4073  2: imm8 : 4074  
Pattern id=1432 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0B:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8350 :BLENDPS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0C; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = blendps(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8350(id0.1399) printpiece=[BLENDPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3982  1: XmmReg2 : 3983  2: imm8 : 3984  
Pattern id=1399 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0C:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8349 :BLENDPS XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0C; XmmReg ... & m128; imm8 { XmmReg = blendps(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8349(id0.1398) printpiece=[BLENDPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 3979  1: m128 : 3980  2: imm8 : 3981  
Pattern id=1398 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0C:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8354 :BLENDPD XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0D; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = blendpd(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8354(id0.1401) printpiece=[BLENDPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3989  1: XmmReg2 : 3990  2: imm8 : 3991  
Pattern id=1401 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0D:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8353 :BLENDPD XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0D; XmmReg ... & m128; imm8 { XmmReg = blendpd(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8353(id0.1400) printpiece=[BLENDPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 3986  1: m128 : 3987  2: imm8 : 3988  
Pattern id=1400 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0D:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8370 :PBLENDW XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0E; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = pblendw(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8370(id0.1409) printpiece=[PBLENDW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4011  1: XmmReg2 : 4012  2: imm8 : 4013  
Pattern id=1409 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0E:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8369 :PBLENDW XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0E; XmmReg ... & m128; imm8 { XmmReg = pblendw(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8369(id0.1408) printpiece=[PBLENDW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4008  1: m128 : 4009  2: imm8 : 4010  
Pattern id=1408 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0E:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:6387 :PALIGNR        mmxreg1, mmxreg2, imm8  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x3A; byte=0x0F; mmxmod = 3 & mmxreg1 & mmxreg2; imm8
{
    temp:16 = ( ( zext(mmxreg1) << 64 ) | zext( mmxreg2 ) ) >> ( imm8 * 8 );
    mmxreg1 = temp:8;
}
0: Constructor line ia.sinc:6387(id0.1065) printpiece=[PALIGNR,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: mmxreg1 : 3218  1: mmxreg2 : 3219  2: imm8 : 3220  
Pattern id=1065 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:3A:0F:[11xx]X)
Template
	0: unique[6ca80:10] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	1: unique[6cb00:10] = INT_LEFT unique[6ca80:10], const[40:4]
	2: unique[6cb80:10] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[6cc00:10] = INT_OR unique[6cb00:10], unique[6cb80:10]
	4: unique[6cc80:4] = INT_MULT [handle:space][[handle:offset]:4], const[8:4]
	5: unique[6cd80:10] = INT_RIGHT unique[6cc00:10], unique[6cc80:4]
	6: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[6cd80:10], const[0:4]

Line ia.sinc:6381 :PALIGNR        mmxreg, m64, imm8       is vexMode=0 & mandover=0 & byte=0x0F; byte=0x3A; byte=0x0F; m64 & mmxreg ...; imm8
{
    temp:16 = ( ( zext(mmxreg) << 64 ) | zext( m64 ) ) >> ( imm8 * 8 );
    mmxreg = temp:8;
}
1: Constructor line ia.sinc:6381(id0.1064) printpiece=[PALIGNR,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m64 : 3216  1: mmxreg : 3215  2: imm8 : 3217  
Pattern id=1064 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:3A:0F:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[6c680:10] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[6c700:10] = INT_LEFT unique[6c680:10], const[40:4]
	3: unique[6c780:10] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[6c800:10] = INT_OR unique[6c700:10], unique[6c780:10]
	5: unique[6c880:4] = INT_MULT [handle:space][[handle:offset]:4], const[8:4]
	6: unique[6c980:10] = INT_RIGHT unique[6c800:10], unique[6c880:4]
	7: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[6c980:10], const[0:4]

Line ia.sinc:6399 :PALIGNR        XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0F; xmmmod=3 & XmmReg1 & XmmReg2; imm8
{
    temp:32 = ( ( zext(XmmReg1) << 128 ) | zext( XmmReg2 ) ) >> ( imm8 * 8 );
    XmmReg1 = temp:16;
}
0: Constructor line ia.sinc:6399(id0.1067) printpiece=[PALIGNR,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3224  1: XmmReg2 : 3225  2: imm8 : 3226  
Pattern id=1067 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0F:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[6d280:20] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[6d300:20] = INT_LEFT unique[6d280:20], const[80:4]
	4: unique[6d380:20] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[6d400:20] = INT_OR unique[6d300:20], unique[6d380:20]
	6: unique[6d480:4] = INT_MULT [handle:space][[handle:offset]:4], const[8:4]
	7: unique[6d580:20] = INT_RIGHT unique[6d400:20], unique[6d480:4]
	8: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[6d580:20], const[0:4]

Line ia.sinc:6393 :PALIGNR        XmmReg1, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x0F; m128 & XmmReg1 ...; imm8
{
    temp:32 = ( ( zext(XmmReg1) << 128 ) | zext( m128 ) ) >> ( imm8 * 8 );
    XmmReg1 = temp:16;
}
1: Constructor line ia.sinc:6393(id0.1066) printpiece=[PALIGNR,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m128 : 3222  1: XmmReg1 : 3221  2: imm8 : 3223  
Pattern id=1066 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:0F:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[6ce80:20] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[6cf00:20] = INT_LEFT unique[6ce80:20], const[80:4]
	4: unique[6cf80:20] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[6d000:20] = INT_OR unique[6cf00:20], unique[6cf80:20]
	6: unique[6d080:4] = INT_MULT [handle:space][[handle:offset]:4], const[8:4]
	7: unique[6d180:20] = INT_RIGHT unique[6d000:20], unique[6d080:4]
	8: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[6d180:20], const[0:4]

Line ia.sinc:8505 :PEXTRB rm8, XmmReg, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x14; XmmReg ... & rm8; imm8 { rm8 = pextrb(XmmReg, imm8:8); }
0: Constructor line ia.sinc:8505(id0.1439) printpiece=[PEXTRB,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: XmmReg : 4100  1: rm8 : 4099  2: imm8 : 4101  
Pattern id=1439 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:14:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:6817 :PEXTRW        Rmr32, XmmReg1, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x15; (mod = 3 & Rmr32 & check_Rmr32_dest) & XmmReg1 ; imm8
{
    temp:16 = XmmReg1 >> ( (imm8 & 0x07) * 16 );
    Rmr32 = zext(temp:2);
    build check_Rmr32_dest;
}
0: Constructor line ia.sinc:6817(id0.1110) printpiece=[PEXTRW,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: Rmr32 : 3315  1: check_Rmr32_dest : 3318  2: XmmReg1 : 3316  3: imm8 : 3317  
Pattern id=1110 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:15:[11xx]X)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[81680:4] = INT_AND [handle:space][[handle:offset]:4], const[7:4]
	3: unique[81700:4] = INT_MULT unique[81680:4], const[10:4]
	4: unique[81800:10] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[81700:4]
	5: unique[81880:2] = SUBPIECE unique[81800:10], const[0:4]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[81880:2]
	7: MULTIEQUAL const[1:4]

Line ia.sinc:6824 :PEXTRW        m16, XmmReg1, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x15; XmmReg1 ... & m16; imm8
{
    temp:16 = XmmReg1 >> ( (imm8 & 0x07) * 16 );
    m16 = temp:2;
}
1: Constructor line ia.sinc:6824(id0.1111) printpiece=[PEXTRW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 3320  1: m16 : 3319  2: imm8 : 3321  
Pattern id=1111 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:15:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[81980:4] = INT_AND [handle:space][[handle:offset]:4], const[7:4]
	3: unique[81a00:4] = INT_MULT unique[81980:4], const[10:4]
	4: unique[81b00:10] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[81a00:4]
	5: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[81b00:10], const[0:4]

Line ia.sinc:8508 :PEXTRD rm32, XmmReg, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x16; XmmReg ... & rm32 & check_rm32_dest ...; imm8 { rm32 = pextrd(XmmReg, imm8:8); build check_rm32_dest; }
0: Constructor line ia.sinc:8508(id0.1440) printpiece=[PEXTRD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: XmmReg : 4104  1: rm32 : 4103  2: check_rm32_dest : 4106  3: imm8 : 4105  
Pattern id=1440 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:16:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]
	3: MULTIEQUAL const[2:4]

Line ia.sinc:8502 :EXTRACTPS rm32, XmmReg, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x17; XmmReg ... & rm32 & check_rm32_dest ...; imm8 { rm32 = extractps(XmmReg, imm8:8); build check_rm32_dest; }
0: Constructor line ia.sinc:8502(id0.1438) printpiece=[EXTRACTPS,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: XmmReg : 4095  1: rm32 : 4094  2: check_rm32_dest : 4097  3: imm8 : 4096  
Pattern id=1438 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:17:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]
	3: MULTIEQUAL const[2:4]

Line ia.sinc:8488 :PINSRB XmmReg, rm8, imm8       is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x20; XmmReg ... & rm8; imm8 { XmmReg = pinsrb(XmmReg, rm8, imm8:8); }
0: Constructor line ia.sinc:8488(id0.1436) printpiece=[PINSRB,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4086  1: rm8 : 4087  2: imm8 : 4088  
Pattern id=1436 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:20:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8485 :INSERTPS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x21; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = insertps(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8485(id0.1435) printpiece=[INSERTPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4082  1: XmmReg2 : 4083  2: imm8 : 4084  
Pattern id=1435 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:21:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8484 :INSERTPS XmmReg, m32, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x21; XmmReg ... & m32; imm8 { XmmReg = insertps(XmmReg, m32, imm8:8); }
1: Constructor line ia.sinc:8484(id0.1434) printpiece=[INSERTPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4079  1: m32 : 4080  2: imm8 : 4081  
Pattern id=1434 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:21:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8491 :PINSRD XmmReg, rm32, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x22; XmmReg ... & rm32; imm8 { XmmReg = pinsrd(XmmReg, rm32, imm8:8); }
0: Constructor line ia.sinc:8491(id0.1437) printpiece=[PINSRD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4090  1: rm32 : 4091  2: imm8 : 4092  
Pattern id=1437 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:22:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[c4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8342 :DPPS XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x40; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = dpps(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8342(id0.1395) printpiece=[DPPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3968  1: XmmReg2 : 3969  2: imm8 : 3970  
Pattern id=1395 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:40:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8341 :DPPS XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x40; XmmReg ... & m128; imm8 { XmmReg = dpps(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8341(id0.1394) printpiece=[DPPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 3965  1: m128 : 3966  2: imm8 : 3967  
Pattern id=1394 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:40:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8346 :DPPD XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x41; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = dppd(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8346(id0.1397) printpiece=[DPPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3975  1: XmmReg2 : 3976  2: imm8 : 3977  
Pattern id=1397 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:41:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8345 :DPPD XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x41; XmmReg ... & m128; imm8 { XmmReg = dppd(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8345(id0.1396) printpiece=[DPPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 3972  1: m128 : 3973  2: imm8 : 3974  
Pattern id=1396 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:41:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[b3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8326 :MPSADBW XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x42; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = mpsadbw(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8326(id0.1387) printpiece=[MPSADBW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3946  1: XmmReg2 : 3947  2: imm8 : 3948  
Pattern id=1387 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:42:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ae:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8325 :MPSADBW XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x42; XmmReg ... & m128; imm8 { XmmReg = mpsadbw(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8325(id0.1386) printpiece=[MPSADBW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 3943  1: m128 : 3944  2: imm8 : 3945  
Pattern id=1386 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:42:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[ae:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line pclmulqdq.sinc:19 :PCLMULLQLQDQ XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; byte=0x00
{
    local src1:16 = zext(XmmReg1[0,64]);
    local src2:16 = zext(XmmReg2[0,64]);
    pclmul(src1,src2,XmmReg1);
}
0: Constructor line pclmulqdq.sinc:19(id0.2088) printpiece=[PCLMULLQLQDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6973  1: XmmReg2 : 6974  
Pattern id=2088 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X:00:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[c9480:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	3: unique[c9580:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: unique[c8f80:4] = COPY const[0:4]
	5: unique[c9000:10] = COPY const[0:10]
	6: PTRADD const[0:4]
	7: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	8: CBRANCH const[[rel:1]:4], unique[c9080:1]
	9: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	10: unique[c9180:10] = INT_AND unique[c9480:10], unique[c9100:10]
	11: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	12: CBRANCH const[[rel:2]:4], unique[c9200:1]
	13: unique[c9280:10] = INT_LEFT unique[c9580:10], unique[c8f80:4]
	14: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	15: PTRADD const[2:4]
	16: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	17: BRANCH const[[rel:0]:4]
	18: PTRADD const[1:4]
	19: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
1: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
2: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:26 :PCLMULHQLQDQ XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; byte=0x01
{
    local src1:16 = zext(XmmReg1[64,64]);
    local src2:16 = zext(XmmReg2[0,64]);
    pclmul(src1,src2,XmmReg1);
}
0: Constructor line pclmulqdq.sinc:26(id0.2089) printpiece=[PCLMULHQLQDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6975  1: XmmReg2 : 6976  
Pattern id=2089 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X:01:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[c9680:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	3: unique[c9780:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: unique[c8f80:4] = COPY const[0:4]
	5: unique[c9000:10] = COPY const[0:10]
	6: PTRADD const[0:4]
	7: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	8: CBRANCH const[[rel:1]:4], unique[c9080:1]
	9: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	10: unique[c9180:10] = INT_AND unique[c9680:10], unique[c9100:10]
	11: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	12: CBRANCH const[[rel:2]:4], unique[c9200:1]
	13: unique[c9280:10] = INT_LEFT unique[c9780:10], unique[c8f80:4]
	14: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	15: PTRADD const[2:4]
	16: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	17: BRANCH const[[rel:0]:4]
	18: PTRADD const[1:4]
	19: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
1: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
2: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:33 :PCLMULLQHQDQ XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; byte=0x10
{
    local src1:16 = zext(XmmReg1[0,64]);
    local src2:16 = zext(XmmReg2[64,64]);
    pclmul(src1,src2,XmmReg1);
}
0: Constructor line pclmulqdq.sinc:33(id0.2090) printpiece=[PCLMULLQHQDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6977  1: XmmReg2 : 6978  
Pattern id=2090 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X:10:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[c9880:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	3: unique[c9980:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	4: unique[c8f80:4] = COPY const[0:4]
	5: unique[c9000:10] = COPY const[0:10]
	6: PTRADD const[0:4]
	7: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	8: CBRANCH const[[rel:1]:4], unique[c9080:1]
	9: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	10: unique[c9180:10] = INT_AND unique[c9880:10], unique[c9100:10]
	11: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	12: CBRANCH const[[rel:2]:4], unique[c9200:1]
	13: unique[c9280:10] = INT_LEFT unique[c9980:10], unique[c8f80:4]
	14: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	15: PTRADD const[2:4]
	16: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	17: BRANCH const[[rel:0]:4]
	18: PTRADD const[1:4]
	19: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
1: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
2: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:40 :PCLMULHQHQDQ XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; byte=0x11
{
    local src1:16 = zext(XmmReg1[64,64]);
    local src2:16 = zext(XmmReg2[64,64]);
    pclmul(src1,src2,XmmReg1);
}
0: Constructor line pclmulqdq.sinc:40(id0.2091) printpiece=[PCLMULHQHQDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6979  1: XmmReg2 : 6980  
Pattern id=2091 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X:11:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[c9a80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	3: unique[c9b80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	4: unique[c8f80:4] = COPY const[0:4]
	5: unique[c9000:10] = COPY const[0:10]
	6: PTRADD const[0:4]
	7: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	8: CBRANCH const[[rel:1]:4], unique[c9080:1]
	9: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	10: unique[c9180:10] = INT_AND unique[c9a80:10], unique[c9100:10]
	11: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	12: CBRANCH const[[rel:2]:4], unique[c9200:1]
	13: unique[c9280:10] = INT_LEFT unique[c9b80:10], unique[c8f80:4]
	14: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	15: PTRADD const[2:4]
	16: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	17: BRANCH const[[rel:0]:4]
	18: PTRADD const[1:4]
	19: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
1: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
2: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:47 :PCLMULQDQ XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg1[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg1[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1); 
}
0: Constructor line pclmulqdq.sinc:47(id0.2092) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 6981  1: XmmReg2 : 6982  2: imm8 : 6983  3: imm8_4 : 6984  4: imm8_0 : 6985  
Pattern id=2092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9c80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	9: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	10: BRANCH const[[rel:3]:4]
	11: PTRADD const[2:4]
	12: unique[c9e00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	13: PTRADD const[3:4]
	14: unique[c8f80:4] = COPY const[0:4]
	15: unique[c9000:10] = COPY const[0:10]
	16: PTRADD const[4:4]
	17: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	18: CBRANCH const[[rel:5]:4], unique[c9080:1]
	19: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	20: unique[c9180:10] = INT_AND unique[c9c80:10], unique[c9100:10]
	21: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	22: CBRANCH const[[rel:6]:4], unique[c9200:1]
	23: unique[c9280:10] = INT_LEFT unique[c9e00:10], unique[c8f80:4]
	24: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	25: PTRADD const[6:4]
	26: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	27: BRANCH const[[rel:4]:4]
	28: PTRADD const[5:4]
	29: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line pclmulqdq.sinc:70 :PCLMULQDQ XmmReg, m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0f; byte=0x3a; byte=0x44; XmmReg ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(XmmReg[64,64]);
	
	<done1>
        local m:16 = m128;		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
     pclmul(src1,src2,XmmReg);
}
1: Constructor line pclmulqdq.sinc:70(id0.2093) printpiece=[PCLMULQDQ,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 6986  1: m128 : 6987  2: imm8 : 6988  3: imm8_4 : 6989  4: imm8_0 : 6990  
Pattern id=2093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:44:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	3: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: BRANCH const[[rel:1]:4]
	5: PTRADD const[0:4]
	6: unique[c9f80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	7: PTRADD const[1:4]
	8: unique[ca080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[ca100:8] = SUBPIECE unique[ca080:10], const[0:4]
	11: unique[ca200:10] = INT_ZEXT unique[ca100:8]
	12: BRANCH const[[rel:3]:4]
	13: PTRADD const[2:4]
	14: unique[ca280:8] = SUBPIECE unique[ca080:10], const[8:4]
	15: unique[ca200:10] = INT_ZEXT unique[ca280:8]
	16: PTRADD const[3:4]
	17: unique[c8f80:4] = COPY const[0:4]
	18: unique[c9000:10] = COPY const[0:10]
	19: PTRADD const[4:4]
	20: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	21: CBRANCH const[[rel:5]:4], unique[c9080:1]
	22: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	23: unique[c9180:10] = INT_AND unique[c9f80:10], unique[c9100:10]
	24: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	25: CBRANCH const[[rel:6]:4], unique[c9200:1]
	26: unique[c9280:10] = INT_LEFT unique[ca200:10], unique[c8f80:4]
	27: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	28: PTRADD const[6:4]
	29: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	30: BRANCH const[[rel:4]:4]
	31: PTRADD const[5:4]
	32: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]

Line sha.sinc:7 :SHA1RNDS4 XmmReg1, XmmReg2_m128, imm8 is vexMode=0 & byte=0x0F; byte=0x3A; byte=0xCC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	XmmReg1 = sha1rnds4_sha( XmmReg1, XmmReg2_m128, imm8:1 );
}
0: Constructor line sha.sinc:7(id0.2130) printpiece=[SHA1RNDS4,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: XmmReg1 : 7169  1: YmmReg1 : 7172  2: XmmReg2_m128 : 7170  3: imm8 : 7171  
Pattern id=2130 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:3A:CC:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[27b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:8701 :AESKEYGENASSIST XmmReg1, XmmReg2_m128, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0xdf; XmmReg1 ... & XmmReg2_m128; imm8 {
	XmmReg1 = aeskeygenassist(XmmReg2_m128, imm8:1);
}
0: Constructor line ia.sinc:8701(id0.1497) printpiece=[AESKEYGENASSIST,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4271  1: XmmReg2_m128 : 4272  2: imm8 : 4273  
Pattern id=1497 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:DF:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:8623 :PCMPESTRM XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x60; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XMM0 = pcmpestrm(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8623(id0.1478) printpiece=[PCMPESTRM,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4204  1: XmmReg2 : 4205  2: imm8 : 4206  
Pattern id=1478 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:60:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[1200:10] = CALLOTHER const[d8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8622 :PCMPESTRM XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x60; XmmReg ... & m128; imm8 { XMM0 = pcmpestrm(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8622(id0.1477) printpiece=[PCMPESTRM,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4201  1: m128 : 4202  2: imm8 : 4203  
Pattern id=1477 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:60:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[1200:10] = CALLOTHER const[d8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8619 :PCMPESTRI XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x61; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { ECX = pcmpestri(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8619(id0.1476) printpiece=[PCMPESTRI,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4197  1: XmmReg2 : 4198  2: imm8 : 4199  
Pattern id=1476 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:61:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[4:4] = CALLOTHER const[d7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8618 :PCMPESTRI XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x61; XmmReg ... & m128; imm8 { ECX = pcmpestri(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8618(id0.1475) printpiece=[PCMPESTRI,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4194  1: m128 : 4195  2: imm8 : 4196  
Pattern id=1475 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:61:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[4:4] = CALLOTHER const[d7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8631 :PCMPISTRM XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x62; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XMM0 = pcmpistrm(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8631(id0.1482) printpiece=[PCMPISTRM,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4218  1: XmmReg2 : 4219  2: imm8 : 4220  
Pattern id=1482 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:62:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[1200:10] = CALLOTHER const[da:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8630 :PCMPISTRM XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x62; XmmReg ... & m128; imm8 { XMM0 = pcmpistrm(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8630(id0.1481) printpiece=[PCMPISTRM,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4215  1: m128 : 4216  2: imm8 : 4217  
Pattern id=1481 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:62:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[1200:10] = CALLOTHER const[da:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8627 :PCMPISTRI XmmReg1, XmmReg2, imm8 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x63; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { ECX = pcmpistri(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8627(id0.1480) printpiece=[PCMPISTRI,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 4211  1: XmmReg2 : 4212  2: imm8 : 4213  
Pattern id=1480 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:63:[11xx]X)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[4:4] = CALLOTHER const[d9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8626 :PCMPISTRI XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x3A; byte=0x63; XmmReg ... & m128; imm8 { ECX = pcmpistri(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8626(id0.1479) printpiece=[PCMPISTRI,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 4208  1: m128 : 4209  2: imm8 : 4210  
Pattern id=1479 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:3A:63:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[4:4] = CALLOTHER const[d9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:2191 :CMOV^cc Reg16,rm16 is vexMode=0 & opsize=0 & byte=0xf; row=4 & cc; rm16 & Reg16 ...    { if (!cc) goto inst_next; Reg16 = rm16; }
0: Constructor line ia.sinc:2191(id0.132) printpiece=[CMOV,  A,  ,  C, ,,  B]
Operands 0: cc : 1589  1: rm16 : 1591  2: Reg16 : 1590  
Pattern id=132 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:4X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[1df80:1] = BOOL_NEGATE [handle:space][[handle:offset]:[handle:size]]
	4: CBRANCH [curspace][[next]:[curspace_size]], unique[1df80:1]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2192 :CMOV^cc Reg32,rm32 is vexMode=0 & opsize=1 & byte=0xf; row=4 & cc; rm32 & Reg32 ... & check_Reg32_dest ...   { build check_Reg32_dest; if (!cc) goto inst_next; Reg32 = rm32;}
0: Constructor line ia.sinc:2192(id0.133) printpiece=[CMOV,  A,  ,  C, ,,  B]
Operands 0: cc : 1592  1: rm32 : 1594  2: Reg32 : 1593  3: check_Reg32_dest : 1595  
Pattern id=133 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:4X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: MULTIEQUAL const[3:4]
	4: unique[1e000:1] = BOOL_NEGATE [handle:space][[handle:offset]:[handle:size]]
	5: CBRANCH [curspace][[next]:[curspace_size]], unique[1e000:1]
	6: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:5801 :MOVMSKPS     Reg32, XmmReg2      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x50; XmmReg2 & Reg32 { Reg32 = movmskps(Reg32, XmmReg2); }
0: Constructor line ia.sinc:5801(id0.966) printpiece=[MOVMSKPS,  ,  B, ,,  ,  A]
Operands 0: XmmReg2 : 3011  1: Reg32 : 3010  
Pattern id=966 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:50:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[74:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5798 :MOVMSKPD     Reg32, XmmReg2      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x50; XmmReg2 & Reg32 { Reg32 = movmskpd(Reg32, XmmReg2); }
0: Constructor line ia.sinc:5798(id0.965) printpiece=[MOVMSKPD,  ,  B, ,,  ,  A]
Operands 0: XmmReg2 : 3008  1: Reg32 : 3007  
Pattern id=965 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:50:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[73:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8088 :SQRTPS          XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = sqrtps(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8088(id0.1347) printpiece=[SQRTPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3874  1: XmmReg2 : 3875  
Pattern id=1347 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:51:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8087 :SQRTPS          XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x51; XmmReg ... & m128 { XmmReg = sqrtps(XmmReg, m128); }
1: Constructor line ia.sinc:8087(id0.1346) printpiece=[SQRTPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3872  1: m128 : 3873  
Pattern id=1346 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:51:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8084 :SQRTPD          XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = sqrtpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8084(id0.1345) printpiece=[SQRTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3869  1: XmmReg2 : 3870  
Pattern id=1345 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:51:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8083 :SQRTPD          XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x51; XmmReg ... & m128 { XmmReg = sqrtpd(XmmReg, m128); }
1: Constructor line ia.sinc:8083(id0.1344) printpiece=[SQRTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3867  1: m128 : 3868  
Pattern id=1344 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:51:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8084 :SQRTPD          XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = sqrtpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8084(id0.1345) printpiece=[SQRTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3869  1: XmmReg2 : 3870  
Pattern id=1345 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:51:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8083 :SQRTPD          XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x51; XmmReg ... & m128 { XmmReg = sqrtpd(XmmReg, m128); }
1: Constructor line ia.sinc:8083(id0.1344) printpiece=[SQRTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3867  1: m128 : 3868  
Pattern id=1344 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:51:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8094 :SQRTSS          XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,32] = sqrt(XmmReg2[0,32]); }
2: Constructor line ia.sinc:8094(id0.1351) printpiece=[SQRTSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3882  1: XmmReg2 : 3883  
Pattern id=1351 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:51:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SQRT [handle:space][[handle:offset+0]:4]

Line ia.sinc:8093 :SQRTSS          XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x51; XmmReg ... & m32 { XmmReg[0,32] = sqrt(m32); }
3: Constructor line ia.sinc:8093(id0.1350) printpiece=[SQRTSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3880  1: m32 : 3881  
Pattern id=1350 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:51:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SQRT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8084 :SQRTPD          XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = sqrtpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8084(id0.1345) printpiece=[SQRTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3869  1: XmmReg2 : 3870  
Pattern id=1345 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:51:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8083 :SQRTPD          XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x51; XmmReg ... & m128 { XmmReg = sqrtpd(XmmReg, m128); }
1: Constructor line ia.sinc:8083(id0.1344) printpiece=[SQRTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3867  1: m128 : 3868  
Pattern id=1344 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:51:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8091 :SQRTSD          XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,64] = sqrt(XmmReg2[0,64]); }
2: Constructor line ia.sinc:8091(id0.1349) printpiece=[SQRTSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3878  1: XmmReg2 : 3879  
Pattern id=1349 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:51:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_SQRT [handle:space][[handle:offset+0]:8]

Line ia.sinc:8090 :SQRTSD          XmmReg, m64      is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x51; XmmReg ... & m64 { XmmReg[0,64] = sqrt(m64); }
3: Constructor line ia.sinc:8090(id0.1348) printpiece=[SQRTSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3876  1: m64 : 3877  
Pattern id=1348 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:51:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_SQRT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8094 :SQRTSS          XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x51; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,32] = sqrt(XmmReg2[0,32]); }
4: Constructor line ia.sinc:8094(id0.1351) printpiece=[SQRTSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3882  1: XmmReg2 : 3883  
Pattern id=1351 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:51:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SQRT [handle:space][[handle:offset+0]:4]

Line ia.sinc:8093 :SQRTSS          XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x51; XmmReg ... & m32 { XmmReg[0,32] = sqrt(m32); }
5: Constructor line ia.sinc:8093(id0.1350) printpiece=[SQRTSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3880  1: m32 : 3881  
Pattern id=1350 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:51:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SQRT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8036 :RSQRTPS         XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x52; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = rsqrtps(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8036(id0.1337) printpiece=[RSQRTPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3838  1: XmmReg2 : 3839  
Pattern id=1337 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:52:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8035 :RSQRTPS         XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x52; XmmReg ... & m128 { XmmReg = rsqrtps(XmmReg, m128); }
1: Constructor line ia.sinc:8035(id0.1336) printpiece=[RSQRTPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3836  1: m128 : 3837  
Pattern id=1336 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:52:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8040 :RSQRTSS         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x52; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = rsqrtss(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8040(id0.1339) printpiece=[RSQRTSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3843  1: XmmReg2 : 3844  
Pattern id=1339 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:52:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8039 :RSQRTSS         XmmReg, m32      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x52; XmmReg ... & m32 { XmmReg = rsqrtss(XmmReg, m32); }
1: Constructor line ia.sinc:8039(id0.1338) printpiece=[RSQRTSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3841  1: m32 : 3842  
Pattern id=1338 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:52:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8028 :RCPPS           XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x53; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = rcpps(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8028(id0.1333) printpiece=[RCPPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3828  1: XmmReg2 : 3829  
Pattern id=1333 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:53:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8027 :RCPPS           XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x53; XmmReg ... & m128 { XmmReg = rcpps(XmmReg, m128); }
1: Constructor line ia.sinc:8027(id0.1332) printpiece=[RCPPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3826  1: m128 : 3827  
Pattern id=1332 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:53:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8032 :RCPSS           XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x53; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = rcpss(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:8032(id0.1335) printpiece=[RCPSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3833  1: XmmReg2 : 3834  
Pattern id=1335 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:53:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8031 :RCPSS           XmmReg, m32      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x53; XmmReg ... & m32 { XmmReg = rcpss(XmmReg, m32); }
1: Constructor line ia.sinc:8031(id0.1334) printpiece=[RCPSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3831  1: m32 : 3832  
Pattern id=1334 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:53:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4763 :ANDPS        XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x54; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] & XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] & XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] & XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] & XmmReg2[96,32];
}
0: Constructor line ia.sinc:4763(id0.834) printpiece=[ANDPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2699  1: XmmReg2 : 2700  
Pattern id=834 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:54:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = INT_AND [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = INT_AND [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = INT_AND [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = INT_AND [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:4753 :ANDPS        XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x54; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] & m[0,32];
    XmmReg[32,32] = XmmReg[32,32] & m[32,32];
    XmmReg[64,32] = XmmReg[64,32] & m[64,32];
    XmmReg[96,32] = XmmReg[96,32] & m[96,32];
}
1: Constructor line ia.sinc:4753(id0.833) printpiece=[ANDPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2698  1: XmmReg : 2697  
Pattern id=833 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:54:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[51480:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[51500:4] = SUBPIECE unique[51480:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = INT_AND [handle:space][[handle:offset+0]:4], unique[51500:4]
	5: unique[51600:4] = SUBPIECE unique[51480:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = INT_AND [handle:space][[handle:offset+40004]:4], unique[51600:4]
	7: unique[51700:4] = SUBPIECE unique[51480:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = INT_AND [handle:space][[handle:offset+80008]:4], unique[51700:4]
	9: unique[51800:4] = SUBPIECE unique[51480:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = INT_AND [handle:space][[handle:offset+c000c]:4], unique[51800:4]

Line ia.sinc:4746 :ANDPD  XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x54; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] & XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] & XmmReg2[64,64];
}
0: Constructor line ia.sinc:4746(id0.832) printpiece=[ANDPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2695  1: XmmReg2 : 2696  
Pattern id=832 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:54:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = INT_AND [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = INT_AND [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:4738 :ANDPD  XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x54; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] & m[0,64];
    XmmReg[64,64] = XmmReg[64,64] & m[64,64];
}
1: Constructor line ia.sinc:4738(id0.831) printpiece=[ANDPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 2694  1: XmmReg : 2693  
Pattern id=831 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:54:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[51100:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[51180:8] = SUBPIECE unique[51100:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = INT_AND [handle:space][[handle:offset+0]:8], unique[51180:8]
	5: unique[51280:8] = SUBPIECE unique[51100:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = INT_AND [handle:space][[handle:offset+80008]:8], unique[51280:8]

Line ia.sinc:4795 :ANDNPS       XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x55; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = ~XmmReg1[0,32] & XmmReg2[0,32];
    XmmReg1[32,32] = ~XmmReg1[32,32] & XmmReg2[32,32];
    XmmReg1[64,32] = ~XmmReg1[64,32] & XmmReg2[64,32];
    XmmReg1[96,32] = ~XmmReg1[96,32] & XmmReg2[96,32];
}
0: Constructor line ia.sinc:4795(id0.838) printpiece=[ANDNPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2707  1: XmmReg2 : 2708  
Pattern id=838 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:55:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[52700:4] = INT_NEGATE [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+0]:4] = INT_AND unique[52700:4], [handle:space][[handle:offset+0]:4]
	4: unique[52800:4] = INT_NEGATE [handle:space][[handle:offset+40004]:4]
	5: [handle:space][[handle:offset+40004]:4] = INT_AND unique[52800:4], [handle:space][[handle:offset+40004]:4]
	6: unique[52900:4] = INT_NEGATE [handle:space][[handle:offset+80008]:4]
	7: [handle:space][[handle:offset+80008]:4] = INT_AND unique[52900:4], [handle:space][[handle:offset+80008]:4]
	8: unique[52a00:4] = INT_NEGATE [handle:space][[handle:offset+c000c]:4]
	9: [handle:space][[handle:offset+c000c]:4] = INT_AND unique[52a00:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:4786 :ANDNPS       XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x55; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = ~XmmReg[0,32] & m[0,32];
    XmmReg[32,32] = ~XmmReg[32,32] & m[32,32];
    XmmReg[64,32] = ~XmmReg[64,32] & m[64,32];
    XmmReg[96,32] = ~XmmReg[96,32] & m[96,32];
}
1: Constructor line ia.sinc:4786(id0.837) printpiece=[ANDNPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2706  1: XmmReg : 2705  
Pattern id=837 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:55:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[52080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[52100:4] = INT_NEGATE [handle:space][[handle:offset+0]:4]
	4: unique[52180:4] = SUBPIECE unique[52080:10], const[0:4]
	5: [handle:space][[handle:offset+0]:4] = INT_AND unique[52100:4], unique[52180:4]
	6: unique[52280:4] = INT_NEGATE [handle:space][[handle:offset+40004]:4]
	7: unique[52300:4] = SUBPIECE unique[52080:10], const[4:4]
	8: [handle:space][[handle:offset+40004]:4] = INT_AND unique[52280:4], unique[52300:4]
	9: unique[52400:4] = INT_NEGATE [handle:space][[handle:offset+80008]:4]
	10: unique[52480:4] = SUBPIECE unique[52080:10], const[8:4]
	11: [handle:space][[handle:offset+80008]:4] = INT_AND unique[52400:4], unique[52480:4]
	12: unique[52580:4] = INT_NEGATE [handle:space][[handle:offset+c000c]:4]
	13: unique[52600:4] = SUBPIECE unique[52080:10], const[c:4]
	14: [handle:space][[handle:offset+c000c]:4] = INT_AND unique[52580:4], unique[52600:4]

Line ia.sinc:4779 :ANDNPD       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x55; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = ~XmmReg1[0,64] & XmmReg2[0,64];
    XmmReg1[64,64] = ~XmmReg1[64,64] & XmmReg2[64,64];
}
0: Constructor line ia.sinc:4779(id0.836) printpiece=[ANDNPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2703  1: XmmReg2 : 2704  
Pattern id=836 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:55:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[51e80:8] = INT_NEGATE [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+0]:8] = INT_AND unique[51e80:8], [handle:space][[handle:offset+0]:8]
	4: unique[51f80:8] = INT_NEGATE [handle:space][[handle:offset+80008]:8]
	5: [handle:space][[handle:offset+80008]:8] = INT_AND unique[51f80:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:4772 :ANDNPD       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x55; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = ~XmmReg[0,64] & m[0,64];
    XmmReg[64,64] = ~XmmReg[64,64] & m[64,64];
}
1: Constructor line ia.sinc:4772(id0.835) printpiece=[ANDNPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 2702  1: XmmReg : 2701  
Pattern id=835 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:55:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[51b00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[51b80:8] = INT_NEGATE [handle:space][[handle:offset+0]:8]
	4: unique[51c00:8] = SUBPIECE unique[51b00:10], const[0:4]
	5: [handle:space][[handle:offset+0]:8] = INT_AND unique[51b80:8], unique[51c00:8]
	6: unique[51d00:8] = INT_NEGATE [handle:space][[handle:offset+80008]:8]
	7: unique[51d80:8] = SUBPIECE unique[51b00:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:8] = INT_AND unique[51d00:8], unique[51d80:8]

Line ia.sinc:6004 :ORPS          XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x56; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = XmmReg1 | XmmReg2; }
0: Constructor line ia.sinc:6004(id0.1007) printpiece=[ORPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3092  1: XmmReg2 : 3093  
Pattern id=1007 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:56:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6003 :ORPS          XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x56; XmmReg ... & m128 { XmmReg = XmmReg | m128; }
1: Constructor line ia.sinc:6003(id0.1006) printpiece=[ORPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3090  1: m128 : 3091  
Pattern id=1006 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:56:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6001 :ORPD          XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x56; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = XmmReg1 | XmmReg2; }
0: Constructor line ia.sinc:6001(id0.1005) printpiece=[ORPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3088  1: XmmReg2 : 3089  
Pattern id=1005 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:56:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6000 :ORPD          XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x56; XmmReg ... & m128 { XmmReg = XmmReg | m128; }
1: Constructor line ia.sinc:6000(id0.1004) printpiece=[ORPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3086  1: m128 : 3087  
Pattern id=1004 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:56:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8252 :XORPS           XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x57; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = ( XmmReg1[0,32] ^ XmmReg2[0,32] );
    XmmReg1[32,32] = ( XmmReg1[32,32] ^ XmmReg2[32,32] );
    XmmReg1[64,32] = ( XmmReg1[64,32] ^ XmmReg2[64,32] );
    XmmReg1[96,32] = ( XmmReg1[96,32] ^ XmmReg2[96,32] );
}
0: Constructor line ia.sinc:8252(id0.1375) printpiece=[XORPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3930  1: XmmReg2 : 3931  
Pattern id=1375 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:57:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = INT_XOR [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = INT_XOR [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = INT_XOR [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = INT_XOR [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:8243 :XORPS           XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x57; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = ( XmmReg[0,32] ^ m[0,32] );
    XmmReg[32,32] = ( XmmReg[32,32] ^ m[32,32] );
    XmmReg[64,32] = ( XmmReg[64,32] ^ m[64,32] );
    XmmReg[96,32] = ( XmmReg[96,32] ^ m[96,32] );
}
1: Constructor line ia.sinc:8243(id0.1374) printpiece=[XORPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 3929  1: XmmReg : 3928  
Pattern id=1374 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:57:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[99a00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[99a80:4] = SUBPIECE unique[99a00:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = INT_XOR [handle:space][[handle:offset+0]:4], unique[99a80:4]
	5: unique[99b80:4] = SUBPIECE unique[99a00:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = INT_XOR [handle:space][[handle:offset+40004]:4], unique[99b80:4]
	7: unique[99c80:4] = SUBPIECE unique[99a00:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = INT_XOR [handle:space][[handle:offset+80008]:4], unique[99c80:4]
	9: unique[99d80:4] = SUBPIECE unique[99a00:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = INT_XOR [handle:space][[handle:offset+c000c]:4], unique[99d80:4]

Line ia.sinc:8237 :XORPD           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x57; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = ( XmmReg1[0,64] ^ XmmReg2[0,64] );
    XmmReg1[64,64] = ( XmmReg1[64,64] ^ XmmReg2[64,64] );
}
0: Constructor line ia.sinc:8237(id0.1373) printpiece=[XORPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3926  1: XmmReg2 : 3927  
Pattern id=1373 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:57:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = INT_XOR [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = INT_XOR [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:8230 :XORPD           XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x57; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = ( XmmReg[0,64] ^ m[0,64] );
    XmmReg[64,64] = ( XmmReg[64,64] ^ m[64,64] );
}
1: Constructor line ia.sinc:8230(id0.1372) printpiece=[XORPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3925  1: XmmReg : 3924  
Pattern id=1372 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:57:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[99680:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[99700:8] = SUBPIECE unique[99680:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = INT_XOR [handle:space][[handle:offset+0]:8], unique[99700:8]
	5: unique[99800:8] = SUBPIECE unique[99680:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = INT_XOR [handle:space][[handle:offset+80008]:8], unique[99800:8]

Line ia.sinc:4679 :ADDPS        XmmReg1, XmmReg2 is vexMode=0 & mandover=0 & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f+ XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] f+ XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] f+ XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] f+ XmmReg2[96,32];
}
0: Constructor line ia.sinc:4679(id0.822) printpiece=[ADDPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2675  1: XmmReg2 : 2676  
Pattern id=822 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:58:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = FLOAT_ADD [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = FLOAT_ADD [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = FLOAT_ADD [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:4670 :ADDPS        XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x58; m128 & XmmReg ...
{
    local m:16 = m128;	# Guarantee value is in a fixed location
    XmmReg[0,32] = XmmReg[0,32] f+ m[0,32];
    XmmReg[32,32] = XmmReg[32,32] f+ m[32,32];
    XmmReg[64,32] = XmmReg[64,32] f+ m[64,32];
    XmmReg[96,32] = XmmReg[96,32] f+ m[96,32];
}
1: Constructor line ia.sinc:4670(id0.821) printpiece=[ADDPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2674  1: XmmReg : 2673  
Pattern id=821 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:58:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[4fe80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[4ff00:4] = SUBPIECE unique[4fe80:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = FLOAT_ADD [handle:space][[handle:offset+0]:4], unique[4ff00:4]
	5: unique[50000:4] = SUBPIECE unique[4fe80:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = FLOAT_ADD [handle:space][[handle:offset+40004]:4], unique[50000:4]
	7: unique[50100:4] = SUBPIECE unique[4fe80:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = FLOAT_ADD [handle:space][[handle:offset+80008]:4], unique[50100:4]
	9: unique[50200:4] = SUBPIECE unique[4fe80:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = FLOAT_ADD [handle:space][[handle:offset+c000c]:4], unique[50200:4]

Line ia.sinc:4664 :ADDPD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64]  = XmmReg1[0,64]  f+ XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f+ XmmReg2[64,64];
}
0: Constructor line ia.sinc:4664(id0.820) printpiece=[ADDPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2671  1: XmmReg2 : 2672  
Pattern id=820 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:58:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:4658 :ADDPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x58; XmmReg ... & m128
{
    XmmReg[0,64]  = XmmReg[0,64]  f+ m128[0,64];
    XmmReg[64,64] = XmmReg[64,64] f+ m128[64,64];
}
1: Constructor line ia.sinc:4658(id0.819) printpiece=[ADDPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2669  1: m128 : 2670  
Pattern id=819 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:58:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:4664 :ADDPD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64]  = XmmReg1[0,64]  f+ XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f+ XmmReg2[64,64];
}
0: Constructor line ia.sinc:4664(id0.820) printpiece=[ADDPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2671  1: XmmReg2 : 2672  
Pattern id=820 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:58:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:4658 :ADDPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x58; XmmReg ... & m128
{
    XmmReg[0,64]  = XmmReg[0,64]  f+ m128[0,64];
    XmmReg[64,64] = XmmReg[64,64] f+ m128[64,64];
}
1: Constructor line ia.sinc:4658(id0.819) printpiece=[ADDPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2669  1: m128 : 2670  
Pattern id=819 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:58:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:4702 :ADDSS        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f+ XmmReg2[0,32];
}
2: Constructor line ia.sinc:4702(id0.826) printpiece=[ADDSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2683  1: XmmReg2 : 2684  
Pattern id=826 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:58:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]

Line ia.sinc:4697 :ADDSS        XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x58; m32 & XmmReg ...
{
    XmmReg[0,32] = XmmReg[0,32] f+ m32;
}
3: Constructor line ia.sinc:4697(id0.825) printpiece=[ADDSS,  ,  B, ,,  ,  A]
Operands 0: m32 : 2682  1: XmmReg : 2681  
Pattern id=825 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:58:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4664 :ADDPD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64]  = XmmReg1[0,64]  f+ XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f+ XmmReg2[64,64];
}
0: Constructor line ia.sinc:4664(id0.820) printpiece=[ADDPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2671  1: XmmReg2 : 2672  
Pattern id=820 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:58:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:4658 :ADDPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x58; XmmReg ... & m128
{
    XmmReg[0,64]  = XmmReg[0,64]  f+ m128[0,64];
    XmmReg[64,64] = XmmReg[64,64] f+ m128[64,64];
}
1: Constructor line ia.sinc:4658(id0.819) printpiece=[ADDPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2669  1: m128 : 2670  
Pattern id=819 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:58:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:4692 :ADDSD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f+ XmmReg2[0,64];
}
2: Constructor line ia.sinc:4692(id0.824) printpiece=[ADDSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2679  1: XmmReg2 : 2680  
Pattern id=824 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:58:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]

Line ia.sinc:4687 :ADDSD        XmmReg, m64      is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x58; m64 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[0,64] f+ m64;
}
3: Constructor line ia.sinc:4687(id0.823) printpiece=[ADDSD,  ,  B, ,,  ,  A]
Operands 0: m64 : 2678  1: XmmReg : 2677  
Pattern id=823 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:58:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4702 :ADDSS        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x58; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f+ XmmReg2[0,32];
}
4: Constructor line ia.sinc:4702(id0.826) printpiece=[ADDSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2683  1: XmmReg2 : 2684  
Pattern id=826 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:58:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]

Line ia.sinc:4697 :ADDSS        XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x58; m32 & XmmReg ...
{
    XmmReg[0,32] = XmmReg[0,32] f+ m32;
}
5: Constructor line ia.sinc:4697(id0.825) printpiece=[ADDSS,  ,  B, ,,  ,  A]
Operands 0: m32 : 2682  1: XmmReg : 2681  
Pattern id=825 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:58:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5972 :MULPS        XmmReg1, XmmReg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f* XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] f* XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] f* XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] f* XmmReg2[96,32];
}
0: Constructor line ia.sinc:5972(id0.999) printpiece=[MULPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3076  1: XmmReg2 : 3077  
Pattern id=999 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:59:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_MULT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = FLOAT_MULT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = FLOAT_MULT [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = FLOAT_MULT [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5963 :MULPS        XmmReg, m128     is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x59; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f* m[0,32];
    XmmReg[32,32] = XmmReg[32,32] f* m[32,32];
    XmmReg[64,32] = XmmReg[64,32] f* m[64,32];
    XmmReg[96,32] = XmmReg[96,32] f* m[96,32];
}
1: Constructor line ia.sinc:5963(id0.998) printpiece=[MULPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 3075  1: XmmReg : 3074  
Pattern id=998 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:59:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[62a00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[62a80:4] = SUBPIECE unique[62a00:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = FLOAT_MULT [handle:space][[handle:offset+0]:4], unique[62a80:4]
	5: unique[62b80:4] = SUBPIECE unique[62a00:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = FLOAT_MULT [handle:space][[handle:offset+40004]:4], unique[62b80:4]
	7: unique[62c80:4] = SUBPIECE unique[62a00:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = FLOAT_MULT [handle:space][[handle:offset+80008]:4], unique[62c80:4]
	9: unique[62d80:4] = SUBPIECE unique[62a00:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = FLOAT_MULT [handle:space][[handle:offset+c000c]:4], unique[62d80:4]

Line ia.sinc:5957 :MULPD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f* XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f* XmmReg2[64,64];
}
0: Constructor line ia.sinc:5957(id0.997) printpiece=[MULPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3072  1: XmmReg2 : 3073  
Pattern id=997 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:59:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_MULT [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_MULT [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5950 :MULPD        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x59; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f* m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f* m[64,64];
}
1: Constructor line ia.sinc:5950(id0.996) printpiece=[MULPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3071  1: XmmReg : 3070  
Pattern id=996 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:59:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[62680:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[62700:8] = SUBPIECE unique[62680:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = FLOAT_MULT [handle:space][[handle:offset+0]:8], unique[62700:8]
	5: unique[62800:8] = SUBPIECE unique[62680:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT_MULT [handle:space][[handle:offset+80008]:8], unique[62800:8]

Line ia.sinc:5957 :MULPD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f* XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f* XmmReg2[64,64];
}
0: Constructor line ia.sinc:5957(id0.997) printpiece=[MULPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3072  1: XmmReg2 : 3073  
Pattern id=997 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:59:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_MULT [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_MULT [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5950 :MULPD        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x59; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f* m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f* m[64,64];
}
1: Constructor line ia.sinc:5950(id0.996) printpiece=[MULPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3071  1: XmmReg : 3070  
Pattern id=996 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:59:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[62680:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[62700:8] = SUBPIECE unique[62680:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = FLOAT_MULT [handle:space][[handle:offset+0]:8], unique[62700:8]
	5: unique[62800:8] = SUBPIECE unique[62680:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT_MULT [handle:space][[handle:offset+80008]:8], unique[62800:8]

Line ia.sinc:5995 :MULSS        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f* XmmReg2[0,32];
}
2: Constructor line ia.sinc:5995(id0.1003) printpiece=[MULSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3084  1: XmmReg2 : 3085  
Pattern id=1003 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:59:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_MULT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]

Line ia.sinc:5990 :MULSS        XmmReg, m32      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x59; m32 & XmmReg ...
{
    XmmReg[0,32] = XmmReg[0,32] f* m32;
}
3: Constructor line ia.sinc:5990(id0.1002) printpiece=[MULSS,  ,  B, ,,  ,  A]
Operands 0: m32 : 3083  1: XmmReg : 3082  
Pattern id=1002 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:59:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_MULT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5957 :MULPD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f* XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f* XmmReg2[64,64];
}
0: Constructor line ia.sinc:5957(id0.997) printpiece=[MULPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3072  1: XmmReg2 : 3073  
Pattern id=997 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:59:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_MULT [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_MULT [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5950 :MULPD        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x59; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f* m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f* m[64,64];
}
1: Constructor line ia.sinc:5950(id0.996) printpiece=[MULPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3071  1: XmmReg : 3070  
Pattern id=996 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:59:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[62680:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[62700:8] = SUBPIECE unique[62680:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = FLOAT_MULT [handle:space][[handle:offset+0]:8], unique[62700:8]
	5: unique[62800:8] = SUBPIECE unique[62680:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT_MULT [handle:space][[handle:offset+80008]:8], unique[62800:8]

Line ia.sinc:5985 :MULSD        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f* XmmReg2[0,64];
}
2: Constructor line ia.sinc:5985(id0.1001) printpiece=[MULSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3080  1: XmmReg2 : 3081  
Pattern id=1001 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:59:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_MULT [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]

Line ia.sinc:5980 :MULSD        XmmReg, m64      is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x59;  m64 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[0,64] f* m64;
}
3: Constructor line ia.sinc:5980(id0.1000) printpiece=[MULSD,  ,  B, ,,  ,  A]
Operands 0: m64 : 3079  1: XmmReg : 3078  
Pattern id=1000 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:59:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_MULT [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5995 :MULSS        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x59; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f* XmmReg2[0,32];
}
4: Constructor line ia.sinc:5995(id0.1003) printpiece=[MULSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3084  1: XmmReg2 : 3085  
Pattern id=1003 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:59:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_MULT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]

Line ia.sinc:5990 :MULSS        XmmReg, m32      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x59; m32 & XmmReg ...
{
    XmmReg[0,32] = XmmReg[0,32] f* m32;
}
5: Constructor line ia.sinc:5990(id0.1002) printpiece=[MULSS,  ,  B, ,,  ,  A]
Operands 0: m32 : 3083  1: XmmReg : 3082  
Pattern id=1002 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:59:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_MULT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5266 :CVTPS2PD     XmmReg1, XmmReg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = float2float( XmmReg2[0,32] );
    XmmReg1[64,64] = float2float( XmmReg2[32,32] );
}
0: Constructor line ia.sinc:5266(id0.868) printpiece=[CVTPS2PD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2803  1: XmmReg2 : 2804  
Pattern id=868 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT2FLOAT [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT2FLOAT [handle:space][[handle:offset+40004]:4]

Line ia.sinc:5259 :CVTPS2PD     XmmReg, m64       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5A; m64 & XmmReg ...
{
    local m:8 = m64;
    XmmReg[0,64] = float2float( m[0,32] );
    XmmReg[64,64] = float2float( m[32,32] );
}
1: Constructor line ia.sinc:5259(id0.867) printpiece=[CVTPS2PD,  ,  B, ,,  ,  A]
Operands 0: m64 : 2802  1: XmmReg : 2801  
Pattern id=867 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5d100:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5d180:4] = SUBPIECE unique[5d100:8], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = FLOAT2FLOAT unique[5d180:4]
	5: unique[5d280:4] = SUBPIECE unique[5d100:8], const[4:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT2FLOAT unique[5d280:4]

Line ia.sinc:5208 :CVTPD2PS     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = float2float( XmmReg2[0,64] );
    XmmReg1[32,32] = float2float( XmmReg2[64,64] );
    XmmReg1[64,32] = 0;
    XmmReg1[96,32] = 0;
}
0: Constructor line ia.sinc:5208(id0.860) printpiece=[CVTPD2PS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2787  1: XmmReg2 : 2788  
Pattern id=860 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT2FLOAT [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+40004]:4] = FLOAT2FLOAT [handle:space][[handle:offset+80008]:8]
	4: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5199 :CVTPD2PS     XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5A; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = float2float( m[0,64] );
    XmmReg[32,32] = float2float( m[64,64] );
    XmmReg[64,32] = 0;
    XmmReg[96,32] = 0;
}
1: Constructor line ia.sinc:5199(id0.859) printpiece=[CVTPD2PS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2786  1: XmmReg : 2785  
Pattern id=859 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5c000:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5c080:8] = SUBPIECE unique[5c000:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = FLOAT2FLOAT unique[5c080:8]
	5: unique[5c180:8] = SUBPIECE unique[5c000:10], const[8:4]
	6: [handle:space][[handle:offset+40004]:4] = FLOAT2FLOAT unique[5c180:8]
	7: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	8: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5208 :CVTPD2PS     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = float2float( XmmReg2[0,64] );
    XmmReg1[32,32] = float2float( XmmReg2[64,64] );
    XmmReg1[64,32] = 0;
    XmmReg1[96,32] = 0;
}
0: Constructor line ia.sinc:5208(id0.860) printpiece=[CVTPD2PS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2787  1: XmmReg2 : 2788  
Pattern id=860 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT2FLOAT [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+40004]:4] = FLOAT2FLOAT [handle:space][[handle:offset+80008]:8]
	4: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5199 :CVTPD2PS     XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5A; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = float2float( m[0,64] );
    XmmReg[32,32] = float2float( m[64,64] );
    XmmReg[64,32] = 0;
    XmmReg[96,32] = 0;
}
1: Constructor line ia.sinc:5199(id0.859) printpiece=[CVTPD2PS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2786  1: XmmReg : 2785  
Pattern id=859 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5c000:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5c080:8] = SUBPIECE unique[5c000:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = FLOAT2FLOAT unique[5c080:8]
	5: unique[5c180:8] = SUBPIECE unique[5c000:10], const[8:4]
	6: [handle:space][[handle:offset+40004]:4] = FLOAT2FLOAT unique[5c180:8]
	7: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	8: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5348 :CVTSS2SD     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,64] = float2float(XmmReg2[0,32]);
}
2: Constructor line ia.sinc:5348(id0.878) printpiece=[CVTSS2SD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2823  1: XmmReg2 : 2824  
Pattern id=878 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT2FLOAT [handle:space][[handle:offset+0]:4]

Line ia.sinc:5343 :CVTSS2SD     XmmReg, m32    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5A; m32 & XmmReg ...
{
  XmmReg[0,64] = float2float(m32);
}
3: Constructor line ia.sinc:5343(id0.877) printpiece=[CVTSS2SD,  ,  B, ,,  ,  A]
Operands 0: m32 : 2822  1: XmmReg : 2821  
Pattern id=877 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5208 :CVTPD2PS     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = float2float( XmmReg2[0,64] );
    XmmReg1[32,32] = float2float( XmmReg2[64,64] );
    XmmReg1[64,32] = 0;
    XmmReg1[96,32] = 0;
}
0: Constructor line ia.sinc:5208(id0.860) printpiece=[CVTPD2PS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2787  1: XmmReg2 : 2788  
Pattern id=860 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT2FLOAT [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+40004]:4] = FLOAT2FLOAT [handle:space][[handle:offset+80008]:8]
	4: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5199 :CVTPD2PS     XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5A; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = float2float( m[0,64] );
    XmmReg[32,32] = float2float( m[64,64] );
    XmmReg[64,32] = 0;
    XmmReg[96,32] = 0;
}
1: Constructor line ia.sinc:5199(id0.859) printpiece=[CVTPD2PS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2786  1: XmmReg : 2785  
Pattern id=859 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5c000:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5c080:8] = SUBPIECE unique[5c000:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = FLOAT2FLOAT unique[5c080:8]
	5: unique[5c180:8] = SUBPIECE unique[5c000:10], const[8:4]
	6: [handle:space][[handle:offset+40004]:4] = FLOAT2FLOAT unique[5c180:8]
	7: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	8: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5314 :CVTSD2SS     XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,32] = float2float(XmmReg2[0,64]);
}
2: Constructor line ia.sinc:5314(id0.874) printpiece=[CVTSD2SS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2815  1: XmmReg2 : 2816  
Pattern id=874 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT2FLOAT [handle:space][[handle:offset+0]:8]

Line ia.sinc:5309 :CVTSD2SS     XmmReg, m64       is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5A; m64 & XmmReg ...
{
  XmmReg[0,32] = float2float(m64);
}
3: Constructor line ia.sinc:5309(id0.873) printpiece=[CVTSD2SS,  ,  B, ,,  ,  A]
Operands 0: m64 : 2814  1: XmmReg : 2813  
Pattern id=873 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5348 :CVTSS2SD     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5A; xmmmod=3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,64] = float2float(XmmReg2[0,32]);
}
4: Constructor line ia.sinc:5348(id0.878) printpiece=[CVTSS2SD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2823  1: XmmReg2 : 2824  
Pattern id=878 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT2FLOAT [handle:space][[handle:offset+0]:4]

Line ia.sinc:5343 :CVTSS2SD     XmmReg, m32    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5A; m32 & XmmReg ...
{
  XmmReg[0,64] = float2float(m32);
}
5: Constructor line ia.sinc:5343(id0.877) printpiece=[CVTSS2SD,  ,  B, ,,  ,  A]
Operands 0: m32 : 2822  1: XmmReg : 2821  
Pattern id=877 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5161 :CVTDQ2PS     XmmReg1, XmmReg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5B; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = int2float( XmmReg2[0,32] );
    XmmReg1[32,32] = int2float( XmmReg2[32,32] );
    XmmReg1[64,32] = int2float( XmmReg2[64,32] );
    XmmReg1[96,32] = int2float( XmmReg2[96,32] );
}
0: Constructor line ia.sinc:5161(id0.854) printpiece=[CVTDQ2PS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2775  1: XmmReg2 : 2776  
Pattern id=854 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5B:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = INT2FLOAT [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = INT2FLOAT [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = INT2FLOAT [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = INT2FLOAT [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5152 :CVTDQ2PS     XmmReg, m128      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5B; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = int2float( m[0,32] );
    XmmReg[32,32] = int2float( m[32,32] );
    XmmReg[64,32] = int2float( m[64,32] );
    XmmReg[96,32] = int2float( m[96,32] );
}
1: Constructor line ia.sinc:5152(id0.853) printpiece=[CVTDQ2PS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2774  1: XmmReg : 2773  
Pattern id=853 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5B:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5b280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5b300:4] = SUBPIECE unique[5b280:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = INT2FLOAT unique[5b300:4]
	5: unique[5b400:4] = SUBPIECE unique[5b280:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = INT2FLOAT unique[5b400:4]
	7: unique[5b500:4] = SUBPIECE unique[5b280:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = INT2FLOAT unique[5b500:4]
	9: unique[5b600:4] = SUBPIECE unique[5b280:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = INT2FLOAT unique[5b600:4]

Line ia.sinc:5251 :CVTPS2DQ      XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5B; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = trunc( XmmReg2[0,32] );
    XmmReg1[32,32] = trunc( XmmReg2[32,32] );
    XmmReg1[64,32] = trunc( XmmReg2[64,32] );
    XmmReg1[96,32] = trunc( XmmReg2[96,32] );
}
0: Constructor line ia.sinc:5251(id0.866) printpiece=[CVTPS2DQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2799  1: XmmReg2 : 2800  
Pattern id=866 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5B:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = TRUNC [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = TRUNC [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5242 :CVTPS2DQ      XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5B; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = trunc( m[0,32] );
    XmmReg[32,32] = trunc( m[32,32] );
    XmmReg[64,32] = trunc( m[64,32] );
    XmmReg[96,32] = trunc( m[96,32] );
}
1: Constructor line ia.sinc:5242(id0.865) printpiece=[CVTPS2DQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 2798  1: XmmReg : 2797  
Pattern id=865 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5B:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5ca80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5cb00:4] = SUBPIECE unique[5ca80:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = TRUNC unique[5cb00:4]
	5: unique[5cc00:4] = SUBPIECE unique[5ca80:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5cc00:4]
	7: unique[5cd00:4] = SUBPIECE unique[5ca80:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = TRUNC unique[5cd00:4]
	9: unique[5ce00:4] = SUBPIECE unique[5ca80:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = TRUNC unique[5ce00:4]

Line ia.sinc:5251 :CVTPS2DQ      XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5B; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = trunc( XmmReg2[0,32] );
    XmmReg1[32,32] = trunc( XmmReg2[32,32] );
    XmmReg1[64,32] = trunc( XmmReg2[64,32] );
    XmmReg1[96,32] = trunc( XmmReg2[96,32] );
}
0: Constructor line ia.sinc:5251(id0.866) printpiece=[CVTPS2DQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2799  1: XmmReg2 : 2800  
Pattern id=866 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5B:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = TRUNC [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = TRUNC [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5242 :CVTPS2DQ      XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5B; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = trunc( m[0,32] );
    XmmReg[32,32] = trunc( m[32,32] );
    XmmReg[64,32] = trunc( m[64,32] );
    XmmReg[96,32] = trunc( m[96,32] );
}
1: Constructor line ia.sinc:5242(id0.865) printpiece=[CVTPS2DQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 2798  1: XmmReg : 2797  
Pattern id=865 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5B:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5ca80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5cb00:4] = SUBPIECE unique[5ca80:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = TRUNC unique[5cb00:4]
	5: unique[5cc00:4] = SUBPIECE unique[5ca80:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5cc00:4]
	7: unique[5cd00:4] = SUBPIECE unique[5ca80:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = TRUNC unique[5cd00:4]
	9: unique[5ce00:4] = SUBPIECE unique[5ca80:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = TRUNC unique[5ce00:4]

Line ia.sinc:5416 :CVTTPS2DQ    XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5B; xmmmod=3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,32] = trunc(XmmReg2[0,32]);
  XmmReg1[32,32] = trunc(XmmReg2[32,32]);
  XmmReg1[64,32] = trunc(XmmReg2[64,32]);
  XmmReg1[96,32] = trunc(XmmReg2[96,32]);
}
2: Constructor line ia.sinc:5416(id0.886) printpiece=[CVTTPS2DQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2839  1: XmmReg2 : 2840  
Pattern id=886 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5B:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = TRUNC [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = TRUNC [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5407 :CVTTPS2DQ    XmmReg, m128        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5B; m128 & XmmReg ...
{
  local m:16 = m128;
  XmmReg[0,32] = trunc(m[0,32]);
  XmmReg[32,32] = trunc(m[32,32]);
  XmmReg[64,32] = trunc(m[64,32]);
  XmmReg[96,32] = trunc(m[96,32]);
}
3: Constructor line ia.sinc:5407(id0.885) printpiece=[CVTTPS2DQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 2838  1: XmmReg : 2837  
Pattern id=885 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5B:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5e500:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5e580:4] = SUBPIECE unique[5e500:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = TRUNC unique[5e580:4]
	5: unique[5e680:4] = SUBPIECE unique[5e500:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5e680:4]
	7: unique[5e780:4] = SUBPIECE unique[5e500:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = TRUNC unique[5e780:4]
	9: unique[5e880:4] = SUBPIECE unique[5e500:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = TRUNC unique[5e880:4]

Line ia.sinc:8118 :SUBPS           XmmReg1, XmmReg2  is vexMode=0 & mandover=0 & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f- XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] f- XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] f- XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] f- XmmReg2[96,32];
}
0: Constructor line ia.sinc:8118(id0.1355) printpiece=[SUBPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3890  1: XmmReg2 : 3891  
Pattern id=1355 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = FLOAT_SUB [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = FLOAT_SUB [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = FLOAT_SUB [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:8109 :SUBPS           XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x5C; XmmReg ... & m128
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f- m[0,32];
    XmmReg[32,32] = XmmReg[32,32] f- m[32,32];
    XmmReg[64,32] = XmmReg[64,32] f- m[64,32];
    XmmReg[96,32] = XmmReg[96,32] f- m[96,32];
}
1: Constructor line ia.sinc:8109(id0.1354) printpiece=[SUBPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3888  1: m128 : 3889  
Pattern id=1354 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[98b00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[98b80:4] = SUBPIECE unique[98b00:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], unique[98b80:4]
	5: unique[98c80:4] = SUBPIECE unique[98b00:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = FLOAT_SUB [handle:space][[handle:offset+40004]:4], unique[98c80:4]
	7: unique[98d80:4] = SUBPIECE unique[98b00:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = FLOAT_SUB [handle:space][[handle:offset+80008]:4], unique[98d80:4]
	9: unique[98e80:4] = SUBPIECE unique[98b00:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = FLOAT_SUB [handle:space][[handle:offset+c000c]:4], unique[98e80:4]

Line ia.sinc:8103 :SUBPD           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f- XmmReg2[64,64];
}
0: Constructor line ia.sinc:8103(id0.1353) printpiece=[SUBPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3886  1: XmmReg2 : 3887  
Pattern id=1353 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_SUB [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:8096 :SUBPD           XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5C;XmmReg ... & m128
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f- m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f- m[64,64];
}
1: Constructor line ia.sinc:8096(id0.1352) printpiece=[SUBPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3884  1: m128 : 3885  
Pattern id=1352 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[98780:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[98800:8] = SUBPIECE unique[98780:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], unique[98800:8]
	5: unique[98900:8] = SUBPIECE unique[98780:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT_SUB [handle:space][[handle:offset+80008]:8], unique[98900:8]

Line ia.sinc:8103 :SUBPD           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f- XmmReg2[64,64];
}
0: Constructor line ia.sinc:8103(id0.1353) printpiece=[SUBPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3886  1: XmmReg2 : 3887  
Pattern id=1353 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_SUB [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:8096 :SUBPD           XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5C;XmmReg ... & m128
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f- m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f- m[64,64];
}
1: Constructor line ia.sinc:8096(id0.1352) printpiece=[SUBPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3884  1: m128 : 3885  
Pattern id=1352 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[98780:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[98800:8] = SUBPIECE unique[98780:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], unique[98800:8]
	5: unique[98900:8] = SUBPIECE unique[98780:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT_SUB [handle:space][[handle:offset+80008]:8], unique[98900:8]

Line ia.sinc:8130 :SUBSS           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,32] = XmmReg1[0,32] f- XmmReg2[0,32]; }
2: Constructor line ia.sinc:8130(id0.1359) printpiece=[SUBSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3898  1: XmmReg2 : 3899  
Pattern id=1359 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]

Line ia.sinc:8129 :SUBSS           XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x5C; XmmReg ...& m32 { XmmReg[0,32] = XmmReg[0,32] f- m32; }
3: Constructor line ia.sinc:8129(id0.1358) printpiece=[SUBSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3896  1: m32 : 3897  
Pattern id=1358 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8103 :SUBPD           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f- XmmReg2[64,64];
}
0: Constructor line ia.sinc:8103(id0.1353) printpiece=[SUBPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3886  1: XmmReg2 : 3887  
Pattern id=1353 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_SUB [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:8096 :SUBPD           XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5C;XmmReg ... & m128
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f- m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f- m[64,64];
}
1: Constructor line ia.sinc:8096(id0.1352) printpiece=[SUBPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3884  1: m128 : 3885  
Pattern id=1352 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[98780:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[98800:8] = SUBPIECE unique[98780:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], unique[98800:8]
	5: unique[98900:8] = SUBPIECE unique[98780:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT_SUB [handle:space][[handle:offset+80008]:8], unique[98900:8]

Line ia.sinc:8127 :SUBSD           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg2[0,64]; }
2: Constructor line ia.sinc:8127(id0.1357) printpiece=[SUBSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3894  1: XmmReg2 : 3895  
Pattern id=1357 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]

Line ia.sinc:8126 :SUBSD           XmmReg, m64      is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5C; XmmReg ... & m64 { XmmReg[0,64] = XmmReg[0,64] f- m64; }
3: Constructor line ia.sinc:8126(id0.1356) printpiece=[SUBSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3892  1: m64 : 3893  
Pattern id=1356 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8130 :SUBSS           XmmReg1, XmmReg2  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x5C; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1[0,32] = XmmReg1[0,32] f- XmmReg2[0,32]; }
4: Constructor line ia.sinc:8130(id0.1359) printpiece=[SUBSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3898  1: XmmReg2 : 3899  
Pattern id=1359 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]

Line ia.sinc:8129 :SUBSS           XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x5C; XmmReg ...& m32 { XmmReg[0,32] = XmmReg[0,32] f- m32; }
5: Constructor line ia.sinc:8129(id0.1358) printpiece=[SUBSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3896  1: m32 : 3897  
Pattern id=1358 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5C:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5623 :MINPS        XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = minps(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5623(id0.923) printpiece=[MINPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2919  1: XmmReg2 : 2920  
Pattern id=923 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[71:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5622 :MINPS        XmmReg, m128        is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5D; XmmReg ... & m128 { XmmReg = minps(XmmReg, m128); }
1: Constructor line ia.sinc:5622(id0.922) printpiece=[MINPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2917  1: m128 : 2918  
Pattern id=922 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[71:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5619 :MINPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = minpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5619(id0.921) printpiece=[MINPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2914  1: XmmReg2 : 2915  
Pattern id=921 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[70:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5618 :MINPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5D; XmmReg ... & m128 { XmmReg = minpd(XmmReg, m128); }
1: Constructor line ia.sinc:5618(id0.920) printpiece=[MINPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2912  1: m128 : 2913  
Pattern id=920 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[70:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5619 :MINPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = minpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5619(id0.921) printpiece=[MINPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2914  1: XmmReg2 : 2915  
Pattern id=921 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[70:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5618 :MINPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5D; XmmReg ... & m128 { XmmReg = minpd(XmmReg, m128); }
1: Constructor line ia.sinc:5618(id0.920) printpiece=[MINPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2912  1: m128 : 2913  
Pattern id=920 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[70:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5645 :MINSS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg1[0,32] f< XmmReg2[0,32]) goto inst_next;
    XmmReg1[0,32] = XmmReg2[0,32];
}
2: Constructor line ia.sinc:5645(id0.927) printpiece=[MINSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2927  1: XmmReg2 : 2928  
Pattern id=927 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[61380:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: CBRANCH [curspace][[next]:[curspace_size]], unique[61380:1]
	4: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:5638 :MINSS        XmmReg, m32         is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5D; XmmReg ... & m32
{
    local tmp:4 = m32;
    if (XmmReg[0,32] f< tmp) goto inst_next;
    XmmReg[0,32] = tmp;
}
3: Constructor line ia.sinc:5638(id0.926) printpiece=[MINSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2925  1: m32 : 2926  
Pattern id=926 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[61280:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[61300:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], unique[61280:4]
	4: CBRANCH [curspace][[next]:[curspace_size]], unique[61300:1]
	5: [handle:space][[handle:offset+0]:4] = COPY unique[61280:4]

Line ia.sinc:5619 :MINPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = minpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5619(id0.921) printpiece=[MINPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2914  1: XmmReg2 : 2915  
Pattern id=921 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[70:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5618 :MINPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5D; XmmReg ... & m128 { XmmReg = minpd(XmmReg, m128); }
1: Constructor line ia.sinc:5618(id0.920) printpiece=[MINPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2912  1: m128 : 2913  
Pattern id=920 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[70:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5632 :MINSD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg1[0,64] f< XmmReg2[0,64]) goto inst_next;
    XmmReg1[0,64] = XmmReg2[0,64];
}
2: Constructor line ia.sinc:5632(id0.925) printpiece=[MINSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2923  1: XmmReg2 : 2924  
Pattern id=925 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[61200:1] = FLOAT_LESS [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: CBRANCH [curspace][[next]:[curspace_size]], unique[61200:1]
	4: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:5625 :MINSD        XmmReg, m64         is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5D; XmmReg ... & m64
{
    local tmp:8 = m64;
    if (XmmReg[0,64] f< tmp) goto inst_next;
    XmmReg[0,64] = tmp;
}
3: Constructor line ia.sinc:5625(id0.924) printpiece=[MINSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2921  1: m64 : 2922  
Pattern id=924 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[61100:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[61180:1] = FLOAT_LESS [handle:space][[handle:offset+0]:8], unique[61100:8]
	4: CBRANCH [curspace][[next]:[curspace_size]], unique[61180:1]
	5: [handle:space][[handle:offset+0]:8] = COPY unique[61100:8]

Line ia.sinc:5645 :MINSS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg1[0,32] f< XmmReg2[0,32]) goto inst_next;
    XmmReg1[0,32] = XmmReg2[0,32];
}
4: Constructor line ia.sinc:5645(id0.927) printpiece=[MINSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2927  1: XmmReg2 : 2928  
Pattern id=927 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[61380:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: CBRANCH [curspace][[next]:[curspace_size]], unique[61380:1]
	4: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:5638 :MINSS        XmmReg, m32         is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5D; XmmReg ... & m32
{
    local tmp:4 = m32;
    if (XmmReg[0,32] f< tmp) goto inst_next;
    XmmReg[0,32] = tmp;
}
5: Constructor line ia.sinc:5638(id0.926) printpiece=[MINSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2925  1: m32 : 2926  
Pattern id=926 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5D:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[61280:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[61300:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], unique[61280:4]
	4: CBRANCH [curspace][[next]:[curspace_size]], unique[61300:1]
	5: [handle:space][[handle:offset+0]:4] = COPY unique[61280:4]

Line ia.sinc:5489 :DIVPS        XmmReg1, XmmReg2 is vexMode=0 & mandover=0 & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = divps(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5489(id0.896) printpiece=[DIVPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2861  1: XmmReg2 : 2862  
Pattern id=896 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5488 :DIVPS        XmmReg, m128     is vexMode=0 & mandover=0 & byte=0x0F; byte=0x5E; XmmReg ... & m128 { XmmReg = divps(XmmReg, m128); }
1: Constructor line ia.sinc:5488(id0.895) printpiece=[DIVPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2859  1: m128 : 2860  
Pattern id=895 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5E:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5485 :DIVPD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = divpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5485(id0.894) printpiece=[DIVPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2856  1: XmmReg2 : 2857  
Pattern id=894 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5484 :DIVPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5E; XmmReg ... & m128 { XmmReg = divpd(XmmReg, m128); }
1: Constructor line ia.sinc:5484(id0.893) printpiece=[DIVPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2854  1: m128 : 2855  
Pattern id=893 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5E:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5485 :DIVPD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = divpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5485(id0.894) printpiece=[DIVPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2856  1: XmmReg2 : 2857  
Pattern id=894 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5484 :DIVPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5E; XmmReg ... & m128 { XmmReg = divpd(XmmReg, m128); }
1: Constructor line ia.sinc:5484(id0.893) printpiece=[DIVPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2854  1: m128 : 2855  
Pattern id=893 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5E:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5506 :DIVSS        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f/ XmmReg2[0,32];
}
2: Constructor line ia.sinc:5506(id0.900) printpiece=[DIVSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2869  1: XmmReg2 : 2870  
Pattern id=900 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_DIV [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]

Line ia.sinc:5501 :DIVSS        XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x5E; m32 & XmmReg ...
{
    XmmReg[0,32] = XmmReg[0,32] f/ m32;
}
3: Constructor line ia.sinc:5501(id0.899) printpiece=[DIVSS,  ,  B, ,,  ,  A]
Operands 0: m32 : 2868  1: XmmReg : 2867  
Pattern id=899 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5E:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_DIV [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5485 :DIVPD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = divpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5485(id0.894) printpiece=[DIVPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2856  1: XmmReg2 : 2857  
Pattern id=894 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5484 :DIVPD        XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x5E; XmmReg ... & m128 { XmmReg = divpd(XmmReg, m128); }
1: Constructor line ia.sinc:5484(id0.893) printpiece=[DIVPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2854  1: m128 : 2855  
Pattern id=893 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5E:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5496 :DIVSD        XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f/ XmmReg2[0,64];
}
2: Constructor line ia.sinc:5496(id0.898) printpiece=[DIVSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2865  1: XmmReg2 : 2866  
Pattern id=898 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_DIV [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]

Line ia.sinc:5491 :DIVSD        XmmReg, m64      is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x5E; m64 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[0,64] f/ m64;
}
3: Constructor line ia.sinc:5491(id0.897) printpiece=[DIVSD,  ,  B, ,,  ,  A]
Operands 0: m64 : 2864  1: XmmReg : 2863  
Pattern id=897 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5E:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_DIV [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5506 :DIVSS        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5E; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f/ XmmReg2[0,32];
}
4: Constructor line ia.sinc:5506(id0.900) printpiece=[DIVSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2869  1: XmmReg2 : 2870  
Pattern id=900 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_DIV [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]

Line ia.sinc:5501 :DIVSS        XmmReg, m32      is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x5E; m32 & XmmReg ...
{
    XmmReg[0,32] = XmmReg[0,32] f/ m32;
}
5: Constructor line ia.sinc:5501(id0.899) printpiece=[DIVSS,  ,  B, ,,  ,  A]
Operands 0: m32 : 2868  1: XmmReg : 2867  
Pattern id=899 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5E:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_DIV [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5589 :MAXPS        XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = maxps(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5589(id0.915) printpiece=[MAXPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2901  1: XmmReg2 : 2902  
Pattern id=915 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5588 :MAXPS        XmmReg, m128        is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5F; XmmReg ... & m128 { XmmReg = maxps(XmmReg, m128); }
1: Constructor line ia.sinc:5588(id0.914) printpiece=[MAXPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2899  1: m128 : 2900  
Pattern id=914 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:5F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5585 :MAXPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = maxpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5585(id0.913) printpiece=[MAXPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2896  1: XmmReg2 : 2897  
Pattern id=913 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5584 :MAXPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5F; XmmReg ... & m128 { XmmReg = maxpd(XmmReg, m128); }
1: Constructor line ia.sinc:5584(id0.912) printpiece=[MAXPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2894  1: m128 : 2895  
Pattern id=912 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5585 :MAXPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = maxpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5585(id0.913) printpiece=[MAXPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2896  1: XmmReg2 : 2897  
Pattern id=913 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5584 :MAXPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5F; XmmReg ... & m128 { XmmReg = maxpd(XmmReg, m128); }
1: Constructor line ia.sinc:5584(id0.912) printpiece=[MAXPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2894  1: m128 : 2895  
Pattern id=912 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5611 :MAXSS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg2[0,32] f< XmmReg1[0,32]) goto inst_next;
    XmmReg1[0,32] = XmmReg2[0,32];
}
2: Constructor line ia.sinc:5611(id0.919) printpiece=[MAXSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2909  1: XmmReg2 : 2910  
Pattern id=919 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[60e80:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: CBRANCH [curspace][[next]:[curspace_size]], unique[60e80:1]
	4: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:5604 :MAXSS        XmmReg, m32         is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5F; XmmReg ... & m32
{
    local tmp:4 = m32;
    if (tmp f< XmmReg[0,32]) goto inst_next;
    XmmReg[0,32] = tmp;
}
3: Constructor line ia.sinc:5604(id0.918) printpiece=[MAXSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2907  1: m32 : 2908  
Pattern id=918 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[60d80:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[60e00:1] = FLOAT_LESS unique[60d80:4], [handle:space][[handle:offset+0]:4]
	4: CBRANCH [curspace][[next]:[curspace_size]], unique[60e00:1]
	5: [handle:space][[handle:offset+0]:4] = COPY unique[60d80:4]

Line ia.sinc:5585 :MAXPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = maxpd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5585(id0.913) printpiece=[MAXPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2896  1: XmmReg2 : 2897  
Pattern id=913 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5584 :MAXPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5F; XmmReg ... & m128 { XmmReg = maxpd(XmmReg, m128); }
1: Constructor line ia.sinc:5584(id0.912) printpiece=[MAXPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2894  1: m128 : 2895  
Pattern id=912 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:5F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5598 :MAXSD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg2[0,64] f< XmmReg1[0,64]) goto inst_next;
    XmmReg1[0,64] = XmmReg2[0,64];
}
2: Constructor line ia.sinc:5598(id0.917) printpiece=[MAXSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2905  1: XmmReg2 : 2906  
Pattern id=917 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[60d00:1] = FLOAT_LESS [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: CBRANCH [curspace][[next]:[curspace_size]], unique[60d00:1]
	4: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:5591 :MAXSD        XmmReg, m64         is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5F; XmmReg ... & m64
{
    local tmp:8 = m64;
    if (tmp f< XmmReg[0,64]) goto inst_next;
    XmmReg[0,64] = tmp;
}
3: Constructor line ia.sinc:5591(id0.916) printpiece=[MAXSD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2903  1: m64 : 2904  
Pattern id=916 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:5F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[60c00:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[60c80:1] = FLOAT_LESS unique[60c00:8], [handle:space][[handle:offset+0]:8]
	4: CBRANCH [curspace][[next]:[curspace_size]], unique[60c80:1]
	5: [handle:space][[handle:offset+0]:8] = COPY unique[60c00:8]

Line ia.sinc:5611 :MAXSS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2
{
    if (XmmReg2[0,32] f< XmmReg1[0,32]) goto inst_next;
    XmmReg1[0,32] = XmmReg2[0,32];
}
4: Constructor line ia.sinc:5611(id0.919) printpiece=[MAXSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2909  1: XmmReg2 : 2910  
Pattern id=919 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[60e80:1] = FLOAT_LESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: CBRANCH [curspace][[next]:[curspace_size]], unique[60e80:1]
	4: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:5604 :MAXSS        XmmReg, m32         is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5F; XmmReg ... & m32
{
    local tmp:4 = m32;
    if (tmp f< XmmReg[0,32]) goto inst_next;
    XmmReg[0,32] = tmp;
}
5: Constructor line ia.sinc:5604(id0.918) printpiece=[MAXSS,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2907  1: m32 : 2908  
Pattern id=918 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:5F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[60d80:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[60e00:1] = FLOAT_LESS unique[60d80:4], [handle:space][[handle:offset+0]:4]
	4: CBRANCH [curspace][[next]:[curspace_size]], unique[60e00:1]
	5: [handle:space][[handle:offset+0]:4] = COPY unique[60d80:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:7883 :PUNPCKLBW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x60; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[56,8] = mmxreg2[24,8];
    mmxreg1[48,8] = mmxreg1[24,8];
    mmxreg1[40,8] = mmxreg2[16,8];
    mmxreg1[32,8] = mmxreg1[16,8];
    mmxreg1[24,8] = mmxreg2[8,8];
    mmxreg1[16,8] = mmxreg1[8,8];
    mmxreg1[8,8] = mmxreg2[0,8];
#   mmxreg1[0,8] = mmxreg1[0,8]; superfluous
}
0: Constructor line ia.sinc:7883(id0.1315) printpiece=[PUNPCKLBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3790  1: mmxreg2 : 3791  
Pattern id=1315 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:60:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+70007]:1] = COPY [handle:space][[handle:offset+30003]:1]
	1: [handle:space][[handle:offset+60006]:1] = COPY [handle:space][[handle:offset+30003]:1]
	2: [handle:space][[handle:offset+50005]:1] = COPY [handle:space][[handle:offset+20002]:1]
	3: [handle:space][[handle:offset+40004]:1] = COPY [handle:space][[handle:offset+20002]:1]
	4: [handle:space][[handle:offset+30003]:1] = COPY [handle:space][[handle:offset+10001]:1]
	5: [handle:space][[handle:offset+20002]:1] = COPY [handle:space][[handle:offset+10001]:1]
	6: [handle:space][[handle:offset+10001]:1] = COPY [handle:space][[handle:offset+0]:1]

Line ia.sinc:7870 :PUNPCKLBW       mmxreg, m32      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x60; mmxreg ... & m32
{
    local m:4 = m32;
    mmxreg[56,8] =    m[24,8];
    mmxreg[48,8] = mmxreg[24,8];
    mmxreg[40,8] =    m[16,8];
    mmxreg[32,8] = mmxreg[16,8];
    mmxreg[24,8] =    m[8,8];
    mmxreg[16,8] = mmxreg[8,8];
    mmxreg[8,8] =    m[0,8];
#   mmxreg[0,8] = mmxreg[0,8]; superfluous
}
1: Constructor line ia.sinc:7870(id0.1314) printpiece=[PUNPCKLBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3788  1: m32 : 3789  
Pattern id=1314 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:60:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[96800:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset+70007]:1] = SUBPIECE unique[96800:4], const[3:4]
	3: [handle:space][[handle:offset+60006]:1] = COPY [handle:space][[handle:offset+30003]:1]
	4: [handle:space][[handle:offset+50005]:1] = SUBPIECE unique[96800:4], const[2:4]
	5: [handle:space][[handle:offset+40004]:1] = COPY [handle:space][[handle:offset+20002]:1]
	6: [handle:space][[handle:offset+30003]:1] = SUBPIECE unique[96800:4], const[1:4]
	7: [handle:space][[handle:offset+20002]:1] = COPY [handle:space][[handle:offset+10001]:1]
	8: [handle:space][[handle:offset+10001]:1] = SUBPIECE unique[96800:4], const[0:4]

Line ia.sinc:7945 :PUNPCKLBW       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x60; xmmmod = 3 &
XmmReg1 & XmmReg2
{
    XmmReg1[120,8] = XmmReg2[56,8];
    XmmReg1[112,8] = XmmReg1[56,8];
    XmmReg1[104,8] = XmmReg2[48,8];
    XmmReg1[96,8] = XmmReg1[48,8];
    XmmReg1[88,8] = XmmReg2[40,8];
    XmmReg1[80,8] = XmmReg1[40,8];
    XmmReg1[72,8] = XmmReg2[32,8];
    XmmReg1[64,8] = XmmReg1[32,8];
    XmmReg1[56,8] = XmmReg2[24,8];
    XmmReg1[48,8] = XmmReg1[24,8];
    XmmReg1[40,8] = XmmReg2[16,8];
    XmmReg1[32,8] = XmmReg1[16,8];
    XmmReg1[24,8] = XmmReg2[8,8];
    XmmReg1[16,8] = XmmReg1[8,8];
    XmmReg1[8,8] = XmmReg2[0,8];
#   XmmReg1[0,8] = XmmReg1[0,8]; superfluous
}
0: Constructor line ia.sinc:7945(id0.1321) printpiece=[PUNPCKLBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3802  1: XmmReg2 : 3803  
Pattern id=1321 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:60:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+f000f]:1] = COPY [handle:space][[handle:offset+70007]:1]
	3: [handle:space][[handle:offset+e000e]:1] = COPY [handle:space][[handle:offset+70007]:1]
	4: [handle:space][[handle:offset+d000d]:1] = COPY [handle:space][[handle:offset+60006]:1]
	5: [handle:space][[handle:offset+c000c]:1] = COPY [handle:space][[handle:offset+60006]:1]
	6: [handle:space][[handle:offset+b000b]:1] = COPY [handle:space][[handle:offset+50005]:1]
	7: [handle:space][[handle:offset+a000a]:1] = COPY [handle:space][[handle:offset+50005]:1]
	8: [handle:space][[handle:offset+90009]:1] = COPY [handle:space][[handle:offset+40004]:1]
	9: [handle:space][[handle:offset+80008]:1] = COPY [handle:space][[handle:offset+40004]:1]
	10: [handle:space][[handle:offset+70007]:1] = COPY [handle:space][[handle:offset+30003]:1]
	11: [handle:space][[handle:offset+60006]:1] = COPY [handle:space][[handle:offset+30003]:1]
	12: [handle:space][[handle:offset+50005]:1] = COPY [handle:space][[handle:offset+20002]:1]
	13: [handle:space][[handle:offset+40004]:1] = COPY [handle:space][[handle:offset+20002]:1]
	14: [handle:space][[handle:offset+30003]:1] = COPY [handle:space][[handle:offset+10001]:1]
	15: [handle:space][[handle:offset+20002]:1] = COPY [handle:space][[handle:offset+10001]:1]
	16: [handle:space][[handle:offset+10001]:1] = COPY [handle:space][[handle:offset+0]:1]

Line ia.sinc:7924 :PUNPCKLBW       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x60; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[120,8] =   m[56,8];
    XmmReg[112,8] = XmmReg[56,8];
    XmmReg[104,8] =   m[48,8];
    XmmReg[96,8] = XmmReg[48,8];
    XmmReg[88,8] =   m[40,8];
    XmmReg[80,8] = XmmReg[40,8];
    XmmReg[72,8] =   m[32,8];
    XmmReg[64,8] = XmmReg[32,8];
    XmmReg[56,8] =   m[24,8];
    XmmReg[48,8] = XmmReg[24,8];
    XmmReg[40,8] =   m[16,8];
    XmmReg[32,8] = XmmReg[16,8];
    XmmReg[24,8] =   m[8,8];
    XmmReg[16,8] = XmmReg[8,8];
    XmmReg[8,8] =   m[0,8];
#   XmmReg[0,8] = XmmReg[0,8]; superfluous
}
1: Constructor line ia.sinc:7924(id0.1320) printpiece=[PUNPCKLBW,  ,  B, ,,  ,  A]
Operands 0: m128 : 3801  1: XmmReg : 3800  
Pattern id=1320 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:60:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[96c00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+f000f]:1] = SUBPIECE unique[96c00:10], const[7:4]
	4: [handle:space][[handle:offset+e000e]:1] = COPY [handle:space][[handle:offset+70007]:1]
	5: [handle:space][[handle:offset+d000d]:1] = SUBPIECE unique[96c00:10], const[6:4]
	6: [handle:space][[handle:offset+c000c]:1] = COPY [handle:space][[handle:offset+60006]:1]
	7: [handle:space][[handle:offset+b000b]:1] = SUBPIECE unique[96c00:10], const[5:4]
	8: [handle:space][[handle:offset+a000a]:1] = COPY [handle:space][[handle:offset+50005]:1]
	9: [handle:space][[handle:offset+90009]:1] = SUBPIECE unique[96c00:10], const[4:4]
	10: [handle:space][[handle:offset+80008]:1] = COPY [handle:space][[handle:offset+40004]:1]
	11: [handle:space][[handle:offset+70007]:1] = SUBPIECE unique[96c00:10], const[3:4]
	12: [handle:space][[handle:offset+60006]:1] = COPY [handle:space][[handle:offset+30003]:1]
	13: [handle:space][[handle:offset+50005]:1] = SUBPIECE unique[96c00:10], const[2:4]
	14: [handle:space][[handle:offset+40004]:1] = COPY [handle:space][[handle:offset+20002]:1]
	15: [handle:space][[handle:offset+30003]:1] = SUBPIECE unique[96c00:10], const[1:4]
	16: [handle:space][[handle:offset+20002]:1] = COPY [handle:space][[handle:offset+10001]:1]
	17: [handle:space][[handle:offset+10001]:1] = SUBPIECE unique[96c00:10], const[0:4]

Line ia.sinc:7904 :PUNPCKLWD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x61; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[48,16] = mmxreg2[16,16];
    mmxreg1[32,16] = mmxreg1[16,16];
    mmxreg1[16,16] = mmxreg2[0,16];
#   mmxreg1[0,16] = mmxreg1[0,16]; superfluous
}
0: Constructor line ia.sinc:7904(id0.1317) printpiece=[PUNPCKLWD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3794  1: mmxreg2 : 3795  
Pattern id=1317 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:61:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+60006]:2] = COPY [handle:space][[handle:offset+20002]:2]
	1: [handle:space][[handle:offset+40004]:2] = COPY [handle:space][[handle:offset+20002]:2]
	2: [handle:space][[handle:offset+20002]:2] = COPY [handle:space][[handle:offset+0]:2]

Line ia.sinc:7895 :PUNPCKLWD       mmxreg, m32      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x61; mmxreg ... & m32
{
    local m:4 = m32;
    mmxreg[48,16] =    m[16,16];
    mmxreg[32,16] = mmxreg[16,16];
    mmxreg[16,16] =    m[0,16];
#   mmxreg[0,16] = mmxreg[0,16]; superfluous
}
1: Constructor line ia.sinc:7895(id0.1316) printpiece=[PUNPCKLWD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3792  1: m32 : 3793  
Pattern id=1316 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:61:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[96a80:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset+60006]:2] = SUBPIECE unique[96a80:4], const[2:4]
	3: [handle:space][[handle:offset+40004]:2] = COPY [handle:space][[handle:offset+20002]:2]
	4: [handle:space][[handle:offset+20002]:2] = SUBPIECE unique[96a80:4], const[0:4]

Line ia.sinc:7979 :PUNPCKLWD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x61; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[112,16] = XmmReg2[48,16];
    XmmReg1[96,16] = XmmReg1[48,16];
    XmmReg1[80,16] = XmmReg2[32,16];
    XmmReg1[64,16] = XmmReg1[32,16];
    XmmReg1[48,16] = XmmReg2[16,16];
    XmmReg1[32,16] = XmmReg1[16,16];
    XmmReg1[16,16] = XmmReg2[0,16];
#   XmmReg1[0,16] = XmmReg1[0,16]; superfluous
}
0: Constructor line ia.sinc:7979(id0.1323) printpiece=[PUNPCKLWD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3806  1: XmmReg2 : 3807  
Pattern id=1323 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:61:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+e000e]:2] = COPY [handle:space][[handle:offset+60006]:2]
	3: [handle:space][[handle:offset+c000c]:2] = COPY [handle:space][[handle:offset+60006]:2]
	4: [handle:space][[handle:offset+a000a]:2] = COPY [handle:space][[handle:offset+40004]:2]
	5: [handle:space][[handle:offset+80008]:2] = COPY [handle:space][[handle:offset+40004]:2]
	6: [handle:space][[handle:offset+60006]:2] = COPY [handle:space][[handle:offset+20002]:2]
	7: [handle:space][[handle:offset+40004]:2] = COPY [handle:space][[handle:offset+20002]:2]
	8: [handle:space][[handle:offset+20002]:2] = COPY [handle:space][[handle:offset+0]:2]

Line ia.sinc:7966 :PUNPCKLWD       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x61; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[112,16] =   m[48,16];
    XmmReg[96,16] = XmmReg[48,16];
    XmmReg[80,16] =   m[32,16];
    XmmReg[64,16] = XmmReg[32,16];
    XmmReg[48,16] =   m[16,16];
    XmmReg[32,16] = XmmReg[16,16];
    XmmReg[16,16] =   m[0,16];
#   XmmReg[0,16] = XmmReg[0,16]; superfluous
}
1: Constructor line ia.sinc:7966(id0.1322) printpiece=[PUNPCKLWD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3805  1: XmmReg : 3804  
Pattern id=1322 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:61:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[97080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+e000e]:2] = SUBPIECE unique[97080:10], const[6:4]
	4: [handle:space][[handle:offset+c000c]:2] = COPY [handle:space][[handle:offset+60006]:2]
	5: [handle:space][[handle:offset+a000a]:2] = SUBPIECE unique[97080:10], const[4:4]
	6: [handle:space][[handle:offset+80008]:2] = COPY [handle:space][[handle:offset+40004]:2]
	7: [handle:space][[handle:offset+60006]:2] = SUBPIECE unique[97080:10], const[2:4]
	8: [handle:space][[handle:offset+40004]:2] = COPY [handle:space][[handle:offset+20002]:2]
	9: [handle:space][[handle:offset+20002]:2] = SUBPIECE unique[97080:10], const[0:4]

Line ia.sinc:7918 :PUNPCKLDQ       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x62; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[32,32] = mmxreg2[0,32];
#   mmxreg1[0,32] = mmxreg1[0,32]; superfluous
}
0: Constructor line ia.sinc:7918(id0.1319) printpiece=[PUNPCKLDQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3798  1: mmxreg2 : 3799  
Pattern id=1319 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:62:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:7912 :PUNPCKLDQ       mmxreg, m32      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x62; mmxreg ... & m32
{
    mmxreg[32,32] =    m32;
#   mmxreg[0,32] = mmxreg[0,32]; superfluous
}
1: Constructor line ia.sinc:7912(id0.1318) printpiece=[PUNPCKLDQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3796  1: m32 : 3797  
Pattern id=1318 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:62:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8000 :PUNPCKLDQ       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x62; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[96,32] = XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[32,32];
    XmmReg1[32,32] = XmmReg2[0,32];
#   XmmReg1[0,32] = XmmReg1[0,32]; superfluous
}
0: Constructor line ia.sinc:8000(id0.1325) printpiece=[PUNPCKLDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3810  1: XmmReg2 : 3811  
Pattern id=1325 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:62:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+40004]:4]
	3: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+0]:4]

Line ia.sinc:7991 :PUNPCKLDQ       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x62; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[96,32] =   m[32,32];
    XmmReg[64,32] = XmmReg[32,32];
    XmmReg[32,32] =   m[0,32];
#   XmmReg[0,32] = XmmReg[0,32]; superfluous
}
1: Constructor line ia.sinc:7991(id0.1324) printpiece=[PUNPCKLDQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 3809  1: XmmReg : 3808  
Pattern id=1324 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:62:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[97300:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+c000c]:4] = SUBPIECE unique[97300:10], const[4:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+40004]:4]
	5: [handle:space][[handle:offset+40004]:4] = SUBPIECE unique[97300:10], const[0:4]

Line ia.sinc:6009 :PACKSSWB      mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x63; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = packsswb(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:6009(id0.1009) printpiece=[PACKSSWB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3097  1: mmxreg2 : 3098  
Pattern id=1009 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:63:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[75:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6008 :PACKSSWB      mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x63; mmxreg ... & m64 { mmxreg = packsswb(mmxreg, m64); }
1: Constructor line ia.sinc:6008(id0.1008) printpiece=[PACKSSWB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3095  1: m64 : 3096  
Pattern id=1008 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:63:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[75:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6016 :PACKSSWB      XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x63; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = packsswb(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:6016(id0.1013) printpiece=[PACKSSWB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3106  1: XmmReg2 : 3107  
Pattern id=1013 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:63:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[75:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6015 :PACKSSWB      XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x63; XmmReg ... & m128 { XmmReg = packsswb(XmmReg, m128); }
1: Constructor line ia.sinc:6015(id0.1012) printpiece=[PACKSSWB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3104  1: m128 : 3105  
Pattern id=1012 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:63:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[75:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6678 :PCMPGTB       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x64; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = (mmxreg1[0,8] s> mmxreg2[0,8]) * 0xFF;
    mmxreg1[8,8] = (mmxreg1[8,8] s> mmxreg2[8,8]) * 0xFF;
    mmxreg1[16,8] = (mmxreg1[16,8] s> mmxreg2[16,8]) * 0xFF;
    mmxreg1[24,8] = (mmxreg1[24,8] s> mmxreg2[24,8]) * 0xFF;
    mmxreg1[32,8] = (mmxreg1[32,8] s> mmxreg2[32,8]) * 0xFF;
    mmxreg1[40,8] = (mmxreg1[40,8] s> mmxreg2[40,8]) * 0xFF;
    mmxreg1[48,8] = (mmxreg1[48,8] s> mmxreg2[48,8]) * 0xFF;
    mmxreg1[56,8] = (mmxreg1[56,8] s> mmxreg2[56,8]) * 0xFF;
}
0: Constructor line ia.sinc:6678(id0.1097) printpiece=[PCMPGTB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3287  1: mmxreg2 : 3288  
Pattern id=1097 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:64:[11xx]X:XX)
Template
	0: unique[79f00:1] = INT_SLESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	1: [handle:space][[handle:offset+0]:1] = INT_MULT unique[79f00:1], const[ff:1]
	2: unique[7a000:1] = INT_SLESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	3: [handle:space][[handle:offset+10001]:1] = INT_MULT unique[7a000:1], const[ff:1]
	4: unique[7a100:1] = INT_SLESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	5: [handle:space][[handle:offset+20002]:1] = INT_MULT unique[7a100:1], const[ff:1]
	6: unique[7a200:1] = INT_SLESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	7: [handle:space][[handle:offset+30003]:1] = INT_MULT unique[7a200:1], const[ff:1]
	8: unique[7a300:1] = INT_SLESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	9: [handle:space][[handle:offset+40004]:1] = INT_MULT unique[7a300:1], const[ff:1]
	10: unique[7a400:1] = INT_SLESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	11: [handle:space][[handle:offset+50005]:1] = INT_MULT unique[7a400:1], const[ff:1]
	12: unique[7a500:1] = INT_SLESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	13: [handle:space][[handle:offset+60006]:1] = INT_MULT unique[7a500:1], const[ff:1]
	14: unique[7a600:1] = INT_SLESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	15: [handle:space][[handle:offset+70007]:1] = INT_MULT unique[7a600:1], const[ff:1]

Line ia.sinc:6665 :PCMPGTB       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x64; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = (mmxreg[0,8] s> m[0,8]) * 0xFF;
    mmxreg[8,8] = (mmxreg[8,8] s> m[8,8]) * 0xFF;
    mmxreg[16,8] = (mmxreg[16,8] s> m[16,8]) * 0xFF;
    mmxreg[24,8] = (mmxreg[24,8] s> m[24,8]) * 0xFF;
    mmxreg[32,8] = (mmxreg[32,8] s> m[32,8]) * 0xFF;
    mmxreg[40,8] = (mmxreg[40,8] s> m[40,8]) * 0xFF;
    mmxreg[48,8] = (mmxreg[48,8] s> m[48,8]) * 0xFF;
    mmxreg[56,8] = (mmxreg[56,8] s> m[56,8]) * 0xFF;
}
1: Constructor line ia.sinc:6665(id0.1096) printpiece=[PCMPGTB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3285  1: m64 : 3286  
Pattern id=1096 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:64:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[79280:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[79300:1] = SUBPIECE unique[79280:8], const[0:4]
	3: unique[79380:1] = INT_SLESS unique[79300:1], [handle:space][[handle:offset+0]:1]
	4: [handle:space][[handle:offset+0]:1] = INT_MULT unique[79380:1], const[ff:1]
	5: unique[79480:1] = SUBPIECE unique[79280:8], const[1:4]
	6: unique[79500:1] = INT_SLESS unique[79480:1], [handle:space][[handle:offset+10001]:1]
	7: [handle:space][[handle:offset+10001]:1] = INT_MULT unique[79500:1], const[ff:1]
	8: unique[79600:1] = SUBPIECE unique[79280:8], const[2:4]
	9: unique[79680:1] = INT_SLESS unique[79600:1], [handle:space][[handle:offset+20002]:1]
	10: [handle:space][[handle:offset+20002]:1] = INT_MULT unique[79680:1], const[ff:1]
	11: unique[79780:1] = SUBPIECE unique[79280:8], const[3:4]
	12: unique[79800:1] = INT_SLESS unique[79780:1], [handle:space][[handle:offset+30003]:1]
	13: [handle:space][[handle:offset+30003]:1] = INT_MULT unique[79800:1], const[ff:1]
	14: unique[79900:1] = SUBPIECE unique[79280:8], const[4:4]
	15: unique[79980:1] = INT_SLESS unique[79900:1], [handle:space][[handle:offset+40004]:1]
	16: [handle:space][[handle:offset+40004]:1] = INT_MULT unique[79980:1], const[ff:1]
	17: unique[79a80:1] = SUBPIECE unique[79280:8], const[5:4]
	18: unique[79b00:1] = INT_SLESS unique[79a80:1], [handle:space][[handle:offset+50005]:1]
	19: [handle:space][[handle:offset+50005]:1] = INT_MULT unique[79b00:1], const[ff:1]
	20: unique[79c00:1] = SUBPIECE unique[79280:8], const[6:4]
	21: unique[79c80:1] = INT_SLESS unique[79c00:1], [handle:space][[handle:offset+60006]:1]
	22: [handle:space][[handle:offset+60006]:1] = INT_MULT unique[79c80:1], const[ff:1]
	23: unique[79d80:1] = SUBPIECE unique[79280:8], const[7:4]
	24: unique[79e00:1] = INT_SLESS unique[79d80:1], [handle:space][[handle:offset+70007]:1]
	25: [handle:space][[handle:offset+70007]:1] = INT_MULT unique[79e00:1], const[ff:1]

Line ia.sinc:6742 :PCMPGTB       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x64; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = (XmmReg1[0,8] s> XmmReg2[0,8]) * 0xFF;
    XmmReg1[8,8] = (XmmReg1[8,8] s> XmmReg2[8,8]) * 0xFF;
    XmmReg1[16,8] = (XmmReg1[16,8] s> XmmReg2[16,8]) * 0xFF;
    XmmReg1[24,8] = (XmmReg1[24,8] s> XmmReg2[24,8]) * 0xFF;
    XmmReg1[32,8] = (XmmReg1[32,8] s> XmmReg2[32,8]) * 0xFF;
    XmmReg1[40,8] = (XmmReg1[40,8] s> XmmReg2[40,8]) * 0xFF;
    XmmReg1[48,8] = (XmmReg1[48,8] s> XmmReg2[48,8]) * 0xFF;
    XmmReg1[56,8] = (XmmReg1[56,8] s> XmmReg2[56,8]) * 0xFF;
    XmmReg1[64,8] = (XmmReg1[64,8] s> XmmReg2[64,8]) * 0xFF;
    XmmReg1[72,8] = (XmmReg1[72,8] s> XmmReg2[72,8]) * 0xFF;
    XmmReg1[80,8] = (XmmReg1[80,8] s> XmmReg2[80,8]) * 0xFF;
    XmmReg1[88,8] = (XmmReg1[88,8] s> XmmReg2[88,8]) * 0xFF;
    XmmReg1[96,8] = (XmmReg1[96,8] s> XmmReg2[96,8]) * 0xFF;
    XmmReg1[104,8] = (XmmReg1[104,8] s> XmmReg2[104,8]) * 0xFF;
    XmmReg1[112,8] = (XmmReg1[112,8] s> XmmReg2[112,8]) * 0xFF;
    XmmReg1[120,8] = (XmmReg1[120,8] s> XmmReg2[120,8]) * 0xFF;
}
0: Constructor line ia.sinc:6742(id0.1103) printpiece=[PCMPGTB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3299  1: XmmReg2 : 3300  
Pattern id=1103 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:64:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[7d580:1] = INT_SLESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	3: [handle:space][[handle:offset+0]:1] = INT_MULT unique[7d580:1], const[ff:1]
	4: unique[7d680:1] = INT_SLESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	5: [handle:space][[handle:offset+10001]:1] = INT_MULT unique[7d680:1], const[ff:1]
	6: unique[7d780:1] = INT_SLESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	7: [handle:space][[handle:offset+20002]:1] = INT_MULT unique[7d780:1], const[ff:1]
	8: unique[7d880:1] = INT_SLESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	9: [handle:space][[handle:offset+30003]:1] = INT_MULT unique[7d880:1], const[ff:1]
	10: unique[7d980:1] = INT_SLESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	11: [handle:space][[handle:offset+40004]:1] = INT_MULT unique[7d980:1], const[ff:1]
	12: unique[7da80:1] = INT_SLESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	13: [handle:space][[handle:offset+50005]:1] = INT_MULT unique[7da80:1], const[ff:1]
	14: unique[7db80:1] = INT_SLESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	15: [handle:space][[handle:offset+60006]:1] = INT_MULT unique[7db80:1], const[ff:1]
	16: unique[7dc80:1] = INT_SLESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	17: [handle:space][[handle:offset+70007]:1] = INT_MULT unique[7dc80:1], const[ff:1]
	18: unique[7dd80:1] = INT_SLESS [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	19: [handle:space][[handle:offset+80008]:1] = INT_MULT unique[7dd80:1], const[ff:1]
	20: unique[7de80:1] = INT_SLESS [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	21: [handle:space][[handle:offset+90009]:1] = INT_MULT unique[7de80:1], const[ff:1]
	22: unique[7df80:1] = INT_SLESS [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	23: [handle:space][[handle:offset+a000a]:1] = INT_MULT unique[7df80:1], const[ff:1]
	24: unique[7e080:1] = INT_SLESS [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	25: [handle:space][[handle:offset+b000b]:1] = INT_MULT unique[7e080:1], const[ff:1]
	26: unique[7e180:1] = INT_SLESS [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	27: [handle:space][[handle:offset+c000c]:1] = INT_MULT unique[7e180:1], const[ff:1]
	28: unique[7e280:1] = INT_SLESS [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	29: [handle:space][[handle:offset+d000d]:1] = INT_MULT unique[7e280:1], const[ff:1]
	30: unique[7e380:1] = INT_SLESS [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	31: [handle:space][[handle:offset+e000e]:1] = INT_MULT unique[7e380:1], const[ff:1]
	32: unique[7e480:1] = INT_SLESS [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	33: [handle:space][[handle:offset+f000f]:1] = INT_MULT unique[7e480:1], const[ff:1]

Line ia.sinc:6720 :PCMPGTB       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x64; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = (XmmReg[0,8] s> m[0,8]) * 0xFF;
    XmmReg[8,8] = (XmmReg[8,8] s> m[8,8]) * 0xFF;
    XmmReg[16,8] = (XmmReg[16,8] s> m[16,8]) * 0xFF;
    XmmReg[24,8] = (XmmReg[24,8] s> m[24,8]) * 0xFF;
    XmmReg[32,8] = (XmmReg[32,8] s> m[32,8]) * 0xFF;
    XmmReg[40,8] = (XmmReg[40,8] s> m[40,8]) * 0xFF;
    XmmReg[48,8] = (XmmReg[48,8] s> m[48,8]) * 0xFF;
    XmmReg[56,8] = (XmmReg[56,8] s> m[56,8]) * 0xFF;
    XmmReg[64,8] = (XmmReg[64,8] s> m[64,8]) * 0xFF;
    XmmReg[72,8] = (XmmReg[72,8] s> m[72,8]) * 0xFF;
    XmmReg[80,8] = (XmmReg[80,8] s> m[80,8]) * 0xFF;
    XmmReg[88,8] = (XmmReg[88,8] s> m[88,8]) * 0xFF;
    XmmReg[96,8] = (XmmReg[96,8] s> m[96,8]) * 0xFF;
    XmmReg[104,8] = (XmmReg[104,8] s> m[104,8]) * 0xFF;
    XmmReg[112,8] = (XmmReg[112,8] s> m[112,8]) * 0xFF;
    XmmReg[120,8] = (XmmReg[120,8] s> m[120,8]) * 0xFF;
}
1: Constructor line ia.sinc:6720(id0.1102) printpiece=[PCMPGTB,  ,  B, ,,  ,  A]
Operands 0: m128 : 3298  1: XmmReg : 3297  
Pattern id=1102 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:64:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[7bd00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[7bd80:1] = SUBPIECE unique[7bd00:10], const[0:4]
	4: unique[7be00:1] = INT_SLESS unique[7bd80:1], [handle:space][[handle:offset+0]:1]
	5: [handle:space][[handle:offset+0]:1] = INT_MULT unique[7be00:1], const[ff:1]
	6: unique[7bf00:1] = SUBPIECE unique[7bd00:10], const[1:4]
	7: unique[7bf80:1] = INT_SLESS unique[7bf00:1], [handle:space][[handle:offset+10001]:1]
	8: [handle:space][[handle:offset+10001]:1] = INT_MULT unique[7bf80:1], const[ff:1]
	9: unique[7c080:1] = SUBPIECE unique[7bd00:10], const[2:4]
	10: unique[7c100:1] = INT_SLESS unique[7c080:1], [handle:space][[handle:offset+20002]:1]
	11: [handle:space][[handle:offset+20002]:1] = INT_MULT unique[7c100:1], const[ff:1]
	12: unique[7c200:1] = SUBPIECE unique[7bd00:10], const[3:4]
	13: unique[7c280:1] = INT_SLESS unique[7c200:1], [handle:space][[handle:offset+30003]:1]
	14: [handle:space][[handle:offset+30003]:1] = INT_MULT unique[7c280:1], const[ff:1]
	15: unique[7c380:1] = SUBPIECE unique[7bd00:10], const[4:4]
	16: unique[7c400:1] = INT_SLESS unique[7c380:1], [handle:space][[handle:offset+40004]:1]
	17: [handle:space][[handle:offset+40004]:1] = INT_MULT unique[7c400:1], const[ff:1]
	18: unique[7c500:1] = SUBPIECE unique[7bd00:10], const[5:4]
	19: unique[7c580:1] = INT_SLESS unique[7c500:1], [handle:space][[handle:offset+50005]:1]
	20: [handle:space][[handle:offset+50005]:1] = INT_MULT unique[7c580:1], const[ff:1]
	21: unique[7c680:1] = SUBPIECE unique[7bd00:10], const[6:4]
	22: unique[7c700:1] = INT_SLESS unique[7c680:1], [handle:space][[handle:offset+60006]:1]
	23: [handle:space][[handle:offset+60006]:1] = INT_MULT unique[7c700:1], const[ff:1]
	24: unique[7c800:1] = SUBPIECE unique[7bd00:10], const[7:4]
	25: unique[7c880:1] = INT_SLESS unique[7c800:1], [handle:space][[handle:offset+70007]:1]
	26: [handle:space][[handle:offset+70007]:1] = INT_MULT unique[7c880:1], const[ff:1]
	27: unique[7c980:1] = SUBPIECE unique[7bd00:10], const[8:4]
	28: unique[7ca00:1] = INT_SLESS unique[7c980:1], [handle:space][[handle:offset+80008]:1]
	29: [handle:space][[handle:offset+80008]:1] = INT_MULT unique[7ca00:1], const[ff:1]
	30: unique[7cb00:1] = SUBPIECE unique[7bd00:10], const[9:4]
	31: unique[7cb80:1] = INT_SLESS unique[7cb00:1], [handle:space][[handle:offset+90009]:1]
	32: [handle:space][[handle:offset+90009]:1] = INT_MULT unique[7cb80:1], const[ff:1]
	33: unique[7cc80:1] = SUBPIECE unique[7bd00:10], const[a:4]
	34: unique[7cd00:1] = INT_SLESS unique[7cc80:1], [handle:space][[handle:offset+a000a]:1]
	35: [handle:space][[handle:offset+a000a]:1] = INT_MULT unique[7cd00:1], const[ff:1]
	36: unique[7ce00:1] = SUBPIECE unique[7bd00:10], const[b:4]
	37: unique[7ce80:1] = INT_SLESS unique[7ce00:1], [handle:space][[handle:offset+b000b]:1]
	38: [handle:space][[handle:offset+b000b]:1] = INT_MULT unique[7ce80:1], const[ff:1]
	39: unique[7cf80:1] = SUBPIECE unique[7bd00:10], const[c:4]
	40: unique[7d000:1] = INT_SLESS unique[7cf80:1], [handle:space][[handle:offset+c000c]:1]
	41: [handle:space][[handle:offset+c000c]:1] = INT_MULT unique[7d000:1], const[ff:1]
	42: unique[7d100:1] = SUBPIECE unique[7bd00:10], const[d:4]
	43: unique[7d180:1] = INT_SLESS unique[7d100:1], [handle:space][[handle:offset+d000d]:1]
	44: [handle:space][[handle:offset+d000d]:1] = INT_MULT unique[7d180:1], const[ff:1]
	45: unique[7d280:1] = SUBPIECE unique[7bd00:10], const[e:4]
	46: unique[7d300:1] = INT_SLESS unique[7d280:1], [handle:space][[handle:offset+e000e]:1]
	47: [handle:space][[handle:offset+e000e]:1] = INT_MULT unique[7d300:1], const[ff:1]
	48: unique[7d400:1] = SUBPIECE unique[7bd00:10], const[f:4]
	49: unique[7d480:1] = INT_SLESS unique[7d400:1], [handle:space][[handle:offset+f000f]:1]
	50: [handle:space][[handle:offset+f000f]:1] = INT_MULT unique[7d480:1], const[ff:1]

Line ia.sinc:6699 :PCMPGTW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x65; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = zext(mmxreg1[0,16] s> mmxreg2[0,16]) * 0xFFFF;
    mmxreg1[16,16] = zext(mmxreg1[16,16] s> mmxreg2[16,16]) * 0xFFFF;
    mmxreg1[32,16] = zext(mmxreg1[32,16] s> mmxreg2[32,16]) * 0xFFFF;
    mmxreg1[48,16] = zext(mmxreg1[48,16] s> mmxreg2[48,16]) * 0xFFFF;
}
0: Constructor line ia.sinc:6699(id0.1099) printpiece=[PCMPGTW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3291  1: mmxreg2 : 3292  
Pattern id=1099 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:65:[11xx]X:XX)
Template
	0: unique[7af80:1] = INT_SLESS [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	1: unique[7b000:2] = INT_ZEXT unique[7af80:1]
	2: [handle:space][[handle:offset+0]:2] = INT_MULT unique[7b000:2], const[ffff:2]
	3: unique[7b100:1] = INT_SLESS [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	4: unique[7b180:2] = INT_ZEXT unique[7b100:1]
	5: [handle:space][[handle:offset+20002]:2] = INT_MULT unique[7b180:2], const[ffff:2]
	6: unique[7b280:1] = INT_SLESS [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	7: unique[7b300:2] = INT_ZEXT unique[7b280:1]
	8: [handle:space][[handle:offset+40004]:2] = INT_MULT unique[7b300:2], const[ffff:2]
	9: unique[7b400:1] = INT_SLESS [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	10: unique[7b480:2] = INT_ZEXT unique[7b400:1]
	11: [handle:space][[handle:offset+60006]:2] = INT_MULT unique[7b480:2], const[ffff:2]

Line ia.sinc:6690 :PCMPGTW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x65; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = zext(mmxreg[0,16] s> m[0,16]) * 0xFFFF;
    mmxreg[16,16] = zext(mmxreg[16,16] s> m[16,16]) * 0xFFFF;
    mmxreg[32,16] = zext(mmxreg[32,16] s> m[32,16]) * 0xFFFF;
    mmxreg[48,16] = zext(mmxreg[48,16] s> m[48,16]) * 0xFFFF;
}
1: Constructor line ia.sinc:6690(id0.1098) printpiece=[PCMPGTW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3289  1: m64 : 3290  
Pattern id=1098 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:65:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[7a700:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[7a780:2] = SUBPIECE unique[7a700:8], const[0:4]
	3: unique[7a800:1] = INT_SLESS unique[7a780:2], [handle:space][[handle:offset+0]:2]
	4: unique[7a880:2] = INT_ZEXT unique[7a800:1]
	5: [handle:space][[handle:offset+0]:2] = INT_MULT unique[7a880:2], const[ffff:2]
	6: unique[7a980:2] = SUBPIECE unique[7a700:8], const[2:4]
	7: unique[7aa00:1] = INT_SLESS unique[7a980:2], [handle:space][[handle:offset+20002]:2]
	8: unique[7aa80:2] = INT_ZEXT unique[7aa00:1]
	9: [handle:space][[handle:offset+20002]:2] = INT_MULT unique[7aa80:2], const[ffff:2]
	10: unique[7ab80:2] = SUBPIECE unique[7a700:8], const[4:4]
	11: unique[7ac00:1] = INT_SLESS unique[7ab80:2], [handle:space][[handle:offset+40004]:2]
	12: unique[7ac80:2] = INT_ZEXT unique[7ac00:1]
	13: [handle:space][[handle:offset+40004]:2] = INT_MULT unique[7ac80:2], const[ffff:2]
	14: unique[7ad80:2] = SUBPIECE unique[7a700:8], const[6:4]
	15: unique[7ae00:1] = INT_SLESS unique[7ad80:2], [handle:space][[handle:offset+60006]:2]
	16: unique[7ae80:2] = INT_ZEXT unique[7ae00:1]
	17: [handle:space][[handle:offset+60006]:2] = INT_MULT unique[7ae80:2], const[ffff:2]

Line ia.sinc:6775 :PCMPGTW       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x65; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = zext(XmmReg1[0,16] s> XmmReg2[0,16]) * 0xFFFF;
    XmmReg1[16,16] = zext(XmmReg1[16,16] s> XmmReg2[16,16]) * 0xFFFF;
    XmmReg1[32,16] = zext(XmmReg1[32,16] s> XmmReg2[32,16]) * 0xFFFF;
    XmmReg1[48,16] = zext(XmmReg1[48,16] s> XmmReg2[48,16]) * 0xFFFF;
    XmmReg1[64,16] = zext(XmmReg1[64,16] s> XmmReg2[64,16]) * 0xFFFF;
    XmmReg1[80,16] = zext(XmmReg1[80,16] s> XmmReg2[80,16]) * 0xFFFF;
    XmmReg1[96,16] = zext(XmmReg1[96,16] s> XmmReg2[96,16]) * 0xFFFF;
    XmmReg1[112,16] = zext(XmmReg1[112,16] s> XmmReg2[112,16]) * 0xFFFF;
}
0: Constructor line ia.sinc:6775(id0.1105) printpiece=[PCMPGTW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3303  1: XmmReg2 : 3304  
Pattern id=1105 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:65:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[7f600:1] = INT_SLESS [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: unique[7f680:2] = INT_ZEXT unique[7f600:1]
	4: [handle:space][[handle:offset+0]:2] = INT_MULT unique[7f680:2], const[ffff:2]
	5: unique[7f780:1] = INT_SLESS [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	6: unique[7f800:2] = INT_ZEXT unique[7f780:1]
	7: [handle:space][[handle:offset+20002]:2] = INT_MULT unique[7f800:2], const[ffff:2]
	8: unique[7f900:1] = INT_SLESS [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	9: unique[7f980:2] = INT_ZEXT unique[7f900:1]
	10: [handle:space][[handle:offset+40004]:2] = INT_MULT unique[7f980:2], const[ffff:2]
	11: unique[7fa80:1] = INT_SLESS [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	12: unique[7fb00:2] = INT_ZEXT unique[7fa80:1]
	13: [handle:space][[handle:offset+60006]:2] = INT_MULT unique[7fb00:2], const[ffff:2]
	14: unique[7fc00:1] = INT_SLESS [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	15: unique[7fc80:2] = INT_ZEXT unique[7fc00:1]
	16: [handle:space][[handle:offset+80008]:2] = INT_MULT unique[7fc80:2], const[ffff:2]
	17: unique[7fd80:1] = INT_SLESS [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	18: unique[7fe00:2] = INT_ZEXT unique[7fd80:1]
	19: [handle:space][[handle:offset+a000a]:2] = INT_MULT unique[7fe00:2], const[ffff:2]
	20: unique[7ff00:1] = INT_SLESS [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	21: unique[7ff80:2] = INT_ZEXT unique[7ff00:1]
	22: [handle:space][[handle:offset+c000c]:2] = INT_MULT unique[7ff80:2], const[ffff:2]
	23: unique[80080:1] = INT_SLESS [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	24: unique[80100:2] = INT_ZEXT unique[80080:1]
	25: [handle:space][[handle:offset+e000e]:2] = INT_MULT unique[80100:2], const[ffff:2]

Line ia.sinc:6762 :PCMPGTW       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x65; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = zext(XmmReg[0,16] s> m[0,16]) * 0xFFFF;
    XmmReg[16,16] = zext(XmmReg[16,16] s> m[16,16]) * 0xFFFF;
    XmmReg[32,16] = zext(XmmReg[32,16] s> m[32,16]) * 0xFFFF;
    XmmReg[48,16] = zext(XmmReg[48,16] s> m[48,16]) * 0xFFFF;
    XmmReg[64,16] = zext(XmmReg[64,16] s> m[64,16]) * 0xFFFF;
    XmmReg[80,16] = zext(XmmReg[80,16] s> m[80,16]) * 0xFFFF;
    XmmReg[96,16] = zext(XmmReg[96,16] s> m[96,16]) * 0xFFFF;
    XmmReg[112,16] = zext(XmmReg[112,16] s> m[112,16]) * 0xFFFF;
}
1: Constructor line ia.sinc:6762(id0.1104) printpiece=[PCMPGTW,  ,  B, ,,  ,  A]
Operands 0: m128 : 3302  1: XmmReg : 3301  
Pattern id=1104 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:65:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[7e580:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[7e600:2] = SUBPIECE unique[7e580:10], const[0:4]
	4: unique[7e680:1] = INT_SLESS unique[7e600:2], [handle:space][[handle:offset+0]:2]
	5: unique[7e700:2] = INT_ZEXT unique[7e680:1]
	6: [handle:space][[handle:offset+0]:2] = INT_MULT unique[7e700:2], const[ffff:2]
	7: unique[7e800:2] = SUBPIECE unique[7e580:10], const[2:4]
	8: unique[7e880:1] = INT_SLESS unique[7e800:2], [handle:space][[handle:offset+20002]:2]
	9: unique[7e900:2] = INT_ZEXT unique[7e880:1]
	10: [handle:space][[handle:offset+20002]:2] = INT_MULT unique[7e900:2], const[ffff:2]
	11: unique[7ea00:2] = SUBPIECE unique[7e580:10], const[4:4]
	12: unique[7ea80:1] = INT_SLESS unique[7ea00:2], [handle:space][[handle:offset+40004]:2]
	13: unique[7eb00:2] = INT_ZEXT unique[7ea80:1]
	14: [handle:space][[handle:offset+40004]:2] = INT_MULT unique[7eb00:2], const[ffff:2]
	15: unique[7ec00:2] = SUBPIECE unique[7e580:10], const[6:4]
	16: unique[7ec80:1] = INT_SLESS unique[7ec00:2], [handle:space][[handle:offset+60006]:2]
	17: unique[7ed00:2] = INT_ZEXT unique[7ec80:1]
	18: [handle:space][[handle:offset+60006]:2] = INT_MULT unique[7ed00:2], const[ffff:2]
	19: unique[7ee00:2] = SUBPIECE unique[7e580:10], const[8:4]
	20: unique[7ee80:1] = INT_SLESS unique[7ee00:2], [handle:space][[handle:offset+80008]:2]
	21: unique[7ef00:2] = INT_ZEXT unique[7ee80:1]
	22: [handle:space][[handle:offset+80008]:2] = INT_MULT unique[7ef00:2], const[ffff:2]
	23: unique[7f000:2] = SUBPIECE unique[7e580:10], const[a:4]
	24: unique[7f080:1] = INT_SLESS unique[7f000:2], [handle:space][[handle:offset+a000a]:2]
	25: unique[7f100:2] = INT_ZEXT unique[7f080:1]
	26: [handle:space][[handle:offset+a000a]:2] = INT_MULT unique[7f100:2], const[ffff:2]
	27: unique[7f200:2] = SUBPIECE unique[7e580:10], const[c:4]
	28: unique[7f280:1] = INT_SLESS unique[7f200:2], [handle:space][[handle:offset+c000c]:2]
	29: unique[7f300:2] = INT_ZEXT unique[7f280:1]
	30: [handle:space][[handle:offset+c000c]:2] = INT_MULT unique[7f300:2], const[ffff:2]
	31: unique[7f400:2] = SUBPIECE unique[7e580:10], const[e:4]
	32: unique[7f480:1] = INT_SLESS unique[7f400:2], [handle:space][[handle:offset+e000e]:2]
	33: unique[7f500:2] = INT_ZEXT unique[7f480:1]
	34: [handle:space][[handle:offset+e000e]:2] = INT_MULT unique[7f500:2], const[ffff:2]

Line ia.sinc:6714 :PCMPGTD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x66; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32] = zext(mmxreg1[0,32] s> mmxreg2[0,32]) * 0xFFFFFFFF;
    mmxreg1[32,32] = zext(mmxreg1[32,32] s> mmxreg2[32,32]) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:6714(id0.1101) printpiece=[PCMPGTD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3295  1: mmxreg2 : 3296  
Pattern id=1101 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:66:[11xx]X:XX)
Template
	0: unique[7ba00:1] = INT_SLESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	1: unique[7ba80:4] = INT_ZEXT unique[7ba00:1]
	2: [handle:space][[handle:offset+0]:4] = INT_MULT unique[7ba80:4], const[ffffffff:4]
	3: unique[7bb80:1] = INT_SLESS [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: unique[7bc00:4] = INT_ZEXT unique[7bb80:1]
	5: [handle:space][[handle:offset+40004]:4] = INT_MULT unique[7bc00:4], const[ffffffff:4]

Line ia.sinc:6707 :PCMPGTD       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x66; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,32] = zext(mmxreg[0,32] s> m[0,32]) * 0xFFFFFFFF;
    mmxreg[32,32] = zext(mmxreg[32,32] s> m[32,32]) * 0xFFFFFFFF;
}
1: Constructor line ia.sinc:6707(id0.1100) printpiece=[PCMPGTD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3293  1: m64 : 3294  
Pattern id=1100 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:66:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[7b580:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[7b600:4] = SUBPIECE unique[7b580:8], const[0:4]
	3: unique[7b680:1] = INT_SLESS unique[7b600:4], [handle:space][[handle:offset+0]:4]
	4: unique[7b700:4] = INT_ZEXT unique[7b680:1]
	5: [handle:space][[handle:offset+0]:4] = INT_MULT unique[7b700:4], const[ffffffff:4]
	6: unique[7b800:4] = SUBPIECE unique[7b580:8], const[4:4]
	7: unique[7b880:1] = INT_SLESS unique[7b800:4], [handle:space][[handle:offset+40004]:4]
	8: unique[7b900:4] = INT_ZEXT unique[7b880:1]
	9: [handle:space][[handle:offset+40004]:4] = INT_MULT unique[7b900:4], const[ffffffff:4]

Line ia.sinc:6796 :PCMPGTD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x66; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = zext(XmmReg1[0,32] s> XmmReg2[0,32]) * 0xFFFFFFFF;
    XmmReg1[32,32] = zext(XmmReg1[32,32] s> XmmReg2[32,32]) * 0xFFFFFFFF;
    XmmReg1[64,32] = zext(XmmReg1[64,32] s> XmmReg2[64,32]) * 0xFFFFFFFF;
    XmmReg1[96,32] = zext(XmmReg1[96,32] s> XmmReg2[96,32]) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:6796(id0.1107) printpiece=[PCMPGTD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3307  1: XmmReg2 : 3308  
Pattern id=1107 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:66:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[80a80:1] = INT_SLESS [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: unique[80b00:4] = INT_ZEXT unique[80a80:1]
	4: [handle:space][[handle:offset+0]:4] = INT_MULT unique[80b00:4], const[ffffffff:4]
	5: unique[80c00:1] = INT_SLESS [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	6: unique[80c80:4] = INT_ZEXT unique[80c00:1]
	7: [handle:space][[handle:offset+40004]:4] = INT_MULT unique[80c80:4], const[ffffffff:4]
	8: unique[80d80:1] = INT_SLESS [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	9: unique[80e00:4] = INT_ZEXT unique[80d80:1]
	10: [handle:space][[handle:offset+80008]:4] = INT_MULT unique[80e00:4], const[ffffffff:4]
	11: unique[80f00:1] = INT_SLESS [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	12: unique[80f80:4] = INT_ZEXT unique[80f00:1]
	13: [handle:space][[handle:offset+c000c]:4] = INT_MULT unique[80f80:4], const[ffffffff:4]

Line ia.sinc:6787 :PCMPGTD       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x66; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = zext(XmmReg[0,32] s> m[0,32]) * 0xFFFFFFFF;
    XmmReg[32,32] = zext(XmmReg[32,32] s> m[32,32]) * 0xFFFFFFFF;
    XmmReg[64,32] = zext(XmmReg[64,32] s> m[64,32]) * 0xFFFFFFFF;
    XmmReg[96,32] = zext(XmmReg[96,32] s> m[96,32]) * 0xFFFFFFFF;
}
1: Constructor line ia.sinc:6787(id0.1106) printpiece=[PCMPGTD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3306  1: XmmReg : 3305  
Pattern id=1106 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:66:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[80200:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[80280:4] = SUBPIECE unique[80200:10], const[0:4]
	4: unique[80300:1] = INT_SLESS unique[80280:4], [handle:space][[handle:offset+0]:4]
	5: unique[80380:4] = INT_ZEXT unique[80300:1]
	6: [handle:space][[handle:offset+0]:4] = INT_MULT unique[80380:4], const[ffffffff:4]
	7: unique[80480:4] = SUBPIECE unique[80200:10], const[4:4]
	8: unique[80500:1] = INT_SLESS unique[80480:4], [handle:space][[handle:offset+40004]:4]
	9: unique[80580:4] = INT_ZEXT unique[80500:1]
	10: [handle:space][[handle:offset+40004]:4] = INT_MULT unique[80580:4], const[ffffffff:4]
	11: unique[80680:4] = SUBPIECE unique[80200:10], const[8:4]
	12: unique[80700:1] = INT_SLESS unique[80680:4], [handle:space][[handle:offset+80008]:4]
	13: unique[80780:4] = INT_ZEXT unique[80700:1]
	14: [handle:space][[handle:offset+80008]:4] = INT_MULT unique[80780:4], const[ffffffff:4]
	15: unique[80880:4] = SUBPIECE unique[80200:10], const[c:4]
	16: unique[80900:1] = INT_SLESS unique[80880:4], [handle:space][[handle:offset+c000c]:4]
	17: unique[80980:4] = INT_ZEXT unique[80900:1]
	18: [handle:space][[handle:offset+c000c]:4] = INT_MULT unique[80980:4], const[ffffffff:4]

Line ia.sinc:6051 :PACKUSWB      mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x67; mmxmod = 3 & mmxreg1 & mmxreg2
{
    local dest_copy:8 = mmxreg1;
    local src_copy:8 = mmxreg2;
    local ubyte:1 = 0;
    sswub(dest_copy[0,16],ubyte);
    mmxreg1[0,8] = ubyte;
    sswub(dest_copy[16,16],ubyte);
    mmxreg1[8,8] = ubyte;
    sswub(dest_copy[32,16],ubyte);
    mmxreg1[16,8] = ubyte;
    sswub(dest_copy[48,16],ubyte);
    mmxreg1[24,8] = ubyte;
    sswub(src_copy[0,16],ubyte);
    mmxreg1[32,8] = ubyte;
    sswub(src_copy[16,16],ubyte);
    mmxreg1[40,8] = ubyte;
    sswub(src_copy[32,16],ubyte);
    mmxreg1[48,8] = ubyte;
    sswub(src_copy[48,16],ubyte);
    mmxreg1[56,8] = ubyte;
}
0: Constructor line ia.sinc:6051(id0.1017) printpiece=[PACKUSWB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3114  1: mmxreg2 : 3115  
Pattern id=1017 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:67:[11xx]X:XX)
Template
	0: unique[64580:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	1: unique[64600:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[64680:1] = COPY const[0:1]
	3: unique[64700:2] = SUBPIECE unique[64580:8], const[0:4]
	4: unique[63880:1] = INT_SLESS const[ff:2], unique[64700:2]
	5: unique[64680:1] = INT_MULT unique[63880:1], const[ff:1]
	6: unique[63980:1] = INT_SLESS const[0:2], unique[64700:2]
	7: unique[63a00:1] = INT_SLESS unique[64700:2], const[ff:2]
	8: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	9: unique[64b00:1] = SUBPIECE unique[64700:2], const[0:4]
	10: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64b00:1]
	11: unique[64680:1] = INT_ADD unique[64680:1], unique[63b00:1]
	12: [handle:space][[handle:offset+0]:1] = COPY unique[64680:1]
	13: unique[64780:2] = SUBPIECE unique[64580:8], const[2:4]
	14: unique[63880:1] = INT_SLESS const[ff:2], unique[64780:2]
	15: unique[64680:1] = INT_MULT unique[63880:1], const[ff:1]
	16: unique[63980:1] = INT_SLESS const[0:2], unique[64780:2]
	17: unique[63a00:1] = INT_SLESS unique[64780:2], const[ff:2]
	18: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	19: unique[64b80:1] = SUBPIECE unique[64780:2], const[0:4]
	20: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64b80:1]
	21: unique[64680:1] = INT_ADD unique[64680:1], unique[63b00:1]
	22: [handle:space][[handle:offset+10001]:1] = COPY unique[64680:1]
	23: unique[64800:2] = SUBPIECE unique[64580:8], const[4:4]
	24: unique[63880:1] = INT_SLESS const[ff:2], unique[64800:2]
	25: unique[64680:1] = INT_MULT unique[63880:1], const[ff:1]
	26: unique[63980:1] = INT_SLESS const[0:2], unique[64800:2]
	27: unique[63a00:1] = INT_SLESS unique[64800:2], const[ff:2]
	28: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	29: unique[64c00:1] = SUBPIECE unique[64800:2], const[0:4]
	30: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64c00:1]
	31: unique[64680:1] = INT_ADD unique[64680:1], unique[63b00:1]
	32: [handle:space][[handle:offset+20002]:1] = COPY unique[64680:1]
	33: unique[64880:2] = SUBPIECE unique[64580:8], const[6:4]
	34: unique[63880:1] = INT_SLESS const[ff:2], unique[64880:2]
	35: unique[64680:1] = INT_MULT unique[63880:1], const[ff:1]
	36: unique[63980:1] = INT_SLESS const[0:2], unique[64880:2]
	37: unique[63a00:1] = INT_SLESS unique[64880:2], const[ff:2]
	38: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	39: unique[64c80:1] = SUBPIECE unique[64880:2], const[0:4]
	40: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64c80:1]
	41: unique[64680:1] = INT_ADD unique[64680:1], unique[63b00:1]
	42: [handle:space][[handle:offset+30003]:1] = COPY unique[64680:1]
	43: unique[64900:2] = SUBPIECE unique[64600:8], const[0:4]
	44: unique[63880:1] = INT_SLESS const[ff:2], unique[64900:2]
	45: unique[64680:1] = INT_MULT unique[63880:1], const[ff:1]
	46: unique[63980:1] = INT_SLESS const[0:2], unique[64900:2]
	47: unique[63a00:1] = INT_SLESS unique[64900:2], const[ff:2]
	48: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	49: unique[64d00:1] = SUBPIECE unique[64900:2], const[0:4]
	50: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64d00:1]
	51: unique[64680:1] = INT_ADD unique[64680:1], unique[63b00:1]
	52: [handle:space][[handle:offset+40004]:1] = COPY unique[64680:1]
	53: unique[64980:2] = SUBPIECE unique[64600:8], const[2:4]
	54: unique[63880:1] = INT_SLESS const[ff:2], unique[64980:2]
	55: unique[64680:1] = INT_MULT unique[63880:1], const[ff:1]
	56: unique[63980:1] = INT_SLESS const[0:2], unique[64980:2]
	57: unique[63a00:1] = INT_SLESS unique[64980:2], const[ff:2]
	58: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	59: unique[64d80:1] = SUBPIECE unique[64980:2], const[0:4]
	60: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64d80:1]
	61: unique[64680:1] = INT_ADD unique[64680:1], unique[63b00:1]
	62: [handle:space][[handle:offset+50005]:1] = COPY unique[64680:1]
	63: unique[64a00:2] = SUBPIECE unique[64600:8], const[4:4]
	64: unique[63880:1] = INT_SLESS const[ff:2], unique[64a00:2]
	65: unique[64680:1] = INT_MULT unique[63880:1], const[ff:1]
	66: unique[63980:1] = INT_SLESS const[0:2], unique[64a00:2]
	67: unique[63a00:1] = INT_SLESS unique[64a00:2], const[ff:2]
	68: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	69: unique[64e00:1] = SUBPIECE unique[64a00:2], const[0:4]
	70: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64e00:1]
	71: unique[64680:1] = INT_ADD unique[64680:1], unique[63b00:1]
	72: [handle:space][[handle:offset+60006]:1] = COPY unique[64680:1]
	73: unique[64a80:2] = SUBPIECE unique[64600:8], const[6:4]
	74: unique[63880:1] = INT_SLESS const[ff:2], unique[64a80:2]
	75: unique[64680:1] = INT_MULT unique[63880:1], const[ff:1]
	76: unique[63980:1] = INT_SLESS const[0:2], unique[64a80:2]
	77: unique[63a00:1] = INT_SLESS unique[64a80:2], const[ff:2]
	78: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	79: unique[64e80:1] = SUBPIECE unique[64a80:2], const[0:4]
	80: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64e80:1]
	81: unique[64680:1] = INT_ADD unique[64680:1], unique[63b00:1]
	82: [handle:space][[handle:offset+70007]:1] = COPY unique[64680:1]

Line ia.sinc:6028 :PACKUSWB      mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x67; mmxreg ... & m64
{
    local dest_copy:8 = mmxreg;
    local src_copy:8 = m64;
    local ubyte:1 = 0;
    sswub(dest_copy[0,16],ubyte);
    mmxreg[0,8] = ubyte;
    sswub(dest_copy[16,16],ubyte);
    mmxreg[8,8] = ubyte;
    sswub(dest_copy[32,16],ubyte);
    mmxreg[16,8] = ubyte;
    sswub(dest_copy[48,16],ubyte);
    mmxreg[24,8] = ubyte;
    sswub(src_copy[0,16],ubyte);
    mmxreg[32,8] = ubyte;
    sswub(src_copy[16,16],ubyte);
    mmxreg[40,8] = ubyte;
    sswub(src_copy[32,16],ubyte);
    mmxreg[48,8] = ubyte;
    sswub(src_copy[48,16],ubyte);
    mmxreg[56,8] = ubyte;
}
1: Constructor line ia.sinc:6028(id0.1016) printpiece=[PACKUSWB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3112  1: m64 : 3113  
Pattern id=1016 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:67:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[63c00:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[63c80:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[63d00:1] = COPY const[0:1]
	4: unique[63d80:2] = SUBPIECE unique[63c00:8], const[0:4]
	5: unique[63880:1] = INT_SLESS const[ff:2], unique[63d80:2]
	6: unique[63d00:1] = INT_MULT unique[63880:1], const[ff:1]
	7: unique[63980:1] = INT_SLESS const[0:2], unique[63d80:2]
	8: unique[63a00:1] = INT_SLESS unique[63d80:2], const[ff:2]
	9: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	10: unique[64180:1] = SUBPIECE unique[63d80:2], const[0:4]
	11: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64180:1]
	12: unique[63d00:1] = INT_ADD unique[63d00:1], unique[63b00:1]
	13: [handle:space][[handle:offset+0]:1] = COPY unique[63d00:1]
	14: unique[63e00:2] = SUBPIECE unique[63c00:8], const[2:4]
	15: unique[63880:1] = INT_SLESS const[ff:2], unique[63e00:2]
	16: unique[63d00:1] = INT_MULT unique[63880:1], const[ff:1]
	17: unique[63980:1] = INT_SLESS const[0:2], unique[63e00:2]
	18: unique[63a00:1] = INT_SLESS unique[63e00:2], const[ff:2]
	19: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	20: unique[64200:1] = SUBPIECE unique[63e00:2], const[0:4]
	21: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64200:1]
	22: unique[63d00:1] = INT_ADD unique[63d00:1], unique[63b00:1]
	23: [handle:space][[handle:offset+10001]:1] = COPY unique[63d00:1]
	24: unique[63e80:2] = SUBPIECE unique[63c00:8], const[4:4]
	25: unique[63880:1] = INT_SLESS const[ff:2], unique[63e80:2]
	26: unique[63d00:1] = INT_MULT unique[63880:1], const[ff:1]
	27: unique[63980:1] = INT_SLESS const[0:2], unique[63e80:2]
	28: unique[63a00:1] = INT_SLESS unique[63e80:2], const[ff:2]
	29: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	30: unique[64280:1] = SUBPIECE unique[63e80:2], const[0:4]
	31: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64280:1]
	32: unique[63d00:1] = INT_ADD unique[63d00:1], unique[63b00:1]
	33: [handle:space][[handle:offset+20002]:1] = COPY unique[63d00:1]
	34: unique[63f00:2] = SUBPIECE unique[63c00:8], const[6:4]
	35: unique[63880:1] = INT_SLESS const[ff:2], unique[63f00:2]
	36: unique[63d00:1] = INT_MULT unique[63880:1], const[ff:1]
	37: unique[63980:1] = INT_SLESS const[0:2], unique[63f00:2]
	38: unique[63a00:1] = INT_SLESS unique[63f00:2], const[ff:2]
	39: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	40: unique[64300:1] = SUBPIECE unique[63f00:2], const[0:4]
	41: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64300:1]
	42: unique[63d00:1] = INT_ADD unique[63d00:1], unique[63b00:1]
	43: [handle:space][[handle:offset+30003]:1] = COPY unique[63d00:1]
	44: unique[63f80:2] = SUBPIECE unique[63c80:8], const[0:4]
	45: unique[63880:1] = INT_SLESS const[ff:2], unique[63f80:2]
	46: unique[63d00:1] = INT_MULT unique[63880:1], const[ff:1]
	47: unique[63980:1] = INT_SLESS const[0:2], unique[63f80:2]
	48: unique[63a00:1] = INT_SLESS unique[63f80:2], const[ff:2]
	49: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	50: unique[64380:1] = SUBPIECE unique[63f80:2], const[0:4]
	51: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64380:1]
	52: unique[63d00:1] = INT_ADD unique[63d00:1], unique[63b00:1]
	53: [handle:space][[handle:offset+40004]:1] = COPY unique[63d00:1]
	54: unique[64000:2] = SUBPIECE unique[63c80:8], const[2:4]
	55: unique[63880:1] = INT_SLESS const[ff:2], unique[64000:2]
	56: unique[63d00:1] = INT_MULT unique[63880:1], const[ff:1]
	57: unique[63980:1] = INT_SLESS const[0:2], unique[64000:2]
	58: unique[63a00:1] = INT_SLESS unique[64000:2], const[ff:2]
	59: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	60: unique[64400:1] = SUBPIECE unique[64000:2], const[0:4]
	61: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64400:1]
	62: unique[63d00:1] = INT_ADD unique[63d00:1], unique[63b00:1]
	63: [handle:space][[handle:offset+50005]:1] = COPY unique[63d00:1]
	64: unique[64080:2] = SUBPIECE unique[63c80:8], const[4:4]
	65: unique[63880:1] = INT_SLESS const[ff:2], unique[64080:2]
	66: unique[63d00:1] = INT_MULT unique[63880:1], const[ff:1]
	67: unique[63980:1] = INT_SLESS const[0:2], unique[64080:2]
	68: unique[63a00:1] = INT_SLESS unique[64080:2], const[ff:2]
	69: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	70: unique[64480:1] = SUBPIECE unique[64080:2], const[0:4]
	71: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64480:1]
	72: unique[63d00:1] = INT_ADD unique[63d00:1], unique[63b00:1]
	73: [handle:space][[handle:offset+60006]:1] = COPY unique[63d00:1]
	74: unique[64100:2] = SUBPIECE unique[63c80:8], const[6:4]
	75: unique[63880:1] = INT_SLESS const[ff:2], unique[64100:2]
	76: unique[63d00:1] = INT_MULT unique[63880:1], const[ff:1]
	77: unique[63980:1] = INT_SLESS const[0:2], unique[64100:2]
	78: unique[63a00:1] = INT_SLESS unique[64100:2], const[ff:2]
	79: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	80: unique[64500:1] = SUBPIECE unique[64100:2], const[0:4]
	81: unique[63b00:1] = INT_MULT unique[63a80:1], unique[64500:1]
	82: unique[63d00:1] = INT_ADD unique[63d00:1], unique[63b00:1]
	83: [handle:space][[handle:offset+70007]:1] = COPY unique[63d00:1]

Line ia.sinc:6114 :PACKUSWB      XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x67; xmmmod = 3 & XmmReg1 & XmmReg2
{
    local dest_copy:16 = XmmReg1;
    local src_copy:16 = XmmReg2;
    local ubyte:1 = 0;
    sswub(dest_copy[0,16],ubyte);
    XmmReg1[0,8] = ubyte;
    sswub(dest_copy[16,16],ubyte);
    XmmReg1[8,8] = ubyte;
    sswub(dest_copy[32,16],ubyte);
    XmmReg1[16,8] = ubyte;
    sswub(dest_copy[48,16],ubyte);
    XmmReg1[24,8] = ubyte;
    sswub(dest_copy[64,16],ubyte);
    XmmReg1[32,8] = ubyte;
    sswub(dest_copy[80,16],ubyte);
    XmmReg1[40,8] = ubyte;
    sswub(dest_copy[96,16],ubyte);
    XmmReg1[48,8] = ubyte;
    sswub(dest_copy[112,16],ubyte);
    XmmReg1[56,8] = ubyte;

    sswub(src_copy[0,16],ubyte);
    XmmReg1[64,8] = ubyte;
    sswub(src_copy[16,16],ubyte);
    XmmReg1[72,8] = ubyte;
    sswub(src_copy[32,16],ubyte);
    XmmReg1[80,8] = ubyte;
    sswub(src_copy[48,16],ubyte);
    XmmReg1[88,8] = ubyte;
    sswub(src_copy[64,16],ubyte);
    XmmReg1[96,8] = ubyte;
    sswub(src_copy[80,16],ubyte);
    XmmReg1[104,8] = ubyte;
    sswub(src_copy[96,16],ubyte);
    XmmReg1[112,8] = ubyte;
    sswub(src_copy[112,16],ubyte);
    XmmReg1[120,8] = ubyte;
}
0: Constructor line ia.sinc:6114(id0.1019) printpiece=[PACKUSWB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3118  1: XmmReg2 : 3119  
Pattern id=1019 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:67:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[66080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[66100:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[66180:1] = COPY const[0:1]
	5: unique[66200:2] = SUBPIECE unique[66080:10], const[0:4]
	6: unique[63880:1] = INT_SLESS const[ff:2], unique[66200:2]
	7: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	8: unique[63980:1] = INT_SLESS const[0:2], unique[66200:2]
	9: unique[63a00:1] = INT_SLESS unique[66200:2], const[ff:2]
	10: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	11: unique[66a00:1] = SUBPIECE unique[66200:2], const[0:4]
	12: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66a00:1]
	13: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	14: [handle:space][[handle:offset+0]:1] = COPY unique[66180:1]
	15: unique[66280:2] = SUBPIECE unique[66080:10], const[2:4]
	16: unique[63880:1] = INT_SLESS const[ff:2], unique[66280:2]
	17: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	18: unique[63980:1] = INT_SLESS const[0:2], unique[66280:2]
	19: unique[63a00:1] = INT_SLESS unique[66280:2], const[ff:2]
	20: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	21: unique[66a80:1] = SUBPIECE unique[66280:2], const[0:4]
	22: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66a80:1]
	23: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	24: [handle:space][[handle:offset+10001]:1] = COPY unique[66180:1]
	25: unique[66300:2] = SUBPIECE unique[66080:10], const[4:4]
	26: unique[63880:1] = INT_SLESS const[ff:2], unique[66300:2]
	27: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	28: unique[63980:1] = INT_SLESS const[0:2], unique[66300:2]
	29: unique[63a00:1] = INT_SLESS unique[66300:2], const[ff:2]
	30: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	31: unique[66b00:1] = SUBPIECE unique[66300:2], const[0:4]
	32: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66b00:1]
	33: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	34: [handle:space][[handle:offset+20002]:1] = COPY unique[66180:1]
	35: unique[66380:2] = SUBPIECE unique[66080:10], const[6:4]
	36: unique[63880:1] = INT_SLESS const[ff:2], unique[66380:2]
	37: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	38: unique[63980:1] = INT_SLESS const[0:2], unique[66380:2]
	39: unique[63a00:1] = INT_SLESS unique[66380:2], const[ff:2]
	40: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	41: unique[66b80:1] = SUBPIECE unique[66380:2], const[0:4]
	42: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66b80:1]
	43: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	44: [handle:space][[handle:offset+30003]:1] = COPY unique[66180:1]
	45: unique[66400:2] = SUBPIECE unique[66080:10], const[8:4]
	46: unique[63880:1] = INT_SLESS const[ff:2], unique[66400:2]
	47: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	48: unique[63980:1] = INT_SLESS const[0:2], unique[66400:2]
	49: unique[63a00:1] = INT_SLESS unique[66400:2], const[ff:2]
	50: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	51: unique[66c00:1] = SUBPIECE unique[66400:2], const[0:4]
	52: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66c00:1]
	53: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	54: [handle:space][[handle:offset+40004]:1] = COPY unique[66180:1]
	55: unique[66480:2] = SUBPIECE unique[66080:10], const[a:4]
	56: unique[63880:1] = INT_SLESS const[ff:2], unique[66480:2]
	57: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	58: unique[63980:1] = INT_SLESS const[0:2], unique[66480:2]
	59: unique[63a00:1] = INT_SLESS unique[66480:2], const[ff:2]
	60: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	61: unique[66c80:1] = SUBPIECE unique[66480:2], const[0:4]
	62: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66c80:1]
	63: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	64: [handle:space][[handle:offset+50005]:1] = COPY unique[66180:1]
	65: unique[66500:2] = SUBPIECE unique[66080:10], const[c:4]
	66: unique[63880:1] = INT_SLESS const[ff:2], unique[66500:2]
	67: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	68: unique[63980:1] = INT_SLESS const[0:2], unique[66500:2]
	69: unique[63a00:1] = INT_SLESS unique[66500:2], const[ff:2]
	70: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	71: unique[66d00:1] = SUBPIECE unique[66500:2], const[0:4]
	72: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66d00:1]
	73: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	74: [handle:space][[handle:offset+60006]:1] = COPY unique[66180:1]
	75: unique[66580:2] = SUBPIECE unique[66080:10], const[e:4]
	76: unique[63880:1] = INT_SLESS const[ff:2], unique[66580:2]
	77: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	78: unique[63980:1] = INT_SLESS const[0:2], unique[66580:2]
	79: unique[63a00:1] = INT_SLESS unique[66580:2], const[ff:2]
	80: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	81: unique[66d80:1] = SUBPIECE unique[66580:2], const[0:4]
	82: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66d80:1]
	83: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	84: [handle:space][[handle:offset+70007]:1] = COPY unique[66180:1]
	85: unique[66600:2] = SUBPIECE unique[66100:10], const[0:4]
	86: unique[63880:1] = INT_SLESS const[ff:2], unique[66600:2]
	87: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	88: unique[63980:1] = INT_SLESS const[0:2], unique[66600:2]
	89: unique[63a00:1] = INT_SLESS unique[66600:2], const[ff:2]
	90: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	91: unique[66e00:1] = SUBPIECE unique[66600:2], const[0:4]
	92: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66e00:1]
	93: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	94: [handle:space][[handle:offset+80008]:1] = COPY unique[66180:1]
	95: unique[66680:2] = SUBPIECE unique[66100:10], const[2:4]
	96: unique[63880:1] = INT_SLESS const[ff:2], unique[66680:2]
	97: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	98: unique[63980:1] = INT_SLESS const[0:2], unique[66680:2]
	99: unique[63a00:1] = INT_SLESS unique[66680:2], const[ff:2]
	100: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	101: unique[66e80:1] = SUBPIECE unique[66680:2], const[0:4]
	102: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66e80:1]
	103: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	104: [handle:space][[handle:offset+90009]:1] = COPY unique[66180:1]
	105: unique[66700:2] = SUBPIECE unique[66100:10], const[4:4]
	106: unique[63880:1] = INT_SLESS const[ff:2], unique[66700:2]
	107: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	108: unique[63980:1] = INT_SLESS const[0:2], unique[66700:2]
	109: unique[63a00:1] = INT_SLESS unique[66700:2], const[ff:2]
	110: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	111: unique[66f00:1] = SUBPIECE unique[66700:2], const[0:4]
	112: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66f00:1]
	113: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	114: [handle:space][[handle:offset+a000a]:1] = COPY unique[66180:1]
	115: unique[66780:2] = SUBPIECE unique[66100:10], const[6:4]
	116: unique[63880:1] = INT_SLESS const[ff:2], unique[66780:2]
	117: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	118: unique[63980:1] = INT_SLESS const[0:2], unique[66780:2]
	119: unique[63a00:1] = INT_SLESS unique[66780:2], const[ff:2]
	120: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	121: unique[66f80:1] = SUBPIECE unique[66780:2], const[0:4]
	122: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66f80:1]
	123: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	124: [handle:space][[handle:offset+b000b]:1] = COPY unique[66180:1]
	125: unique[66800:2] = SUBPIECE unique[66100:10], const[8:4]
	126: unique[63880:1] = INT_SLESS const[ff:2], unique[66800:2]
	127: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	128: unique[63980:1] = INT_SLESS const[0:2], unique[66800:2]
	129: unique[63a00:1] = INT_SLESS unique[66800:2], const[ff:2]
	130: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	131: unique[67000:1] = SUBPIECE unique[66800:2], const[0:4]
	132: unique[63b00:1] = INT_MULT unique[63a80:1], unique[67000:1]
	133: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	134: [handle:space][[handle:offset+c000c]:1] = COPY unique[66180:1]
	135: unique[66880:2] = SUBPIECE unique[66100:10], const[a:4]
	136: unique[63880:1] = INT_SLESS const[ff:2], unique[66880:2]
	137: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	138: unique[63980:1] = INT_SLESS const[0:2], unique[66880:2]
	139: unique[63a00:1] = INT_SLESS unique[66880:2], const[ff:2]
	140: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	141: unique[67080:1] = SUBPIECE unique[66880:2], const[0:4]
	142: unique[63b00:1] = INT_MULT unique[63a80:1], unique[67080:1]
	143: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	144: [handle:space][[handle:offset+d000d]:1] = COPY unique[66180:1]
	145: unique[66900:2] = SUBPIECE unique[66100:10], const[c:4]
	146: unique[63880:1] = INT_SLESS const[ff:2], unique[66900:2]
	147: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	148: unique[63980:1] = INT_SLESS const[0:2], unique[66900:2]
	149: unique[63a00:1] = INT_SLESS unique[66900:2], const[ff:2]
	150: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	151: unique[67100:1] = SUBPIECE unique[66900:2], const[0:4]
	152: unique[63b00:1] = INT_MULT unique[63a80:1], unique[67100:1]
	153: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	154: [handle:space][[handle:offset+e000e]:1] = COPY unique[66180:1]
	155: unique[66980:2] = SUBPIECE unique[66100:10], const[e:4]
	156: unique[63880:1] = INT_SLESS const[ff:2], unique[66980:2]
	157: unique[66180:1] = INT_MULT unique[63880:1], const[ff:1]
	158: unique[63980:1] = INT_SLESS const[0:2], unique[66980:2]
	159: unique[63a00:1] = INT_SLESS unique[66980:2], const[ff:2]
	160: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	161: unique[67180:1] = SUBPIECE unique[66980:2], const[0:4]
	162: unique[63b00:1] = INT_MULT unique[63a80:1], unique[67180:1]
	163: unique[66180:1] = INT_ADD unique[66180:1], unique[63b00:1]
	164: [handle:space][[handle:offset+f000f]:1] = COPY unique[66180:1]

Line ia.sinc:6074 :PACKUSWB      XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x67; XmmReg ... & m128
{
    local dest_copy:16 = XmmReg;
    local src_copy:16 = m128;
    local ubyte:1 = 0;
    sswub(dest_copy[0,16],ubyte);
    XmmReg[0,8] = ubyte;
    sswub(dest_copy[16,16],ubyte);
    XmmReg[8,8] = ubyte;
    sswub(dest_copy[32,16],ubyte);
    XmmReg[16,8] = ubyte;
    sswub(dest_copy[48,16],ubyte);
    XmmReg[24,8] = ubyte;
    sswub(dest_copy[64,16],ubyte);
    XmmReg[32,8] = ubyte;
    sswub(dest_copy[80,16],ubyte);
    XmmReg[40,8] = ubyte;
    sswub(dest_copy[96,16],ubyte);
    XmmReg[48,8] = ubyte;
    sswub(dest_copy[112,16],ubyte);
    XmmReg[56,8] = ubyte;

    sswub(src_copy[0,16],ubyte);
    XmmReg[64,8] = ubyte;
    sswub(src_copy[16,16],ubyte);
    XmmReg[72,8] = ubyte;
    sswub(src_copy[32,16],ubyte);
    XmmReg[80,8] = ubyte;
    sswub(src_copy[48,16],ubyte);
    XmmReg[88,8] = ubyte;
    sswub(src_copy[64,16],ubyte);
    XmmReg[96,8] = ubyte;
    sswub(src_copy[80,16],ubyte);
    XmmReg[104,8] = ubyte;
    sswub(src_copy[96,16],ubyte);
    XmmReg[112,8] = ubyte;
    sswub(src_copy[112,16],ubyte);
    XmmReg[120,8] = ubyte;
}
1: Constructor line ia.sinc:6074(id0.1018) printpiece=[PACKUSWB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3116  1: m128 : 3117  
Pattern id=1018 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:67:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[64f00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[64f80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[65000:1] = COPY const[0:1]
	5: unique[65080:2] = SUBPIECE unique[64f00:10], const[0:4]
	6: unique[63880:1] = INT_SLESS const[ff:2], unique[65080:2]
	7: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	8: unique[63980:1] = INT_SLESS const[0:2], unique[65080:2]
	9: unique[63a00:1] = INT_SLESS unique[65080:2], const[ff:2]
	10: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	11: unique[65880:1] = SUBPIECE unique[65080:2], const[0:4]
	12: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65880:1]
	13: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	14: [handle:space][[handle:offset+0]:1] = COPY unique[65000:1]
	15: unique[65100:2] = SUBPIECE unique[64f00:10], const[2:4]
	16: unique[63880:1] = INT_SLESS const[ff:2], unique[65100:2]
	17: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	18: unique[63980:1] = INT_SLESS const[0:2], unique[65100:2]
	19: unique[63a00:1] = INT_SLESS unique[65100:2], const[ff:2]
	20: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	21: unique[65900:1] = SUBPIECE unique[65100:2], const[0:4]
	22: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65900:1]
	23: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	24: [handle:space][[handle:offset+10001]:1] = COPY unique[65000:1]
	25: unique[65180:2] = SUBPIECE unique[64f00:10], const[4:4]
	26: unique[63880:1] = INT_SLESS const[ff:2], unique[65180:2]
	27: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	28: unique[63980:1] = INT_SLESS const[0:2], unique[65180:2]
	29: unique[63a00:1] = INT_SLESS unique[65180:2], const[ff:2]
	30: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	31: unique[65980:1] = SUBPIECE unique[65180:2], const[0:4]
	32: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65980:1]
	33: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	34: [handle:space][[handle:offset+20002]:1] = COPY unique[65000:1]
	35: unique[65200:2] = SUBPIECE unique[64f00:10], const[6:4]
	36: unique[63880:1] = INT_SLESS const[ff:2], unique[65200:2]
	37: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	38: unique[63980:1] = INT_SLESS const[0:2], unique[65200:2]
	39: unique[63a00:1] = INT_SLESS unique[65200:2], const[ff:2]
	40: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	41: unique[65a00:1] = SUBPIECE unique[65200:2], const[0:4]
	42: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65a00:1]
	43: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	44: [handle:space][[handle:offset+30003]:1] = COPY unique[65000:1]
	45: unique[65280:2] = SUBPIECE unique[64f00:10], const[8:4]
	46: unique[63880:1] = INT_SLESS const[ff:2], unique[65280:2]
	47: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	48: unique[63980:1] = INT_SLESS const[0:2], unique[65280:2]
	49: unique[63a00:1] = INT_SLESS unique[65280:2], const[ff:2]
	50: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	51: unique[65a80:1] = SUBPIECE unique[65280:2], const[0:4]
	52: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65a80:1]
	53: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	54: [handle:space][[handle:offset+40004]:1] = COPY unique[65000:1]
	55: unique[65300:2] = SUBPIECE unique[64f00:10], const[a:4]
	56: unique[63880:1] = INT_SLESS const[ff:2], unique[65300:2]
	57: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	58: unique[63980:1] = INT_SLESS const[0:2], unique[65300:2]
	59: unique[63a00:1] = INT_SLESS unique[65300:2], const[ff:2]
	60: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	61: unique[65b00:1] = SUBPIECE unique[65300:2], const[0:4]
	62: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65b00:1]
	63: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	64: [handle:space][[handle:offset+50005]:1] = COPY unique[65000:1]
	65: unique[65380:2] = SUBPIECE unique[64f00:10], const[c:4]
	66: unique[63880:1] = INT_SLESS const[ff:2], unique[65380:2]
	67: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	68: unique[63980:1] = INT_SLESS const[0:2], unique[65380:2]
	69: unique[63a00:1] = INT_SLESS unique[65380:2], const[ff:2]
	70: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	71: unique[65b80:1] = SUBPIECE unique[65380:2], const[0:4]
	72: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65b80:1]
	73: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	74: [handle:space][[handle:offset+60006]:1] = COPY unique[65000:1]
	75: unique[65400:2] = SUBPIECE unique[64f00:10], const[e:4]
	76: unique[63880:1] = INT_SLESS const[ff:2], unique[65400:2]
	77: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	78: unique[63980:1] = INT_SLESS const[0:2], unique[65400:2]
	79: unique[63a00:1] = INT_SLESS unique[65400:2], const[ff:2]
	80: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	81: unique[65c00:1] = SUBPIECE unique[65400:2], const[0:4]
	82: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65c00:1]
	83: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	84: [handle:space][[handle:offset+70007]:1] = COPY unique[65000:1]
	85: unique[65480:2] = SUBPIECE unique[64f80:10], const[0:4]
	86: unique[63880:1] = INT_SLESS const[ff:2], unique[65480:2]
	87: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	88: unique[63980:1] = INT_SLESS const[0:2], unique[65480:2]
	89: unique[63a00:1] = INT_SLESS unique[65480:2], const[ff:2]
	90: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	91: unique[65c80:1] = SUBPIECE unique[65480:2], const[0:4]
	92: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65c80:1]
	93: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	94: [handle:space][[handle:offset+80008]:1] = COPY unique[65000:1]
	95: unique[65500:2] = SUBPIECE unique[64f80:10], const[2:4]
	96: unique[63880:1] = INT_SLESS const[ff:2], unique[65500:2]
	97: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	98: unique[63980:1] = INT_SLESS const[0:2], unique[65500:2]
	99: unique[63a00:1] = INT_SLESS unique[65500:2], const[ff:2]
	100: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	101: unique[65d00:1] = SUBPIECE unique[65500:2], const[0:4]
	102: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65d00:1]
	103: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	104: [handle:space][[handle:offset+90009]:1] = COPY unique[65000:1]
	105: unique[65580:2] = SUBPIECE unique[64f80:10], const[4:4]
	106: unique[63880:1] = INT_SLESS const[ff:2], unique[65580:2]
	107: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	108: unique[63980:1] = INT_SLESS const[0:2], unique[65580:2]
	109: unique[63a00:1] = INT_SLESS unique[65580:2], const[ff:2]
	110: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	111: unique[65d80:1] = SUBPIECE unique[65580:2], const[0:4]
	112: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65d80:1]
	113: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	114: [handle:space][[handle:offset+a000a]:1] = COPY unique[65000:1]
	115: unique[65600:2] = SUBPIECE unique[64f80:10], const[6:4]
	116: unique[63880:1] = INT_SLESS const[ff:2], unique[65600:2]
	117: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	118: unique[63980:1] = INT_SLESS const[0:2], unique[65600:2]
	119: unique[63a00:1] = INT_SLESS unique[65600:2], const[ff:2]
	120: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	121: unique[65e00:1] = SUBPIECE unique[65600:2], const[0:4]
	122: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65e00:1]
	123: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	124: [handle:space][[handle:offset+b000b]:1] = COPY unique[65000:1]
	125: unique[65680:2] = SUBPIECE unique[64f80:10], const[8:4]
	126: unique[63880:1] = INT_SLESS const[ff:2], unique[65680:2]
	127: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	128: unique[63980:1] = INT_SLESS const[0:2], unique[65680:2]
	129: unique[63a00:1] = INT_SLESS unique[65680:2], const[ff:2]
	130: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	131: unique[65e80:1] = SUBPIECE unique[65680:2], const[0:4]
	132: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65e80:1]
	133: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	134: [handle:space][[handle:offset+c000c]:1] = COPY unique[65000:1]
	135: unique[65700:2] = SUBPIECE unique[64f80:10], const[a:4]
	136: unique[63880:1] = INT_SLESS const[ff:2], unique[65700:2]
	137: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	138: unique[63980:1] = INT_SLESS const[0:2], unique[65700:2]
	139: unique[63a00:1] = INT_SLESS unique[65700:2], const[ff:2]
	140: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	141: unique[65f00:1] = SUBPIECE unique[65700:2], const[0:4]
	142: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65f00:1]
	143: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	144: [handle:space][[handle:offset+d000d]:1] = COPY unique[65000:1]
	145: unique[65780:2] = SUBPIECE unique[64f80:10], const[c:4]
	146: unique[63880:1] = INT_SLESS const[ff:2], unique[65780:2]
	147: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	148: unique[63980:1] = INT_SLESS const[0:2], unique[65780:2]
	149: unique[63a00:1] = INT_SLESS unique[65780:2], const[ff:2]
	150: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	151: unique[65f80:1] = SUBPIECE unique[65780:2], const[0:4]
	152: unique[63b00:1] = INT_MULT unique[63a80:1], unique[65f80:1]
	153: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	154: [handle:space][[handle:offset+e000e]:1] = COPY unique[65000:1]
	155: unique[65800:2] = SUBPIECE unique[64f80:10], const[e:4]
	156: unique[63880:1] = INT_SLESS const[ff:2], unique[65800:2]
	157: unique[65000:1] = INT_MULT unique[63880:1], const[ff:1]
	158: unique[63980:1] = INT_SLESS const[0:2], unique[65800:2]
	159: unique[63a00:1] = INT_SLESS unique[65800:2], const[ff:2]
	160: unique[63a80:1] = INT_MULT unique[63980:1], unique[63a00:1]
	161: unique[66000:1] = SUBPIECE unique[65800:2], const[0:4]
	162: unique[63b00:1] = INT_MULT unique[63a80:1], unique[66000:1]
	163: unique[65000:1] = INT_ADD unique[65000:1], unique[63b00:1]
	164: [handle:space][[handle:offset+f000f]:1] = COPY unique[65000:1]

Line ia.sinc:7733 :PUNPCKHBW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x68; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = mmxreg1[32,8];
    mmxreg1[8,8] = mmxreg2[32,8];
    mmxreg1[16,8] = mmxreg1[40,8];
    mmxreg1[24,8] = mmxreg2[40,8];
    mmxreg1[32,8] = mmxreg1[48,8];
    mmxreg1[40,8] = mmxreg2[48,8];
    mmxreg1[48,8] = mmxreg1[56,8];
    mmxreg1[56,8] = mmxreg2[56,8];
}
0: Constructor line ia.sinc:7733(id0.1301) printpiece=[PUNPCKHBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3762  1: mmxreg2 : 3763  
Pattern id=1301 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:68:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:1] = COPY [handle:space][[handle:offset+40004]:1]
	1: [handle:space][[handle:offset+10001]:1] = COPY [handle:space][[handle:offset+40004]:1]
	2: [handle:space][[handle:offset+20002]:1] = COPY [handle:space][[handle:offset+50005]:1]
	3: [handle:space][[handle:offset+30003]:1] = COPY [handle:space][[handle:offset+50005]:1]
	4: [handle:space][[handle:offset+40004]:1] = COPY [handle:space][[handle:offset+60006]:1]
	5: [handle:space][[handle:offset+50005]:1] = COPY [handle:space][[handle:offset+60006]:1]
	6: [handle:space][[handle:offset+60006]:1] = COPY [handle:space][[handle:offset+70007]:1]
	7: [handle:space][[handle:offset+70007]:1] = COPY [handle:space][[handle:offset+70007]:1]

Line ia.sinc:7720 :PUNPCKHBW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x68; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = mmxreg[32,8];
    mmxreg[8,8] =    m[32,8];
    mmxreg[16,8] = mmxreg[40,8];
    mmxreg[24,8] =    m[40,8];
    mmxreg[32,8] = mmxreg[48,8];
    mmxreg[40,8] =    m[48,8];
    mmxreg[48,8] = mmxreg[56,8];
    mmxreg[56,8] =    m[56,8];
}
1: Constructor line ia.sinc:7720(id0.1300) printpiece=[PUNPCKHBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3760  1: m64 : 3761  
Pattern id=1300 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:68:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[95b80:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset+0]:1] = COPY [handle:space][[handle:offset+40004]:1]
	3: [handle:space][[handle:offset+10001]:1] = SUBPIECE unique[95b80:8], const[4:4]
	4: [handle:space][[handle:offset+20002]:1] = COPY [handle:space][[handle:offset+50005]:1]
	5: [handle:space][[handle:offset+30003]:1] = SUBPIECE unique[95b80:8], const[5:4]
	6: [handle:space][[handle:offset+40004]:1] = COPY [handle:space][[handle:offset+60006]:1]
	7: [handle:space][[handle:offset+50005]:1] = SUBPIECE unique[95b80:8], const[6:4]
	8: [handle:space][[handle:offset+60006]:1] = COPY [handle:space][[handle:offset+70007]:1]
	9: [handle:space][[handle:offset+70007]:1] = SUBPIECE unique[95b80:8], const[7:4]

Line ia.sinc:7796 :PUNPCKHBW  XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x68; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = XmmReg1[64,8];
    XmmReg1[8,8] = XmmReg2[64,8];
    XmmReg1[16,8] = XmmReg1[72,8];
    XmmReg1[24,8] = XmmReg2[72,8];
    XmmReg1[32,8] = XmmReg1[80,8];
    XmmReg1[40,8] = XmmReg2[80,8];
    XmmReg1[48,8] = XmmReg1[88,8];
    XmmReg1[56,8] = XmmReg2[88,8];
    XmmReg1[64,8] = XmmReg1[96,8];
    XmmReg1[72,8] = XmmReg2[96,8];
    XmmReg1[80,8] = XmmReg1[104,8];
    XmmReg1[88,8] = XmmReg2[104,8];
    XmmReg1[96,8] = XmmReg1[112,8];
    XmmReg1[104,8] = XmmReg2[112,8];
    XmmReg1[112,8] = XmmReg1[120,8];
    XmmReg1[120,8] = XmmReg2[120,8];
}
0: Constructor line ia.sinc:7796(id0.1307) printpiece=[PUNPCKHBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3774  1: XmmReg2 : 3775  
Pattern id=1307 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:68:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:1] = COPY [handle:space][[handle:offset+80008]:1]
	3: [handle:space][[handle:offset+10001]:1] = COPY [handle:space][[handle:offset+80008]:1]
	4: [handle:space][[handle:offset+20002]:1] = COPY [handle:space][[handle:offset+90009]:1]
	5: [handle:space][[handle:offset+30003]:1] = COPY [handle:space][[handle:offset+90009]:1]
	6: [handle:space][[handle:offset+40004]:1] = COPY [handle:space][[handle:offset+a000a]:1]
	7: [handle:space][[handle:offset+50005]:1] = COPY [handle:space][[handle:offset+a000a]:1]
	8: [handle:space][[handle:offset+60006]:1] = COPY [handle:space][[handle:offset+b000b]:1]
	9: [handle:space][[handle:offset+70007]:1] = COPY [handle:space][[handle:offset+b000b]:1]
	10: [handle:space][[handle:offset+80008]:1] = COPY [handle:space][[handle:offset+c000c]:1]
	11: [handle:space][[handle:offset+90009]:1] = COPY [handle:space][[handle:offset+c000c]:1]
	12: [handle:space][[handle:offset+a000a]:1] = COPY [handle:space][[handle:offset+d000d]:1]
	13: [handle:space][[handle:offset+b000b]:1] = COPY [handle:space][[handle:offset+d000d]:1]
	14: [handle:space][[handle:offset+c000c]:1] = COPY [handle:space][[handle:offset+e000e]:1]
	15: [handle:space][[handle:offset+d000d]:1] = COPY [handle:space][[handle:offset+e000e]:1]
	16: [handle:space][[handle:offset+e000e]:1] = COPY [handle:space][[handle:offset+f000f]:1]
	17: [handle:space][[handle:offset+f000f]:1] = COPY [handle:space][[handle:offset+f000f]:1]

Line ia.sinc:7774 :PUNPCKHBW       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x68; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = XmmReg[64,8];
    XmmReg[8,8] =   m[64,8];
    XmmReg[16,8] = XmmReg[72,8];
    XmmReg[24,8] =   m[72,8];
    XmmReg[32,8] = XmmReg[80,8];
    XmmReg[40,8] =   m[80,8];
    XmmReg[48,8] = XmmReg[88,8];
    XmmReg[56,8] =   m[88,8];
    XmmReg[64,8] = XmmReg[96,8];
    XmmReg[72,8] =   m[96,8];
    XmmReg[80,8] = XmmReg[104,8];
    XmmReg[88,8] =   m[104,8];
    XmmReg[96,8] = XmmReg[112,8];
    XmmReg[104,8] =   m[112,8];
    XmmReg[112,8] = XmmReg[120,8];
    XmmReg[120,8] =   m[120,8];
}
1: Constructor line ia.sinc:7774(id0.1306) printpiece=[PUNPCKHBW,  ,  B, ,,  ,  A]
Operands 0: m128 : 3773  1: XmmReg : 3772  
Pattern id=1306 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:68:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[95f80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:1] = COPY [handle:space][[handle:offset+80008]:1]
	4: [handle:space][[handle:offset+10001]:1] = SUBPIECE unique[95f80:10], const[8:4]
	5: [handle:space][[handle:offset+20002]:1] = COPY [handle:space][[handle:offset+90009]:1]
	6: [handle:space][[handle:offset+30003]:1] = SUBPIECE unique[95f80:10], const[9:4]
	7: [handle:space][[handle:offset+40004]:1] = COPY [handle:space][[handle:offset+a000a]:1]
	8: [handle:space][[handle:offset+50005]:1] = SUBPIECE unique[95f80:10], const[a:4]
	9: [handle:space][[handle:offset+60006]:1] = COPY [handle:space][[handle:offset+b000b]:1]
	10: [handle:space][[handle:offset+70007]:1] = SUBPIECE unique[95f80:10], const[b:4]
	11: [handle:space][[handle:offset+80008]:1] = COPY [handle:space][[handle:offset+c000c]:1]
	12: [handle:space][[handle:offset+90009]:1] = SUBPIECE unique[95f80:10], const[c:4]
	13: [handle:space][[handle:offset+a000a]:1] = COPY [handle:space][[handle:offset+d000d]:1]
	14: [handle:space][[handle:offset+b000b]:1] = SUBPIECE unique[95f80:10], const[d:4]
	15: [handle:space][[handle:offset+c000c]:1] = COPY [handle:space][[handle:offset+e000e]:1]
	16: [handle:space][[handle:offset+d000d]:1] = SUBPIECE unique[95f80:10], const[e:4]
	17: [handle:space][[handle:offset+e000e]:1] = COPY [handle:space][[handle:offset+f000f]:1]
	18: [handle:space][[handle:offset+f000f]:1] = SUBPIECE unique[95f80:10], const[f:4]

Line ia.sinc:7754 :PUNPCKHWD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x69; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = mmxreg1[32,16];
    mmxreg1[16,16] = mmxreg2[32,16];
    mmxreg1[32,16] = mmxreg1[48,16];
    mmxreg1[48,16] = mmxreg2[48,16];
}
0: Constructor line ia.sinc:7754(id0.1303) printpiece=[PUNPCKHWD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3766  1: mmxreg2 : 3767  
Pattern id=1303 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:69:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:2] = COPY [handle:space][[handle:offset+40004]:2]
	1: [handle:space][[handle:offset+20002]:2] = COPY [handle:space][[handle:offset+40004]:2]
	2: [handle:space][[handle:offset+40004]:2] = COPY [handle:space][[handle:offset+60006]:2]
	3: [handle:space][[handle:offset+60006]:2] = COPY [handle:space][[handle:offset+60006]:2]

Line ia.sinc:7745 :PUNPCKHWD       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x69; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = mmxreg[32,16];
    mmxreg[16,16] =    m[32,16];
    mmxreg[32,16] = mmxreg[48,16];
    mmxreg[48,16] =    m[48,16];
}
1: Constructor line ia.sinc:7745(id0.1302) printpiece=[PUNPCKHWD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3764  1: m64 : 3765  
Pattern id=1302 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:69:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[95e00:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset+0]:2] = COPY [handle:space][[handle:offset+40004]:2]
	3: [handle:space][[handle:offset+20002]:2] = SUBPIECE unique[95e00:8], const[4:4]
	4: [handle:space][[handle:offset+40004]:2] = COPY [handle:space][[handle:offset+60006]:2]
	5: [handle:space][[handle:offset+60006]:2] = SUBPIECE unique[95e00:8], const[6:4]

Line ia.sinc:7829 :PUNPCKHWD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x69; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = XmmReg1[64,16];
    XmmReg1[16,16] = XmmReg2[64,16];
    XmmReg1[32,16] = XmmReg1[80,16];
    XmmReg1[48,16] = XmmReg2[80,16];
    XmmReg1[64,16] = XmmReg1[96,16];
    XmmReg1[80,16] = XmmReg2[96,16];
    XmmReg1[96,16] = XmmReg1[112,16];
    XmmReg1[112,16] = XmmReg2[112,16];
}
0: Constructor line ia.sinc:7829(id0.1309) printpiece=[PUNPCKHWD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3778  1: XmmReg2 : 3779  
Pattern id=1309 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:69:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:2] = COPY [handle:space][[handle:offset+80008]:2]
	3: [handle:space][[handle:offset+20002]:2] = COPY [handle:space][[handle:offset+80008]:2]
	4: [handle:space][[handle:offset+40004]:2] = COPY [handle:space][[handle:offset+a000a]:2]
	5: [handle:space][[handle:offset+60006]:2] = COPY [handle:space][[handle:offset+a000a]:2]
	6: [handle:space][[handle:offset+80008]:2] = COPY [handle:space][[handle:offset+c000c]:2]
	7: [handle:space][[handle:offset+a000a]:2] = COPY [handle:space][[handle:offset+c000c]:2]
	8: [handle:space][[handle:offset+c000c]:2] = COPY [handle:space][[handle:offset+e000e]:2]
	9: [handle:space][[handle:offset+e000e]:2] = COPY [handle:space][[handle:offset+e000e]:2]

Line ia.sinc:7816 :PUNPCKHWD       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x69; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = XmmReg[64,16];
    XmmReg[16,16] =   m[64,16];
    XmmReg[32,16] = XmmReg[80,16];
    XmmReg[48,16] =   m[80,16];
    XmmReg[64,16] = XmmReg[96,16];
    XmmReg[80,16] =   m[96,16];
    XmmReg[96,16] = XmmReg[112,16];
    XmmReg[112,16] =   m[112,16];
}
1: Constructor line ia.sinc:7816(id0.1308) printpiece=[PUNPCKHWD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3777  1: XmmReg : 3776  
Pattern id=1308 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:69:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[96400:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:2] = COPY [handle:space][[handle:offset+80008]:2]
	4: [handle:space][[handle:offset+20002]:2] = SUBPIECE unique[96400:10], const[8:4]
	5: [handle:space][[handle:offset+40004]:2] = COPY [handle:space][[handle:offset+a000a]:2]
	6: [handle:space][[handle:offset+60006]:2] = SUBPIECE unique[96400:10], const[a:4]
	7: [handle:space][[handle:offset+80008]:2] = COPY [handle:space][[handle:offset+c000c]:2]
	8: [handle:space][[handle:offset+a000a]:2] = SUBPIECE unique[96400:10], const[c:4]
	9: [handle:space][[handle:offset+c000c]:2] = COPY [handle:space][[handle:offset+e000e]:2]
	10: [handle:space][[handle:offset+e000e]:2] = SUBPIECE unique[96400:10], const[e:4]

Line ia.sinc:7768 :PUNPCKHDQ       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6A; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32] = mmxreg1[32,32];
    mmxreg1[32,32] = mmxreg2[32,32];
}
0: Constructor line ia.sinc:7768(id0.1305) printpiece=[PUNPCKHDQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3770  1: mmxreg2 : 3771  
Pattern id=1305 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:6A:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+40004]:4]
	1: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+40004]:4]

Line ia.sinc:7762 :PUNPCKHDQ       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6A; mmxreg ... & m64
{
    mmxreg[0,32] = mmxreg[32,32];
    mmxreg[32,32] =    m64[32,32];
}
1: Constructor line ia.sinc:7762(id0.1304) printpiece=[PUNPCKHDQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3768  1: m64 : 3769  
Pattern id=1304 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:6A:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+40004]:4]
	2: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+40004]:4]

Line ia.sinc:7850 :PUNPCKHDQ       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6A; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[64,32];
    XmmReg1[32,32] = XmmReg2[64,32];
    XmmReg1[64,32] = XmmReg1[96,32];
    XmmReg1[96,32] = XmmReg2[96,32];
}
0: Constructor line ia.sinc:7850(id0.1311) printpiece=[PUNPCKHDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3782  1: XmmReg2 : 3783  
Pattern id=1311 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6A:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+80008]:4]
	3: [handle:space][[handle:offset+40004]:4] = COPY [handle:space][[handle:offset+80008]:4]
	4: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+c000c]:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:7841 :PUNPCKHDQ       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6A; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[64,32];
    XmmReg[32,32] =   m[64,32];
    XmmReg[64,32] = XmmReg[96,32];
    XmmReg[96,32] =   m[96,32];
}
1: Constructor line ia.sinc:7841(id0.1310) printpiece=[PUNPCKHDQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 3781  1: XmmReg : 3780  
Pattern id=1310 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6A:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[96680:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:4] = COPY [handle:space][[handle:offset+80008]:4]
	4: [handle:space][[handle:offset+40004]:4] = SUBPIECE unique[96680:10], const[8:4]
	5: [handle:space][[handle:offset+80008]:4] = COPY [handle:space][[handle:offset+c000c]:4]
	6: [handle:space][[handle:offset+c000c]:4] = SUBPIECE unique[96680:10], const[c:4]

Line ia.sinc:6013 :PACKSSDW      mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6B; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = packssdw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:6013(id0.1011) printpiece=[PACKSSDW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3102  1: mmxreg2 : 3103  
Pattern id=1011 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:6B:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[76:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6012 :PACKSSDW      mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6B; mmxreg ... & m64 { mmxreg = packssdw(mmxreg, m64); }
1: Constructor line ia.sinc:6012(id0.1010) printpiece=[PACKSSDW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3100  1: m64 : 3101  
Pattern id=1010 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:6B:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[76:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6018 :PACKSSDW      XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6B; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = packssdw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:6018(id0.1015) printpiece=[PACKSSDW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3110  1: XmmReg2 : 3111  
Pattern id=1015 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6B:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[76:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6017 :PACKSSDW      XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6B; XmmReg ... & m128 { XmmReg = packssdw(XmmReg, m128); }
1: Constructor line ia.sinc:6017(id0.1014) printpiece=[PACKSSDW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3108  1: m128 : 3109  
Pattern id=1014 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6B:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[76:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8015 :PUNPCKLQDQ      XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6C; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[64,64] = XmmReg2[0,64];
#   XmmReg1[0,64] = XmmReg1[0,64]; superfluous
}
0: Constructor line ia.sinc:8015(id0.1327) printpiece=[PUNPCKLQDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3815  1: XmmReg2 : 3816  
Pattern id=1327 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:8009 :PUNPCKLQDQ      XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6C; m128 & XmmReg ...
{
    XmmReg[64,64] =   m128[0,64];
#   XmmReg[0,64] = XmmReg[0,64]; superfluous
}
1: Constructor line ia.sinc:8009(id0.1326) printpiece=[PUNPCKLQDQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 3814  1: XmmReg : 3813  
Pattern id=1326 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6C:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:7864 :PUNPCKHQDQ      XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6D; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[64,64];
    XmmReg1[64,64] = XmmReg2[64,64];
}
0: Constructor line ia.sinc:7864(id0.1313) printpiece=[PUNPCKHQDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3786  1: XmmReg2 : 3787  
Pattern id=1313 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+80008]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:7858 :PUNPCKHQDQ      XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6D; m128 & XmmReg ...
{
    XmmReg[0,64] = XmmReg[64,64];
    XmmReg[64,64] =   m128[64,64];
}
1: Constructor line ia.sinc:7858(id0.1312) printpiece=[PUNPCKHQDQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 3785  1: XmmReg : 3784  
Pattern id=1312 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6D:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset+80008]:8]
	3: [handle:space][[handle:offset+80008]:8] = COPY [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5705 :MOVD         mmxreg, rm32   is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6E; rm32 & mmxreg ...                    { mmxreg = zext(rm32); }
0: Constructor line ia.sinc:5705(id0.936) printpiece=[MOVD,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2946  1: mmxreg : 2945  
Pattern id=936 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:6E:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5707 :MOVD         XmmReg, rm32   is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6E; rm32 & XmmReg ...         { XmmReg = zext(rm32); }
0: Constructor line ia.sinc:5707(id0.938) printpiece=[MOVD,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2951  1: XmmReg : 2950  
Pattern id=938 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6E:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5812 :MOVQ         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6F; mmxmod = 3 & mmxreg1 & mmxreg2     { mmxreg1 = mmxreg2; }
0: Constructor line ia.sinc:5812(id0.972) printpiece=[MOVQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3022  1: mmxreg2 : 3023  
Pattern id=972 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:6F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5811 :MOVQ         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x6F; mmxreg ... & m64                   { mmxreg = m64; }
1: Constructor line ia.sinc:5811(id0.971) printpiece=[MOVQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3020  1: m64 : 3021  
Pattern id=971 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:6F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5763 :MOVDQA       XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = XmmReg2; }
0: Constructor line ia.sinc:5763(id0.947) printpiece=[MOVDQA,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2969  1: XmmReg2 : 2970  
Pattern id=947 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5762 :MOVDQA       XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6F; XmmReg ... & m128            { XmmReg = m128; }  
1: Constructor line ia.sinc:5762(id0.946) printpiece=[MOVDQA,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2967  1: m128 : 2968  
Pattern id=946 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5763 :MOVDQA       XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = XmmReg2; }
0: Constructor line ia.sinc:5763(id0.947) printpiece=[MOVDQA,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2969  1: XmmReg2 : 2970  
Pattern id=947 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5762 :MOVDQA       XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x6F; XmmReg ... & m128            { XmmReg = m128; }  
1: Constructor line ia.sinc:5762(id0.946) printpiece=[MOVDQA,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2967  1: m128 : 2968  
Pattern id=946 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:6F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5768 :MOVDQU       XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x6F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = XmmReg2; }
2: Constructor line ia.sinc:5768(id0.951) printpiece=[MOVDQU,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2977  1: XmmReg2 : 2978  
Pattern id=951 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:6F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5767 :MOVDQU       XmmReg, m128        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x6F; XmmReg ... & m128            { XmmReg = m128; }
3: Constructor line ia.sinc:5767(id0.950) printpiece=[MOVDQU,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2975  1: m128 : 2976  
Pattern id=950 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:6F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:7228 :PSHUFW         mmxreg1, mmxreg2, imm8  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x70; mmxmod = 3 & mmxreg1 & mmxreg2; imm8 { mmxreg1 = pshufw(mmxreg1, mmxreg2, imm8:8); }
0: Constructor line ia.sinc:7228(id0.1205) printpiece=[PSHUFW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: mmxreg1 : 3560  1: mmxreg2 : 3561  2: imm8 : 3562  
Pattern id=1205 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:70:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[92:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7227 :PSHUFW         mmxreg, m64, imm8       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x70; m64 & mmxreg ...; imm8 { mmxreg = pshufw(mmxreg, m64, imm8:8); }
1: Constructor line ia.sinc:7227(id0.1204) printpiece=[PSHUFW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m64 : 3558  1: mmxreg : 3557  2: imm8 : 3559  
Pattern id=1204 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:70:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[92:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7205 :PSHUFD         XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x70; xmmmod=3 & XmmReg1 & XmmReg2 ; imm8 & Order0 & Order1 & Order2 & Order3
{
    local c0 = XmmReg2[0,32];
    local c1 = XmmReg2[32,32];
    local c2 = XmmReg2[64,32];
    local c3 = XmmReg2[96,32];

    shuffle_4(XmmReg1[0,32],Order0,c0,c1,c2,c3);
    shuffle_4(XmmReg1[32,32],Order1,c0,c1,c2,c3);
    shuffle_4(XmmReg1[64,32],Order2,c0,c1,c2,c3);
    shuffle_4(XmmReg1[96,32],Order3,c0,c1,c2,c3);
}
0: Constructor line ia.sinc:7205(id0.1199) printpiece=[PSHUFD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3535  1: XmmReg2 : 3536  2: imm8 : 3537  3: Order0 : 3538  4: Order1 : 3539  5: Order2 : 3540  6: Order3 : 3541  
Pattern id=1199 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:70:[11xx]X:XX)
Template
	0: MULTIEQUAL const[6:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[3:4]
	4: MULTIEQUAL const[1:4]
	5: MULTIEQUAL const[0:4]
	6: unique[8b780:4] = COPY [handle:space][[handle:offset+0]:4]
	7: unique[8b800:4] = COPY [handle:space][[handle:offset+40004]:4]
	8: unique[8b880:4] = COPY [handle:space][[handle:offset+80008]:4]
	9: unique[8b900:4] = COPY [handle:space][[handle:offset+c000c]:4]
	10: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	12: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	13: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	14: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	15: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	16: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	17: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	18: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	19: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	20: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	21: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	22: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	23: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	24: [handle:space][[handle:offset+0]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	25: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	27: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	28: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	29: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	30: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	31: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	32: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	33: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	34: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	35: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	36: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	37: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	38: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	39: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	40: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	41: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	42: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	43: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	44: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	45: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	46: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	47: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	48: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	49: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	50: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	51: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	52: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	53: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	54: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	55: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	56: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	57: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	58: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	59: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	60: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	61: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	62: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	63: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	64: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	65: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	66: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	67: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	68: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	69: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[8b300:4], unique[8b480:4]

Line ia.sinc:7192 :PSHUFD         XmmReg1, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x70; (m128 & XmmReg1 ...); imm8 & Order0 & Order1 & Order2 & Order3
{
    local c0 = m128[0,32];
    local c1 = m128[32,32];
    local c2 = m128[64,32];
    local c3 = m128[96,32];

    shuffle_4(XmmReg1[0,32],Order0,c0,c1,c2,c3);
    shuffle_4(XmmReg1[32,32],Order1,c0,c1,c2,c3);
    shuffle_4(XmmReg1[64,32],Order2,c0,c1,c2,c3);
    shuffle_4(XmmReg1[96,32],Order3,c0,c1,c2,c3);
}
1: Constructor line ia.sinc:7192(id0.1198) printpiece=[PSHUFD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m128 : 3529  1: XmmReg1 : 3528  2: imm8 : 3530  3: Order0 : 3531  4: Order1 : 3532  5: Order2 : 3533  6: Order3 : 3534  
Pattern id=1198 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:70:XX:XX)
Template
	0: MULTIEQUAL const[6:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[3:4]
	4: MULTIEQUAL const[0:4]
	5: MULTIEQUAL const[1:4]
	6: unique[8b580:4] = COPY [handle:space][[handle:offset+0]:4]
	7: unique[8b600:4] = COPY [handle:space][[handle:offset+40004]:4]
	8: unique[8b680:4] = COPY [handle:space][[handle:offset+80008]:4]
	9: unique[8b700:4] = COPY [handle:space][[handle:offset+c000c]:4]
	10: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	12: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	13: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	14: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	15: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	16: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	17: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	18: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	19: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	20: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	21: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	22: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	23: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	24: [handle:space][[handle:offset+0]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	25: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	27: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	28: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	29: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	30: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	31: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	32: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	33: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	34: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	35: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	36: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	37: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	38: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	39: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	40: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	41: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	42: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	43: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	44: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	45: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	46: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	47: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	48: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	49: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	50: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	51: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	52: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	53: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	54: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	55: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	56: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	57: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	58: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	59: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	60: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	61: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	62: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	63: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	64: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	65: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	66: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	67: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	68: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	69: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[8b300:4], unique[8b480:4]

Line ia.sinc:7205 :PSHUFD         XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x70; xmmmod=3 & XmmReg1 & XmmReg2 ; imm8 & Order0 & Order1 & Order2 & Order3
{
    local c0 = XmmReg2[0,32];
    local c1 = XmmReg2[32,32];
    local c2 = XmmReg2[64,32];
    local c3 = XmmReg2[96,32];

    shuffle_4(XmmReg1[0,32],Order0,c0,c1,c2,c3);
    shuffle_4(XmmReg1[32,32],Order1,c0,c1,c2,c3);
    shuffle_4(XmmReg1[64,32],Order2,c0,c1,c2,c3);
    shuffle_4(XmmReg1[96,32],Order3,c0,c1,c2,c3);
}
0: Constructor line ia.sinc:7205(id0.1199) printpiece=[PSHUFD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3535  1: XmmReg2 : 3536  2: imm8 : 3537  3: Order0 : 3538  4: Order1 : 3539  5: Order2 : 3540  6: Order3 : 3541  
Pattern id=1199 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:70:[11xx]X:XX)
Template
	0: MULTIEQUAL const[6:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[3:4]
	4: MULTIEQUAL const[1:4]
	5: MULTIEQUAL const[0:4]
	6: unique[8b780:4] = COPY [handle:space][[handle:offset+0]:4]
	7: unique[8b800:4] = COPY [handle:space][[handle:offset+40004]:4]
	8: unique[8b880:4] = COPY [handle:space][[handle:offset+80008]:4]
	9: unique[8b900:4] = COPY [handle:space][[handle:offset+c000c]:4]
	10: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	12: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	13: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	14: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	15: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	16: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	17: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	18: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	19: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	20: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	21: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	22: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	23: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	24: [handle:space][[handle:offset+0]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	25: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	27: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	28: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	29: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	30: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	31: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	32: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	33: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	34: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	35: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	36: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	37: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	38: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	39: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	40: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	41: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	42: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	43: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	44: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	45: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	46: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	47: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	48: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	49: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	50: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	51: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	52: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	53: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	54: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	55: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	56: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	57: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	58: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	59: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	60: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	61: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	62: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	63: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	64: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	65: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	66: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	67: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	68: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	69: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[8b300:4], unique[8b480:4]

Line ia.sinc:7192 :PSHUFD         XmmReg1, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x70; (m128 & XmmReg1 ...); imm8 & Order0 & Order1 & Order2 & Order3
{
    local c0 = m128[0,32];
    local c1 = m128[32,32];
    local c2 = m128[64,32];
    local c3 = m128[96,32];

    shuffle_4(XmmReg1[0,32],Order0,c0,c1,c2,c3);
    shuffle_4(XmmReg1[32,32],Order1,c0,c1,c2,c3);
    shuffle_4(XmmReg1[64,32],Order2,c0,c1,c2,c3);
    shuffle_4(XmmReg1[96,32],Order3,c0,c1,c2,c3);
}
1: Constructor line ia.sinc:7192(id0.1198) printpiece=[PSHUFD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m128 : 3529  1: XmmReg1 : 3528  2: imm8 : 3530  3: Order0 : 3531  4: Order1 : 3532  5: Order2 : 3533  6: Order3 : 3534  
Pattern id=1198 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:70:XX:XX)
Template
	0: MULTIEQUAL const[6:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[3:4]
	4: MULTIEQUAL const[0:4]
	5: MULTIEQUAL const[1:4]
	6: unique[8b580:4] = COPY [handle:space][[handle:offset+0]:4]
	7: unique[8b600:4] = COPY [handle:space][[handle:offset+40004]:4]
	8: unique[8b680:4] = COPY [handle:space][[handle:offset+80008]:4]
	9: unique[8b700:4] = COPY [handle:space][[handle:offset+c000c]:4]
	10: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	12: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	13: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	14: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	15: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	16: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	17: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	18: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	19: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	20: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	21: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	22: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	23: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	24: [handle:space][[handle:offset+0]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	25: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	27: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	28: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	29: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	30: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	31: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	32: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	33: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	34: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	35: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	36: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	37: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	38: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	39: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	40: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	41: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	42: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	43: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	44: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	45: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	46: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	47: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	48: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	49: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	50: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	51: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	52: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	53: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	54: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	55: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	56: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	57: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	58: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	59: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	60: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	61: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	62: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	63: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	64: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	65: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	66: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	67: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	68: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	69: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[8b300:4], unique[8b480:4]

Line ia.sinc:7220 :PSHUFHW        XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x70; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = pshufhw(XmmReg1, XmmReg2, imm8:8); }
2: Constructor line ia.sinc:7220(id0.1201) printpiece=[PSHUFHW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3546  1: XmmReg2 : 3547  2: imm8 : 3548  
Pattern id=1201 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:70:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[90:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7219 :PSHUFHW        XmmReg1, m128, imm8     is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x70; m128 & XmmReg1 ...; imm8 { XmmReg1 = pshufhw(XmmReg1, m128, imm8:8); }
3: Constructor line ia.sinc:7219(id0.1200) printpiece=[PSHUFHW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m128 : 3544  1: XmmReg1 : 3543  2: imm8 : 3545  
Pattern id=1200 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:70:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[90:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7205 :PSHUFD         XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x70; xmmmod=3 & XmmReg1 & XmmReg2 ; imm8 & Order0 & Order1 & Order2 & Order3
{
    local c0 = XmmReg2[0,32];
    local c1 = XmmReg2[32,32];
    local c2 = XmmReg2[64,32];
    local c3 = XmmReg2[96,32];

    shuffle_4(XmmReg1[0,32],Order0,c0,c1,c2,c3);
    shuffle_4(XmmReg1[32,32],Order1,c0,c1,c2,c3);
    shuffle_4(XmmReg1[64,32],Order2,c0,c1,c2,c3);
    shuffle_4(XmmReg1[96,32],Order3,c0,c1,c2,c3);
}
0: Constructor line ia.sinc:7205(id0.1199) printpiece=[PSHUFD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3535  1: XmmReg2 : 3536  2: imm8 : 3537  3: Order0 : 3538  4: Order1 : 3539  5: Order2 : 3540  6: Order3 : 3541  
Pattern id=1199 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:70:[11xx]X:XX)
Template
	0: MULTIEQUAL const[6:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[3:4]
	4: MULTIEQUAL const[1:4]
	5: MULTIEQUAL const[0:4]
	6: unique[8b780:4] = COPY [handle:space][[handle:offset+0]:4]
	7: unique[8b800:4] = COPY [handle:space][[handle:offset+40004]:4]
	8: unique[8b880:4] = COPY [handle:space][[handle:offset+80008]:4]
	9: unique[8b900:4] = COPY [handle:space][[handle:offset+c000c]:4]
	10: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	12: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	13: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	14: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	15: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	16: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	17: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	18: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	19: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	20: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	21: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	22: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	23: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	24: [handle:space][[handle:offset+0]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	25: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	27: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	28: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	29: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	30: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	31: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	32: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	33: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	34: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	35: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	36: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	37: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	38: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	39: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	40: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	41: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	42: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	43: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	44: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	45: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	46: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	47: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	48: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	49: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	50: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	51: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	52: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	53: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	54: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	55: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	56: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	57: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b780:4]
	58: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	59: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	60: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b800:4]
	61: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	62: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	63: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	64: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b880:4]
	65: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	66: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	67: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	68: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b900:4]
	69: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[8b300:4], unique[8b480:4]

Line ia.sinc:7192 :PSHUFD         XmmReg1, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x70; (m128 & XmmReg1 ...); imm8 & Order0 & Order1 & Order2 & Order3
{
    local c0 = m128[0,32];
    local c1 = m128[32,32];
    local c2 = m128[64,32];
    local c3 = m128[96,32];

    shuffle_4(XmmReg1[0,32],Order0,c0,c1,c2,c3);
    shuffle_4(XmmReg1[32,32],Order1,c0,c1,c2,c3);
    shuffle_4(XmmReg1[64,32],Order2,c0,c1,c2,c3);
    shuffle_4(XmmReg1[96,32],Order3,c0,c1,c2,c3);
}
1: Constructor line ia.sinc:7192(id0.1198) printpiece=[PSHUFD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m128 : 3529  1: XmmReg1 : 3528  2: imm8 : 3530  3: Order0 : 3531  4: Order1 : 3532  5: Order2 : 3533  6: Order3 : 3534  
Pattern id=1198 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:70:XX:XX)
Template
	0: MULTIEQUAL const[6:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[3:4]
	4: MULTIEQUAL const[0:4]
	5: MULTIEQUAL const[1:4]
	6: unique[8b580:4] = COPY [handle:space][[handle:offset+0]:4]
	7: unique[8b600:4] = COPY [handle:space][[handle:offset+40004]:4]
	8: unique[8b680:4] = COPY [handle:space][[handle:offset+80008]:4]
	9: unique[8b700:4] = COPY [handle:space][[handle:offset+c000c]:4]
	10: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	12: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	13: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	14: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	15: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	16: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	17: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	18: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	19: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	20: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	21: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	22: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	23: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	24: [handle:space][[handle:offset+0]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	25: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	27: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	28: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	29: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	30: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	31: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	32: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	33: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	34: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	35: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	36: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	37: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	38: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	39: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	40: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	41: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	42: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	43: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	44: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	45: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	46: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	47: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	48: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	49: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	50: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	51: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	52: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	53: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	54: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	55: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	56: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	57: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[8b580:4]
	58: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	59: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	60: unique[8b080:4] = INT_MULT unique[8b000:4], unique[8b600:4]
	61: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	62: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	63: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	64: unique[8b280:4] = INT_MULT unique[8b200:4], unique[8b680:4]
	65: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	66: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	67: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	68: unique[8b480:4] = INT_MULT unique[8b400:4], unique[8b700:4]
	69: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[8b300:4], unique[8b480:4]

Line ia.sinc:7220 :PSHUFHW        XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x70; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = pshufhw(XmmReg1, XmmReg2, imm8:8); }
2: Constructor line ia.sinc:7220(id0.1201) printpiece=[PSHUFHW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3546  1: XmmReg2 : 3547  2: imm8 : 3548  
Pattern id=1201 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:70:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[90:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7219 :PSHUFHW        XmmReg1, m128, imm8     is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0x70; m128 & XmmReg1 ...; imm8 { XmmReg1 = pshufhw(XmmReg1, m128, imm8:8); }
3: Constructor line ia.sinc:7219(id0.1200) printpiece=[PSHUFHW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m128 : 3544  1: XmmReg1 : 3543  2: imm8 : 3545  
Pattern id=1200 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:70:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[90:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7224 :PSHUFLW        XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x70; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = pshuflw(XmmReg1, XmmReg2, imm8:8); }
4: Constructor line ia.sinc:7224(id0.1203) printpiece=[PSHUFLW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3553  1: XmmReg2 : 3554  2: imm8 : 3555  
Pattern id=1203 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:70:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[91:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7223 :PSHUFLW        XmmReg1, m128, imm8     is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0x70; m128 & XmmReg1 ...; imm8 { XmmReg1 = pshuflw(XmmReg1, m128, imm8:8); }
5: Constructor line ia.sinc:7223(id0.1202) printpiece=[PSHUFLW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m128 : 3551  1: XmmReg1 : 3550  2: imm8 : 3552  
Pattern id=1202 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:70:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[91:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7412 :PSRLW          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=2 & mmxreg2; imm8
{
    mmxreg2[0,16]  = mmxreg2[0,16]  >> imm8;
    mmxreg2[16,16] = mmxreg2[16,16] >> imm8;
    mmxreg2[32,16] = mmxreg2[32,16] >> imm8;
    mmxreg2[48,16] = mmxreg2[48,16] >> imm8;
}
0: Constructor line ia.sinc:7412(id0.1252) printpiece=[PSRLW,  ,  A, ,,  ,  B]
Operands 0: mmxreg2 : 3660  1: imm8 : 3661  
Pattern id=1252 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:71:D[0xxx]:XX)
Template
	0: [handle:space][[handle:offset+0]:2] = INT_RIGHT [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset]:4]
	1: [handle:space][[handle:offset+20002]:2] = INT_RIGHT [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset]:4]
	2: [handle:space][[handle:offset+40004]:2] = INT_RIGHT [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset]:4]
	3: [handle:space][[handle:offset+60006]:2] = INT_RIGHT [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset]:4]

Line ia.sinc:7480 :PSRLW          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=2 & XmmReg2; imm8
{
    XmmReg2[0,16]   = XmmReg2[0,16]   >> imm8;
    XmmReg2[16,16]  = XmmReg2[16,16]  >> imm8;
    XmmReg2[32,16]  = XmmReg2[32,16]  >> imm8;
    XmmReg2[48,16]  = XmmReg2[48,16]  >> imm8;
    XmmReg2[64,16]  = XmmReg2[64,16]  >> imm8;
    XmmReg2[80,16]  = XmmReg2[80,16]  >> imm8;
    XmmReg2[96,16]  = XmmReg2[96,16]  >> imm8;
    XmmReg2[112,16] = XmmReg2[112,16] >> imm8;
}
0: Constructor line ia.sinc:7480(id0.1261) printpiece=[PSRLW,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3678  1: imm8 : 3679  
Pattern id=1261 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:71:D[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset+0]:2] = INT_RIGHT [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset]:4]
	2: [handle:space][[handle:offset+20002]:2] = INT_RIGHT [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset]:4]
	3: [handle:space][[handle:offset+40004]:2] = INT_RIGHT [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset]:4]
	4: [handle:space][[handle:offset+60006]:2] = INT_RIGHT [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset]:4]
	5: [handle:space][[handle:offset+80008]:2] = INT_RIGHT [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset]:4]
	6: [handle:space][[handle:offset+a000a]:2] = INT_RIGHT [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset]:4]
	7: [handle:space][[handle:offset+c000c]:2] = INT_RIGHT [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset]:4]
	8: [handle:space][[handle:offset+e000e]:2] = INT_RIGHT [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset]:4]

Line ia.sinc:7336 :PSRAW          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=4 & mmxreg2; imm8 { mmxreg2 = psraw(mmxreg2, imm8:8); }
0: Constructor line ia.sinc:7336(id0.1239) printpiece=[PSRAW,  ,  A, ,,  ,  B]
Operands 0: mmxreg2 : 3634  1: imm8 : 3635  
Pattern id=1239 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:71:E[0xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[97:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7361 :PSRAW          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=4 & XmmReg2; imm8 { XmmReg2 = psraw(XmmReg2, imm8:8); }
0: Constructor line ia.sinc:7361(id0.1245) printpiece=[PSRAW,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3646  1: imm8 : 3647  
Pattern id=1245 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:71:E[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[97:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7269 :PSLLW          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=6 & mmxreg2; imm8 { mmxreg2 = psllw(mmxreg2, imm8:8); }
0: Constructor line ia.sinc:7269(id0.1221) printpiece=[PSLLW,  ,  A, ,,  ,  B]
Operands 0: mmxreg2 : 3597  1: imm8 : 3598  
Pattern id=1221 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:71:F[0xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[96:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7293 :PSLLW          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x71; mod = 0b11 & reg_opcode=6 & XmmReg2; imm8 { XmmReg2 = psllw(XmmReg2, imm8:8); }
0: Constructor line ia.sinc:7293(id0.1230) printpiece=[PSLLW,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3615  1: imm8 : 3616  
Pattern id=1230 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:71:F[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[96:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7432 :PSRLD          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=2 & mmxreg2; imm8
{
    mmxreg2[0,32]  = mmxreg2[0,32]  >> imm8;
    mmxreg2[32,32] = mmxreg2[32,32] >> imm8;
}
0: Constructor line ia.sinc:7432(id0.1255) printpiece=[PSRLD,  ,  A, ,,  ,  B]
Operands 0: mmxreg2 : 3666  1: imm8 : 3667  
Pattern id=1255 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:72:D[0xxx]:XX)
Template
	0: [handle:space][[handle:offset+0]:4] = INT_RIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:4]
	1: [handle:space][[handle:offset+40004]:4] = INT_RIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:4]

Line ia.sinc:7511 :PSRLD          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=2 & XmmReg2; imm8
{
    XmmReg2[0,32]  = XmmReg2[0,32]  >> imm8;
    XmmReg2[32,32] = XmmReg2[32,32] >> imm8;
    XmmReg2[64,32] = XmmReg2[64,32] >> imm8;
    XmmReg2[96,32] = XmmReg2[96,32] >> imm8;
}
0: Constructor line ia.sinc:7511(id0.1264) printpiece=[PSRLD,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3684  1: imm8 : 3685  
Pattern id=1264 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:72:D[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset+0]:4] = INT_RIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:4]
	2: [handle:space][[handle:offset+40004]:4] = INT_RIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:4]
	3: [handle:space][[handle:offset+80008]:4] = INT_RIGHT [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset]:4]
	4: [handle:space][[handle:offset+c000c]:4] = INT_RIGHT [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset]:4]

Line ia.sinc:7352 :PSRAD          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=4 & mmxreg2; imm8
{
# a count greater than 31 just clears all the bits
    mmxreg2[0,32] = mmxreg2[0,32] s>> imm8;
    mmxreg2[32,32] = mmxreg2[32,32] s>> imm8;
}
0: Constructor line ia.sinc:7352(id0.1242) printpiece=[PSRAD,  ,  A, ,,  ,  B]
Operands 0: mmxreg2 : 3640  1: imm8 : 3641  
Pattern id=1242 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:72:E[0xxx]:XX)
Template
	0: [handle:space][[handle:offset+0]:4] = INT_SRIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:4]
	1: [handle:space][[handle:offset+40004]:4] = INT_SRIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:4]

Line ia.sinc:7381 :PSRAD          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=4 & XmmReg2; imm8
{
# a count greater than 31 just clears all the bits
    XmmReg2[0,32] = XmmReg2[0,32] s>> imm8;
    XmmReg2[32,32] = XmmReg2[32,32] s>> imm8;
    XmmReg2[64,32] = XmmReg2[64,32] s>> imm8;
    XmmReg2[96,32] = XmmReg2[96,32] s>> imm8;
}
0: Constructor line ia.sinc:7381(id0.1248) printpiece=[PSRAD,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3652  1: imm8 : 3653  
Pattern id=1248 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:72:E[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset+0]:4] = INT_SRIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:4]
	2: [handle:space][[handle:offset+40004]:4] = INT_SRIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:4]
	3: [handle:space][[handle:offset+80008]:4] = INT_SRIGHT [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset]:4]
	4: [handle:space][[handle:offset+c000c]:4] = INT_SRIGHT [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset]:4]

Line ia.sinc:7282 :PSLLD          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=6 & mmxreg2; imm8 {
  mmxreg2[0,32] = mmxreg2[0,32] << imm8;
  mmxreg2[32,32] = mmxreg2[32,32] << imm8;
}
0: Constructor line ia.sinc:7282(id0.1224) printpiece=[PSLLD,  ,  A, ,,  ,  B]
Operands 0: mmxreg2 : 3603  1: imm8 : 3604  
Pattern id=1224 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:72:F[0xxx]:XX)
Template
	0: [handle:space][[handle:offset+0]:4] = INT_LEFT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:4]
	1: [handle:space][[handle:offset+40004]:4] = INT_LEFT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:4]

Line ia.sinc:7310 :PSLLD          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x72; mod = 0b11 & reg_opcode=6 & XmmReg2; imm8 {
  XmmReg2[0,32] = XmmReg2[0,32] << imm8;
  XmmReg2[32,32] = XmmReg2[32,32] << imm8;
  XmmReg2[64,32] = XmmReg2[64,32] << imm8;
  XmmReg2[96,32] = XmmReg2[96,32] << imm8;
}
0: Constructor line ia.sinc:7310(id0.1233) printpiece=[PSLLD,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3621  1: imm8 : 3622  
Pattern id=1233 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:72:F[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset+0]:4] = INT_LEFT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:4]
	2: [handle:space][[handle:offset+40004]:4] = INT_LEFT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:4]
	3: [handle:space][[handle:offset+80008]:4] = INT_LEFT [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset]:4]
	4: [handle:space][[handle:offset+c000c]:4] = INT_LEFT [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset]:4]

Line ia.sinc:7448 :PSRLQ          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x73; mod = 0b11 & reg_opcode=2 & mmxreg2; imm8
{
    mmxreg2 = mmxreg2 >> imm8;
}
0: Constructor line ia.sinc:7448(id0.1258) printpiece=[PSRLQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg2 : 3672  1: imm8 : 3673  
Pattern id=1258 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:73:D[0xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:4]

Line ia.sinc:7534 :PSRLQ          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x73; mod = 0b11 & reg_opcode=2 & XmmReg2; imm8
{
    XmmReg2[0,64]  = XmmReg2[0,64]  >> imm8;
    XmmReg2[64,64] = XmmReg2[64,64] >> imm8;
}
0: Constructor line ia.sinc:7534(id0.1267) printpiece=[PSRLQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3690  1: imm8 : 3691  
Pattern id=1267 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:73:D[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset+0]:8] = INT_RIGHT [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:4]
	2: [handle:space][[handle:offset+80008]:8] = INT_RIGHT [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset]:4]

Line ia.sinc:7390 :PSRLDQ         XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x73; xmmmod=3 & reg_opcode=3 & XmmReg2; imm8
{
# a count greater than 15 just clears all the bits
    XmmReg2 = XmmReg2 >> (imm8 * 8);
}
0: Constructor line ia.sinc:7390(id0.1249) printpiece=[PSRLDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3654  1: imm8 : 3655  
Pattern id=1249 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:73:D[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[8eb80:4] = INT_MULT [handle:space][[handle:offset]:4], const[8:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[8eb80:4]

Line ia.sinc:7289 :PSLLQ          mmxreg2, imm8    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x73; mod = 0b11 & reg_opcode=6 & mmxreg2; imm8 { mmxreg2 = mmxreg2 << imm8:8; }
0: Constructor line ia.sinc:7289(id0.1227) printpiece=[PSLLQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg2 : 3609  1: imm8 : 3610  
Pattern id=1227 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:73:F[0xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:7328 :PSLLQ          XmmReg2, imm8     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x73; mod = 0b11 & reg_opcode=6 & XmmReg2; imm8 {
  XmmReg2[0,64] = XmmReg2[0,64] << imm8;
  XmmReg2[64,64] = XmmReg2[64,64] << imm8;
}
0: Constructor line ia.sinc:7328(id0.1236) printpiece=[PSLLQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3627  1: imm8 : 3628  
Pattern id=1236 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:73:F[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset+0]:8] = INT_LEFT [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset]:4]
	2: [handle:space][[handle:offset+80008]:8] = INT_LEFT [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset]:4]

Line ia.sinc:7249 :PSLLDQ         XmmReg2, imm8    is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0x73; xmmmod = 3 & reg_opcode=7 & XmmReg2; imm8 
{ 
	if (imm8:1 > 15:1) goto <zero>;
    local low64copy:8 = XmmReg2[0,64];
    XmmReg2[0,64] = XmmReg2[0,64] << (8:1 * imm8:1);
    if (imm8:1 > 8:1)  goto <greater>;
    XmmReg2[64,64] = (XmmReg2[64,64] << (8:1 * imm8:1)) | (low64copy >> (8:1 * (8 - imm8:1)));
    goto <end>;
<greater>
    XmmReg2[64,64] = low64copy << (8:1 * (imm8 - 8));
    goto <end>;
<zero>
    XmmReg2[0,64] = 0:8;
    XmmReg2[64,64] = 0:8;
<end>
}
0: Constructor line ia.sinc:7249(id0.1218) printpiece=[PSLLDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg2 : 3590  1: imm8 : 3591  
Pattern id=1218 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:73:F[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[8c280:1] = INT_LESS const[f:1], [handle:space][[handle:offset]:1]
	2: CBRANCH const[[rel:0]:4], unique[8c280:1]
	3: unique[8c300:8] = COPY [handle:space][[handle:offset+0]:8]
	4: unique[8c380:1] = INT_MULT const[8:1], [handle:space][[handle:offset]:1]
	5: [handle:space][[handle:offset+0]:8] = INT_LEFT [handle:space][[handle:offset+0]:8], unique[8c380:1]
	6: unique[8c480:1] = INT_LESS const[8:1], [handle:space][[handle:offset]:1]
	7: CBRANCH const[[rel:1]:4], unique[8c480:1]
	8: unique[8c500:1] = INT_MULT const[8:1], [handle:space][[handle:offset]:1]
	9: unique[8c580:8] = INT_LEFT [handle:space][[handle:offset+80008]:8], unique[8c500:1]
	10: unique[8c600:1] = INT_SUB const[8:1], [handle:space][[handle:offset]:1]
	11: unique[8c680:1] = INT_MULT const[8:1], unique[8c600:1]
	12: unique[8c700:8] = INT_RIGHT unique[8c300:8], unique[8c680:1]
	13: [handle:space][[handle:offset+80008]:8] = INT_OR unique[8c580:8], unique[8c700:8]
	14: BRANCH const[[rel:2]:4]
	15: PTRADD const[1:4]
	16: unique[8c800:1] = INT_SUB [handle:space][[handle:offset]:1], const[8:1]
	17: unique[8c880:1] = INT_MULT const[8:1], unique[8c800:1]
	18: [handle:space][[handle:offset+80008]:8] = INT_LEFT unique[8c300:8], unique[8c880:1]
	19: BRANCH const[[rel:2]:4]
	20: PTRADD const[0:4]
	21: [handle:space][[handle:offset+0]:8] = COPY const[0:8]
	22: [handle:space][[handle:offset+80008]:8] = COPY const[0:8]
	23: PTRADD const[2:4]

Line ia.sinc:6539 :PCMPEQB       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x74; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = (mmxreg1[0,8] == mmxreg2[0,8]) * 0xFF;
    mmxreg1[8,8] = (mmxreg1[8,8] == mmxreg2[8,8]) * 0xFF;
    mmxreg1[16,8] = (mmxreg1[16,8] == mmxreg2[16,8]) * 0xFF;
    mmxreg1[24,8] = (mmxreg1[24,8] == mmxreg2[24,8]) * 0xFF;
    mmxreg1[32,8] = (mmxreg1[32,8] == mmxreg2[32,8]) * 0xFF;
    mmxreg1[40,8] = (mmxreg1[40,8] == mmxreg2[40,8]) * 0xFF;
    mmxreg1[48,8] = (mmxreg1[48,8] == mmxreg2[48,8]) * 0xFF;
    mmxreg1[56,8] = (mmxreg1[56,8] == mmxreg2[56,8]) * 0xFF;
}
0: Constructor line ia.sinc:6539(id0.1085) printpiece=[PCMPEQB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3263  1: mmxreg2 : 3264  
Pattern id=1085 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:74:[11xx]X:XX)
Template
	0: unique[72100:1] = INT_EQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	1: [handle:space][[handle:offset+0]:1] = INT_MULT unique[72100:1], const[ff:1]
	2: unique[72200:1] = INT_EQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	3: [handle:space][[handle:offset+10001]:1] = INT_MULT unique[72200:1], const[ff:1]
	4: unique[72300:1] = INT_EQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	5: [handle:space][[handle:offset+20002]:1] = INT_MULT unique[72300:1], const[ff:1]
	6: unique[72400:1] = INT_EQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	7: [handle:space][[handle:offset+30003]:1] = INT_MULT unique[72400:1], const[ff:1]
	8: unique[72500:1] = INT_EQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	9: [handle:space][[handle:offset+40004]:1] = INT_MULT unique[72500:1], const[ff:1]
	10: unique[72600:1] = INT_EQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	11: [handle:space][[handle:offset+50005]:1] = INT_MULT unique[72600:1], const[ff:1]
	12: unique[72700:1] = INT_EQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	13: [handle:space][[handle:offset+60006]:1] = INT_MULT unique[72700:1], const[ff:1]
	14: unique[72800:1] = INT_EQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	15: [handle:space][[handle:offset+70007]:1] = INT_MULT unique[72800:1], const[ff:1]

Line ia.sinc:6526 :PCMPEQB       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x74; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = (mmxreg[0,8] == m[0,8]) * 0xFF;
    mmxreg[8,8] = (mmxreg[8,8] == m[8,8]) * 0xFF;
    mmxreg[16,8] = (mmxreg[16,8] == m[16,8]) * 0xFF;
    mmxreg[24,8] = (mmxreg[24,8] == m[24,8]) * 0xFF;
    mmxreg[32,8] = (mmxreg[32,8] == m[32,8]) * 0xFF;
    mmxreg[40,8] = (mmxreg[40,8] == m[40,8]) * 0xFF;
    mmxreg[48,8] = (mmxreg[48,8] == m[48,8]) * 0xFF;
    mmxreg[56,8] = (mmxreg[56,8] == m[56,8]) * 0xFF;
}
1: Constructor line ia.sinc:6526(id0.1084) printpiece=[PCMPEQB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3261  1: m64 : 3262  
Pattern id=1084 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:74:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[71480:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[71500:1] = SUBPIECE unique[71480:8], const[0:4]
	3: unique[71580:1] = INT_EQUAL [handle:space][[handle:offset+0]:1], unique[71500:1]
	4: [handle:space][[handle:offset+0]:1] = INT_MULT unique[71580:1], const[ff:1]
	5: unique[71680:1] = SUBPIECE unique[71480:8], const[1:4]
	6: unique[71700:1] = INT_EQUAL [handle:space][[handle:offset+10001]:1], unique[71680:1]
	7: [handle:space][[handle:offset+10001]:1] = INT_MULT unique[71700:1], const[ff:1]
	8: unique[71800:1] = SUBPIECE unique[71480:8], const[2:4]
	9: unique[71880:1] = INT_EQUAL [handle:space][[handle:offset+20002]:1], unique[71800:1]
	10: [handle:space][[handle:offset+20002]:1] = INT_MULT unique[71880:1], const[ff:1]
	11: unique[71980:1] = SUBPIECE unique[71480:8], const[3:4]
	12: unique[71a00:1] = INT_EQUAL [handle:space][[handle:offset+30003]:1], unique[71980:1]
	13: [handle:space][[handle:offset+30003]:1] = INT_MULT unique[71a00:1], const[ff:1]
	14: unique[71b00:1] = SUBPIECE unique[71480:8], const[4:4]
	15: unique[71b80:1] = INT_EQUAL [handle:space][[handle:offset+40004]:1], unique[71b00:1]
	16: [handle:space][[handle:offset+40004]:1] = INT_MULT unique[71b80:1], const[ff:1]
	17: unique[71c80:1] = SUBPIECE unique[71480:8], const[5:4]
	18: unique[71d00:1] = INT_EQUAL [handle:space][[handle:offset+50005]:1], unique[71c80:1]
	19: [handle:space][[handle:offset+50005]:1] = INT_MULT unique[71d00:1], const[ff:1]
	20: unique[71e00:1] = SUBPIECE unique[71480:8], const[6:4]
	21: unique[71e80:1] = INT_EQUAL [handle:space][[handle:offset+60006]:1], unique[71e00:1]
	22: [handle:space][[handle:offset+60006]:1] = INT_MULT unique[71e80:1], const[ff:1]
	23: unique[71f80:1] = SUBPIECE unique[71480:8], const[7:4]
	24: unique[72000:1] = INT_EQUAL [handle:space][[handle:offset+70007]:1], unique[71f80:1]
	25: [handle:space][[handle:offset+70007]:1] = INT_MULT unique[72000:1], const[ff:1]

Line ia.sinc:6603 :PCMPEQB       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x74; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = (XmmReg1[0,8] == XmmReg2[0,8]) * 0xFF;
    XmmReg1[8,8] = (XmmReg1[8,8] == XmmReg2[8,8]) * 0xFF;
    XmmReg1[16,8] = (XmmReg1[16,8] == XmmReg2[16,8]) * 0xFF;
    XmmReg1[24,8] = (XmmReg1[24,8] == XmmReg2[24,8]) * 0xFF;
    XmmReg1[32,8] = (XmmReg1[32,8] == XmmReg2[32,8]) * 0xFF;
    XmmReg1[40,8] = (XmmReg1[40,8] == XmmReg2[40,8]) * 0xFF;
    XmmReg1[48,8] = (XmmReg1[48,8] == XmmReg2[48,8]) * 0xFF;
    XmmReg1[56,8] = (XmmReg1[56,8] == XmmReg2[56,8]) * 0xFF;
    XmmReg1[64,8] = (XmmReg1[64,8] == XmmReg2[64,8]) * 0xFF;
    XmmReg1[72,8] = (XmmReg1[72,8] == XmmReg2[72,8]) * 0xFF;
    XmmReg1[80,8] = (XmmReg1[80,8] == XmmReg2[80,8]) * 0xFF;
    XmmReg1[88,8] = (XmmReg1[88,8] == XmmReg2[88,8]) * 0xFF;
    XmmReg1[96,8] = (XmmReg1[96,8] == XmmReg2[96,8]) * 0xFF;
    XmmReg1[104,8] = (XmmReg1[104,8] == XmmReg2[104,8]) * 0xFF;
    XmmReg1[112,8] = (XmmReg1[112,8] == XmmReg2[112,8]) * 0xFF;
    XmmReg1[120,8] = (XmmReg1[120,8] == XmmReg2[120,8]) * 0xFF;
}
0: Constructor line ia.sinc:6603(id0.1091) printpiece=[PCMPEQB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3275  1: XmmReg2 : 3276  
Pattern id=1091 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:74:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[75780:1] = INT_EQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	3: [handle:space][[handle:offset+0]:1] = INT_MULT unique[75780:1], const[ff:1]
	4: unique[75880:1] = INT_EQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	5: [handle:space][[handle:offset+10001]:1] = INT_MULT unique[75880:1], const[ff:1]
	6: unique[75980:1] = INT_EQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	7: [handle:space][[handle:offset+20002]:1] = INT_MULT unique[75980:1], const[ff:1]
	8: unique[75a80:1] = INT_EQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	9: [handle:space][[handle:offset+30003]:1] = INT_MULT unique[75a80:1], const[ff:1]
	10: unique[75b80:1] = INT_EQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	11: [handle:space][[handle:offset+40004]:1] = INT_MULT unique[75b80:1], const[ff:1]
	12: unique[75c80:1] = INT_EQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	13: [handle:space][[handle:offset+50005]:1] = INT_MULT unique[75c80:1], const[ff:1]
	14: unique[75d80:1] = INT_EQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	15: [handle:space][[handle:offset+60006]:1] = INT_MULT unique[75d80:1], const[ff:1]
	16: unique[75e80:1] = INT_EQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	17: [handle:space][[handle:offset+70007]:1] = INT_MULT unique[75e80:1], const[ff:1]
	18: unique[75f80:1] = INT_EQUAL [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	19: [handle:space][[handle:offset+80008]:1] = INT_MULT unique[75f80:1], const[ff:1]
	20: unique[76080:1] = INT_EQUAL [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	21: [handle:space][[handle:offset+90009]:1] = INT_MULT unique[76080:1], const[ff:1]
	22: unique[76180:1] = INT_EQUAL [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	23: [handle:space][[handle:offset+a000a]:1] = INT_MULT unique[76180:1], const[ff:1]
	24: unique[76280:1] = INT_EQUAL [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	25: [handle:space][[handle:offset+b000b]:1] = INT_MULT unique[76280:1], const[ff:1]
	26: unique[76380:1] = INT_EQUAL [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	27: [handle:space][[handle:offset+c000c]:1] = INT_MULT unique[76380:1], const[ff:1]
	28: unique[76480:1] = INT_EQUAL [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	29: [handle:space][[handle:offset+d000d]:1] = INT_MULT unique[76480:1], const[ff:1]
	30: unique[76580:1] = INT_EQUAL [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	31: [handle:space][[handle:offset+e000e]:1] = INT_MULT unique[76580:1], const[ff:1]
	32: unique[76680:1] = INT_EQUAL [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	33: [handle:space][[handle:offset+f000f]:1] = INT_MULT unique[76680:1], const[ff:1]

Line ia.sinc:6581 :PCMPEQB       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x74; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = (XmmReg[0,8] == m[0,8]) * 0xFF;
    XmmReg[8,8] = (XmmReg[8,8] == m[8,8]) * 0xFF;
    XmmReg[16,8] = (XmmReg[16,8] == m[16,8]) * 0xFF;
    XmmReg[24,8] = (XmmReg[24,8] == m[24,8]) * 0xFF;
    XmmReg[32,8] = (XmmReg[32,8] == m[32,8]) * 0xFF;
    XmmReg[40,8] = (XmmReg[40,8] == m[40,8]) * 0xFF;
    XmmReg[48,8] = (XmmReg[48,8] == m[48,8]) * 0xFF;
    XmmReg[56,8] = (XmmReg[56,8] == m[56,8]) * 0xFF;
    XmmReg[64,8] = (XmmReg[64,8] == m[64,8]) * 0xFF;
    XmmReg[72,8] = (XmmReg[72,8] == m[72,8]) * 0xFF;
    XmmReg[80,8] = (XmmReg[80,8] == m[80,8]) * 0xFF;
    XmmReg[88,8] = (XmmReg[88,8] == m[88,8]) * 0xFF;
    XmmReg[96,8] = (XmmReg[96,8] == m[96,8]) * 0xFF;
    XmmReg[104,8] = (XmmReg[104,8] == m[104,8]) * 0xFF;
    XmmReg[112,8] = (XmmReg[112,8] == m[112,8]) * 0xFF;
    XmmReg[120,8] = (XmmReg[120,8] == m[120,8]) * 0xFF;
}
1: Constructor line ia.sinc:6581(id0.1090) printpiece=[PCMPEQB,  ,  B, ,,  ,  A]
Operands 0: m128 : 3274  1: XmmReg : 3273  
Pattern id=1090 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:74:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[73f00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[73f80:1] = SUBPIECE unique[73f00:10], const[0:4]
	4: unique[74000:1] = INT_EQUAL [handle:space][[handle:offset+0]:1], unique[73f80:1]
	5: [handle:space][[handle:offset+0]:1] = INT_MULT unique[74000:1], const[ff:1]
	6: unique[74100:1] = SUBPIECE unique[73f00:10], const[1:4]
	7: unique[74180:1] = INT_EQUAL [handle:space][[handle:offset+10001]:1], unique[74100:1]
	8: [handle:space][[handle:offset+10001]:1] = INT_MULT unique[74180:1], const[ff:1]
	9: unique[74280:1] = SUBPIECE unique[73f00:10], const[2:4]
	10: unique[74300:1] = INT_EQUAL [handle:space][[handle:offset+20002]:1], unique[74280:1]
	11: [handle:space][[handle:offset+20002]:1] = INT_MULT unique[74300:1], const[ff:1]
	12: unique[74400:1] = SUBPIECE unique[73f00:10], const[3:4]
	13: unique[74480:1] = INT_EQUAL [handle:space][[handle:offset+30003]:1], unique[74400:1]
	14: [handle:space][[handle:offset+30003]:1] = INT_MULT unique[74480:1], const[ff:1]
	15: unique[74580:1] = SUBPIECE unique[73f00:10], const[4:4]
	16: unique[74600:1] = INT_EQUAL [handle:space][[handle:offset+40004]:1], unique[74580:1]
	17: [handle:space][[handle:offset+40004]:1] = INT_MULT unique[74600:1], const[ff:1]
	18: unique[74700:1] = SUBPIECE unique[73f00:10], const[5:4]
	19: unique[74780:1] = INT_EQUAL [handle:space][[handle:offset+50005]:1], unique[74700:1]
	20: [handle:space][[handle:offset+50005]:1] = INT_MULT unique[74780:1], const[ff:1]
	21: unique[74880:1] = SUBPIECE unique[73f00:10], const[6:4]
	22: unique[74900:1] = INT_EQUAL [handle:space][[handle:offset+60006]:1], unique[74880:1]
	23: [handle:space][[handle:offset+60006]:1] = INT_MULT unique[74900:1], const[ff:1]
	24: unique[74a00:1] = SUBPIECE unique[73f00:10], const[7:4]
	25: unique[74a80:1] = INT_EQUAL [handle:space][[handle:offset+70007]:1], unique[74a00:1]
	26: [handle:space][[handle:offset+70007]:1] = INT_MULT unique[74a80:1], const[ff:1]
	27: unique[74b80:1] = SUBPIECE unique[73f00:10], const[8:4]
	28: unique[74c00:1] = INT_EQUAL [handle:space][[handle:offset+80008]:1], unique[74b80:1]
	29: [handle:space][[handle:offset+80008]:1] = INT_MULT unique[74c00:1], const[ff:1]
	30: unique[74d00:1] = SUBPIECE unique[73f00:10], const[9:4]
	31: unique[74d80:1] = INT_EQUAL [handle:space][[handle:offset+90009]:1], unique[74d00:1]
	32: [handle:space][[handle:offset+90009]:1] = INT_MULT unique[74d80:1], const[ff:1]
	33: unique[74e80:1] = SUBPIECE unique[73f00:10], const[a:4]
	34: unique[74f00:1] = INT_EQUAL [handle:space][[handle:offset+a000a]:1], unique[74e80:1]
	35: [handle:space][[handle:offset+a000a]:1] = INT_MULT unique[74f00:1], const[ff:1]
	36: unique[75000:1] = SUBPIECE unique[73f00:10], const[b:4]
	37: unique[75080:1] = INT_EQUAL [handle:space][[handle:offset+b000b]:1], unique[75000:1]
	38: [handle:space][[handle:offset+b000b]:1] = INT_MULT unique[75080:1], const[ff:1]
	39: unique[75180:1] = SUBPIECE unique[73f00:10], const[c:4]
	40: unique[75200:1] = INT_EQUAL [handle:space][[handle:offset+c000c]:1], unique[75180:1]
	41: [handle:space][[handle:offset+c000c]:1] = INT_MULT unique[75200:1], const[ff:1]
	42: unique[75300:1] = SUBPIECE unique[73f00:10], const[d:4]
	43: unique[75380:1] = INT_EQUAL [handle:space][[handle:offset+d000d]:1], unique[75300:1]
	44: [handle:space][[handle:offset+d000d]:1] = INT_MULT unique[75380:1], const[ff:1]
	45: unique[75480:1] = SUBPIECE unique[73f00:10], const[e:4]
	46: unique[75500:1] = INT_EQUAL [handle:space][[handle:offset+e000e]:1], unique[75480:1]
	47: [handle:space][[handle:offset+e000e]:1] = INT_MULT unique[75500:1], const[ff:1]
	48: unique[75600:1] = SUBPIECE unique[73f00:10], const[f:4]
	49: unique[75680:1] = INT_EQUAL [handle:space][[handle:offset+f000f]:1], unique[75600:1]
	50: [handle:space][[handle:offset+f000f]:1] = INT_MULT unique[75680:1], const[ff:1]

Line ia.sinc:6560 :PCMPEQW       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x75; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = zext(mmxreg1[0,16] == mmxreg2[0,16]) * 0xFFFF;
    mmxreg1[16,16] = zext(mmxreg1[16,16] == mmxreg2[16,16]) * 0xFFFF;
    mmxreg1[32,16] = zext(mmxreg1[32,16] == mmxreg2[32,16]) * 0xFFFF;
    mmxreg1[48,16] = zext(mmxreg1[48,16] == mmxreg2[48,16]) * 0xFFFF;
}
0: Constructor line ia.sinc:6560(id0.1087) printpiece=[PCMPEQW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3267  1: mmxreg2 : 3268  
Pattern id=1087 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:75:[11xx]X:XX)
Template
	0: unique[73180:1] = INT_EQUAL [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	1: unique[73200:2] = INT_ZEXT unique[73180:1]
	2: [handle:space][[handle:offset+0]:2] = INT_MULT unique[73200:2], const[ffff:2]
	3: unique[73300:1] = INT_EQUAL [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	4: unique[73380:2] = INT_ZEXT unique[73300:1]
	5: [handle:space][[handle:offset+20002]:2] = INT_MULT unique[73380:2], const[ffff:2]
	6: unique[73480:1] = INT_EQUAL [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	7: unique[73500:2] = INT_ZEXT unique[73480:1]
	8: [handle:space][[handle:offset+40004]:2] = INT_MULT unique[73500:2], const[ffff:2]
	9: unique[73600:1] = INT_EQUAL [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	10: unique[73680:2] = INT_ZEXT unique[73600:1]
	11: [handle:space][[handle:offset+60006]:2] = INT_MULT unique[73680:2], const[ffff:2]

Line ia.sinc:6551 :PCMPEQW       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x75; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = zext(mmxreg[0,16] == m[0,16]) * 0xFFFF;
    mmxreg[16,16] = zext(mmxreg[16,16] == m[16,16]) * 0xFFFF;
    mmxreg[32,16] = zext(mmxreg[32,16] == m[32,16]) * 0xFFFF;
    mmxreg[48,16] = zext(mmxreg[48,16] == m[48,16]) * 0xFFFF;
}
1: Constructor line ia.sinc:6551(id0.1086) printpiece=[PCMPEQW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3265  1: m64 : 3266  
Pattern id=1086 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:75:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[72900:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[72980:2] = SUBPIECE unique[72900:8], const[0:4]
	3: unique[72a00:1] = INT_EQUAL [handle:space][[handle:offset+0]:2], unique[72980:2]
	4: unique[72a80:2] = INT_ZEXT unique[72a00:1]
	5: [handle:space][[handle:offset+0]:2] = INT_MULT unique[72a80:2], const[ffff:2]
	6: unique[72b80:2] = SUBPIECE unique[72900:8], const[2:4]
	7: unique[72c00:1] = INT_EQUAL [handle:space][[handle:offset+20002]:2], unique[72b80:2]
	8: unique[72c80:2] = INT_ZEXT unique[72c00:1]
	9: [handle:space][[handle:offset+20002]:2] = INT_MULT unique[72c80:2], const[ffff:2]
	10: unique[72d80:2] = SUBPIECE unique[72900:8], const[4:4]
	11: unique[72e00:1] = INT_EQUAL [handle:space][[handle:offset+40004]:2], unique[72d80:2]
	12: unique[72e80:2] = INT_ZEXT unique[72e00:1]
	13: [handle:space][[handle:offset+40004]:2] = INT_MULT unique[72e80:2], const[ffff:2]
	14: unique[72f80:2] = SUBPIECE unique[72900:8], const[6:4]
	15: unique[73000:1] = INT_EQUAL [handle:space][[handle:offset+60006]:2], unique[72f80:2]
	16: unique[73080:2] = INT_ZEXT unique[73000:1]
	17: [handle:space][[handle:offset+60006]:2] = INT_MULT unique[73080:2], const[ffff:2]

Line ia.sinc:6636 :PCMPEQW       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x75; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = zext(XmmReg1[0,16] == XmmReg2[0,16]) * 0xFFFF;
    XmmReg1[16,16] = zext(XmmReg1[16,16] == XmmReg2[16,16]) * 0xFFFF;
    XmmReg1[32,16] = zext(XmmReg1[32,16] == XmmReg2[32,16]) * 0xFFFF;
    XmmReg1[48,16] = zext(XmmReg1[48,16] == XmmReg2[48,16]) * 0xFFFF;
    XmmReg1[64,16] = zext(XmmReg1[64,16] == XmmReg2[64,16]) * 0xFFFF;
    XmmReg1[80,16] = zext(XmmReg1[80,16] == XmmReg2[80,16]) * 0xFFFF;
    XmmReg1[96,16] = zext(XmmReg1[96,16] == XmmReg2[96,16]) * 0xFFFF;
    XmmReg1[112,16] = zext(XmmReg1[112,16] == XmmReg2[112,16]) * 0xFFFF;
}
0: Constructor line ia.sinc:6636(id0.1093) printpiece=[PCMPEQW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3279  1: XmmReg2 : 3280  
Pattern id=1093 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:75:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[77800:1] = INT_EQUAL [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: unique[77880:2] = INT_ZEXT unique[77800:1]
	4: [handle:space][[handle:offset+0]:2] = INT_MULT unique[77880:2], const[ffff:2]
	5: unique[77980:1] = INT_EQUAL [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	6: unique[77a00:2] = INT_ZEXT unique[77980:1]
	7: [handle:space][[handle:offset+20002]:2] = INT_MULT unique[77a00:2], const[ffff:2]
	8: unique[77b00:1] = INT_EQUAL [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	9: unique[77b80:2] = INT_ZEXT unique[77b00:1]
	10: [handle:space][[handle:offset+40004]:2] = INT_MULT unique[77b80:2], const[ffff:2]
	11: unique[77c80:1] = INT_EQUAL [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	12: unique[77d00:2] = INT_ZEXT unique[77c80:1]
	13: [handle:space][[handle:offset+60006]:2] = INT_MULT unique[77d00:2], const[ffff:2]
	14: unique[77e00:1] = INT_EQUAL [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	15: unique[77e80:2] = INT_ZEXT unique[77e00:1]
	16: [handle:space][[handle:offset+80008]:2] = INT_MULT unique[77e80:2], const[ffff:2]
	17: unique[77f80:1] = INT_EQUAL [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	18: unique[78000:2] = INT_ZEXT unique[77f80:1]
	19: [handle:space][[handle:offset+a000a]:2] = INT_MULT unique[78000:2], const[ffff:2]
	20: unique[78100:1] = INT_EQUAL [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	21: unique[78180:2] = INT_ZEXT unique[78100:1]
	22: [handle:space][[handle:offset+c000c]:2] = INT_MULT unique[78180:2], const[ffff:2]
	23: unique[78280:1] = INT_EQUAL [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]
	24: unique[78300:2] = INT_ZEXT unique[78280:1]
	25: [handle:space][[handle:offset+e000e]:2] = INT_MULT unique[78300:2], const[ffff:2]

Line ia.sinc:6623 :PCMPEQW       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x75; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = zext(XmmReg[0,16] == m[0,16]) * 0xFFFF;
    XmmReg[16,16] = zext(XmmReg[16,16] == m[16,16]) * 0xFFFF;
    XmmReg[32,16] = zext(XmmReg[32,16] == m[32,16]) * 0xFFFF;
    XmmReg[48,16] = zext(XmmReg[48,16] == m[48,16]) * 0xFFFF;
    XmmReg[64,16] = zext(XmmReg[64,16] == m[64,16]) * 0xFFFF;
    XmmReg[80,16] = zext(XmmReg[80,16] == m[80,16]) * 0xFFFF;
    XmmReg[96,16] = zext(XmmReg[96,16] == m[96,16]) * 0xFFFF;
    XmmReg[112,16] = zext(XmmReg[112,16] == m[112,16]) * 0xFFFF;
}
1: Constructor line ia.sinc:6623(id0.1092) printpiece=[PCMPEQW,  ,  B, ,,  ,  A]
Operands 0: m128 : 3278  1: XmmReg : 3277  
Pattern id=1092 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:75:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[76780:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[76800:2] = SUBPIECE unique[76780:10], const[0:4]
	4: unique[76880:1] = INT_EQUAL [handle:space][[handle:offset+0]:2], unique[76800:2]
	5: unique[76900:2] = INT_ZEXT unique[76880:1]
	6: [handle:space][[handle:offset+0]:2] = INT_MULT unique[76900:2], const[ffff:2]
	7: unique[76a00:2] = SUBPIECE unique[76780:10], const[2:4]
	8: unique[76a80:1] = INT_EQUAL [handle:space][[handle:offset+20002]:2], unique[76a00:2]
	9: unique[76b00:2] = INT_ZEXT unique[76a80:1]
	10: [handle:space][[handle:offset+20002]:2] = INT_MULT unique[76b00:2], const[ffff:2]
	11: unique[76c00:2] = SUBPIECE unique[76780:10], const[4:4]
	12: unique[76c80:1] = INT_EQUAL [handle:space][[handle:offset+40004]:2], unique[76c00:2]
	13: unique[76d00:2] = INT_ZEXT unique[76c80:1]
	14: [handle:space][[handle:offset+40004]:2] = INT_MULT unique[76d00:2], const[ffff:2]
	15: unique[76e00:2] = SUBPIECE unique[76780:10], const[6:4]
	16: unique[76e80:1] = INT_EQUAL [handle:space][[handle:offset+60006]:2], unique[76e00:2]
	17: unique[76f00:2] = INT_ZEXT unique[76e80:1]
	18: [handle:space][[handle:offset+60006]:2] = INT_MULT unique[76f00:2], const[ffff:2]
	19: unique[77000:2] = SUBPIECE unique[76780:10], const[8:4]
	20: unique[77080:1] = INT_EQUAL [handle:space][[handle:offset+80008]:2], unique[77000:2]
	21: unique[77100:2] = INT_ZEXT unique[77080:1]
	22: [handle:space][[handle:offset+80008]:2] = INT_MULT unique[77100:2], const[ffff:2]
	23: unique[77200:2] = SUBPIECE unique[76780:10], const[a:4]
	24: unique[77280:1] = INT_EQUAL [handle:space][[handle:offset+a000a]:2], unique[77200:2]
	25: unique[77300:2] = INT_ZEXT unique[77280:1]
	26: [handle:space][[handle:offset+a000a]:2] = INT_MULT unique[77300:2], const[ffff:2]
	27: unique[77400:2] = SUBPIECE unique[76780:10], const[c:4]
	28: unique[77480:1] = INT_EQUAL [handle:space][[handle:offset+c000c]:2], unique[77400:2]
	29: unique[77500:2] = INT_ZEXT unique[77480:1]
	30: [handle:space][[handle:offset+c000c]:2] = INT_MULT unique[77500:2], const[ffff:2]
	31: unique[77600:2] = SUBPIECE unique[76780:10], const[e:4]
	32: unique[77680:1] = INT_EQUAL [handle:space][[handle:offset+e000e]:2], unique[77600:2]
	33: unique[77700:2] = INT_ZEXT unique[77680:1]
	34: [handle:space][[handle:offset+e000e]:2] = INT_MULT unique[77700:2], const[ffff:2]

Line ia.sinc:6575 :PCMPEQD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x76; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32] = zext(mmxreg1[0,32] == mmxreg2[0,32]) * 0xFFFFFFFF;
    mmxreg1[32,32] = zext(mmxreg1[32,32] == mmxreg2[32,32]) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:6575(id0.1089) printpiece=[PCMPEQD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3271  1: mmxreg2 : 3272  
Pattern id=1089 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:76:[11xx]X:XX)
Template
	0: unique[73c00:1] = INT_EQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	1: unique[73c80:4] = INT_ZEXT unique[73c00:1]
	2: [handle:space][[handle:offset+0]:4] = INT_MULT unique[73c80:4], const[ffffffff:4]
	3: unique[73d80:1] = INT_EQUAL [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: unique[73e00:4] = INT_ZEXT unique[73d80:1]
	5: [handle:space][[handle:offset+40004]:4] = INT_MULT unique[73e00:4], const[ffffffff:4]

Line ia.sinc:6568 :PCMPEQD       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x76; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,32] = zext(mmxreg[0,32] == m[0,32]) * 0xFFFFFFFF;
    mmxreg[32,32] = zext(mmxreg[32,32] == m[32,32]) * 0xFFFFFFFF;
}
1: Constructor line ia.sinc:6568(id0.1088) printpiece=[PCMPEQD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3269  1: m64 : 3270  
Pattern id=1088 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:76:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[73780:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[73800:4] = SUBPIECE unique[73780:8], const[0:4]
	3: unique[73880:1] = INT_EQUAL [handle:space][[handle:offset+0]:4], unique[73800:4]
	4: unique[73900:4] = INT_ZEXT unique[73880:1]
	5: [handle:space][[handle:offset+0]:4] = INT_MULT unique[73900:4], const[ffffffff:4]
	6: unique[73a00:4] = SUBPIECE unique[73780:8], const[4:4]
	7: unique[73a80:1] = INT_EQUAL [handle:space][[handle:offset+40004]:4], unique[73a00:4]
	8: unique[73b00:4] = INT_ZEXT unique[73a80:1]
	9: [handle:space][[handle:offset+40004]:4] = INT_MULT unique[73b00:4], const[ffffffff:4]

Line ia.sinc:6657 :PCMPEQD       XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x76; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = zext(XmmReg1[0,32] == XmmReg2[0,32]) * 0xFFFFFFFF;
    XmmReg1[32,32] = zext(XmmReg1[32,32] == XmmReg2[32,32]) * 0xFFFFFFFF;
    XmmReg1[64,32] = zext(XmmReg1[64,32] == XmmReg2[64,32]) * 0xFFFFFFFF;
    XmmReg1[96,32] = zext(XmmReg1[96,32] == XmmReg2[96,32]) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:6657(id0.1095) printpiece=[PCMPEQD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3283  1: XmmReg2 : 3284  
Pattern id=1095 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:76:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[78c80:1] = INT_EQUAL [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: unique[78d00:4] = INT_ZEXT unique[78c80:1]
	4: [handle:space][[handle:offset+0]:4] = INT_MULT unique[78d00:4], const[ffffffff:4]
	5: unique[78e00:1] = INT_EQUAL [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	6: unique[78e80:4] = INT_ZEXT unique[78e00:1]
	7: [handle:space][[handle:offset+40004]:4] = INT_MULT unique[78e80:4], const[ffffffff:4]
	8: unique[78f80:1] = INT_EQUAL [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	9: unique[79000:4] = INT_ZEXT unique[78f80:1]
	10: [handle:space][[handle:offset+80008]:4] = INT_MULT unique[79000:4], const[ffffffff:4]
	11: unique[79100:1] = INT_EQUAL [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]
	12: unique[79180:4] = INT_ZEXT unique[79100:1]
	13: [handle:space][[handle:offset+c000c]:4] = INT_MULT unique[79180:4], const[ffffffff:4]

Line ia.sinc:6648 :PCMPEQD       XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x76; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = zext(XmmReg[0,32] == m[0,32]) * 0xFFFFFFFF;
    XmmReg[32,32] = zext(XmmReg[32,32] == m[32,32]) * 0xFFFFFFFF;
    XmmReg[64,32] = zext(XmmReg[64,32] == m[64,32]) * 0xFFFFFFFF;
    XmmReg[96,32] = zext(XmmReg[96,32] == m[96,32]) * 0xFFFFFFFF;
}
1: Constructor line ia.sinc:6648(id0.1094) printpiece=[PCMPEQD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3282  1: XmmReg : 3281  
Pattern id=1094 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:76:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[78400:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[78480:4] = SUBPIECE unique[78400:10], const[0:4]
	4: unique[78500:1] = INT_EQUAL [handle:space][[handle:offset+0]:4], unique[78480:4]
	5: unique[78580:4] = INT_ZEXT unique[78500:1]
	6: [handle:space][[handle:offset+0]:4] = INT_MULT unique[78580:4], const[ffffffff:4]
	7: unique[78680:4] = SUBPIECE unique[78400:10], const[4:4]
	8: unique[78700:1] = INT_EQUAL [handle:space][[handle:offset+40004]:4], unique[78680:4]
	9: unique[78780:4] = INT_ZEXT unique[78700:1]
	10: [handle:space][[handle:offset+40004]:4] = INT_MULT unique[78780:4], const[ffffffff:4]
	11: unique[78880:4] = SUBPIECE unique[78400:10], const[8:4]
	12: unique[78900:1] = INT_EQUAL [handle:space][[handle:offset+80008]:4], unique[78880:4]
	13: unique[78980:4] = INT_ZEXT unique[78900:1]
	14: [handle:space][[handle:offset+80008]:4] = INT_MULT unique[78980:4], const[ffffffff:4]
	15: unique[78a80:4] = SUBPIECE unique[78400:10], const[c:4]
	16: unique[78b00:1] = INT_EQUAL [handle:space][[handle:offset+c000c]:4], unique[78a80:4]
	17: unique[78b80:4] = INT_ZEXT unique[78b00:1]
	18: [handle:space][[handle:offset+c000c]:4] = INT_MULT unique[78b80:4], const[ffffffff:4]

Line ia.sinc:5511 :EMMS                     is vexMode=0 &  byte=0x0F; byte=0x77 { FPUTagWord = 0xFFFF; }
0: Constructor line ia.sinc:5511(id0.901) printpiece=[EMMS]
Operands 
Pattern id=901 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:77:XX:XX)
Template
	0: register[10a4:2] = COPY const[ffff:2]

Line ia.sinc:3911 :VMREAD rm32, Reg32  is vexMode=0 & opsize=1 & byte=0x0f; byte=0x78; rm32 & check_rm32_dest ... & Reg32 ...     { rm32 = vmread(Reg32); build check_rm32_dest; }
0: Constructor line ia.sinc:3911(id0.614) printpiece=[VMREAD,  ,  A, ,,  ,  C]
Operands 0: rm32 : 2433  1: check_rm32_dest : 2435  2: Reg32 : 2434  
Pattern id=614 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:78:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[21:4], [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:3915 :VMWRITE Reg32, rm32 is vexMode=0 & opsize=1 & byte=0x0f; byte=0x79; rm32 & Reg32 ... & check_Reg32_dest ...   { vmwrite(rm32,Reg32); build check_Reg32_dest; }
0: Constructor line ia.sinc:3915(id0.615) printpiece=[VMWRITE,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2437  1: Reg32 : 2436  2: check_Reg32_dest : 2438  
Pattern id=615 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:79:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[22:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[2:4]

Line ia.sinc:5520 :HADDPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f+ XmmReg1[64,64];
    XmmReg1[64,64] = XmmReg2[0,64] f+ XmmReg2[64,64];
}
0: Constructor line ia.sinc:5520(id0.903) printpiece=[HADDPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2873  1: XmmReg2 : 2874  
Pattern id=903 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:7C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+80008]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5513 :HADDPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7C; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f+ XmmReg[64,64];
    XmmReg[64,64] = m[0,64]   f+ m[64,64];
}
1: Constructor line ia.sinc:5513(id0.902) printpiece=[HADDPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 2872  1: XmmReg : 2871  
Pattern id=902 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:7C:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5f500:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:8] = FLOAT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+80008]:8]
	4: unique[5f600:8] = SUBPIECE unique[5f500:10], const[0:4]
	5: unique[5f680:8] = SUBPIECE unique[5f500:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD unique[5f600:8], unique[5f680:8]

Line ia.sinc:5535 :HADDPS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x7C; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f+ XmmReg1[32,32];
    XmmReg1[32,32] = XmmReg1[64,32] f+ XmmReg1[96,32];
    XmmReg1[64,32] = XmmReg2[0,32] f+ XmmReg2[32,32];
    XmmReg1[96,32] = XmmReg2[64,32] f+ XmmReg2[96,32];
}
2: Constructor line ia.sinc:5535(id0.905) printpiece=[HADDPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2877  1: XmmReg2 : 2878  
Pattern id=905 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:7C:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+40004]:4]
	3: [handle:space][[handle:offset+40004]:4] = FLOAT_ADD [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+c000c]:4]
	4: [handle:space][[handle:offset+80008]:4] = FLOAT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+40004]:4]
	5: [handle:space][[handle:offset+c000c]:4] = FLOAT_ADD [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5526 :HADDPS        XmmReg, m128        is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x7C; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f+ XmmReg[32,32];
    XmmReg[32,32] = XmmReg[64,32] f+ XmmReg[96,32];
    XmmReg[64,32] = m[0,32]   f+ m[32,32];
    XmmReg[96,32] = m[64,32]   f+ m[96,32];
}
3: Constructor line ia.sinc:5526(id0.904) printpiece=[HADDPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2876  1: XmmReg : 2875  
Pattern id=904 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:7C:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5f880:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:4] = FLOAT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+40004]:4] = FLOAT_ADD [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+c000c]:4]
	5: unique[5fa00:4] = SUBPIECE unique[5f880:10], const[0:4]
	6: unique[5fa80:4] = SUBPIECE unique[5f880:10], const[4:4]
	7: [handle:space][[handle:offset+80008]:4] = FLOAT_ADD unique[5fa00:4], unique[5fa80:4]
	8: unique[5fb80:4] = SUBPIECE unique[5f880:10], const[8:4]
	9: unique[5fc00:4] = SUBPIECE unique[5f880:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = FLOAT_ADD unique[5fb80:4], unique[5fc00:4]

Line ia.sinc:5550 :HSUBPD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7D; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg1[64,64];
    XmmReg1[64,64] = XmmReg2[0,64] f- XmmReg2[64,64];
}
0: Constructor line ia.sinc:5550(id0.907) printpiece=[HSUBPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2881  1: XmmReg2 : 2882  
Pattern id=907 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:7D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+80008]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:5543 :HSUBPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7D; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f- XmmReg[64,64];
    XmmReg[64,64] = m[0,64]   f- m[64,64];
}
1: Constructor line ia.sinc:5543(id0.906) printpiece=[HSUBPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 2880  1: XmmReg : 2879  
Pattern id=906 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:7D:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5ff00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+80008]:8]
	4: unique[60000:8] = SUBPIECE unique[5ff00:10], const[0:4]
	5: unique[60080:8] = SUBPIECE unique[5ff00:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT_SUB unique[60000:8], unique[60080:8]

Line ia.sinc:5565 :HSUBPS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x7D; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f- XmmReg1[32,32];
    XmmReg1[32,32] = XmmReg1[64,32] f- XmmReg1[96,32];
    XmmReg1[64,32] = XmmReg2[0,32] f- XmmReg2[32,32];
    XmmReg1[96,32] = XmmReg2[64,32] f- XmmReg2[96,32];
}
2: Constructor line ia.sinc:5565(id0.909) printpiece=[HSUBPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2885  1: XmmReg2 : 2886  
Pattern id=909 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:7D:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+40004]:4]
	3: [handle:space][[handle:offset+40004]:4] = FLOAT_SUB [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+c000c]:4]
	4: [handle:space][[handle:offset+80008]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+40004]:4]
	5: [handle:space][[handle:offset+c000c]:4] = FLOAT_SUB [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:5556 :HSUBPS        XmmReg, m128        is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x7D; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f- XmmReg[32,32];
    XmmReg[32,32] = XmmReg[64,32] f- XmmReg[96,32];
    XmmReg[64,32] = m[0,32]   f- m[32,32];
    XmmReg[96,32] = m[64,32]   f- m[96,32];
}
3: Constructor line ia.sinc:5556(id0.908) printpiece=[HSUBPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2884  1: XmmReg : 2883  
Pattern id=908 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:7D:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[60280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+40004]:4] = FLOAT_SUB [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+c000c]:4]
	5: unique[60400:4] = SUBPIECE unique[60280:10], const[0:4]
	6: unique[60480:4] = SUBPIECE unique[60280:10], const[4:4]
	7: [handle:space][[handle:offset+80008]:4] = FLOAT_SUB unique[60400:4], unique[60480:4]
	8: unique[60580:4] = SUBPIECE unique[60280:10], const[8:4]
	9: unique[60600:4] = SUBPIECE unique[60280:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = FLOAT_SUB unique[60580:4], unique[60600:4]

Line ia.sinc:5706 :MOVD         rm32, mmxreg   is vexMode=0 &  rexWprefix=0 & mandover=0 & byte=0x0F; byte=0x7E; rm32 & check_rm32_dest ... & mmxreg ...                    { rm32 = mmxreg(0); build check_rm32_dest; }
0: Constructor line ia.sinc:5706(id0.937) printpiece=[MOVD,  ,  A, ,,  ,  C]
Operands 0: rm32 : 2947  1: check_rm32_dest : 2949  2: mmxreg : 2948  
Pattern id=937 pattern=cmb:(ctx:SS:X0:X[0xxx]:XX:XX,ins:0F:7E:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE [handle:space][[handle:offset]:[handle:size]], const[0:4]
	2: MULTIEQUAL const[1:4]

Line ia.sinc:5708 :MOVD         rm32, XmmReg   is vexMode=0 &  $(PRE_66) & rexWprefix=0 & byte=0x0F; byte=0x7E; rm32 & check_rm32_dest ... & XmmReg ...         { rm32 = XmmReg(0); build check_rm32_dest; }
0: Constructor line ia.sinc:5708(id0.939) printpiece=[MOVD,  ,  A, ,,  ,  C]
Operands 0: rm32 : 2952  1: check_rm32_dest : 2954  2: XmmReg : 2953  
Pattern id=939 pattern=cmb:(ctx:SS:X[xx10]:X[0xxx]:XX:XX,ins:0F:7E:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE [handle:space][[handle:offset]:[handle:size]], const[0:4]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:5708 :MOVD         rm32, XmmReg   is vexMode=0 &  $(PRE_66) & rexWprefix=0 & byte=0x0F; byte=0x7E; rm32 & check_rm32_dest ... & XmmReg ...         { rm32 = XmmReg(0); build check_rm32_dest; }
0: Constructor line ia.sinc:5708(id0.939) printpiece=[MOVD,  ,  A, ,,  ,  C]
Operands 0: rm32 : 2952  1: check_rm32_dest : 2954  2: XmmReg : 2953  
Pattern id=939 pattern=cmb:(ctx:SS:X[xx10]:X[0xxx]:XX:XX,ins:0F:7E:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE [handle:space][[handle:offset]:[handle:size]], const[0:4]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:5821 :MOVQ         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x7E; xmmmod = 3 & XmmReg1 & XmmReg2
{
	XmmReg1 = zext(XmmReg2[0,64]);
}
1: Constructor line ia.sinc:5821(id0.976) printpiece=[MOVQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3030  1: XmmReg2 : 3031  
Pattern id=976 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:7E:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:8]

Line ia.sinc:5816 :MOVQ         XmmReg, m64      is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x7E; XmmReg ... & m64
{
	XmmReg = zext(m64);
}
2: Constructor line ia.sinc:5816(id0.975) printpiece=[MOVQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3028  1: m64 : 3029  
Pattern id=975 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:7E:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5814 :MOVQ         mmxreg2, mmxreg1 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x7F; mmxmod = 3 & mmxreg1 & mmxreg2     { mmxreg2 = mmxreg1; }
0: Constructor line ia.sinc:5814(id0.974) printpiece=[MOVQ,  ,  B, ,,  ,  A]
Operands 0: mmxreg1 : 3027  1: mmxreg2 : 3026  
Pattern id=974 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:7F:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5813 :MOVQ         m64, mmxreg      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x7F; mmxreg ... & m64                   { m64 = mmxreg; }
1: Constructor line ia.sinc:5813(id0.973) printpiece=[MOVQ,  ,  B, ,,  ,  A]
Operands 0: mmxreg : 3025  1: m64 : 3024  
Pattern id=973 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:7F:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5765 :MOVDQA       XmmReg2, XmmReg1    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg2 = XmmReg1; }
0: Constructor line ia.sinc:5765(id0.949) printpiece=[MOVDQA,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 2974  1: XmmReg2 : 2973  
Pattern id=949 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:7F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5764 :MOVDQA       m128, XmmReg        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7F; XmmReg ... & m128            { m128 = XmmReg; }
1: Constructor line ia.sinc:5764(id0.948) printpiece=[MOVDQA,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 2972  1: m128 : 2971  
Pattern id=948 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:7F:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5765 :MOVDQA       XmmReg2, XmmReg1    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg2 = XmmReg1; }
0: Constructor line ia.sinc:5765(id0.949) printpiece=[MOVDQA,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 2974  1: XmmReg2 : 2973  
Pattern id=949 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:7F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5764 :MOVDQA       m128, XmmReg        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x7F; XmmReg ... & m128            { m128 = XmmReg; }
1: Constructor line ia.sinc:5764(id0.948) printpiece=[MOVDQA,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 2972  1: m128 : 2971  
Pattern id=948 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:7F:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5770 :MOVDQU       XmmReg2, XmmReg1    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x7F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg2 = XmmReg1; }
2: Constructor line ia.sinc:5770(id0.953) printpiece=[MOVDQU,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 2982  1: XmmReg2 : 2981  
Pattern id=953 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:7F:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5769 :MOVDQU       m128, XmmReg        is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x7F; XmmReg ... & m128            { m128 = XmmReg; }  
3: Constructor line ia.sinc:5769(id0.952) printpiece=[MOVDQU,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 2980  1: m128 : 2979  
Pattern id=952 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:7F:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:2834 :J^cc rel16     is vexMode=0 & bit64=0 & opsize=0 & byte=0xf; row=8 & cc; rel16       { if (cc) goto rel16; }
0: Constructor line ia.sinc:2834(id0.221) printpiece=[J,  A,  ,  B]
Operands 0: cc : 1774  1: rel16 : 1775  
Pattern id=221 pattern=cmb:(ctx:X[0x00]:XX:X[0xxx]:XX,ins:0F:8X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2835 :J^cc rel32     is vexMode=0 & opsize=1 & byte=0xf; row=8 & cc; rel32                 { if (cc) goto rel32; }
0: Constructor line ia.sinc:2835(id0.222) printpiece=[J,  A,  ,  B]
Operands 0: cc : 1776  1: rel32 : 1777  
Pattern id=222 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:8X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2836 :J^cc rel32     is vexMode=0 & opsize=2 & byte=0xf; row=8 & cc; rel32                 { if (cc) goto rel32; }
0: Constructor line ia.sinc:2836(id0.223) printpiece=[J,  A,  ,  B]
Operands 0: cc : 1778  1: rel32 : 1779  
Pattern id=223 pattern=cmb:(ctx:X[xx10]:XX:X[0xxx]:XX,ins:0F:8X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3614 :SET^cc rm8     is vexMode=0 & byte=0xf; row=9 & cc; rm8                { rm8 = cc; }
0: Constructor line ia.sinc:3614(id0.522) printpiece=[SET,  A,  ,  B]
Operands 0: cc : 2270  1: rm8 : 2271  
Pattern id=522 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:9X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3380 :PUSH FS        is vexMode=0 & addrsize=0 & byte=0xf; byte=0xa0 & FS        { push22(FS); }
0: Constructor line ia.sinc:3380(id0.424) printpiece=[PUSH,  ,  A]
Operands 0: FS : 2102  
Pattern id=424 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:0F:A0:XX:XX)
Template
	0: unique[9400:2] = COPY register[108:2]
	1: register[10:2] = INT_SUB register[10:2], const[2:2]
	2: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	3: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3381 :PUSH FS        is vexMode=0 & addrsize=1 & byte=0xf; byte=0xa0 & FS        { pushseg44(FS); }
0: Constructor line ia.sinc:3381(id0.425) printpiece=[PUSH,  ,  A]
Operands 0: FS : 2103  
Pattern id=425 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:0F:A0:XX:XX)
Template
	0: register[10:4] = INT_SUB register[10:4], const[4:4]
	1: STORE const[ram:8], register[10:4], register[108:2]

Line ia.sinc:3294 :POP FS         is vexMode=0 & addrsize=0 & byte=0xf; byte=0xa1 & FS    { pop22(FS); }
0: Constructor line ia.sinc:3294(id0.379) printpiece=[POP,  ,  A]
Operands 0: FS : 2063  
Pattern id=379 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:0F:A1:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[108:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]

Line ia.sinc:3295 :POP FS         is vexMode=0 & addrsize=1 & byte=0xf; byte=0xa1 & FS    { popseg44(FS); }
0: Constructor line ia.sinc:3295(id0.380) printpiece=[POP,  ,  A]
Operands 0: FS : 2064  
Pattern id=380 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:0F:A1:XX:XX)
Template
	0: register[108:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]

Line ia.sinc:2327 :CPUID          is vexMode=0 & byte=0xf; byte=0xa2                  {
    tmpptr:$(SIZE) = 0;
    if (EAX == 0) goto <basic_info>;
    if (EAX == 1) goto <Version_info>;
    if (EAX == 2) goto <cache_tlb_info>;
    if (EAX == 3) goto <serial_info>;
    if (EAX == 0x4) goto <Deterministic_Cache_Parameters_info>;
    if (EAX == 0x5) goto <MONITOR_MWAIT_Features_info>;
    if (EAX == 0x6) goto <Thermal_Power_Management_info>;
    if (EAX == 0x7) goto <Extended_Feature_Enumeration_info>;
    if (EAX == 0x9) goto <Direct_Cache_Access_info>;
    if (EAX == 0xa) goto <Architectural_Performance_Monitoring_info>;
    if (EAX == 0xb) goto <Extended_Topology_info>;
    if (EAX == 0xd) goto <Processor_Extended_States_info>;
    if (EAX == 0xf) goto <Quality_of_Service_info>;
    if (EAX == 0x80000002) goto <brand_part1_info>;
    if (EAX == 0x80000003) goto <brand_part2_info>;
    if (EAX == 0x80000004) goto <brand_part3_info>;
    tmpptr = cpuid(EAX);
    goto <finish>;
 <basic_info>
    tmpptr = cpuid_basic_info(EAX);
    goto <finish>;
 <Version_info>
    tmpptr = cpuid_Version_info(EAX);
    goto <finish>;
 <cache_tlb_info>
    tmpptr = cpuid_cache_tlb_info(EAX);
    goto <finish>;
 <serial_info>
    tmpptr = cpuid_serial_info(EAX);
    goto <finish>;
 <Deterministic_Cache_Parameters_info>
    tmpptr = cpuid_Deterministic_Cache_Parameters_info(EAX);
    goto <finish>;    
 <MONITOR_MWAIT_Features_info>
    tmpptr = cpuid_MONITOR_MWAIT_Features_info(EAX);
    goto <finish>;    
 <Thermal_Power_Management_info>
    tmpptr = cpuid_Thermal_Power_Management_info(EAX);
    goto <finish>;
 <Extended_Feature_Enumeration_info>
    tmpptr = cpuid_Extended_Feature_Enumeration_info(EAX);
    goto <finish>;
 <Direct_Cache_Access_info>
    tmpptr = cpuid_Direct_Cache_Access_info(EAX);
    goto <finish>;
 <Architectural_Performance_Monitoring_info>
    tmpptr = cpuid_Architectural_Performance_Monitoring_info(EAX);
    goto <finish>;
 <Extended_Topology_info>
    tmpptr = cpuid_Extended_Topology_info(EAX);
    goto <finish>;
 <Processor_Extended_States_info>
    tmpptr = cpuid_Processor_Extended_States_info(EAX);
    goto <finish>;
 <Quality_of_Service_info>
    tmpptr = cpuid_Quality_of_Service_info(EAX);
    goto <finish>;
 <brand_part1_info>
    tmpptr = cpuid_brand_part1_info(EAX);
    goto <finish>;
 <brand_part2_info>
    tmpptr = cpuid_brand_part2_info(EAX);
    goto <finish>;
 <brand_part3_info>
    tmpptr = cpuid_brand_part3_info(EAX);
    goto <finish>;  
 <finish>
@ifdef IA64
	RAX = zext(*:4 (tmpptr));
	RBX = zext(*:4 (tmpptr + 4));
	RDX = zext(*:4 (tmpptr + 8));
	RCX = zext(*:4 (tmpptr + 12));
@else
	EAX = *tmpptr;
	EBX = *(tmpptr + 4);
	EDX = *(tmpptr + 8);
	ECX = *(tmpptr + 12);
@endif
}
0: Constructor line ia.sinc:2327(id0.159) printpiece=[CPUID]
Operands 
Pattern id=159 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A2:XX:XX)
Template
	0: unique[20500:4] = COPY const[0:4]
	1: unique[20580:1] = INT_EQUAL register[0:4], const[0:4]
	2: CBRANCH const[[rel:0]:4], unique[20580:1]
	3: unique[20600:1] = INT_EQUAL register[0:4], const[1:4]
	4: CBRANCH const[[rel:1]:4], unique[20600:1]
	5: unique[20680:1] = INT_EQUAL register[0:4], const[2:4]
	6: CBRANCH const[[rel:2]:4], unique[20680:1]
	7: unique[20700:1] = INT_EQUAL register[0:4], const[3:4]
	8: CBRANCH const[[rel:3]:4], unique[20700:1]
	9: unique[20780:1] = INT_EQUAL register[0:4], const[4:4]
	10: CBRANCH const[[rel:4]:4], unique[20780:1]
	11: unique[20800:1] = INT_EQUAL register[0:4], const[5:4]
	12: CBRANCH const[[rel:5]:4], unique[20800:1]
	13: unique[20880:1] = INT_EQUAL register[0:4], const[6:4]
	14: CBRANCH const[[rel:6]:4], unique[20880:1]
	15: unique[20900:1] = INT_EQUAL register[0:4], const[7:4]
	16: CBRANCH const[[rel:7]:4], unique[20900:1]
	17: unique[20980:1] = INT_EQUAL register[0:4], const[9:4]
	18: CBRANCH const[[rel:8]:4], unique[20980:1]
	19: unique[20a00:1] = INT_EQUAL register[0:4], const[a:4]
	20: CBRANCH const[[rel:9]:4], unique[20a00:1]
	21: unique[20a80:1] = INT_EQUAL register[0:4], const[b:4]
	22: CBRANCH const[[rel:a]:4], unique[20a80:1]
	23: unique[20b00:1] = INT_EQUAL register[0:4], const[d:4]
	24: CBRANCH const[[rel:b]:4], unique[20b00:1]
	25: unique[20b80:1] = INT_EQUAL register[0:4], const[f:4]
	26: CBRANCH const[[rel:c]:4], unique[20b80:1]
	27: unique[20c00:1] = INT_EQUAL register[0:4], const[80000002:4]
	28: CBRANCH const[[rel:d]:4], unique[20c00:1]
	29: unique[20c80:1] = INT_EQUAL register[0:4], const[80000003:4]
	30: CBRANCH const[[rel:e]:4], unique[20c80:1]
	31: unique[20d00:1] = INT_EQUAL register[0:4], const[80000004:4]
	32: CBRANCH const[[rel:f]:4], unique[20d00:1]
	33: unique[20500:4] = CALLOTHER const[2a:4], register[0:4]
	34: BRANCH const[[rel:10]:4]
	35: PTRADD const[0:4]
	36: unique[20500:4] = CALLOTHER const[2b:4], register[0:4]
	37: BRANCH const[[rel:10]:4]
	38: PTRADD const[1:4]
	39: unique[20500:4] = CALLOTHER const[2c:4], register[0:4]
	40: BRANCH const[[rel:10]:4]
	41: PTRADD const[2:4]
	42: unique[20500:4] = CALLOTHER const[2d:4], register[0:4]
	43: BRANCH const[[rel:10]:4]
	44: PTRADD const[3:4]
	45: unique[20500:4] = CALLOTHER const[2e:4], register[0:4]
	46: BRANCH const[[rel:10]:4]
	47: PTRADD const[4:4]
	48: unique[20500:4] = CALLOTHER const[2f:4], register[0:4]
	49: BRANCH const[[rel:10]:4]
	50: PTRADD const[5:4]
	51: unique[20500:4] = CALLOTHER const[30:4], register[0:4]
	52: BRANCH const[[rel:10]:4]
	53: PTRADD const[6:4]
	54: unique[20500:4] = CALLOTHER const[31:4], register[0:4]
	55: BRANCH const[[rel:10]:4]
	56: PTRADD const[7:4]
	57: unique[20500:4] = CALLOTHER const[32:4], register[0:4]
	58: BRANCH const[[rel:10]:4]
	59: PTRADD const[8:4]
	60: unique[20500:4] = CALLOTHER const[33:4], register[0:4]
	61: BRANCH const[[rel:10]:4]
	62: PTRADD const[9:4]
	63: unique[20500:4] = CALLOTHER const[34:4], register[0:4]
	64: BRANCH const[[rel:10]:4]
	65: PTRADD const[a:4]
	66: unique[20500:4] = CALLOTHER const[35:4], register[0:4]
	67: BRANCH const[[rel:10]:4]
	68: PTRADD const[b:4]
	69: unique[20500:4] = CALLOTHER const[36:4], register[0:4]
	70: BRANCH const[[rel:10]:4]
	71: PTRADD const[c:4]
	72: unique[20500:4] = CALLOTHER const[37:4], register[0:4]
	73: BRANCH const[[rel:10]:4]
	74: PTRADD const[d:4]
	75: unique[20500:4] = CALLOTHER const[38:4], register[0:4]
	76: BRANCH const[[rel:10]:4]
	77: PTRADD const[e:4]
	78: unique[20500:4] = CALLOTHER const[39:4], register[0:4]
	79: BRANCH const[[rel:10]:4]
	80: PTRADD const[f:4]
	81: unique[20500:4] = CALLOTHER const[3a:4], register[0:4]
	82: BRANCH const[[rel:10]:4]
	83: PTRADD const[10:4]
	84: register[0:4] = LOAD const[ram:8], unique[20500:4]
	85: unique[21680:4] = INT_ADD unique[20500:4], const[4:4]
	86: register[c:4] = LOAD const[ram:8], unique[21680:4]
	87: unique[21780:4] = INT_ADD unique[20500:4], const[8:4]
	88: register[8:4] = LOAD const[ram:8], unique[21780:4]
	89: unique[21880:4] = INT_ADD unique[20500:4], const[c:4]
	90: register[4:4] = LOAD const[ram:8], unique[21880:4]

Line ia.sinc:1995 :BT Rmr16,Reg16		is vexMode=0 & opsize=0 & byte=0xf; byte=0xa3; mod=3 & Rmr16 & Reg16		{ CF = ((Rmr16 >> (Reg16 &  0xf)) & 1) != 0; }
0: Constructor line ia.sinc:1995(id0.74) printpiece=[BT,  ,  A, ,,  B]
Operands 0: Rmr16 : 1508  1: Reg16 : 1509  
Pattern id=74 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:A3:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[16680:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[f:[handle:size]]
	3: unique[16700:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[16680:[handle:size]]
	4: unique[16780:[handle:size]] = INT_AND unique[16700:[handle:size]], const[1:[handle:size]]
	5: register[200:1] = INT_NOTEQUAL unique[16780:[handle:size]], const[0:[handle:size]]

Line ia.sinc:1996 :BT Mem,Reg16		is vexMode=0 & opsize=0 & byte=0xf; byte=0xa3; Mem & Reg16 ...		{ local ptr = Mem + (sext(Reg16) s>> 3);
											  CF = ((*:1 ptr >> (Reg16 & 0x7)) & 1) != 0; }
1: Constructor line ia.sinc:1996(id0.75) printpiece=[BT,  ,  A, ,,  B]
Operands 0: Mem : 1510  1: Reg16 : 1511  
Pattern id=75 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:A3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[16880:[handle:size]] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[16900:[handle:size]] = INT_SRIGHT unique[16880:[handle:size]], const[3:4]
	4: unique[16a00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[16900:[handle:size]]
	5: unique[16a80:1] = LOAD const[ram:8], unique[16a00:[handle:size]]
	6: unique[16b00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[7:[handle:size]]
	7: unique[16b80:1] = INT_RIGHT unique[16a80:1], unique[16b00:[handle:size]]
	8: unique[16c00:1] = INT_AND unique[16b80:1], const[1:1]
	9: register[200:1] = INT_NOTEQUAL unique[16c00:1], const[0:1]

Line ia.sinc:1998 :BT Rmr32,Reg32		is vexMode=0 & opsize=1 & byte=0xf; byte=0xa3; mod=3 & Rmr32 & Reg32		{ CF = ((Rmr32 >> (Reg32 & 0x1f)) & 1) != 0; }
0: Constructor line ia.sinc:1998(id0.76) printpiece=[BT,  ,  A, ,,  B]
Operands 0: Rmr32 : 1512  1: Reg32 : 1513  
Pattern id=76 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:A3:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[16d00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1f:[handle:size]]
	3: unique[16d80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[16d00:[handle:size]]
	4: unique[16e00:[handle:size]] = INT_AND unique[16d80:[handle:size]], const[1:[handle:size]]
	5: register[200:1] = INT_NOTEQUAL unique[16e00:[handle:size]], const[0:[handle:size]]

Line ia.sinc:1999 :BT Mem,Reg32		is vexMode=0 & opsize=1 & byte=0xf; byte=0xa3; Mem & Reg32 ...		{
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>> 3);
@else
    local ptr = Mem + (Reg32 s>> 3);
@endif
    CF = ((*:1 ptr >> (Reg32 & 0x7)) & 1) != 0;
}
1: Constructor line ia.sinc:1999(id0.77) printpiece=[BT,  ,  A, ,,  B]
Operands 0: Mem : 1514  1: Reg32 : 1515  
Pattern id=77 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:A3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[16f00:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], const[3:4]
	3: unique[17000:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[16f00:[handle:size]]
	4: unique[17080:1] = LOAD const[ram:8], unique[17000:[handle:size]]
	5: unique[17100:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[7:[handle:size]]
	6: unique[17180:1] = INT_RIGHT unique[17080:1], unique[17100:[handle:size]]
	7: unique[17200:1] = INT_AND unique[17180:1], const[1:1]
	8: register[200:1] = INT_NOTEQUAL unique[17200:1], const[0:1]

Line ia.sinc:3658 :SHLD rm16,Reg16,imm8 is vexMode=0 & opsize=0; byte=0x0F; byte=0xA4; rm16 & Reg16 ... ; imm8 { local count = imm8 & 0x1f; local tmp = rm16;
                                           rm16 = (rm16 << count) | (Reg16 >> (16 - count));
                                           shlflags(tmp,rm16,count); shiftresultflags(rm16,count);}
0: Constructor line ia.sinc:3658(id0.534) printpiece=[SHLD,  ,  A, ,,  B, ,,  C]
Operands 0: rm16 : 2295  1: Reg16 : 2296  2: imm8 : 2297  
Pattern id=534 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:A4:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3ef00:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	3: unique[3ef80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[3f000:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3ef00:4]
	5: unique[3f080:4] = INT_SUB const[10:4], unique[3ef00:4]
	6: unique[3f100:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3f080:4]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3f000:[handle:size]], unique[3f100:[handle:size]]
	8: unique[10080:1] = INT_NOTEQUAL unique[3ef00:4], const[0:4]
	9: unique[10100:4] = INT_SUB unique[3ef00:4], const[1:4]
	10: unique[10180:[handle:size]] = INT_LEFT unique[3ef80:[handle:size]], unique[10100:4]
	11: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	12: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	13: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	14: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	15: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	16: unique[10580:1] = INT_EQUAL unique[3ef00:4], const[1:4]
	17: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	18: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	19: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	20: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	21: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	22: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	23: unique[df00:1] = INT_NOTEQUAL unique[3ef00:4], const[0:4]
	24: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	25: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	26: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	27: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	28: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	29: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	30: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	31: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	32: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	33: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	34: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	35: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	36: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	37: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	38: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	39: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	40: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	41: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3664 :SHLD rm32,Reg32,imm8 is vexMode=0 & opsize=1; byte=0x0F; byte=0xA4; rm32 & check_rm32_dest ... & Reg32 ... ; imm8 { local count = imm8 & 0x1f; local tmp = rm32;
                                           rm32 = (rm32 << count) | (Reg32 >> (32 - count)); build check_rm32_dest;
                                           shlflags(tmp,rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3664(id0.536) printpiece=[SHLD,  ,  A, ,,  C, ,,  D]
Operands 0: rm32 : 2301  1: check_rm32_dest : 2304  2: Reg32 : 2302  3: imm8 : 2303  
Pattern id=536 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:A4:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3f600:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	3: unique[3f680:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[3f700:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3f600:4]
	5: unique[3f780:4] = INT_SUB const[20:4], unique[3f600:4]
	6: unique[3f800:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3f780:4]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3f700:[handle:size]], unique[3f800:[handle:size]]
	8: MULTIEQUAL const[1:4]
	9: unique[10080:1] = INT_NOTEQUAL unique[3f600:4], const[0:4]
	10: unique[10100:4] = INT_SUB unique[3f600:4], const[1:4]
	11: unique[10180:[handle:size]] = INT_LEFT unique[3f680:[handle:size]], unique[10100:4]
	12: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	13: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	14: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	15: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	16: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	17: unique[10580:1] = INT_EQUAL unique[3f600:4], const[1:4]
	18: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	19: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	20: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	21: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	22: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	23: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	24: unique[df00:1] = INT_NOTEQUAL unique[3f600:4], const[0:4]
	25: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	28: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	29: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	30: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	31: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	32: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	33: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	34: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	35: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	36: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	37: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	38: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	39: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	40: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	41: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	42: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3661 :SHLD rm16,Reg16,CL   is vexMode=0 & opsize=0; byte=0x0F; byte=0xA5; CL & rm16 & Reg16 ...  { local count =   CL & 0x1f; local tmp = rm16;
                                          rm16 = (rm16 << count) | (Reg16 >> (16 - count));
                                          shlflags(tmp,rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3661(id0.535) printpiece=[SHLD,  ,  B, ,,  C, ,,  A]
Operands 0: CL : 2300  1: rm16 : 2298  2: Reg16 : 2299  
Pattern id=535 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:A5:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: unique[3f280:1] = INT_AND register[4:1], const[1f:1]
	3: unique[3f300:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[3f380:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3f280:1]
	5: unique[3f400:1] = INT_SUB const[10:1], unique[3f280:1]
	6: unique[3f480:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3f400:1]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3f380:[handle:size]], unique[3f480:[handle:size]]
	8: unique[10080:1] = INT_NOTEQUAL unique[3f280:1], const[0:1]
	9: unique[10100:1] = INT_SUB unique[3f280:1], const[1:1]
	10: unique[10180:[handle:size]] = INT_LEFT unique[3f300:[handle:size]], unique[10100:1]
	11: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	12: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	13: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	14: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	15: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	16: unique[10580:1] = INT_EQUAL unique[3f280:1], const[1:1]
	17: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	18: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	19: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	20: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	21: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	22: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	23: unique[df00:1] = INT_NOTEQUAL unique[3f280:1], const[0:1]
	24: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	25: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	26: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	27: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	28: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	29: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	30: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	31: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	32: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	33: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	34: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	35: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	36: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	37: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	38: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	39: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	40: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	41: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3667 :SHLD rm32,Reg32,CL   is vexMode=0 & opsize=1; byte=0x0F; byte=0xA5; CL & rm32 & check_rm32_dest ... & Reg32 ...  { local count =   CL & 0x1f; local tmp = rm32;
                                          rm32 = (rm32 << count) | (Reg32 >> (32 - count)); build check_rm32_dest;
                                          shlflags(tmp,rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3667(id0.537) printpiece=[SHLD,  ,  B, ,,  D, ,,  A]
Operands 0: CL : 2307  1: rm32 : 2305  2: check_rm32_dest : 2308  3: Reg32 : 2306  
Pattern id=537 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:A5:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[3f980:1] = INT_AND register[4:1], const[1f:1]
	3: unique[3fa00:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[3fa80:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3f980:1]
	5: unique[3fb00:1] = INT_SUB const[20:1], unique[3f980:1]
	6: unique[3fb80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3fb00:1]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3fa80:[handle:size]], unique[3fb80:[handle:size]]
	8: MULTIEQUAL const[2:4]
	9: unique[10080:1] = INT_NOTEQUAL unique[3f980:1], const[0:1]
	10: unique[10100:1] = INT_SUB unique[3f980:1], const[1:1]
	11: unique[10180:[handle:size]] = INT_LEFT unique[3fa00:[handle:size]], unique[10100:1]
	12: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	13: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	14: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	15: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	16: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	17: unique[10580:1] = INT_EQUAL unique[3f980:1], const[1:1]
	18: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	19: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	20: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	21: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	22: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	23: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	24: unique[df00:1] = INT_NOTEQUAL unique[3f980:1], const[0:1]
	25: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	28: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	29: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	30: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	31: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	32: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	33: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	34: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	35: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	36: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	37: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	38: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	39: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	40: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	41: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	42: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:8304 :MONTMUL.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA6; byte=0xC0 { 
	montmul(EAX,ECX,ESI); 
	ECX=0; 
	EDX=0; 
}
0: Constructor line ia.sinc:8304(id0.1383) printpiece=[MONTMUL.REP]
Operands 
Pattern id=1383 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:A6:C0:XX)
Template
	0: CALLOTHER const[ab:4], register[0:4], register[4:4], register[18:4]
	1: register[4:4] = COPY const[0:4]
	2: register[8:4] = COPY const[0:4]

Line ia.sinc:2236 :CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xa6; rm8 & Reg8 ...           { _cmpxchg(rm8, Reg8); } #deprecated after 486
:CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2236(id0.152) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm8 : 1639  1: Reg8 : 1640  
Pattern id=152 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A6:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8310 :XSHA1.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA6; byte=0xC8 {
	xsha1(ECX,ESI,EDI); 
	EAX = ECX;
}
0: Constructor line ia.sinc:8310(id0.1384) printpiece=[XSHA1.REP]
Operands 
Pattern id=1384 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:A6:C8:XX)
Template
	0: CALLOTHER const[ac:4], register[4:4], register[18:4], register[1c:4]
	1: register[0:4] = COPY register[4:4]

Line ia.sinc:2236 :CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xa6; rm8 & Reg8 ...           { _cmpxchg(rm8, Reg8); } #deprecated after 486
:CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2236(id0.152) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm8 : 1639  1: Reg8 : 1640  
Pattern id=152 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A6:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8315 :XSHA256.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA6; byte=0xD0 {  
	xsha256(ECX,ESI,EDI); 
	EAX = ECX; 
}
0: Constructor line ia.sinc:8315(id0.1385) printpiece=[XSHA256.REP]
Operands 
Pattern id=1385 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:A6:D0:XX)
Template
	0: CALLOTHER const[ad:4], register[4:4], register[18:4], register[1c:4]
	1: register[0:4] = COPY register[4:4]

Line ia.sinc:2236 :CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xa6; rm8 & Reg8 ...           { _cmpxchg(rm8, Reg8); } #deprecated after 486
:CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2236(id0.152) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm8 : 1639  1: Reg8 : 1640  
Pattern id=152 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A6:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2236 :CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xa6; rm8 & Reg8 ...           { _cmpxchg(rm8, Reg8); } #deprecated after 486
:CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
0: Constructor line ia.sinc:2236(id0.152) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm8 : 1639  1: Reg8 : 1640  
Pattern id=152 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A6:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8275 :XSTORE is vexMode=0 & mandover=0 & byte=0x0F; byte=0xA7; byte=0xC0 {  
	EAX = xstore_available(EDX,EDI); 
}
0: Constructor line ia.sinc:8275(id0.1376) printpiece=[XSTORE]
Operands 
Pattern id=1376 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:A7:C0:XX)
Template
	0: register[0:4] = CALLOTHER const[a4:4], register[8:4], register[1c:4]

Line ia.sinc:2237 :CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2237(id0.153) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1641  1: Reg16 : 1642  
Pattern id=153 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8279 :XSTORE.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xC0 {  
	EAX = xstore(ECX,EDX,EDI);
	ECX = 0;
}
0: Constructor line ia.sinc:8279(id0.1377) printpiece=[XSTORE.REP]
Operands 
Pattern id=1377 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:A7:C0:XX)
Template
	0: register[0:4] = CALLOTHER const[a5:4], register[4:4], register[8:4], register[1c:4]
	1: register[4:4] = COPY const[0:4]

Line ia.sinc:2237 :CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2237(id0.153) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1641  1: Reg16 : 1642  
Pattern id=153 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8284 :XCRYPTECB.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xC8 { 
	xcrypt_ecb(ECX,EDX,EBX,ESI,EDI); 
}
0: Constructor line ia.sinc:8284(id0.1378) printpiece=[XCRYPTECB.REP]
Operands 
Pattern id=1378 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:A7:C8:XX)
Template
	0: CALLOTHER const[a6:4], register[4:4], register[8:4], register[c:4], register[18:4], register[1c:4]

Line ia.sinc:2237 :CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2237(id0.153) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1641  1: Reg16 : 1642  
Pattern id=153 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8288 :XCRYPTCBC.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xD0 { 
	xcrypt_cbc(ECX,EAX,EDX,EBX,ESI,EDI); 
}
0: Constructor line ia.sinc:8288(id0.1379) printpiece=[XCRYPTCBC.REP]
Operands 
Pattern id=1379 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:A7:D0:XX)
Template
	0: CALLOTHER const[a7:4], register[4:4], register[0:4], register[8:4], register[c:4], register[18:4], register[1c:4]

Line ia.sinc:2237 :CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2237(id0.153) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1641  1: Reg16 : 1642  
Pattern id=153 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8292 :XCRYPTCTR.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xD8 {  
	xcrypt_ctr(ECX,EAX,EDX,EBX,ESI,EDI); 
}
0: Constructor line ia.sinc:8292(id0.1380) printpiece=[XCRYPTCTR.REP]
Operands 
Pattern id=1380 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:A7:D8:XX)
Template
	0: CALLOTHER const[a8:4], register[4:4], register[0:4], register[8:4], register[c:4], register[18:4], register[1c:4]

Line ia.sinc:2237 :CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2237(id0.153) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1641  1: Reg16 : 1642  
Pattern id=153 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8296 :XCRYPTCFB.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xE0 { 
	xcrypt_cfb(ECX,EAX,EDX,EBX,ESI,EDI); 
}
0: Constructor line ia.sinc:8296(id0.1381) printpiece=[XCRYPTCFB.REP]
Operands 
Pattern id=1381 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:A7:E0:XX)
Template
	0: CALLOTHER const[a9:4], register[4:4], register[0:4], register[8:4], register[c:4], register[18:4], register[1c:4]

Line ia.sinc:2237 :CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2237(id0.153) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1641  1: Reg16 : 1642  
Pattern id=153 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8300 :XCRYPTOFB.REP is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xA7; byte=0xE8 { 
	xcrypt_ofb(ECX,EAX,EDX,EBX,ESI,EDI); 
}
0: Constructor line ia.sinc:8300(id0.1382) printpiece=[XCRYPTOFB.REP]
Operands 
Pattern id=1382 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:A7:E8:XX)
Template
	0: CALLOTHER const[aa:4], register[4:4], register[0:4], register[8:4], register[c:4], register[18:4], register[1c:4]

Line ia.sinc:2237 :CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
1: Constructor line ia.sinc:2237(id0.153) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1641  1: Reg16 : 1642  
Pattern id=153 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2237 :CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
0: Constructor line ia.sinc:2237(id0.153) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1641  1: Reg16 : 1642  
Pattern id=153 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2237 :CMPXCHG rm16,Reg16  is vexMode=0 & byte=0xf; byte=0xa7; rm16 & Reg16 ...       { _cmpxchg(rm16, Reg16); } #deprecated after 486
:CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
0: Constructor line ia.sinc:2237(id0.153) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1641  1: Reg16 : 1642  
Pattern id=153 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:A7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[28:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3385 :PUSH GS        is vexMode=0 & addrsize=0 & byte=0xf; byte=0xa8 & GS        { push22(GS); }
0: Constructor line ia.sinc:3385(id0.426) printpiece=[PUSH,  ,  A]
Operands 0: GS : 2104  
Pattern id=426 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:0F:A8:XX:XX)
Template
	0: unique[9400:2] = COPY register[10a:2]
	1: register[10:2] = INT_SUB register[10:2], const[2:2]
	2: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	3: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3386 :PUSH GS        is vexMode=0 & addrsize=1 & byte=0xf; byte=0xa8 & GS        { pushseg44(GS); }
0: Constructor line ia.sinc:3386(id0.427) printpiece=[PUSH,  ,  A]
Operands 0: GS : 2105  
Pattern id=427 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:0F:A8:XX:XX)
Template
	0: register[10:4] = INT_SUB register[10:4], const[4:4]
	1: STORE const[ram:8], register[10:4], register[10a:2]

Line ia.sinc:3299 :POP GS         is vexMode=0 & addrsize=0 & byte=0xf; byte=0xa9 & GS    { pop22(GS); }
0: Constructor line ia.sinc:3299(id0.381) printpiece=[POP,  ,  A]
Operands 0: GS : 2065  
Pattern id=381 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:0F:A9:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[10a:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]

Line ia.sinc:3300 :POP GS         is vexMode=0 & addrsize=1 & byte=0xf; byte=0xa9 & GS    { popseg44(GS); }
0: Constructor line ia.sinc:3300(id0.382) printpiece=[POP,  ,  A]
Operands 0: GS : 2066  
Pattern id=382 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:0F:A9:XX:XX)
Template
	0: register[10a:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]

Line ia.sinc:3540 :RSM            is vexMode=0 & byte=0xf; byte=0xaa                  { tmp:4 = smm_restore_state(); return [tmp]; }
0: Constructor line ia.sinc:3540(id0.493) printpiece=[RSM]
Operands 
Pattern id=493 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AA:XX:XX)
Template
	0: unique[3c280:4] = CALLOTHER const[47:4]
	1: RETURN unique[3c280:4]

Line ia.sinc:2066 :BTS Rmr16,Reg16	is vexMode=0 & opsize=0 & byte=0xf; byte=0xab; mod=3 & Rmr16 & Reg16		{ local bit=Reg16&0xf; local val=(Rmr16>>bit)&1; Rmr16=Rmr16 | (1<<bit); CF=(val!=0); }
0: Constructor line ia.sinc:2066(id0.92) printpiece=[BTS,  ,  A, ,,  B]
Operands 0: Rmr16 : 1548  1: Reg16 : 1549  
Pattern id=92 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:AB:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1b580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[f:[handle:size]]
	3: unique[1b600:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[1b580:[handle:size]]
	4: unique[1b700:[handle:size]] = INT_AND unique[1b600:[handle:size]], const[1:[handle:size]]
	5: unique[1b780:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[1b580:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], unique[1b780:[handle:size]]
	7: register[200:1] = INT_NOTEQUAL unique[1b700:[handle:size]], const[0:[handle:size]]

Line ia.sinc:2067 :BTS Mem,Reg16	is vexMode=0 & opsize=0 & byte=0xf; byte=0xab; Mem & Reg16 ...		{ local ptr = Mem + (sext(Reg16) s>> 3); local bit = Reg16&7; local val = (*:1 ptr >> bit) & 1; *:1 ptr = *:1 ptr | (1<<bit); CF = (val != 0); }
1: Constructor line ia.sinc:2067(id0.93) printpiece=[BTS,  ,  A, ,,  B]
Operands 0: Mem : 1550  1: Reg16 : 1551  
Pattern id=93 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:AB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1b900:[handle:size]] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[1b980:[handle:size]] = INT_SRIGHT unique[1b900:[handle:size]], const[3:4]
	4: unique[1ba80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[1b980:[handle:size]]
	5: unique[1bb80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[7:[handle:size]]
	6: unique[1bc00:1] = LOAD const[ram:8], unique[1ba80:[handle:size]]
	7: unique[1bc80:1] = INT_RIGHT unique[1bc00:1], unique[1bb80:[handle:size]]
	8: unique[1bd80:1] = INT_AND unique[1bc80:1], const[1:1]
	9: unique[1be00:1] = LOAD const[ram:8], unique[1ba80:[handle:size]]
	10: unique[1be80:1] = INT_LEFT const[1:1], unique[1bb80:[handle:size]]
	11: unique[1bf00:1] = INT_OR unique[1be00:1], unique[1be80:1]
	12: STORE const[ram:8], unique[1ba80:[handle:size]], unique[1bf00:1]
	13: register[200:1] = INT_NOTEQUAL unique[1bd80:1], const[0:1]

Line ia.sinc:2068 :BTS Rmr32,Reg32	is vexMode=0 & opsize=1 & byte=0xf; byte=0xab; mod=3 & Rmr32 & check_Rmr32_dest & Reg32		{ local bit=Reg32&0x1f; local val=(Rmr32>>bit)&1; CF=(val!=0); Rmr32=Rmr32 | (1<<bit); build check_Rmr32_dest; }
0: Constructor line ia.sinc:2068(id0.94) printpiece=[BTS,  ,  A, ,,  C]
Operands 0: Rmr32 : 1552  1: check_Rmr32_dest : 1554  2: Reg32 : 1553  
Pattern id=94 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:AB:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1c080:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1f:[handle:size]]
	3: unique[1c100:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[1c080:[handle:size]]
	4: unique[1c200:[handle:size]] = INT_AND unique[1c100:[handle:size]], const[1:[handle:size]]
	5: register[200:1] = INT_NOTEQUAL unique[1c200:[handle:size]], const[0:[handle:size]]
	6: unique[1c300:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[1c080:[handle:size]]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], unique[1c300:[handle:size]]
	8: MULTIEQUAL const[1:4]

Line ia.sinc:2069 :BTS Mem,Reg32	is vexMode=0 & opsize=1 & byte=0xf; byte=0xab; Mem & Reg32 ...		{
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>>3);
@else
    local ptr = Mem + (Reg32 s>>3);
@endif
    local bit = Reg32 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr | (1<<bit);
    CF = (val != 0);
}
1: Constructor line ia.sinc:2069(id0.95) printpiece=[BTS,  ,  A, ,,  B]
Operands 0: Mem : 1555  1: Reg32 : 1556  
Pattern id=95 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:AB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1c400:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], const[3:4]
	3: unique[1c500:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[1c400:[handle:size]]
	4: unique[1c600:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[7:[handle:size]]
	5: unique[1c680:1] = LOAD const[ram:8], unique[1c500:[handle:size]]
	6: unique[1c700:1] = INT_RIGHT unique[1c680:1], unique[1c600:[handle:size]]
	7: unique[1c800:1] = INT_AND unique[1c700:1], const[1:1]
	8: unique[1c880:1] = LOAD const[ram:8], unique[1c500:[handle:size]]
	9: unique[1c900:1] = INT_LEFT const[1:1], unique[1c600:[handle:size]]
	10: unique[1c980:1] = INT_OR unique[1c880:1], unique[1c900:1]
	11: STORE const[ram:8], unique[1c500:[handle:size]], unique[1c980:1]
	12: register[200:1] = INT_NOTEQUAL unique[1c800:1], const[0:1]

Line ia.sinc:3679 :SHRD rm16,Reg16,imm8 is vexMode=0 & opsize=0; byte=0x0F; byte=0xAC; rm16 & Reg16 ... ; imm8 { local count = imm8 & 0x1f; local tmp = rm16;
                                           rm16 = (rm16 >> count) | (Reg16 << (16 - count));
                                           shrdflags(tmp,rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3679(id0.538) printpiece=[SHRD,  ,  A, ,,  B, ,,  C]
Operands 0: rm16 : 2309  1: Reg16 : 2310  2: imm8 : 2311  
Pattern id=538 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:AC:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3fd00:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	3: unique[3fd80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[3fe00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3fd00:4]
	5: unique[3fe80:4] = INT_SUB const[10:4], unique[3fd00:4]
	6: unique[3ff00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3fe80:4]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3fe00:[handle:size]], unique[3ff00:[handle:size]]
	8: unique[11b00:1] = INT_NOTEQUAL unique[3fd00:4], const[0:4]
	9: unique[11b80:4] = INT_SUB unique[3fd00:4], const[1:4]
	10: unique[11c00:[handle:size]] = INT_RIGHT unique[3fd80:[handle:size]], unique[11b80:4]
	11: unique[11c80:[handle:size]] = INT_AND unique[11c00:[handle:size]], const[1:[handle:size]]
	12: unique[11d80:1] = INT_NOTEQUAL unique[11c80:[handle:size]], const[0:[handle:size]]
	13: unique[11e00:1] = BOOL_NEGATE unique[11b00:1]
	14: unique[11e80:1] = INT_AND unique[11e00:1], register[200:1]
	15: unique[11f00:1] = INT_AND unique[11b00:1], unique[11d80:1]
	16: register[200:1] = INT_OR unique[11e80:1], unique[11f00:1]
	17: unique[12080:1] = INT_EQUAL unique[3fd00:4], const[1:4]
	18: unique[12100:1] = INT_SLESS unique[3fd80:[handle:size]], const[0:[handle:size]]
	19: unique[12180:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	20: unique[12280:1] = INT_XOR unique[12100:1], unique[12180:1]
	21: unique[12300:1] = BOOL_NEGATE unique[12080:1]
	22: unique[12380:1] = INT_AND unique[12300:1], register[20b:1]
	23: unique[12400:1] = INT_AND unique[12080:1], unique[12280:1]
	24: register[20b:1] = INT_OR unique[12380:1], unique[12400:1]
	25: unique[df00:1] = INT_NOTEQUAL unique[3fd00:4], const[0:4]
	26: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	27: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	28: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	29: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	30: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	31: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	32: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	33: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	34: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	35: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	36: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	37: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	38: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	39: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	40: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	41: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	42: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	43: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3685 :SHRD rm32,Reg32,imm8 is vexMode=0 & opsize=1; byte=0x0F; byte=0xAC; rm32 & check_rm32_dest ... & Reg32 ... ; imm8 { local count = imm8 & 0x1f; local tmp = rm32;
                                           rm32 = (rm32 >> count) | (Reg32 << (32 - count)); build check_rm32_dest;
                                           shrdflags(tmp,rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3685(id0.540) printpiece=[SHRD,  ,  A, ,,  C, ,,  D]
Operands 0: rm32 : 2315  1: check_rm32_dest : 2318  2: Reg32 : 2316  3: imm8 : 2317  
Pattern id=540 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:AC:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[40400:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	3: unique[40480:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[40500:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[40400:4]
	5: unique[40580:4] = INT_SUB const[20:4], unique[40400:4]
	6: unique[40600:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[40580:4]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[40500:[handle:size]], unique[40600:[handle:size]]
	8: MULTIEQUAL const[1:4]
	9: unique[11b00:1] = INT_NOTEQUAL unique[40400:4], const[0:4]
	10: unique[11b80:4] = INT_SUB unique[40400:4], const[1:4]
	11: unique[11c00:[handle:size]] = INT_RIGHT unique[40480:[handle:size]], unique[11b80:4]
	12: unique[11c80:[handle:size]] = INT_AND unique[11c00:[handle:size]], const[1:[handle:size]]
	13: unique[11d80:1] = INT_NOTEQUAL unique[11c80:[handle:size]], const[0:[handle:size]]
	14: unique[11e00:1] = BOOL_NEGATE unique[11b00:1]
	15: unique[11e80:1] = INT_AND unique[11e00:1], register[200:1]
	16: unique[11f00:1] = INT_AND unique[11b00:1], unique[11d80:1]
	17: register[200:1] = INT_OR unique[11e80:1], unique[11f00:1]
	18: unique[12080:1] = INT_EQUAL unique[40400:4], const[1:4]
	19: unique[12100:1] = INT_SLESS unique[40480:[handle:size]], const[0:[handle:size]]
	20: unique[12180:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[12280:1] = INT_XOR unique[12100:1], unique[12180:1]
	22: unique[12300:1] = BOOL_NEGATE unique[12080:1]
	23: unique[12380:1] = INT_AND unique[12300:1], register[20b:1]
	24: unique[12400:1] = INT_AND unique[12080:1], unique[12280:1]
	25: register[20b:1] = INT_OR unique[12380:1], unique[12400:1]
	26: unique[df00:1] = INT_NOTEQUAL unique[40400:4], const[0:4]
	27: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	28: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	29: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	30: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	31: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	32: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	33: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	34: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	35: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	36: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	37: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	38: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	39: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	40: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	41: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	42: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	43: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	44: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3682 :SHRD rm16,Reg16,CL   is vexMode=0 & opsize=0; byte=0x0F; byte=0xAD; CL & rm16 & Reg16 ...  { local count =   CL & 0x1f; local tmp = rm16;
                                          rm16 = (rm16 >> count) | (Reg16 << (16 - count));
                                          shrdflags(tmp,rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3682(id0.539) printpiece=[SHRD,  ,  B, ,,  C, ,,  A]
Operands 0: CL : 2314  1: rm16 : 2312  2: Reg16 : 2313  
Pattern id=539 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:AD:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: unique[40080:1] = INT_AND register[4:1], const[1f:1]
	3: unique[40100:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[40180:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[40080:1]
	5: unique[40200:1] = INT_SUB const[10:1], unique[40080:1]
	6: unique[40280:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[40200:1]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[40180:[handle:size]], unique[40280:[handle:size]]
	8: unique[11b00:1] = INT_NOTEQUAL unique[40080:1], const[0:1]
	9: unique[11b80:1] = INT_SUB unique[40080:1], const[1:1]
	10: unique[11c00:[handle:size]] = INT_RIGHT unique[40100:[handle:size]], unique[11b80:1]
	11: unique[11c80:[handle:size]] = INT_AND unique[11c00:[handle:size]], const[1:[handle:size]]
	12: unique[11d80:1] = INT_NOTEQUAL unique[11c80:[handle:size]], const[0:[handle:size]]
	13: unique[11e00:1] = BOOL_NEGATE unique[11b00:1]
	14: unique[11e80:1] = INT_AND unique[11e00:1], register[200:1]
	15: unique[11f00:1] = INT_AND unique[11b00:1], unique[11d80:1]
	16: register[200:1] = INT_OR unique[11e80:1], unique[11f00:1]
	17: unique[12080:1] = INT_EQUAL unique[40080:1], const[1:1]
	18: unique[12100:1] = INT_SLESS unique[40100:[handle:size]], const[0:[handle:size]]
	19: unique[12180:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	20: unique[12280:1] = INT_XOR unique[12100:1], unique[12180:1]
	21: unique[12300:1] = BOOL_NEGATE unique[12080:1]
	22: unique[12380:1] = INT_AND unique[12300:1], register[20b:1]
	23: unique[12400:1] = INT_AND unique[12080:1], unique[12280:1]
	24: register[20b:1] = INT_OR unique[12380:1], unique[12400:1]
	25: unique[df00:1] = INT_NOTEQUAL unique[40080:1], const[0:1]
	26: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	27: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	28: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	29: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	30: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	31: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	32: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	33: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	34: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	35: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	36: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	37: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	38: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	39: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	40: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	41: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	42: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	43: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3688 :SHRD rm32,Reg32,CL   is vexMode=0 & opsize=1; byte=0x0F; byte=0xAD; CL & rm32 & check_rm32_dest ... & Reg32 ...  { local count =   CL & 0x1f; local tmp = rm32;
                                          rm32 = (rm32 >> count) | (Reg32 << (32 - count)); build check_rm32_dest;
                                          shrdflags(tmp,rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3688(id0.541) printpiece=[SHRD,  ,  B, ,,  D, ,,  A]
Operands 0: CL : 2321  1: rm32 : 2319  2: check_rm32_dest : 2322  3: Reg32 : 2320  
Pattern id=541 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:AD:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[40780:1] = INT_AND register[4:1], const[1f:1]
	3: unique[40800:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: unique[40880:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[40780:1]
	5: unique[40900:1] = INT_SUB const[20:1], unique[40780:1]
	6: unique[40980:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[40900:1]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[40880:[handle:size]], unique[40980:[handle:size]]
	8: MULTIEQUAL const[2:4]
	9: unique[11b00:1] = INT_NOTEQUAL unique[40780:1], const[0:1]
	10: unique[11b80:1] = INT_SUB unique[40780:1], const[1:1]
	11: unique[11c00:[handle:size]] = INT_RIGHT unique[40800:[handle:size]], unique[11b80:1]
	12: unique[11c80:[handle:size]] = INT_AND unique[11c00:[handle:size]], const[1:[handle:size]]
	13: unique[11d80:1] = INT_NOTEQUAL unique[11c80:[handle:size]], const[0:[handle:size]]
	14: unique[11e00:1] = BOOL_NEGATE unique[11b00:1]
	15: unique[11e80:1] = INT_AND unique[11e00:1], register[200:1]
	16: unique[11f00:1] = INT_AND unique[11b00:1], unique[11d80:1]
	17: register[200:1] = INT_OR unique[11e80:1], unique[11f00:1]
	18: unique[12080:1] = INT_EQUAL unique[40780:1], const[1:1]
	19: unique[12100:1] = INT_SLESS unique[40800:[handle:size]], const[0:[handle:size]]
	20: unique[12180:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[12280:1] = INT_XOR unique[12100:1], unique[12180:1]
	22: unique[12300:1] = BOOL_NEGATE unique[12080:1]
	23: unique[12380:1] = INT_AND unique[12300:1], register[20b:1]
	24: unique[12400:1] = INT_AND unique[12080:1], unique[12280:1]
	25: register[20b:1] = INT_OR unique[12380:1], unique[12400:1]
	26: unique[df00:1] = INT_NOTEQUAL unique[40780:1], const[0:1]
	27: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	28: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	29: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	30: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	31: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	32: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	33: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	34: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	35: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	36: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	37: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	38: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	39: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	40: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	41: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	42: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	43: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	44: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:4411 :FXSAVE Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=0 ) ... & Mem
{
# not saved in the same spacing as the actual processor
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  2) = FPUStatusWord;
  *:2  (Mem +  4) = FPUTagWord; #The real implementation saves an 'abridged' tag word, but that is a non-trivial operation
  *:2  (Mem +  6) = FPULastInstructionOpcode;
  *:4  (Mem +  8) = FPUInstructionPointer;
  *:2  (Mem + 12) = FPUPointerSelector;
  *:4  (Mem + 16) = FPUDataPointer;
  *:2  (Mem + 20) = FPUDataSelector;
  *:4  (Mem + 24) = MXCSR;
  # MXCSR_MASK not modeled, since it is processor specific, set to 0.

# saved the FPU ST registers to the ST/MM area of the structure,
  *:10 (Mem +  32) = ST0;
  *:10 (Mem +  48) = ST1;
  *:10 (Mem +  64) = ST2;
  *:10 (Mem +  80) = ST3;
  *:10 (Mem +  96) = ST4;
  *:10 (Mem + 112) = ST5;
  *:10 (Mem + 128) = ST6;
  *:10 (Mem + 144) = ST7;

  *:16 (Mem + 160) = XMM0;
  *:16 (Mem + 176) = XMM1;
  *:16 (Mem + 192) = XMM2;
  *:16 (Mem + 208) = XMM3;
  *:16 (Mem + 224) = XMM4;
  *:16 (Mem + 240) = XMM5;
  *:16 (Mem + 256) = XMM6;
  *:16 (Mem + 272) = XMM7;
}
0: Constructor line ia.sinc:4411(id0.814) printpiece=[FXSAVE,  ,  A]
Operands 0: Mem : 2667  
Pattern id=814 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:0[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	3: STORE const[ram:8], unique[4d300:[handle:size]], register[10a2:2]
	4: unique[4d380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	5: STORE const[ram:8], unique[4d380:[handle:size]], register[10a4:2]
	6: unique[4d400:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[6:[handle:size]]
	7: STORE const[ram:8], unique[4d400:[handle:size]], register[10a6:2]
	8: unique[4d480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	9: STORE const[ram:8], unique[4d480:[handle:size]], register[10ac:4]
	10: unique[4d500:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	11: STORE const[ram:8], unique[4d500:[handle:size]], register[10c8:2]
	12: unique[4d580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[10:[handle:size]]
	13: STORE const[ram:8], unique[4d580:[handle:size]], register[10a8:4]
	14: unique[4d600:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	15: STORE const[ram:8], unique[4d600:[handle:size]], register[10ca:2]
	16: unique[4d680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[18:[handle:size]]
	17: STORE const[ram:8], unique[4d680:[handle:size]], register[1094:4]
	18: unique[4d700:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[20:[handle:size]]
	19: STORE const[ram:8], unique[4d700:[handle:size]], register[1106:a]
	20: unique[4d780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[30:[handle:size]]
	21: STORE const[ram:8], unique[4d780:[handle:size]], register[1116:a]
	22: unique[4d800:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[40:[handle:size]]
	23: STORE const[ram:8], unique[4d800:[handle:size]], register[1126:a]
	24: unique[4d880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[50:[handle:size]]
	25: STORE const[ram:8], unique[4d880:[handle:size]], register[1136:a]
	26: unique[4d900:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[60:[handle:size]]
	27: STORE const[ram:8], unique[4d900:[handle:size]], register[1146:a]
	28: unique[4d980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[70:[handle:size]]
	29: STORE const[ram:8], unique[4d980:[handle:size]], register[1156:a]
	30: unique[4da00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[80:[handle:size]]
	31: STORE const[ram:8], unique[4da00:[handle:size]], register[1166:a]
	32: unique[4da80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[90:[handle:size]]
	33: STORE const[ram:8], unique[4da80:[handle:size]], register[1176:a]
	34: unique[4db00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[a0:[handle:size]]
	35: STORE const[ram:8], unique[4db00:[handle:size]], register[1200:10]
	36: unique[4db80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[b0:[handle:size]]
	37: STORE const[ram:8], unique[4db80:[handle:size]], register[1220:10]
	38: unique[4dc00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c0:[handle:size]]
	39: STORE const[ram:8], unique[4dc00:[handle:size]], register[1240:10]
	40: unique[4dc80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[d0:[handle:size]]
	41: STORE const[ram:8], unique[4dc80:[handle:size]], register[1260:10]
	42: unique[4dd00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[e0:[handle:size]]
	43: STORE const[ram:8], unique[4dd00:[handle:size]], register[1280:10]
	44: unique[4dd80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[f0:[handle:size]]
	45: STORE const[ram:8], unique[4dd80:[handle:size]], register[12a0:10]
	46: unique[4de00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[100:[handle:size]]
	47: STORE const[ram:8], unique[4de00:[handle:size]], register[12c0:10]
	48: unique[4de80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[110:[handle:size]]
	49: STORE const[ram:8], unique[4de80:[handle:size]], register[12e0:10]

Line ia.sinc:4411 :FXSAVE Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=0 ) ... & Mem
{
# not saved in the same spacing as the actual processor
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  2) = FPUStatusWord;
  *:2  (Mem +  4) = FPUTagWord; #The real implementation saves an 'abridged' tag word, but that is a non-trivial operation
  *:2  (Mem +  6) = FPULastInstructionOpcode;
  *:4  (Mem +  8) = FPUInstructionPointer;
  *:2  (Mem + 12) = FPUPointerSelector;
  *:4  (Mem + 16) = FPUDataPointer;
  *:2  (Mem + 20) = FPUDataSelector;
  *:4  (Mem + 24) = MXCSR;
  # MXCSR_MASK not modeled, since it is processor specific, set to 0.

# saved the FPU ST registers to the ST/MM area of the structure,
  *:10 (Mem +  32) = ST0;
  *:10 (Mem +  48) = ST1;
  *:10 (Mem +  64) = ST2;
  *:10 (Mem +  80) = ST3;
  *:10 (Mem +  96) = ST4;
  *:10 (Mem + 112) = ST5;
  *:10 (Mem + 128) = ST6;
  *:10 (Mem + 144) = ST7;

  *:16 (Mem + 160) = XMM0;
  *:16 (Mem + 176) = XMM1;
  *:16 (Mem + 192) = XMM2;
  *:16 (Mem + 208) = XMM3;
  *:16 (Mem + 224) = XMM4;
  *:16 (Mem + 240) = XMM5;
  *:16 (Mem + 256) = XMM6;
  *:16 (Mem + 272) = XMM7;
}
0: Constructor line ia.sinc:4411(id0.814) printpiece=[FXSAVE,  ,  A]
Operands 0: Mem : 2667  
Pattern id=814 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:4[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	3: STORE const[ram:8], unique[4d300:[handle:size]], register[10a2:2]
	4: unique[4d380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	5: STORE const[ram:8], unique[4d380:[handle:size]], register[10a4:2]
	6: unique[4d400:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[6:[handle:size]]
	7: STORE const[ram:8], unique[4d400:[handle:size]], register[10a6:2]
	8: unique[4d480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	9: STORE const[ram:8], unique[4d480:[handle:size]], register[10ac:4]
	10: unique[4d500:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	11: STORE const[ram:8], unique[4d500:[handle:size]], register[10c8:2]
	12: unique[4d580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[10:[handle:size]]
	13: STORE const[ram:8], unique[4d580:[handle:size]], register[10a8:4]
	14: unique[4d600:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	15: STORE const[ram:8], unique[4d600:[handle:size]], register[10ca:2]
	16: unique[4d680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[18:[handle:size]]
	17: STORE const[ram:8], unique[4d680:[handle:size]], register[1094:4]
	18: unique[4d700:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[20:[handle:size]]
	19: STORE const[ram:8], unique[4d700:[handle:size]], register[1106:a]
	20: unique[4d780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[30:[handle:size]]
	21: STORE const[ram:8], unique[4d780:[handle:size]], register[1116:a]
	22: unique[4d800:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[40:[handle:size]]
	23: STORE const[ram:8], unique[4d800:[handle:size]], register[1126:a]
	24: unique[4d880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[50:[handle:size]]
	25: STORE const[ram:8], unique[4d880:[handle:size]], register[1136:a]
	26: unique[4d900:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[60:[handle:size]]
	27: STORE const[ram:8], unique[4d900:[handle:size]], register[1146:a]
	28: unique[4d980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[70:[handle:size]]
	29: STORE const[ram:8], unique[4d980:[handle:size]], register[1156:a]
	30: unique[4da00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[80:[handle:size]]
	31: STORE const[ram:8], unique[4da00:[handle:size]], register[1166:a]
	32: unique[4da80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[90:[handle:size]]
	33: STORE const[ram:8], unique[4da80:[handle:size]], register[1176:a]
	34: unique[4db00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[a0:[handle:size]]
	35: STORE const[ram:8], unique[4db00:[handle:size]], register[1200:10]
	36: unique[4db80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[b0:[handle:size]]
	37: STORE const[ram:8], unique[4db80:[handle:size]], register[1220:10]
	38: unique[4dc00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c0:[handle:size]]
	39: STORE const[ram:8], unique[4dc00:[handle:size]], register[1240:10]
	40: unique[4dc80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[d0:[handle:size]]
	41: STORE const[ram:8], unique[4dc80:[handle:size]], register[1260:10]
	42: unique[4dd00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[e0:[handle:size]]
	43: STORE const[ram:8], unique[4dd00:[handle:size]], register[1280:10]
	44: unique[4dd80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[f0:[handle:size]]
	45: STORE const[ram:8], unique[4dd80:[handle:size]], register[12a0:10]
	46: unique[4de00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[100:[handle:size]]
	47: STORE const[ram:8], unique[4de00:[handle:size]], register[12c0:10]
	48: unique[4de80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[110:[handle:size]]
	49: STORE const[ram:8], unique[4de80:[handle:size]], register[12e0:10]

Line ia.sinc:4411 :FXSAVE Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=0 ) ... & Mem
{
# not saved in the same spacing as the actual processor
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  2) = FPUStatusWord;
  *:2  (Mem +  4) = FPUTagWord; #The real implementation saves an 'abridged' tag word, but that is a non-trivial operation
  *:2  (Mem +  6) = FPULastInstructionOpcode;
  *:4  (Mem +  8) = FPUInstructionPointer;
  *:2  (Mem + 12) = FPUPointerSelector;
  *:4  (Mem + 16) = FPUDataPointer;
  *:2  (Mem + 20) = FPUDataSelector;
  *:4  (Mem + 24) = MXCSR;
  # MXCSR_MASK not modeled, since it is processor specific, set to 0.

# saved the FPU ST registers to the ST/MM area of the structure,
  *:10 (Mem +  32) = ST0;
  *:10 (Mem +  48) = ST1;
  *:10 (Mem +  64) = ST2;
  *:10 (Mem +  80) = ST3;
  *:10 (Mem +  96) = ST4;
  *:10 (Mem + 112) = ST5;
  *:10 (Mem + 128) = ST6;
  *:10 (Mem + 144) = ST7;

  *:16 (Mem + 160) = XMM0;
  *:16 (Mem + 176) = XMM1;
  *:16 (Mem + 192) = XMM2;
  *:16 (Mem + 208) = XMM3;
  *:16 (Mem + 224) = XMM4;
  *:16 (Mem + 240) = XMM5;
  *:16 (Mem + 256) = XMM6;
  *:16 (Mem + 272) = XMM7;
}
0: Constructor line ia.sinc:4411(id0.814) printpiece=[FXSAVE,  ,  A]
Operands 0: Mem : 2667  
Pattern id=814 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:8[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	3: STORE const[ram:8], unique[4d300:[handle:size]], register[10a2:2]
	4: unique[4d380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	5: STORE const[ram:8], unique[4d380:[handle:size]], register[10a4:2]
	6: unique[4d400:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[6:[handle:size]]
	7: STORE const[ram:8], unique[4d400:[handle:size]], register[10a6:2]
	8: unique[4d480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	9: STORE const[ram:8], unique[4d480:[handle:size]], register[10ac:4]
	10: unique[4d500:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	11: STORE const[ram:8], unique[4d500:[handle:size]], register[10c8:2]
	12: unique[4d580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[10:[handle:size]]
	13: STORE const[ram:8], unique[4d580:[handle:size]], register[10a8:4]
	14: unique[4d600:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	15: STORE const[ram:8], unique[4d600:[handle:size]], register[10ca:2]
	16: unique[4d680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[18:[handle:size]]
	17: STORE const[ram:8], unique[4d680:[handle:size]], register[1094:4]
	18: unique[4d700:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[20:[handle:size]]
	19: STORE const[ram:8], unique[4d700:[handle:size]], register[1106:a]
	20: unique[4d780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[30:[handle:size]]
	21: STORE const[ram:8], unique[4d780:[handle:size]], register[1116:a]
	22: unique[4d800:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[40:[handle:size]]
	23: STORE const[ram:8], unique[4d800:[handle:size]], register[1126:a]
	24: unique[4d880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[50:[handle:size]]
	25: STORE const[ram:8], unique[4d880:[handle:size]], register[1136:a]
	26: unique[4d900:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[60:[handle:size]]
	27: STORE const[ram:8], unique[4d900:[handle:size]], register[1146:a]
	28: unique[4d980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[70:[handle:size]]
	29: STORE const[ram:8], unique[4d980:[handle:size]], register[1156:a]
	30: unique[4da00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[80:[handle:size]]
	31: STORE const[ram:8], unique[4da00:[handle:size]], register[1166:a]
	32: unique[4da80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[90:[handle:size]]
	33: STORE const[ram:8], unique[4da80:[handle:size]], register[1176:a]
	34: unique[4db00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[a0:[handle:size]]
	35: STORE const[ram:8], unique[4db00:[handle:size]], register[1200:10]
	36: unique[4db80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[b0:[handle:size]]
	37: STORE const[ram:8], unique[4db80:[handle:size]], register[1220:10]
	38: unique[4dc00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c0:[handle:size]]
	39: STORE const[ram:8], unique[4dc00:[handle:size]], register[1240:10]
	40: unique[4dc80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[d0:[handle:size]]
	41: STORE const[ram:8], unique[4dc80:[handle:size]], register[1260:10]
	42: unique[4dd00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[e0:[handle:size]]
	43: STORE const[ram:8], unique[4dd00:[handle:size]], register[1280:10]
	44: unique[4dd80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[f0:[handle:size]]
	45: STORE const[ram:8], unique[4dd80:[handle:size]], register[12a0:10]
	46: unique[4de00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[100:[handle:size]]
	47: STORE const[ram:8], unique[4de00:[handle:size]], register[12c0:10]
	48: unique[4de80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[110:[handle:size]]
	49: STORE const[ram:8], unique[4de80:[handle:size]], register[12e0:10]

Line ia.sinc:4532 :FXRSTOR Mem   is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=1 ) ... & Mem
{
  FPUControlWord           = *:2  (Mem);
  FPUStatusWord            = *:2  (Mem +  2);
  FPUTagWord               = *:2  (Mem +  4); #The real implementation saves an 'abridged' tag word, but that is a non-trivial operation
  FPULastInstructionOpcode = *:2  (Mem +  6);
  FPUInstructionPointer    = *:4  (Mem +  8);
  FPUPointerSelector       = *:2  (Mem + 12);
  FPUDataPointer           = *:4  (Mem + 16);
  FPUDataSelector          = *:2  (Mem + 20);
  MXCSR                    = *:4  (Mem + 24);
  # MXCSR_MASK not modeled, since it is processor specific, set to 0.

# saved the FPU ST registers to the ST/MM area of the structure,
  ST0 = *:10 (Mem +  32);
  ST1 = *:10 (Mem +  48);
  ST2 = *:10 (Mem +  64);
  ST3 = *:10 (Mem +  80);
  ST4 = *:10 (Mem +  96);
  ST5 = *:10 (Mem + 112);
  ST6 = *:10 (Mem + 128);
  ST7 = *:10 (Mem + 144);

  XMM0 = *:16 (Mem + 160);
  XMM1 = *:16 (Mem + 176);
  XMM2 = *:16 (Mem + 192);
  XMM3 = *:16 (Mem + 208);
  XMM4 = *:16 (Mem + 224);
  XMM5 = *:16 (Mem + 240);
  XMM6 = *:16 (Mem + 256);
  XMM7 = *:16 (Mem + 272);
}
0: Constructor line ia.sinc:4532(id0.815) printpiece=[FXRSTOR,  ,  A]
Operands 0: Mem : 2668  
Pattern id=815 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:0[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[4df80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	3: register[10a2:2] = LOAD const[ram:8], unique[4df80:[handle:size]]
	4: unique[4e080:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	5: register[10a4:2] = LOAD const[ram:8], unique[4e080:[handle:size]]
	6: unique[4e180:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[6:[handle:size]]
	7: register[10a6:2] = LOAD const[ram:8], unique[4e180:[handle:size]]
	8: unique[4e280:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	9: register[10ac:4] = LOAD const[ram:8], unique[4e280:[handle:size]]
	10: unique[4e380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	11: register[10c8:2] = LOAD const[ram:8], unique[4e380:[handle:size]]
	12: unique[4e480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[10:[handle:size]]
	13: register[10a8:4] = LOAD const[ram:8], unique[4e480:[handle:size]]
	14: unique[4e580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	15: register[10ca:2] = LOAD const[ram:8], unique[4e580:[handle:size]]
	16: unique[4e680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[18:[handle:size]]
	17: register[1094:4] = LOAD const[ram:8], unique[4e680:[handle:size]]
	18: unique[4e780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[20:[handle:size]]
	19: register[1106:a] = LOAD const[ram:8], unique[4e780:[handle:size]]
	20: unique[4e880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[30:[handle:size]]
	21: register[1116:a] = LOAD const[ram:8], unique[4e880:[handle:size]]
	22: unique[4e980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[40:[handle:size]]
	23: register[1126:a] = LOAD const[ram:8], unique[4e980:[handle:size]]
	24: unique[4ea80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[50:[handle:size]]
	25: register[1136:a] = LOAD const[ram:8], unique[4ea80:[handle:size]]
	26: unique[4eb80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[60:[handle:size]]
	27: register[1146:a] = LOAD const[ram:8], unique[4eb80:[handle:size]]
	28: unique[4ec80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[70:[handle:size]]
	29: register[1156:a] = LOAD const[ram:8], unique[4ec80:[handle:size]]
	30: unique[4ed80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[80:[handle:size]]
	31: register[1166:a] = LOAD const[ram:8], unique[4ed80:[handle:size]]
	32: unique[4ee80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[90:[handle:size]]
	33: register[1176:a] = LOAD const[ram:8], unique[4ee80:[handle:size]]
	34: unique[4ef80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[a0:[handle:size]]
	35: register[1200:10] = LOAD const[ram:8], unique[4ef80:[handle:size]]
	36: unique[4f080:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[b0:[handle:size]]
	37: register[1220:10] = LOAD const[ram:8], unique[4f080:[handle:size]]
	38: unique[4f180:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c0:[handle:size]]
	39: register[1240:10] = LOAD const[ram:8], unique[4f180:[handle:size]]
	40: unique[4f280:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[d0:[handle:size]]
	41: register[1260:10] = LOAD const[ram:8], unique[4f280:[handle:size]]
	42: unique[4f380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[e0:[handle:size]]
	43: register[1280:10] = LOAD const[ram:8], unique[4f380:[handle:size]]
	44: unique[4f480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[f0:[handle:size]]
	45: register[12a0:10] = LOAD const[ram:8], unique[4f480:[handle:size]]
	46: unique[4f580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[100:[handle:size]]
	47: register[12c0:10] = LOAD const[ram:8], unique[4f580:[handle:size]]
	48: unique[4f680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[110:[handle:size]]
	49: register[12e0:10] = LOAD const[ram:8], unique[4f680:[handle:size]]

Line ia.sinc:4532 :FXRSTOR Mem   is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=1 ) ... & Mem
{
  FPUControlWord           = *:2  (Mem);
  FPUStatusWord            = *:2  (Mem +  2);
  FPUTagWord               = *:2  (Mem +  4); #The real implementation saves an 'abridged' tag word, but that is a non-trivial operation
  FPULastInstructionOpcode = *:2  (Mem +  6);
  FPUInstructionPointer    = *:4  (Mem +  8);
  FPUPointerSelector       = *:2  (Mem + 12);
  FPUDataPointer           = *:4  (Mem + 16);
  FPUDataSelector          = *:2  (Mem + 20);
  MXCSR                    = *:4  (Mem + 24);
  # MXCSR_MASK not modeled, since it is processor specific, set to 0.

# saved the FPU ST registers to the ST/MM area of the structure,
  ST0 = *:10 (Mem +  32);
  ST1 = *:10 (Mem +  48);
  ST2 = *:10 (Mem +  64);
  ST3 = *:10 (Mem +  80);
  ST4 = *:10 (Mem +  96);
  ST5 = *:10 (Mem + 112);
  ST6 = *:10 (Mem + 128);
  ST7 = *:10 (Mem + 144);

  XMM0 = *:16 (Mem + 160);
  XMM1 = *:16 (Mem + 176);
  XMM2 = *:16 (Mem + 192);
  XMM3 = *:16 (Mem + 208);
  XMM4 = *:16 (Mem + 224);
  XMM5 = *:16 (Mem + 240);
  XMM6 = *:16 (Mem + 256);
  XMM7 = *:16 (Mem + 272);
}
0: Constructor line ia.sinc:4532(id0.815) printpiece=[FXRSTOR,  ,  A]
Operands 0: Mem : 2668  
Pattern id=815 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:4[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[4df80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	3: register[10a2:2] = LOAD const[ram:8], unique[4df80:[handle:size]]
	4: unique[4e080:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	5: register[10a4:2] = LOAD const[ram:8], unique[4e080:[handle:size]]
	6: unique[4e180:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[6:[handle:size]]
	7: register[10a6:2] = LOAD const[ram:8], unique[4e180:[handle:size]]
	8: unique[4e280:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	9: register[10ac:4] = LOAD const[ram:8], unique[4e280:[handle:size]]
	10: unique[4e380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	11: register[10c8:2] = LOAD const[ram:8], unique[4e380:[handle:size]]
	12: unique[4e480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[10:[handle:size]]
	13: register[10a8:4] = LOAD const[ram:8], unique[4e480:[handle:size]]
	14: unique[4e580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	15: register[10ca:2] = LOAD const[ram:8], unique[4e580:[handle:size]]
	16: unique[4e680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[18:[handle:size]]
	17: register[1094:4] = LOAD const[ram:8], unique[4e680:[handle:size]]
	18: unique[4e780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[20:[handle:size]]
	19: register[1106:a] = LOAD const[ram:8], unique[4e780:[handle:size]]
	20: unique[4e880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[30:[handle:size]]
	21: register[1116:a] = LOAD const[ram:8], unique[4e880:[handle:size]]
	22: unique[4e980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[40:[handle:size]]
	23: register[1126:a] = LOAD const[ram:8], unique[4e980:[handle:size]]
	24: unique[4ea80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[50:[handle:size]]
	25: register[1136:a] = LOAD const[ram:8], unique[4ea80:[handle:size]]
	26: unique[4eb80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[60:[handle:size]]
	27: register[1146:a] = LOAD const[ram:8], unique[4eb80:[handle:size]]
	28: unique[4ec80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[70:[handle:size]]
	29: register[1156:a] = LOAD const[ram:8], unique[4ec80:[handle:size]]
	30: unique[4ed80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[80:[handle:size]]
	31: register[1166:a] = LOAD const[ram:8], unique[4ed80:[handle:size]]
	32: unique[4ee80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[90:[handle:size]]
	33: register[1176:a] = LOAD const[ram:8], unique[4ee80:[handle:size]]
	34: unique[4ef80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[a0:[handle:size]]
	35: register[1200:10] = LOAD const[ram:8], unique[4ef80:[handle:size]]
	36: unique[4f080:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[b0:[handle:size]]
	37: register[1220:10] = LOAD const[ram:8], unique[4f080:[handle:size]]
	38: unique[4f180:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c0:[handle:size]]
	39: register[1240:10] = LOAD const[ram:8], unique[4f180:[handle:size]]
	40: unique[4f280:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[d0:[handle:size]]
	41: register[1260:10] = LOAD const[ram:8], unique[4f280:[handle:size]]
	42: unique[4f380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[e0:[handle:size]]
	43: register[1280:10] = LOAD const[ram:8], unique[4f380:[handle:size]]
	44: unique[4f480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[f0:[handle:size]]
	45: register[12a0:10] = LOAD const[ram:8], unique[4f480:[handle:size]]
	46: unique[4f580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[100:[handle:size]]
	47: register[12c0:10] = LOAD const[ram:8], unique[4f580:[handle:size]]
	48: unique[4f680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[110:[handle:size]]
	49: register[12e0:10] = LOAD const[ram:8], unique[4f680:[handle:size]]

Line ia.sinc:4532 :FXRSTOR Mem   is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=1 ) ... & Mem
{
  FPUControlWord           = *:2  (Mem);
  FPUStatusWord            = *:2  (Mem +  2);
  FPUTagWord               = *:2  (Mem +  4); #The real implementation saves an 'abridged' tag word, but that is a non-trivial operation
  FPULastInstructionOpcode = *:2  (Mem +  6);
  FPUInstructionPointer    = *:4  (Mem +  8);
  FPUPointerSelector       = *:2  (Mem + 12);
  FPUDataPointer           = *:4  (Mem + 16);
  FPUDataSelector          = *:2  (Mem + 20);
  MXCSR                    = *:4  (Mem + 24);
  # MXCSR_MASK not modeled, since it is processor specific, set to 0.

# saved the FPU ST registers to the ST/MM area of the structure,
  ST0 = *:10 (Mem +  32);
  ST1 = *:10 (Mem +  48);
  ST2 = *:10 (Mem +  64);
  ST3 = *:10 (Mem +  80);
  ST4 = *:10 (Mem +  96);
  ST5 = *:10 (Mem + 112);
  ST6 = *:10 (Mem + 128);
  ST7 = *:10 (Mem + 144);

  XMM0 = *:16 (Mem + 160);
  XMM1 = *:16 (Mem + 176);
  XMM2 = *:16 (Mem + 192);
  XMM3 = *:16 (Mem + 208);
  XMM4 = *:16 (Mem + 224);
  XMM5 = *:16 (Mem + 240);
  XMM6 = *:16 (Mem + 256);
  XMM7 = *:16 (Mem + 272);
}
0: Constructor line ia.sinc:4532(id0.815) printpiece=[FXRSTOR,  ,  A]
Operands 0: Mem : 2668  
Pattern id=815 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:8[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[4df80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	3: register[10a2:2] = LOAD const[ram:8], unique[4df80:[handle:size]]
	4: unique[4e080:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	5: register[10a4:2] = LOAD const[ram:8], unique[4e080:[handle:size]]
	6: unique[4e180:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[6:[handle:size]]
	7: register[10a6:2] = LOAD const[ram:8], unique[4e180:[handle:size]]
	8: unique[4e280:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	9: register[10ac:4] = LOAD const[ram:8], unique[4e280:[handle:size]]
	10: unique[4e380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	11: register[10c8:2] = LOAD const[ram:8], unique[4e380:[handle:size]]
	12: unique[4e480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[10:[handle:size]]
	13: register[10a8:4] = LOAD const[ram:8], unique[4e480:[handle:size]]
	14: unique[4e580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	15: register[10ca:2] = LOAD const[ram:8], unique[4e580:[handle:size]]
	16: unique[4e680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[18:[handle:size]]
	17: register[1094:4] = LOAD const[ram:8], unique[4e680:[handle:size]]
	18: unique[4e780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[20:[handle:size]]
	19: register[1106:a] = LOAD const[ram:8], unique[4e780:[handle:size]]
	20: unique[4e880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[30:[handle:size]]
	21: register[1116:a] = LOAD const[ram:8], unique[4e880:[handle:size]]
	22: unique[4e980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[40:[handle:size]]
	23: register[1126:a] = LOAD const[ram:8], unique[4e980:[handle:size]]
	24: unique[4ea80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[50:[handle:size]]
	25: register[1136:a] = LOAD const[ram:8], unique[4ea80:[handle:size]]
	26: unique[4eb80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[60:[handle:size]]
	27: register[1146:a] = LOAD const[ram:8], unique[4eb80:[handle:size]]
	28: unique[4ec80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[70:[handle:size]]
	29: register[1156:a] = LOAD const[ram:8], unique[4ec80:[handle:size]]
	30: unique[4ed80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[80:[handle:size]]
	31: register[1166:a] = LOAD const[ram:8], unique[4ed80:[handle:size]]
	32: unique[4ee80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[90:[handle:size]]
	33: register[1176:a] = LOAD const[ram:8], unique[4ee80:[handle:size]]
	34: unique[4ef80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[a0:[handle:size]]
	35: register[1200:10] = LOAD const[ram:8], unique[4ef80:[handle:size]]
	36: unique[4f080:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[b0:[handle:size]]
	37: register[1220:10] = LOAD const[ram:8], unique[4f080:[handle:size]]
	38: unique[4f180:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c0:[handle:size]]
	39: register[1240:10] = LOAD const[ram:8], unique[4f180:[handle:size]]
	40: unique[4f280:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[d0:[handle:size]]
	41: register[1260:10] = LOAD const[ram:8], unique[4f280:[handle:size]]
	42: unique[4f380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[e0:[handle:size]]
	43: register[1280:10] = LOAD const[ram:8], unique[4f380:[handle:size]]
	44: unique[4f480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[f0:[handle:size]]
	45: register[12a0:10] = LOAD const[ram:8], unique[4f480:[handle:size]]
	46: unique[4f580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[100:[handle:size]]
	47: register[12c0:10] = LOAD const[ram:8], unique[4f580:[handle:size]]
	48: unique[4f680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[110:[handle:size]]
	49: register[12e0:10] = LOAD const[ram:8], unique[4f680:[handle:size]]

Line ia.sinc:2883 :LDMXCSR m32		is vexMode=0 & byte=0xf; byte=0xae; ( mod != 0b11 & reg_opcode=2 ) ... & m32 { MXCSR = m32; }
0: Constructor line ia.sinc:2883(id0.240) printpiece=[LDMXCSR,  ,  A]
Operands 0: m32 : 1799  
Pattern id=240 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:1[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[1094:4] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2883 :LDMXCSR m32		is vexMode=0 & byte=0xf; byte=0xae; ( mod != 0b11 & reg_opcode=2 ) ... & m32 { MXCSR = m32; }
0: Constructor line ia.sinc:2883(id0.240) printpiece=[LDMXCSR,  ,  A]
Operands 0: m32 : 1799  
Pattern id=240 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:5[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[1094:4] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2883 :LDMXCSR m32		is vexMode=0 & byte=0xf; byte=0xae; ( mod != 0b11 & reg_opcode=2 ) ... & m32 { MXCSR = m32; }
0: Constructor line ia.sinc:2883(id0.240) printpiece=[LDMXCSR,  ,  A]
Operands 0: m32 : 1799  
Pattern id=240 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:9[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[1094:4] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3772 :STMXCSR m32        is vexMode=0 & byte=0xf; byte=0xae; ( mod != 0b11 & reg_opcode=3 ) ... & m32 { m32 = MXCSR; }
0: Constructor line ia.sinc:3772(id0.563) printpiece=[STMXCSR,  ,  A]
Operands 0: m32 : 2352  
Pattern id=563 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:1[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[1094:4]

Line ia.sinc:3772 :STMXCSR m32        is vexMode=0 & byte=0xf; byte=0xae; ( mod != 0b11 & reg_opcode=3 ) ... & m32 { m32 = MXCSR; }
0: Constructor line ia.sinc:3772(id0.563) printpiece=[STMXCSR,  ,  A]
Operands 0: m32 : 2352  
Pattern id=563 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:5[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[1094:4]

Line ia.sinc:3772 :STMXCSR m32        is vexMode=0 & byte=0xf; byte=0xae; ( mod != 0b11 & reg_opcode=3 ) ... & m32 { m32 = MXCSR; }
0: Constructor line ia.sinc:3772(id0.563) printpiece=[STMXCSR,  ,  A]
Operands 0: m32 : 2352  
Pattern id=563 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:9[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[1094:4]

Line ia.sinc:3331 :PTWRITE rm32 is vexMode=0 & $(PRE_F3) & byte=0x0f; byte=0xae; rm32 & reg_opcode=4 ...     { ptwrite(rm32); }
0: Constructor line ia.sinc:3331(id0.399) printpiece=[PTWRITE,  ,  A]
Operands 0: rm32 : 2077  
Pattern id=399 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:AE:[xx10][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[41:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4038 :XSAVE  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsave(Mem, tmp); }
1: Constructor line ia.sinc:4038(id0.654) printpiece=[XSAVE,  ,  A]
Operands 0: Mem : 2521  
Pattern id=654 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:2[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[51:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:3331 :PTWRITE rm32 is vexMode=0 & $(PRE_F3) & byte=0x0f; byte=0xae; rm32 & reg_opcode=4 ...     { ptwrite(rm32); }
0: Constructor line ia.sinc:3331(id0.399) printpiece=[PTWRITE,  ,  A]
Operands 0: rm32 : 2077  
Pattern id=399 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:AE:[xx10][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[41:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4038 :XSAVE  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsave(Mem, tmp); }
1: Constructor line ia.sinc:4038(id0.654) printpiece=[XSAVE,  ,  A]
Operands 0: Mem : 2521  
Pattern id=654 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:6[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[51:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:3331 :PTWRITE rm32 is vexMode=0 & $(PRE_F3) & byte=0x0f; byte=0xae; rm32 & reg_opcode=4 ...     { ptwrite(rm32); }
0: Constructor line ia.sinc:3331(id0.399) printpiece=[PTWRITE,  ,  A]
Operands 0: rm32 : 2077  
Pattern id=399 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:AE:[xx10][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[41:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4038 :XSAVE  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsave(Mem, tmp); }
1: Constructor line ia.sinc:4038(id0.654) printpiece=[XSAVE,  ,  A]
Operands 0: Mem : 2521  
Pattern id=654 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:A[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[51:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:3331 :PTWRITE rm32 is vexMode=0 & $(PRE_F3) & byte=0x0f; byte=0xae; rm32 & reg_opcode=4 ...     { ptwrite(rm32); }
0: Constructor line ia.sinc:3331(id0.399) printpiece=[PTWRITE,  ,  A]
Operands 0: rm32 : 2077  
Pattern id=399 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:AE:[xx10][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[41:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4061 :LFENCE         is vexMode=0 & $(PRE_NO) & byte=0x0F; byte=0xAE; mod = 0b11 & reg_opcode=5 & r_m=0 { }
0: Constructor line ia.sinc:4061(id0.659) printpiece=[LFENCE]
Operands 
Pattern id=659 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:AE:E8:XX)
Template

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
0: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
0: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
0: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4028 :XRSTOR Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xrstor(Mem, tmp); }
0: Constructor line ia.sinc:4028(id0.652) printpiece=[XRSTOR,  ,  A]
Operands 0: Mem : 2519  
Pattern id=652 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[59:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
1: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line cet.sinc:15 :INCSSPD r32 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=5 & r32 {
    SSP = SSP + zext(4 * r32:1);
}
0: Constructor line cet.sinc:15(id0.2138) printpiece=[INCSSPD,  ,  A]
Operands 0: r32 : 7213  
Pattern id=2138 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx10][1xxx]:XX)
Template
	0: unique[d0c80:1] = INT_MULT const[4:1], [handle:space][[handle:offset+0]:1]
	1: unique[d0d00:8] = INT_ZEXT unique[d0c80:1]
	2: register[7c0:8] = INT_ADD register[7c0:8], unique[d0d00:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:3[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:7[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:B[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4062 :MFENCE         is vexMode=0 & $(PRE_NO) & byte=0x0F; byte=0xAE; mod = 0b11 & reg_opcode=6 & r_m=0 { }
0: Constructor line ia.sinc:4062(id0.660) printpiece=[MFENCE]
Operands 
Pattern id=660 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:AE:F0:XX)
Template

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
0: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:3[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:7[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:B[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
0: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
1: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:3[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:7[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:B[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
0: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
1: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:3[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:7[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:B[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
0: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
1: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx10]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:3[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:7[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:4048 :XSAVEOPT  Mem    is vexMode=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=6 ) ... & Mem { tmp:4 = 512; xsaveopt(Mem, tmp); }
0: Constructor line ia.sinc:4048(id0.656) printpiece=[XSAVEOPT,  ,  A]
Operands 0: Mem : 2523  
Pattern id=656 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:AE:B[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[55:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
1: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
2: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line clwb.sinc:2 :CLWB m8      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xAE; m8 & reg_opcode=6 ... {
	clwb(m8);
}
0: Constructor line clwb.sinc:2(id0.2087) printpiece=[CLWB,  ,  A]
Operands 0: m8 : 6972  
Pattern id=2087 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[279:4], [handle:space][[handle:offset]:[handle:size]]

Line cet.sinc:74 :CLRSSBSY m64 is vexMode=0 & $(PRE_F3) & (opsize=0 | opsize=1 | opsize=2 | opsize=3) & byte=0x0f; byte=0xae; reg_opcode=6 ... & m64 {
   clearShadowStackBusy(m64);
   SSP=0;
}
1: Constructor line cet.sinc:74(id0.2145) printpiece=[CLRSSBSY,  ,  A]
Operands 0: m64 : 7224  
Pattern id=2145 pattern=cmb:(ctx:X[xx11]:X[x1xx]:X[0xxx]:XX,ins:0F:AE:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[294:4], [handle:space][[handle:offset]:[handle:size]]
	2: register[7c0:8] = COPY const[0:8]

Line ia.sinc:2164 :CLFLUSH m8     is vexMode=0 & mandover=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=7 ) ... & m8 {
	clflush(m8);
}
0: Constructor line ia.sinc:2164(id0.122) printpiece=[CLFLUSH,  ,  A]
Operands 0: m8 : 1586  
Pattern id=122 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:AE:3[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[25:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2164 :CLFLUSH m8     is vexMode=0 & mandover=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=7 ) ... & m8 {
	clflush(m8);
}
0: Constructor line ia.sinc:2164(id0.122) printpiece=[CLFLUSH,  ,  A]
Operands 0: m8 : 1586  
Pattern id=122 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:AE:7[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[25:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2164 :CLFLUSH m8     is vexMode=0 & mandover=0 & byte=0x0F; byte=0xAE; ( mod != 0b11 & reg_opcode=7 ) ... & m8 {
	clflush(m8);
}
0: Constructor line ia.sinc:2164(id0.122) printpiece=[CLFLUSH,  ,  A]
Operands 0: m8 : 1586  
Pattern id=122 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:AE:B[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[25:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4063 :SFENCE         is vexMode=0 & $(PRE_NO) & byte=0x0F; byte=0xAE; mod = 0b11 & reg_opcode=7 & r_m=0 { }
0: Constructor line ia.sinc:4063(id0.661) printpiece=[SFENCE]
Operands 
Pattern id=661 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:AE:F8:XX)
Template

Line ia.sinc:2733 :IMUL      Reg16,rm16   is vexMode=0 & opsize=0 & byte=0xf; byte=0xaf; rm16 & Reg16 ... { tmp:4 = sext(Reg16) * sext(rm16);
                                          Reg16 = tmp(0); high:2 = tmp(2); imultflags(Reg16,tmp);}
0: Constructor line ia.sinc:2733(id0.186) printpiece=[IMUL,  ,  B, ,,  A]
Operands 0: rm16 : 1714  1: Reg16 : 1713  
Pattern id=186 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:AF:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[28000:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[28080:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[28180:4] = INT_MULT unique[28000:4], unique[28080:4]
	5: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[28180:4], const[0:4]
	6: unique[28300:2] = SUBPIECE unique[28180:4], const[2:4]
	7: unique[ec00:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	8: register[200:1] = INT_NOTEQUAL unique[ec00:4], unique[28180:4]
	9: register[20b:1] = COPY register[200:1]

Line ia.sinc:2735 :IMUL      Reg32,rm32   is vexMode=0 & opsize=1 & byte=0xf; byte=0xaf; rm32 & Reg32 ... & check_Reg32_dest ... { tmp:8 = sext(Reg32) * sext(rm32);
                                          Reg32 = tmp(0); high:4 = tmp(4); imultflags(Reg32,tmp); build check_Reg32_dest; }
0: Constructor line ia.sinc:2735(id0.187) printpiece=[IMUL,  ,  B, ,,  A]
Operands 0: rm32 : 1716  1: Reg32 : 1715  2: check_Reg32_dest : 1717  
Pattern id=187 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:AF:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[28380:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[28400:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[28500:8] = INT_MULT unique[28380:8], unique[28400:8]
	5: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[28500:8], const[0:4]
	6: unique[28680:4] = SUBPIECE unique[28500:8], const[4:4]
	7: unique[ec00:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	8: register[200:1] = INT_NOTEQUAL unique[ec00:8], unique[28500:8]
	9: register[20b:1] = COPY register[200:1]
	10: MULTIEQUAL const[2:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:2238 :CMPXCHG rm8,Reg8  is vexMode=0 & byte=0xf; byte=0xb0; rm8 & Reg8 ...           { subflags(AL,rm8); local tmp=AL-rm8; resultflags(tmp);
                                          local diff = rm8^Reg8; rm8 = rm8 ^ (ZF*diff);
                                          diff = AL ^ rm8; AL = AL ^ ((ZF==0)*diff); }
0: Constructor line ia.sinc:2238(id0.154) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm8 : 1643  1: Reg8 : 1644  
Pattern id=154 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:B0:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS register[0:1], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW register[0:1], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1f300:1] = INT_SUB register[0:1], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1f300:1], const[0:1]
	6: register[206:1] = INT_EQUAL unique[1f300:1], const[0:1]
	7: unique[dc80:1] = INT_AND unique[1f300:1], const[ff:1]
	8: unique[dd00:1] = POPCOUNT unique[dc80:1]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	11: unique[1f400:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	12: unique[1f480:1] = INT_MULT register[206:1], unique[1f400:[handle:size]]
	13: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], unique[1f480:1]
	14: unique[1f400:[handle:size]] = INT_XOR register[0:1], [handle:space][[handle:offset]:[handle:size]]
	15: unique[1f600:1] = INT_EQUAL register[206:1], const[0:1]
	16: unique[1f680:1] = INT_MULT unique[1f600:1], unique[1f400:[handle:size]]
	17: register[0:1] = INT_XOR register[0:1], unique[1f680:1]

Line ia.sinc:2241 :CMPXCHG rm16,Reg16    is vexMode=0 & opsize=0 & byte=0xf; byte=0xb1; rm16 & Reg16 ...  { subflags(AX,rm16); local tmp=AX-rm16; resultflags(tmp);
                                          local diff = rm16^Reg16; rm16 = rm16 ^ (zext(ZF) * diff);
                                          diff = AX ^ rm16; AX = AX ^ (zext(ZF==0) * diff); }
0: Constructor line ia.sinc:2241(id0.155) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm16 : 1645  1: Reg16 : 1646  
Pattern id=155 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:B1:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS register[0:2], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW register[0:2], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1f800:2] = INT_SUB register[0:2], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1f800:2], const[0:2]
	6: register[206:1] = INT_EQUAL unique[1f800:2], const[0:2]
	7: unique[dc80:2] = INT_AND unique[1f800:2], const[ff:2]
	8: unique[dd00:1] = POPCOUNT unique[dc80:2]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	11: unique[1f900:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	12: unique[1f980:[handle:size]] = INT_ZEXT register[206:1]
	13: unique[1fa00:[handle:size]] = INT_MULT unique[1f980:[handle:size]], unique[1f900:[handle:size]]
	14: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], unique[1fa00:[handle:size]]
	15: unique[1f900:[handle:size]] = INT_XOR register[0:2], [handle:space][[handle:offset]:[handle:size]]
	16: unique[1fb80:1] = INT_EQUAL register[206:1], const[0:1]
	17: unique[1fc00:[handle:size]] = INT_ZEXT unique[1fb80:1]
	18: unique[1fc80:[handle:size]] = INT_MULT unique[1fc00:[handle:size]], unique[1f900:[handle:size]]
	19: register[0:2] = INT_XOR register[0:2], unique[1fc80:[handle:size]]

Line ia.sinc:2244 :CMPXCHG rm32,Reg32    is vexMode=0 & opsize=1 & byte=0xf; byte=0xb1; rm32 & Reg32 ... & check_EAX_dest ... & check_rm32_dest ... 
{ 
	#this instruction writes to either EAX or rm32
	#in 64-bit mode, a 32-bit register that is written to 
	#(and only the register that is written to) 
	#must be zero-extended to 64 bits
	subflags(EAX,rm32); 
	local tmp=EAX-rm32; 
	resultflags(tmp);  
    if (ZF==1) goto <equal>;
    EAX = rm32;
    build check_EAX_dest;
    goto inst_next;
<equal>
    rm32 = Reg32;
    build check_rm32_dest;
}
0: Constructor line ia.sinc:2244(id0.156) printpiece=[CMPXCHG,  ,  A, ,,  B]
Operands 0: rm32 : 1647  1: Reg32 : 1648  2: check_EAX_dest : 1649  3: check_rm32_dest : 1650  
Pattern id=156 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:B1:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS register[0:4], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW register[0:4], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1fe00:4] = INT_SUB register[0:4], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1fe00:4], const[0:4]
	6: register[206:1] = INT_EQUAL unique[1fe00:4], const[0:4]
	7: unique[dc80:4] = INT_AND unique[1fe00:4], const[ff:4]
	8: unique[dd00:1] = POPCOUNT unique[dc80:4]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	11: unique[1fe80:1] = INT_EQUAL register[206:1], const[1:1]
	12: CBRANCH const[[rel:0]:4], unique[1fe80:1]
	13: register[0:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	14: MULTIEQUAL const[2:4]
	15: BRANCH [curspace][[next]:[curspace_size]]
	16: PTRADD const[0:4]
	17: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	18: MULTIEQUAL const[3:4]

Line ia.sinc:2889 :LSS Reg16,Mem      is vexMode=0 & opsize=0 & byte=0x0F; byte=0xB2; Mem & Reg16 ... { tmp:4 = *Mem; SS = tmp(2); Reg16 = tmp(0); }
0: Constructor line ia.sinc:2889(id0.243) printpiece=[LSS,  ,  B, ,,  A]
Operands 0: Mem : 1806  1: Reg16 : 1805  
Pattern id=243 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:B2:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2b900:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[104:2] = SUBPIECE unique[2b900:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2b900:4], const[0:4]

Line ia.sinc:2890 :LSS Reg32,Mem      is vexMode=0 & opsize=1 & byte=0x0F; byte=0xB2; Mem & Reg32 ... & check_Reg32_dest ... { tmp:6 = *Mem; SS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
0: Constructor line ia.sinc:2890(id0.244) printpiece=[LSS,  ,  B, ,,  A]
Operands 0: Mem : 1808  1: Reg32 : 1807  2: check_Reg32_dest : 1809  
Pattern id=244 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:B2:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2bb00:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[104:2] = SUBPIECE unique[2bb00:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2bb00:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:2042 :BTR Rmr16,Reg16	is vexMode=0 & opsize=0 & byte=0xf; byte=0xb3; mod=3 & Rmr16 & Reg16		{ local bit=Reg16&0xf; local val=(Rmr16>>bit)&1; Rmr16=Rmr16 & ~(1<<bit); CF=(val!=0); }
0: Constructor line ia.sinc:2042(id0.86) printpiece=[BTR,  ,  A, ,,  B]
Operands 0: Rmr16 : 1534  1: Reg16 : 1535  
Pattern id=86 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:B3:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[19500:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[f:[handle:size]]
	3: unique[19580:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[19500:[handle:size]]
	4: unique[19680:[handle:size]] = INT_AND unique[19580:[handle:size]], const[1:[handle:size]]
	5: unique[19700:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[19500:[handle:size]]
	6: unique[19780:[handle:size]] = INT_NEGATE unique[19700:[handle:size]]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[19780:[handle:size]]
	8: register[200:1] = INT_NOTEQUAL unique[19680:[handle:size]], const[0:[handle:size]]

Line ia.sinc:2043 :BTR Mem,Reg16	is vexMode=0 & opsize=0 & byte=0xf; byte=0xb3; Mem & Reg16 ...		{ local ptr = Mem + (sext(Reg16) s>> 3); local bit=Reg16&7; local val=(*:1 ptr >> bit) & 1; *:1 ptr = *:1 ptr & ~(1<<bit); CF = (val!=0); }
1: Constructor line ia.sinc:2043(id0.87) printpiece=[BTR,  ,  A, ,,  B]
Operands 0: Mem : 1536  1: Reg16 : 1537  
Pattern id=87 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:B3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[19900:[handle:size]] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[19980:[handle:size]] = INT_SRIGHT unique[19900:[handle:size]], const[3:4]
	4: unique[19a80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[19980:[handle:size]]
	5: unique[19b80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[7:[handle:size]]
	6: unique[19c00:1] = LOAD const[ram:8], unique[19a80:[handle:size]]
	7: unique[19c80:1] = INT_RIGHT unique[19c00:1], unique[19b80:[handle:size]]
	8: unique[19d80:1] = INT_AND unique[19c80:1], const[1:1]
	9: unique[19e00:1] = LOAD const[ram:8], unique[19a80:[handle:size]]
	10: unique[19e80:1] = INT_LEFT const[1:1], unique[19b80:[handle:size]]
	11: unique[19f00:1] = INT_NEGATE unique[19e80:1]
	12: unique[19f80:1] = INT_AND unique[19e00:1], unique[19f00:1]
	13: STORE const[ram:8], unique[19a80:[handle:size]], unique[19f80:1]
	14: register[200:1] = INT_NOTEQUAL unique[19d80:1], const[0:1]

Line ia.sinc:2044 :BTR Rmr32,Reg32	is vexMode=0 & opsize=1 & byte=0xf; byte=0xb3; mod=3 & Rmr32 & check_Rmr32_dest & Reg32		{ local bit=Reg32&0x1f; local val=(Rmr32>>bit)&1; CF=(val!=0); Rmr32=Rmr32 & ~(1<<bit); build check_Rmr32_dest;  }
0: Constructor line ia.sinc:2044(id0.88) printpiece=[BTR,  ,  A, ,,  C]
Operands 0: Rmr32 : 1538  1: check_Rmr32_dest : 1540  2: Reg32 : 1539  
Pattern id=88 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:B3:[11xx]X:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1a100:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1f:[handle:size]]
	3: unique[1a180:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[1a100:[handle:size]]
	4: unique[1a280:[handle:size]] = INT_AND unique[1a180:[handle:size]], const[1:[handle:size]]
	5: register[200:1] = INT_NOTEQUAL unique[1a280:[handle:size]], const[0:[handle:size]]
	6: unique[1a380:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[1a100:[handle:size]]
	7: unique[1a400:[handle:size]] = INT_NEGATE unique[1a380:[handle:size]]
	8: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[1a400:[handle:size]]
	9: MULTIEQUAL const[1:4]

Line ia.sinc:2045 :BTR Mem,Reg32	is vexMode=0 & opsize=1 & byte=0xf; byte=0xb3; Mem & Reg32 ...		{
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>> 3);
@else
    local ptr = Mem + (Reg32 s>> 3);
@endif
    local bit = Reg32 & 7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr & ~(1<<bit);
    CF = (val!=0);
}
1: Constructor line ia.sinc:2045(id0.89) printpiece=[BTR,  ,  A, ,,  B]
Operands 0: Mem : 1541  1: Reg32 : 1542  
Pattern id=89 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:B3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1a500:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], const[3:4]
	3: unique[1a600:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[1a500:[handle:size]]
	4: unique[1a700:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[7:[handle:size]]
	5: unique[1a780:1] = LOAD const[ram:8], unique[1a600:[handle:size]]
	6: unique[1a800:1] = INT_RIGHT unique[1a780:1], unique[1a700:[handle:size]]
	7: unique[1a900:1] = INT_AND unique[1a800:1], const[1:1]
	8: unique[1a980:1] = LOAD const[ram:8], unique[1a600:[handle:size]]
	9: unique[1aa00:1] = INT_LEFT const[1:1], unique[1a700:[handle:size]]
	10: unique[1aa80:1] = INT_NEGATE unique[1aa00:1]
	11: unique[1ab00:1] = INT_AND unique[1a980:1], unique[1aa80:1]
	12: STORE const[ram:8], unique[1a600:[handle:size]], unique[1ab00:1]
	13: register[200:1] = INT_NOTEQUAL unique[1a900:1], const[0:1]

Line ia.sinc:2899 :LFS Reg16,Mem      is vexMode=0 & opsize=0 & byte=0x0F; byte=0xB4; Mem & Reg16 ... { tmp:4 = *Mem; FS = tmp(2); Reg16 = tmp(0); }
0: Constructor line ia.sinc:2899(id0.247) printpiece=[LFS,  ,  B, ,,  A]
Operands 0: Mem : 1816  1: Reg16 : 1815  
Pattern id=247 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:B4:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2c100:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[108:2] = SUBPIECE unique[2c100:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2c100:4], const[0:4]

Line ia.sinc:2900 :LFS Reg32,Mem      is vexMode=0 & opsize=1 & byte=0x0F; byte=0xB4; Mem & Reg32 ... & check_Reg32_dest ... { tmp:6 = *Mem; FS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
0: Constructor line ia.sinc:2900(id0.248) printpiece=[LFS,  ,  B, ,,  A]
Operands 0: Mem : 1818  1: Reg32 : 1817  2: check_Reg32_dest : 1819  
Pattern id=248 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:B4:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2c300:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[108:2] = SUBPIECE unique[2c300:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2c300:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:2904 :LGS Reg16,Mem      is vexMode=0 & opsize=0 & byte=0x0F; byte=0xB5; Mem & Reg16 ... { tmp:4 = *Mem; GS = tmp(2); Reg16 = tmp(0); }
0: Constructor line ia.sinc:2904(id0.249) printpiece=[LGS,  ,  B, ,,  A]
Operands 0: Mem : 1821  1: Reg16 : 1820  
Pattern id=249 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:B5:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2c500:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[10a:2] = SUBPIECE unique[2c500:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2c500:4], const[0:4]

Line ia.sinc:2905 :LGS Reg32,Mem      is vexMode=0 & opsize=1 & byte=0x0F; byte=0xB5; Mem & Reg32 ... & check_Reg32_dest ... { tmp:6 = *Mem; GS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
0: Constructor line ia.sinc:2905(id0.250) printpiece=[LGS,  ,  B, ,,  A]
Operands 0: Mem : 1823  1: Reg32 : 1822  2: check_Reg32_dest : 1824  
Pattern id=250 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:B5:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2c700:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[10a:2] = SUBPIECE unique[2c700:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2c700:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:3180 :MOVZX Reg16,spec_rm8    is vexMode=0 & opsize=0 & byte=0xf; byte=0xb6; spec_rm8 & Reg16 ...  { Reg16 = zext(spec_rm8); }
0: Constructor line ia.sinc:3180(id0.316) printpiece=[MOVZX,  ,  B, ,,  A]
Operands 0: spec_rm8 : 1960  1: Reg16 : 1959  
Pattern id=316 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:B6:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3181 :MOVZX Reg32,spec_rm8    is vexMode=0 & opsize=1 & byte=0xf; byte=0xb6; spec_rm8 & Reg32 ... & check_Reg32_dest ... { Reg32 = zext(spec_rm8); build check_Reg32_dest; }
0: Constructor line ia.sinc:3181(id0.317) printpiece=[MOVZX,  ,  B, ,,  A]
Operands 0: spec_rm8 : 1962  1: Reg32 : 1961  2: check_Reg32_dest : 1963  
Pattern id=317 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:B6:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[2:4]

Line ia.sinc:3186 :MOVZX Reg32,spec_rm16   is vexMode=0 &            byte=0xf; byte=0xb7; spec_rm16 & Reg32 ... & check_Reg32_dest ...    { Reg32 = zext(spec_rm16); build check_Reg32_dest; }
0: Constructor line ia.sinc:3186(id0.318) printpiece=[MOVZX,  ,  B, ,,  A]
Operands 0: spec_rm16 : 1965  1: Reg32 : 1964  2: check_Reg32_dest : 1966  
Pattern id=318 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:B7:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[2:4]

Line ia.sinc:8645 :POPCNT Reg16, rm16      is vexMode=0 & opsize=0 & $(PRE_F3) &            byte=0x0F; byte=0xB8; Reg16 ... & rm16 { popcountflags(rm16); Reg16 = popcount(rm16); }
0: Constructor line ia.sinc:8645(id0.1485) printpiece=[POPCNT,  ,  A, ,,  ,  B]
Operands 0: Reg16 : 4226  1: rm16 : 4227  
Pattern id=1485 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:0F:B8:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[20b:1] = COPY const[0:1]
	3: register[207:1] = COPY const[0:1]
	4: register[204:1] = COPY const[0:1]
	5: register[200:1] = COPY const[0:1]
	6: register[202:1] = COPY const[0:1]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: [handle:space][[handle:offset]:[handle:size]] = POPCOUNT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8646 :POPCNT Reg32, rm32      is vexMode=0 & opsize=1 & $(PRE_F3) &            byte=0x0F; byte=0xB8; Reg32 ... & check_Reg32_dest ... & rm32 { popcountflags(rm32); Reg32 = popcount(rm32); build check_Reg32_dest; }
0: Constructor line ia.sinc:8646(id0.1486) printpiece=[POPCNT,  ,  A, ,,  ,  C]
Operands 0: Reg32 : 4228  1: check_Reg32_dest : 4230  2: rm32 : 4229  
Pattern id=1486 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:B8:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[20b:1] = COPY const[0:1]
	3: register[207:1] = COPY const[0:1]
	4: register[204:1] = COPY const[0:1]
	5: register[200:1] = COPY const[0:1]
	6: register[202:1] = COPY const[0:1]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: [handle:space][[handle:offset]:[handle:size]] = POPCOUNT [handle:space][[handle:offset]:[handle:size]]
	9: MULTIEQUAL const[1:4]

Line ia.sinc:3855 :UD1  Reg32, rm32 is vexMode=0 & byte=0x0f; byte=0xb9; rm32 & Reg32 ...           { invalidInstructionException(); goto inst_start; }
0: Constructor line ia.sinc:3855(id0.598) printpiece=[UD1,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2418  1: Reg32 : 2417  
Pattern id=598 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:B9:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[49:4]
	3: BRANCH [curspace][[start]:[curspace_size]]

Line ia.sinc:2012 :BT rm16,imm8       is vexMode=0 & opsize=0 & byte=0xf; byte=0xba; (rm16 & reg_opcode=4 ...); imm8  { CF = ((rm16 >> (imm8 & 0x0f)) & 1) != 0; } 
0: Constructor line ia.sinc:2012(id0.78) printpiece=[BT,  ,  A, ,,  B]
Operands 0: rm16 : 1516  1: imm8 : 1517  
Pattern id=78 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:BA:[xx10][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[17300:4] = INT_AND [handle:space][[handle:offset]:4], const[f:4]
	2: unique[17380:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[17300:4]
	3: unique[17400:[handle:size]] = INT_AND unique[17380:[handle:size]], const[1:[handle:size]]
	4: register[200:1] = INT_NOTEQUAL unique[17400:[handle:size]], const[0:[handle:size]]

Line ia.sinc:2013 :BT rm32,imm8       is vexMode=0 & opsize=1 & byte=0xf; byte=0xba; (rm32 & reg_opcode=4 ...); imm8  { CF = ((rm32 >> (imm8 & 0x1f)) & 1) != 0; }
0: Constructor line ia.sinc:2013(id0.79) printpiece=[BT,  ,  A, ,,  B]
Operands 0: rm32 : 1518  1: imm8 : 1519  
Pattern id=79 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:BA:[xx10][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[17500:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[17580:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[17500:4]
	3: unique[17600:[handle:size]] = INT_AND unique[17580:[handle:size]], const[1:[handle:size]]
	4: register[200:1] = INT_NOTEQUAL unique[17600:[handle:size]], const[0:[handle:size]]

Line ia.sinc:2084 :BTS rm16,imm8     is vexMode=0 & opsize=0 & byte=0xf; byte=0xba; (rm16 & reg_opcode=5 ...); imm8   { local bit=imm8&0xf; local val=(rm16>>bit)&1; rm16=rm16 | (1<<bit); CF=(val!=0); }
0: Constructor line ia.sinc:2084(id0.96) printpiece=[BTS,  ,  A, ,,  B]
Operands 0: rm16 : 1557  1: imm8 : 1558  
Pattern id=96 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:BA:[xx10][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1cb00:4] = INT_AND [handle:space][[handle:offset]:4], const[f:4]
	2: unique[1cb80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[1cb00:4]
	3: unique[1cc80:[handle:size]] = INT_AND unique[1cb80:[handle:size]], const[1:[handle:size]]
	4: unique[1cd00:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[1cb00:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], unique[1cd00:[handle:size]]
	6: register[200:1] = INT_NOTEQUAL unique[1cc80:[handle:size]], const[0:[handle:size]]

Line ia.sinc:2085 :BTS rm32,imm8     is vexMode=0 & opsize=1 & byte=0xf; byte=0xba; (rm32 & reg_opcode=5 ... & check_rm32_dest ...); imm8   { local bit=imm8&0x1f; local val=(rm32>>bit)&1; CF=(val!=0); rm32=rm32 | (1<<bit); build check_rm32_dest;  }
0: Constructor line ia.sinc:2085(id0.97) printpiece=[BTS,  ,  A, ,,  C]
Operands 0: rm32 : 1559  1: check_rm32_dest : 1561  2: imm8 : 1560  
Pattern id=97 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:BA:[xx10][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1cf00:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[1cf80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[1cf00:4]
	3: unique[1d080:[handle:size]] = INT_AND unique[1cf80:[handle:size]], const[1:[handle:size]]
	4: register[200:1] = INT_NOTEQUAL unique[1d080:[handle:size]], const[0:[handle:size]]
	5: unique[1d180:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[1cf00:4]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], unique[1d180:[handle:size]]
	7: MULTIEQUAL const[1:4]

Line ia.sinc:2060 :BTR rm16,imm8     is vexMode=0 & opsize=0 & byte=0xf; byte=0xba; (rm16 & reg_opcode=6 ...); imm8   { local bit=imm8&0xf; local val=(rm16>>bit)&1; rm16=rm16 & ~(1<<bit); CF=(val!=0); }
0: Constructor line ia.sinc:2060(id0.90) printpiece=[BTR,  ,  A, ,,  B]
Operands 0: rm16 : 1543  1: imm8 : 1544  
Pattern id=90 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:BA:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1ac80:4] = INT_AND [handle:space][[handle:offset]:4], const[f:4]
	2: unique[1ad00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[1ac80:4]
	3: unique[1ae00:[handle:size]] = INT_AND unique[1ad00:[handle:size]], const[1:[handle:size]]
	4: unique[1ae80:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[1ac80:4]
	5: unique[1af00:[handle:size]] = INT_NEGATE unique[1ae80:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[1af00:[handle:size]]
	7: register[200:1] = INT_NOTEQUAL unique[1ae00:[handle:size]], const[0:[handle:size]]

Line ia.sinc:2061 :BTR rm32,imm8     is vexMode=0 & opsize=1 & byte=0xf; byte=0xba; (rm32 & reg_opcode=6 ... & check_rm32_dest ...); imm8   { local bit=imm8&0x1f; local val=(rm32>>bit)&1; CF=(val!=0); rm32=rm32 & ~(1<<bit); build check_rm32_dest;  }
0: Constructor line ia.sinc:2061(id0.91) printpiece=[BTR,  ,  A, ,,  C]
Operands 0: rm32 : 1545  1: check_rm32_dest : 1547  2: imm8 : 1546  
Pattern id=91 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:BA:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1b100:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[1b180:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[1b100:4]
	3: unique[1b280:[handle:size]] = INT_AND unique[1b180:[handle:size]], const[1:[handle:size]]
	4: register[200:1] = INT_NOTEQUAL unique[1b280:[handle:size]], const[0:[handle:size]]
	5: unique[1b380:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[1b100:4]
	6: unique[1b400:[handle:size]] = INT_NEGATE unique[1b380:[handle:size]]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[1b400:[handle:size]]
	8: MULTIEQUAL const[1:4]

Line ia.sinc:2036 :BTC rm16,imm8     is vexMode=0 & opsize=0 & byte=0xf; byte=0xba; (rm16 & reg_opcode=7 ...); imm8   { local bit=imm8&0xf; local val=(rm16>>bit)&1; rm16=rm16^(1<<bit); CF=(val!=0); }
0: Constructor line ia.sinc:2036(id0.84) printpiece=[BTC,  ,  A, ,,  B]
Operands 0: rm16 : 1529  1: imm8 : 1530  
Pattern id=84 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:BA:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[18d00:4] = INT_AND [handle:space][[handle:offset]:4], const[f:4]
	2: unique[18d80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[18d00:4]
	3: unique[18e80:[handle:size]] = INT_AND unique[18d80:[handle:size]], const[1:[handle:size]]
	4: unique[18f00:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[18d00:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], unique[18f00:[handle:size]]
	6: register[200:1] = INT_NOTEQUAL unique[18e80:[handle:size]], const[0:[handle:size]]

Line ia.sinc:2037 :BTC rm32,imm8     is vexMode=0 & opsize=1 & byte=0xf; byte=0xba; (rm32 & check_rm32_dest ... & reg_opcode=7 ...); imm8   { local bit=imm8&0x1f; local val=(rm32>>bit)&1; CF=(val!=0); rm32=rm32^(1<<bit); build check_rm32_dest; }
0: Constructor line ia.sinc:2037(id0.85) printpiece=[BTC,  ,  A, ,,  C]
Operands 0: rm32 : 1531  1: check_rm32_dest : 1533  2: imm8 : 1532  
Pattern id=85 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:BA:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[19100:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[19180:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[19100:4]
	3: unique[19280:[handle:size]] = INT_AND unique[19180:[handle:size]], const[1:[handle:size]]
	4: register[200:1] = INT_NOTEQUAL unique[19280:[handle:size]], const[0:[handle:size]]
	5: unique[19380:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[19100:4]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], unique[19380:[handle:size]]
	7: MULTIEQUAL const[1:4]

Line ia.sinc:2018 :BTC Rmr16,Reg16	is vexMode=0 & opsize=0 & byte=0xf; byte=0xbb; mod=3 & Rmr16 & Reg16		{ local bit=Reg16&0xf; local val=(Rmr16>>bit)&1; Rmr16=Rmr16^(1<<bit); CF=(val!=0); }
0: Constructor line ia.sinc:2018(id0.80) printpiece=[BTC,  ,  A, ,,  B]
Operands 0: Rmr16 : 1520  1: Reg16 : 1521  
Pattern id=80 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:BB:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[17780:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[f:[handle:size]]
	3: unique[17800:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[17780:[handle:size]]
	4: unique[17900:[handle:size]] = INT_AND unique[17800:[handle:size]], const[1:[handle:size]]
	5: unique[17980:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[17780:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], unique[17980:[handle:size]]
	7: register[200:1] = INT_NOTEQUAL unique[17900:[handle:size]], const[0:[handle:size]]

Line ia.sinc:2019 :BTC Mem,Reg16	is vexMode=0 & opsize=0 & byte=0xf; byte=0xbb; Mem & Reg16 ...		{ local ptr = Mem + (sext(Reg16) s>> 3); local bit=Reg16&7; local val = (*:1 ptr >> bit) & 1; *:1 ptr= *:1 ptr ^(1<<bit); CF=(val!=0); }
1: Constructor line ia.sinc:2019(id0.81) printpiece=[BTC,  ,  A, ,,  B]
Operands 0: Mem : 1522  1: Reg16 : 1523  
Pattern id=81 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:BB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[17b00:[handle:size]] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[17b80:[handle:size]] = INT_SRIGHT unique[17b00:[handle:size]], const[3:4]
	4: unique[17c80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[17b80:[handle:size]]
	5: unique[17d80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[7:[handle:size]]
	6: unique[17e00:1] = LOAD const[ram:8], unique[17c80:[handle:size]]
	7: unique[17e80:1] = INT_RIGHT unique[17e00:1], unique[17d80:[handle:size]]
	8: unique[17f80:1] = INT_AND unique[17e80:1], const[1:1]
	9: unique[18000:1] = LOAD const[ram:8], unique[17c80:[handle:size]]
	10: unique[18080:1] = INT_LEFT const[1:1], unique[17d80:[handle:size]]
	11: unique[18100:1] = INT_XOR unique[18000:1], unique[18080:1]
	12: STORE const[ram:8], unique[17c80:[handle:size]], unique[18100:1]
	13: register[200:1] = INT_NOTEQUAL unique[17f80:1], const[0:1]

Line ia.sinc:2020 :BTC Rmr32,Reg32	is vexMode=0 & opsize=1 & byte=0xf; byte=0xbb; mod=3 & Rmr32 & Reg32 & check_Rmr32_dest 		{ local bit=Reg32&0x1f; local val=(Rmr32>>bit)&1; CF=(val!=0); Rmr32=Rmr32^(1<<bit); build check_Rmr32_dest; }
0: Constructor line ia.sinc:2020(id0.82) printpiece=[BTC,  ,  A, ,,  B]
Operands 0: Rmr32 : 1524  1: Reg32 : 1525  2: check_Rmr32_dest : 1526  
Pattern id=82 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:BB:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[18280:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1f:[handle:size]]
	3: unique[18300:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[18280:[handle:size]]
	4: unique[18400:[handle:size]] = INT_AND unique[18300:[handle:size]], const[1:[handle:size]]
	5: register[200:1] = INT_NOTEQUAL unique[18400:[handle:size]], const[0:[handle:size]]
	6: unique[18500:[handle:size]] = INT_LEFT const[1:[handle:size]], unique[18280:[handle:size]]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], unique[18500:[handle:size]]
	8: MULTIEQUAL const[2:4]

Line ia.sinc:2021 :BTC Mem,Reg32	is vexMode=0 & opsize=1 & byte=0xf; byte=0xbb; Mem & Reg32 ...		{
@ifdef IA64
    local ptr = Mem + (sext(Reg32) s>> 3);
@else
    local ptr = Mem + (Reg32 s>> 3);
@endif
    local bit=Reg32&7;
    local val = (*:1 ptr >> bit) & 1;
    *:1 ptr = *:1 ptr ^ (1<<bit);
    CF = (val != 0);
}
1: Constructor line ia.sinc:2021(id0.83) printpiece=[BTC,  ,  A, ,,  B]
Operands 0: Mem : 1527  1: Reg32 : 1528  
Pattern id=83 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:BB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[18600:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], const[3:4]
	3: unique[18700:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[18600:[handle:size]]
	4: unique[18800:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[7:[handle:size]]
	5: unique[18880:1] = LOAD const[ram:8], unique[18700:[handle:size]]
	6: unique[18900:1] = INT_RIGHT unique[18880:1], unique[18800:[handle:size]]
	7: unique[18a00:1] = INT_AND unique[18900:1], const[1:1]
	8: unique[18a80:1] = LOAD const[ram:8], unique[18700:[handle:size]]
	9: unique[18b00:1] = INT_LEFT const[1:1], unique[18800:[handle:size]]
	10: unique[18b80:1] = INT_XOR unique[18a80:1], unique[18b00:1]
	11: STORE const[ram:8], unique[18700:[handle:size]], unique[18b80:1]
	12: register[200:1] = INT_NOTEQUAL unique[18a00:1], const[0:1]

Line bmi1.sinc:142 :TZCNT Reg16, rm16	is vexMode=0 & opsize=0 & $(PRE_66) & $(PRE_F3) & byte=0x0F; byte=0xBC; Reg16 ... & rm16 {

  countTmp:2 = 0;
  inputTmp:2 = rm16;

 <loopbegin>
  if ((inputTmp & 1) != 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp >> 1) | 0x8000;
  goto <loopbegin>;

 <loopend>
  tzcntflags(rm16, countTmp);
  Reg16 = countTmp;
 
}
0: Constructor line bmi1.sinc:142(id0.2120) printpiece=[TZCNT,  ,  A, ,,  ,  B]
Operands 0: Reg16 : 7130  1: rm16 : 7131  
Pattern id=2120 pattern=cmb:(ctx:X[xx00]:X[x11x]:X[0xxx]:XX,ins:0F:BC:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[ce180:2] = COPY const[0:2]
	3: unique[ce200:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: PTRADD const[0:4]
	5: unique[ce280:2] = INT_AND unique[ce200:2], const[1:2]
	6: unique[ce300:1] = INT_NOTEQUAL unique[ce280:2], const[0:2]
	7: CBRANCH const[[rel:1]:4], unique[ce300:1]
	8: unique[ce180:2] = INT_ADD unique[ce180:2], const[1:2]
	9: unique[ce400:2] = INT_RIGHT unique[ce200:2], const[1:4]
	10: unique[ce200:2] = INT_OR unique[ce400:2], const[8000:2]
	11: BRANCH const[[rel:0]:4]
	12: PTRADD const[1:4]
	13: register[206:1] = INT_EQUAL unique[ce180:2], const[0:2]
	14: register[200:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: [handle:space][[handle:offset]:[handle:size]] = COPY unique[ce180:2]

Line ia.sinc:1758 :BSF Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0xbc; rm16 & Reg16 ...
{
    bitIndex:2 = 0;

    ZF = ( rm16 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( ((rm16 >> bitIndex) & 0x0001) != 0 ) goto <done>;
      bitIndex = bitIndex + 1;
    goto <start>;
    
<done>
    Reg16 = bitIndex;
}                             
1: Constructor line ia.sinc:1758(id0.69) printpiece=[BSF,  ,  B, ,,  A]
Operands 0: rm16 : 1497  1: Reg16 : 1496  
Pattern id=69 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:BC:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[15380:2] = COPY const[0:2]
	3: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[15480:1] = INT_EQUAL register[206:1], const[1:1]
	5: CBRANCH const[[rel:0]:4], unique[15480:1]
	6: PTRADD const[1:4]
	7: unique[15500:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[15380:2]
	8: unique[15580:[handle:size]] = INT_AND unique[15500:[handle:size]], const[1:[handle:size]]
	9: unique[15600:1] = INT_NOTEQUAL unique[15580:[handle:size]], const[0:[handle:size]]
	10: CBRANCH const[[rel:0]:4], unique[15600:1]
	11: unique[15380:2] = INT_ADD unique[15380:2], const[1:2]
	12: BRANCH const[[rel:1]:4]
	13: PTRADD const[0:4]
	14: [handle:space][[handle:offset]:[handle:size]] = COPY unique[15380:2]

Line bmi1.sinc:160 :TZCNT Reg32, rm32	is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0F; byte=0xBC; Reg32 ... & check_Reg32_dest ... & rm32 {

  countTmp:4 = 0;
  inputTmp:4 = rm32;

 <loopbegin>
  if ((inputTmp & 1) != 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp >> 1) | 0x80000000;
  goto <loopbegin>;

 <loopend>
  tzcntflags(rm32, countTmp);
  Reg32 = countTmp;
  build check_Reg32_dest;
}
0: Constructor line bmi1.sinc:160(id0.2121) printpiece=[TZCNT,  ,  A, ,,  ,  C]
Operands 0: Reg32 : 7132  1: check_Reg32_dest : 7134  2: rm32 : 7133  
Pattern id=2121 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:BC:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[ce500:4] = COPY const[0:4]
	3: unique[ce580:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: PTRADD const[0:4]
	5: unique[ce600:4] = INT_AND unique[ce580:4], const[1:4]
	6: unique[ce680:1] = INT_NOTEQUAL unique[ce600:4], const[0:4]
	7: CBRANCH const[[rel:1]:4], unique[ce680:1]
	8: unique[ce500:4] = INT_ADD unique[ce500:4], const[1:4]
	9: unique[ce780:4] = INT_RIGHT unique[ce580:4], const[1:4]
	10: unique[ce580:4] = INT_OR unique[ce780:4], const[80000000:4]
	11: BRANCH const[[rel:0]:4]
	12: PTRADD const[1:4]
	13: register[206:1] = INT_EQUAL unique[ce500:4], const[0:4]
	14: register[200:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: [handle:space][[handle:offset]:[handle:size]] = COPY unique[ce500:4]
	16: MULTIEQUAL const[1:4]

Line ia.sinc:1798 :BSF Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0xbc; rm32 & Reg32 ... & check_Reg32_dest ...                 
{
    bitIndex:4 = 0;

    ZF = ( rm32 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( ((rm32 >> bitIndex) & 0x00000001) != 0 ) goto <done>;
      bitIndex = bitIndex + 1;
    goto <start>;
    
<done>
    Reg32 = bitIndex;
    build check_Reg32_dest;
}                             
1: Constructor line ia.sinc:1798(id0.70) printpiece=[BSF,  ,  B, ,,  A]
Operands 0: rm32 : 1499  1: Reg32 : 1498  2: check_Reg32_dest : 1500  
Pattern id=70 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:BC:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[15700:4] = COPY const[0:4]
	3: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[15800:1] = INT_EQUAL register[206:1], const[1:1]
	5: CBRANCH const[[rel:0]:4], unique[15800:1]
	6: PTRADD const[1:4]
	7: unique[15880:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[15700:4]
	8: unique[15900:[handle:size]] = INT_AND unique[15880:[handle:size]], const[1:[handle:size]]
	9: unique[15980:1] = INT_NOTEQUAL unique[15900:[handle:size]], const[0:[handle:size]]
	10: CBRANCH const[[rel:0]:4], unique[15980:1]
	11: unique[15700:4] = INT_ADD unique[15700:4], const[1:4]
	12: BRANCH const[[rel:1]:4]
	13: PTRADD const[0:4]
	14: [handle:space][[handle:offset]:[handle:size]] = COPY unique[15700:4]
	15: MULTIEQUAL const[2:4]

Line lzcnt.sinc:12 :LZCNT Reg16, rm16	is vexMode=0 & opsize=0 & $(PRE_66) & $(PRE_F3) & byte=0x0F; byte=0xBD; Reg16 ... & rm16 {

  countTmp:2 = 0;
  inputTmp:2 = rm16;

 <loopbegin>
  if ((inputTmp & 0x8000) != 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp << 1) | 1;
  goto <loopbegin>;

 <loopend>
  lzcntflags(rm16, countTmp);
  Reg16 = countTmp;
 
}
0: Constructor line lzcnt.sinc:12(id0.2113) printpiece=[LZCNT,  ,  A, ,,  ,  B]
Operands 0: Reg16 : 7108  1: rm16 : 7109  
Pattern id=2113 pattern=cmb:(ctx:X[xx00]:X[x11x]:X[0xxx]:XX,ins:0F:BD:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[cce00:2] = COPY const[0:2]
	3: unique[cce80:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: PTRADD const[0:4]
	5: unique[ccf00:2] = INT_AND unique[cce80:2], const[8000:2]
	6: unique[ccf80:1] = INT_NOTEQUAL unique[ccf00:2], const[0:2]
	7: CBRANCH const[[rel:1]:4], unique[ccf80:1]
	8: unique[cce00:2] = INT_ADD unique[cce00:2], const[1:2]
	9: unique[cd080:2] = INT_LEFT unique[cce80:2], const[1:4]
	10: unique[cce80:2] = INT_OR unique[cd080:2], const[1:2]
	11: BRANCH const[[rel:0]:4]
	12: PTRADD const[1:4]
	13: register[206:1] = INT_EQUAL unique[cce00:2], const[0:2]
	14: register[200:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: [handle:space][[handle:offset]:[handle:size]] = COPY unique[cce00:2]

Line ia.sinc:1875 :BSR Reg16,rm16     is vexMode=0 & opsize=0 & byte=0xf; byte=0xbd; rm16 & Reg16 ...                   
{
    bitIndex:2 = 15;

    ZF = ( rm16 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( (rm16 >> bitIndex) != 0 ) goto <done>;
      bitIndex = bitIndex - 1;
    goto <start>;
    
<done>
    Reg16 = bitIndex;
}                             
1: Constructor line ia.sinc:1875(id0.71) printpiece=[BSR,  ,  B, ,,  A]
Operands 0: rm16 : 1502  1: Reg16 : 1501  
Pattern id=71 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:BD:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[15a80:2] = COPY const[f:2]
	3: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[15b80:1] = INT_EQUAL register[206:1], const[1:1]
	5: CBRANCH const[[rel:0]:4], unique[15b80:1]
	6: PTRADD const[1:4]
	7: unique[15c00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[15a80:2]
	8: unique[15c80:1] = INT_NOTEQUAL unique[15c00:[handle:size]], const[0:[handle:size]]
	9: CBRANCH const[[rel:0]:4], unique[15c80:1]
	10: unique[15a80:2] = INT_SUB unique[15a80:2], const[1:2]
	11: BRANCH const[[rel:1]:4]
	12: PTRADD const[0:4]
	13: [handle:space][[handle:offset]:[handle:size]] = COPY unique[15a80:2]

Line lzcnt.sinc:30 :LZCNT Reg32, rm32	is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0F; byte=0xBD; Reg32 ... & check_Reg32_dest ... & rm32 {

  countTmp:4 = 0;
  inputTmp:4 = rm32;

 <loopbegin>
  if ((inputTmp & 0x80000000) != 0) goto <loopend>;

  countTmp = countTmp + 1;
  inputTmp = (inputTmp << 1) | 1;
  goto <loopbegin>;

 <loopend>
  lzcntflags(rm32, countTmp);
  Reg32 = countTmp;
  build check_Reg32_dest;
}
0: Constructor line lzcnt.sinc:30(id0.2114) printpiece=[LZCNT,  ,  A, ,,  ,  C]
Operands 0: Reg32 : 7110  1: check_Reg32_dest : 7112  2: rm32 : 7111  
Pattern id=2114 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:BD:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[cd180:4] = COPY const[0:4]
	3: unique[cd200:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: PTRADD const[0:4]
	5: unique[cd280:4] = INT_AND unique[cd200:4], const[80000000:4]
	6: unique[cd300:1] = INT_NOTEQUAL unique[cd280:4], const[0:4]
	7: CBRANCH const[[rel:1]:4], unique[cd300:1]
	8: unique[cd180:4] = INT_ADD unique[cd180:4], const[1:4]
	9: unique[cd400:4] = INT_LEFT unique[cd200:4], const[1:4]
	10: unique[cd200:4] = INT_OR unique[cd400:4], const[1:4]
	11: BRANCH const[[rel:0]:4]
	12: PTRADD const[1:4]
	13: register[206:1] = INT_EQUAL unique[cd180:4], const[0:4]
	14: register[200:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: [handle:space][[handle:offset]:[handle:size]] = COPY unique[cd180:4]
	16: MULTIEQUAL const[1:4]

Line ia.sinc:1915 :BSR Reg32,rm32     is vexMode=0 & opsize=1 & byte=0xf; byte=0xbd; rm32 & Reg32 ... & check_Reg32_dest ...
{
    bitIndex:4 = 31;

    ZF = ( rm32 == 0 );
    
    if ( ZF == 1 ) goto <done>;
     
<start>
    if ( (rm32 >> bitIndex) != 0 ) goto <done>;
      bitIndex = bitIndex - 1;
    goto <start>;
    
<done>
    Reg32 = bitIndex;
    build check_Reg32_dest;
}                             
1: Constructor line ia.sinc:1915(id0.72) printpiece=[BSR,  ,  B, ,,  A]
Operands 0: rm32 : 1504  1: Reg32 : 1503  2: check_Reg32_dest : 1505  
Pattern id=72 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:BD:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[15d80:4] = COPY const[1f:4]
	3: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[15e80:1] = INT_EQUAL register[206:1], const[1:1]
	5: CBRANCH const[[rel:0]:4], unique[15e80:1]
	6: PTRADD const[1:4]
	7: unique[15f00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[15d80:4]
	8: unique[15f80:1] = INT_NOTEQUAL unique[15f00:[handle:size]], const[0:[handle:size]]
	9: CBRANCH const[[rel:0]:4], unique[15f80:1]
	10: unique[15d80:4] = INT_SUB unique[15d80:4], const[1:4]
	11: BRANCH const[[rel:1]:4]
	12: PTRADD const[0:4]
	13: [handle:space][[handle:offset]:[handle:size]] = COPY unique[15d80:4]
	14: MULTIEQUAL const[2:4]

Line ia.sinc:3165 :MOVSX Reg16,spec_rm8    is vexMode=0 & opsize=0 & byte=0xf; byte=0xbe; spec_rm8 & Reg16 ...  { Reg16 = sext(spec_rm8); }
0: Constructor line ia.sinc:3165(id0.312) printpiece=[MOVSX,  ,  B, ,,  A]
Operands 0: spec_rm8 : 1949  1: Reg16 : 1948  
Pattern id=312 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:BE:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3166 :MOVSX Reg32,spec_rm8    is vexMode=0 & opsize=1 & byte=0xf; byte=0xbe; spec_rm8 & Reg32 ... & check_Reg32_dest ... { Reg32 = sext(spec_rm8); build check_Reg32_dest; }
0: Constructor line ia.sinc:3166(id0.313) printpiece=[MOVSX,  ,  B, ,,  A]
Operands 0: spec_rm8 : 1951  1: Reg32 : 1950  2: check_Reg32_dest : 1952  
Pattern id=313 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:BE:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[2:4]

Line ia.sinc:3170 :MOVSX Reg32,spec_rm16   is vexMode=0 &            byte=0xf; byte=0xbf; spec_rm16 & Reg32 ... & check_Reg32_dest ...    { Reg32 = sext(spec_rm16); build check_Reg32_dest; }
0: Constructor line ia.sinc:3170(id0.314) printpiece=[MOVSX,  ,  B, ,,  A]
Operands 0: spec_rm16 : 1954  1: Reg32 : 1953  2: check_Reg32_dest : 1955  
Pattern id=314 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:BF:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[2:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3944 :XADD   rm8,Reg8   is vexMode=0 & byte=0x0F; byte=0xC0;  rm8 & Reg8  ...        { addflags( rm8,Reg8 ); local tmp =  rm8 +  Reg8;  Reg8 = rm8; rm8 = tmp;     resultflags(tmp); } 
0: Constructor line ia.sinc:3944(id0.622) printpiece=[XADD,  ,  A, ,,  B]
Operands 0: rm8 : 2442  1: Reg8 : 2443  
Pattern id=622 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C0:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[43200:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = COPY unique[43200:[handle:size]]
	7: register[207:1] = INT_SLESS unique[43200:[handle:size]], const[0:[handle:size]]
	8: register[206:1] = INT_EQUAL unique[43200:[handle:size]], const[0:[handle:size]]
	9: unique[dc80:[handle:size]] = INT_AND unique[43200:[handle:size]], const[ff:[handle:size]]
	10: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	11: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	12: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3945 :XADD  rm16,Reg16  is vexMode=0 & opsize=0 & byte=0x0F; byte=0xC1; rm16 & Reg16 ... { addflags(rm16,Reg16); local tmp = rm16 + Reg16; Reg16 = rm16; rm16 = tmp; resultflags(tmp); } 
0: Constructor line ia.sinc:3945(id0.623) printpiece=[XADD,  ,  A, ,,  B]
Operands 0: rm16 : 2444  1: Reg16 : 2445  
Pattern id=623 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:C1:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[43300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = COPY unique[43300:[handle:size]]
	7: register[207:1] = INT_SLESS unique[43300:[handle:size]], const[0:[handle:size]]
	8: register[206:1] = INT_EQUAL unique[43300:[handle:size]], const[0:[handle:size]]
	9: unique[dc80:[handle:size]] = INT_AND unique[43300:[handle:size]], const[ff:[handle:size]]
	10: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	11: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	12: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3946 :XADD  rm32,Reg32  is vexMode=0 & opsize=1 & byte=0x0F; byte=0xC1; rm32 & check_rm32_dest ... & Reg32 ... & check_Reg32_dest ... { addflags(rm32,Reg32); local tmp = rm32 + Reg32; Reg32 = rm32; rm32 = tmp; build check_rm32_dest; build check_Reg32_dest; resultflags(tmp); }
0: Constructor line ia.sinc:3946(id0.624) printpiece=[XADD,  ,  A, ,,  C]
Operands 0: rm32 : 2446  1: check_rm32_dest : 2448  2: Reg32 : 2447  3: check_Reg32_dest : 2449  
Pattern id=624 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:C1:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[43400:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = COPY unique[43400:[handle:size]]
	7: MULTIEQUAL const[1:4]
	8: MULTIEQUAL const[3:4]
	9: register[207:1] = INT_SLESS unique[43400:[handle:size]], const[0:[handle:size]]
	10: register[206:1] = INT_EQUAL unique[43400:[handle:size]], const[0:[handle:size]]
	11: unique[dc80:[handle:size]] = INT_AND unique[43400:[handle:size]], const[ff:[handle:size]]
	12: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	13: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	14: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:4976 :CMP^XmmCondPS^"PS"        XmmReg1,XmmReg2^CMPPS_OPERAND  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondPS & CMPPS_OPERAND 
{
	xmmTmp1_Da = XmmReg1[0,32];
	xmmTmp1_Db = XmmReg1[32,32];
	xmmTmp1_Dc = XmmReg1[64,32];
	xmmTmp1_Dd = XmmReg1[96,32];
	
	xmmTmp2_Da = XmmReg2[0,32];
	xmmTmp2_Db = XmmReg2[32,32];
	xmmTmp2_Dc = XmmReg2[64,32];
	xmmTmp2_Dc = XmmReg2[96,32];
	
	build XmmCondPS;
	
	XmmReg1[0,32] = xmmTmp1_Da;
	XmmReg1[32,32] = xmmTmp1_Db;
	XmmReg1[64,32] = xmmTmp1_Dc;
	XmmReg1[96,32] = xmmTmp1_Dd;
}
0: Constructor line ia.sinc:4976(id0.842) printpiece=[CMP,  C, PS,  ,  A, ,,  B,  D]
Operands 0: XmmReg1 : 2732  1: XmmReg2 : 2733  2: XmmCondPS : 2731  3: CMPPS_OPERAND : 2734  
Pattern id=842 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:C2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: register[1400:4] = COPY [handle:space][[handle:offset+0]:4]
	4: register[1404:4] = COPY [handle:space][[handle:offset+40004]:4]
	5: register[1408:4] = COPY [handle:space][[handle:offset+80008]:4]
	6: register[140c:4] = COPY [handle:space][[handle:offset+c000c]:4]
	7: register[1410:4] = COPY [handle:space][[handle:offset+0]:4]
	8: register[1414:4] = COPY [handle:space][[handle:offset+40004]:4]
	9: register[1418:4] = COPY [handle:space][[handle:offset+80008]:4]
	10: register[1418:4] = COPY [handle:space][[handle:offset+c000c]:4]
	11: MULTIEQUAL const[2:4]
	12: [handle:space][[handle:offset+0]:4] = COPY register[1400:4]
	13: [handle:space][[handle:offset+40004]:4] = COPY register[1404:4]
	14: [handle:space][[handle:offset+80008]:4] = COPY register[1408:4]
	15: [handle:space][[handle:offset+c000c]:4] = COPY register[140c:4]

Line ia.sinc:4955 :CMP^XmmCondPS^"PS"        XmmReg,m128^CMPPS_OPERAND      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC2; (m128 & XmmReg ...); XmmCondPS & CMPPS_OPERAND
{
    local m:16 = m128;
	xmmTmp1_Da = XmmReg[0,32];
	xmmTmp1_Db = XmmReg[32,32];
	xmmTmp1_Dc = XmmReg[64,32];
	xmmTmp1_Dd = XmmReg[96,32];

	xmmTmp2_Da = m[0,32];
	xmmTmp2_Db = m[32,32];
	xmmTmp2_Dc = m[64,32];
	xmmTmp2_Dd = m[96,32];

	build XmmCondPS;
	
	XmmReg[0,32] = xmmTmp1_Da;
	XmmReg[32,32] = xmmTmp1_Db;
	XmmReg[64,32] = xmmTmp1_Dc;
	XmmReg[96,32] = xmmTmp1_Dd;
}
1: Constructor line ia.sinc:4955(id0.841) printpiece=[CMP,  C, PS,  ,  B, ,,  A,  D]
Operands 0: m128 : 2729  1: XmmReg : 2728  2: XmmCondPS : 2727  3: CMPPS_OPERAND : 2730  
Pattern id=841 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:C2:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: unique[58c80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: register[1400:4] = COPY [handle:space][[handle:offset+0]:4]
	5: register[1404:4] = COPY [handle:space][[handle:offset+40004]:4]
	6: register[1408:4] = COPY [handle:space][[handle:offset+80008]:4]
	7: register[140c:4] = COPY [handle:space][[handle:offset+c000c]:4]
	8: register[1410:4] = SUBPIECE unique[58c80:10], const[0:4]
	9: register[1414:4] = SUBPIECE unique[58c80:10], const[4:4]
	10: register[1418:4] = SUBPIECE unique[58c80:10], const[8:4]
	11: register[141c:4] = SUBPIECE unique[58c80:10], const[c:4]
	12: MULTIEQUAL const[2:4]
	13: [handle:space][[handle:offset+0]:4] = COPY register[1400:4]
	14: [handle:space][[handle:offset+40004]:4] = COPY register[1404:4]
	15: [handle:space][[handle:offset+80008]:4] = COPY register[1408:4]
	16: [handle:space][[handle:offset+c000c]:4] = COPY register[140c:4]

Line ia.sinc:4870 :CMP^XmmCondPD^"PD"        XmmReg1,XmmReg2^CMPPD_OPERAND  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondPD & CMPPD_OPERAND 
{
	xmmTmp1_Qa = XmmReg1[0,64];
	xmmTmp1_Qb = XmmReg1[64,64];
	
	xmmTmp2_Qa = XmmReg2[0,64];
	xmmTmp2_Qb = XmmReg2[64,64];
	
	build XmmCondPD;
	
	XmmReg1[0,64] = xmmTmp1_Qa;
	XmmReg1[64,64] = xmmTmp1_Qb;
}
0: Constructor line ia.sinc:4870(id0.840) printpiece=[CMP,  C, PD,  ,  A, ,,  B,  D]
Operands 0: XmmReg1 : 2719  1: XmmReg2 : 2720  2: XmmCondPD : 2718  3: CMPPD_OPERAND : 2721  
Pattern id=840 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: register[1400:8] = COPY [handle:space][[handle:offset+0]:8]
	4: register[1408:8] = COPY [handle:space][[handle:offset+80008]:8]
	5: register[1410:8] = COPY [handle:space][[handle:offset+0]:8]
	6: register[1418:8] = COPY [handle:space][[handle:offset+80008]:8]
	7: MULTIEQUAL const[2:4]
	8: [handle:space][[handle:offset+0]:8] = COPY register[1400:8]
	9: [handle:space][[handle:offset+80008]:8] = COPY register[1408:8]

Line ia.sinc:4855 :CMP^XmmCondPD^"PD"        XmmReg,m128^CMPPD_OPERAND      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC2; (m128 & XmmReg ...); XmmCondPD & CMPPD_OPERAND
{
    local m:16 = m128;
	xmmTmp1_Qa = XmmReg[0,64];
	xmmTmp1_Qb = XmmReg[64,64];

	xmmTmp2_Qa = m[0,64];
	xmmTmp2_Qb = m[64,64];

	build XmmCondPD;
	
	XmmReg[0,64] = xmmTmp1_Qa;
	XmmReg[64,64] = xmmTmp1_Qb;
}
1: Constructor line ia.sinc:4855(id0.839) printpiece=[CMP,  C, PD,  ,  B, ,,  A,  D]
Operands 0: m128 : 2716  1: XmmReg : 2715  2: XmmCondPD : 2714  3: CMPPD_OPERAND : 2717  
Pattern id=839 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C2:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: unique[54b00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: register[1400:8] = COPY [handle:space][[handle:offset+0]:8]
	5: register[1408:8] = COPY [handle:space][[handle:offset+80008]:8]
	6: register[1410:8] = SUBPIECE unique[54b00:10], const[0:4]
	7: register[1418:8] = SUBPIECE unique[54b00:10], const[8:4]
	8: MULTIEQUAL const[2:4]
	9: [handle:space][[handle:offset+0]:8] = COPY register[1400:8]
	10: [handle:space][[handle:offset+80008]:8] = COPY register[1408:8]

Line ia.sinc:4870 :CMP^XmmCondPD^"PD"        XmmReg1,XmmReg2^CMPPD_OPERAND  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondPD & CMPPD_OPERAND 
{
	xmmTmp1_Qa = XmmReg1[0,64];
	xmmTmp1_Qb = XmmReg1[64,64];
	
	xmmTmp2_Qa = XmmReg2[0,64];
	xmmTmp2_Qb = XmmReg2[64,64];
	
	build XmmCondPD;
	
	XmmReg1[0,64] = xmmTmp1_Qa;
	XmmReg1[64,64] = xmmTmp1_Qb;
}
0: Constructor line ia.sinc:4870(id0.840) printpiece=[CMP,  C, PD,  ,  A, ,,  B,  D]
Operands 0: XmmReg1 : 2719  1: XmmReg2 : 2720  2: XmmCondPD : 2718  3: CMPPD_OPERAND : 2721  
Pattern id=840 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: register[1400:8] = COPY [handle:space][[handle:offset+0]:8]
	4: register[1408:8] = COPY [handle:space][[handle:offset+80008]:8]
	5: register[1410:8] = COPY [handle:space][[handle:offset+0]:8]
	6: register[1418:8] = COPY [handle:space][[handle:offset+80008]:8]
	7: MULTIEQUAL const[2:4]
	8: [handle:space][[handle:offset+0]:8] = COPY register[1400:8]
	9: [handle:space][[handle:offset+80008]:8] = COPY register[1408:8]

Line ia.sinc:4855 :CMP^XmmCondPD^"PD"        XmmReg,m128^CMPPD_OPERAND      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC2; (m128 & XmmReg ...); XmmCondPD & CMPPD_OPERAND
{
    local m:16 = m128;
	xmmTmp1_Qa = XmmReg[0,64];
	xmmTmp1_Qb = XmmReg[64,64];

	xmmTmp2_Qa = m[0,64];
	xmmTmp2_Qb = m[64,64];

	build XmmCondPD;
	
	XmmReg[0,64] = xmmTmp1_Qa;
	XmmReg[64,64] = xmmTmp1_Qb;
}
1: Constructor line ia.sinc:4855(id0.839) printpiece=[CMP,  C, PD,  ,  B, ,,  A,  D]
Operands 0: m128 : 2716  1: XmmReg : 2715  2: XmmCondPD : 2714  3: CMPPD_OPERAND : 2717  
Pattern id=839 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C2:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: unique[54b00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: register[1400:8] = COPY [handle:space][[handle:offset+0]:8]
	5: register[1408:8] = COPY [handle:space][[handle:offset+80008]:8]
	6: register[1410:8] = SUBPIECE unique[54b00:10], const[0:4]
	7: register[1418:8] = SUBPIECE unique[54b00:10], const[8:4]
	8: MULTIEQUAL const[2:4]
	9: [handle:space][[handle:offset+0]:8] = COPY register[1400:8]
	10: [handle:space][[handle:offset+80008]:8] = COPY register[1408:8]

Line ia.sinc:5110 :CMP^XmmCondSS^"SS"  XmmReg1, XmmReg2^CMPSS_OPERAND  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondSS & CMPSS_OPERAND
{ 
	xmmTmp1_Da = XmmReg1[0,32];
	xmmTmp2_Da = XmmReg2[0,32];
	build XmmCondSS;
	XmmReg1[0,32] = xmmTmp1_Da;
}
2: Constructor line ia.sinc:5110(id0.846) printpiece=[CMP,  C, SS,  ,  A, ,,  ,  B,  D]
Operands 0: XmmReg1 : 2758  1: XmmReg2 : 2759  2: XmmCondSS : 2757  3: CMPSS_OPERAND : 2760  
Pattern id=846 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:C2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: register[1400:4] = COPY [handle:space][[handle:offset+0]:4]
	4: register[1410:4] = COPY [handle:space][[handle:offset+0]:4]
	5: MULTIEQUAL const[2:4]
	6: [handle:space][[handle:offset+0]:4] = COPY register[1400:4]

Line ia.sinc:5102 :CMP^XmmCondSS^"SS"  XmmReg, m32^CMPSS_OPERAND  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xC2; (m32 & XmmReg ...); XmmCondSS & CMPSS_OPERAND
{ 
	xmmTmp1_Da = XmmReg[0,32];
	xmmTmp2_Da = m32;
	build XmmCondSS;
	XmmReg[0,32] = xmmTmp1_Da;
}
3: Constructor line ia.sinc:5102(id0.845) printpiece=[CMP,  C, SS,  ,  B, ,,  ,  A,  D]
Operands 0: m32 : 2755  1: XmmReg : 2754  2: XmmCondSS : 2753  3: CMPSS_OPERAND : 2756  
Pattern id=845 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:C2:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: register[1400:4] = COPY [handle:space][[handle:offset+0]:4]
	4: register[1410:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[2:4]
	6: [handle:space][[handle:offset+0]:4] = COPY register[1400:4]

Line ia.sinc:4870 :CMP^XmmCondPD^"PD"        XmmReg1,XmmReg2^CMPPD_OPERAND  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondPD & CMPPD_OPERAND 
{
	xmmTmp1_Qa = XmmReg1[0,64];
	xmmTmp1_Qb = XmmReg1[64,64];
	
	xmmTmp2_Qa = XmmReg2[0,64];
	xmmTmp2_Qb = XmmReg2[64,64];
	
	build XmmCondPD;
	
	XmmReg1[0,64] = xmmTmp1_Qa;
	XmmReg1[64,64] = xmmTmp1_Qb;
}
0: Constructor line ia.sinc:4870(id0.840) printpiece=[CMP,  C, PD,  ,  A, ,,  B,  D]
Operands 0: XmmReg1 : 2719  1: XmmReg2 : 2720  2: XmmCondPD : 2718  3: CMPPD_OPERAND : 2721  
Pattern id=840 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: register[1400:8] = COPY [handle:space][[handle:offset+0]:8]
	4: register[1408:8] = COPY [handle:space][[handle:offset+80008]:8]
	5: register[1410:8] = COPY [handle:space][[handle:offset+0]:8]
	6: register[1418:8] = COPY [handle:space][[handle:offset+80008]:8]
	7: MULTIEQUAL const[2:4]
	8: [handle:space][[handle:offset+0]:8] = COPY register[1400:8]
	9: [handle:space][[handle:offset+80008]:8] = COPY register[1408:8]

Line ia.sinc:4855 :CMP^XmmCondPD^"PD"        XmmReg,m128^CMPPD_OPERAND      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC2; (m128 & XmmReg ...); XmmCondPD & CMPPD_OPERAND
{
    local m:16 = m128;
	xmmTmp1_Qa = XmmReg[0,64];
	xmmTmp1_Qb = XmmReg[64,64];

	xmmTmp2_Qa = m[0,64];
	xmmTmp2_Qb = m[64,64];

	build XmmCondPD;
	
	XmmReg[0,64] = xmmTmp1_Qa;
	XmmReg[64,64] = xmmTmp1_Qb;
}
1: Constructor line ia.sinc:4855(id0.839) printpiece=[CMP,  C, PD,  ,  B, ,,  A,  D]
Operands 0: m128 : 2716  1: XmmReg : 2715  2: XmmCondPD : 2714  3: CMPPD_OPERAND : 2717  
Pattern id=839 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C2:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: unique[54b00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: register[1400:8] = COPY [handle:space][[handle:offset+0]:8]
	5: register[1408:8] = COPY [handle:space][[handle:offset+80008]:8]
	6: register[1410:8] = SUBPIECE unique[54b00:10], const[0:4]
	7: register[1418:8] = SUBPIECE unique[54b00:10], const[8:4]
	8: MULTIEQUAL const[2:4]
	9: [handle:space][[handle:offset+0]:8] = COPY register[1400:8]
	10: [handle:space][[handle:offset+80008]:8] = COPY register[1408:8]

Line ia.sinc:5049 :CMP^XmmCondSD^"SD"  XmmReg1, XmmReg2^CMPSD_OPERAND  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondSD & CMPSD_OPERAND
{ 
	xmmTmp1_Qa = XmmReg1[0,64];
	xmmTmp2_Qa = XmmReg2[0,64];
	build XmmCondSD;
	XmmReg1[0,64] = xmmTmp1_Qa;
}
2: Constructor line ia.sinc:5049(id0.844) printpiece=[CMP,  C, SD,  ,  A, ,,  ,  B,  D]
Operands 0: XmmReg1 : 2745  1: XmmReg2 : 2746  2: XmmCondSD : 2744  3: CMPSD_OPERAND : 2747  
Pattern id=844 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:C2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: register[1400:8] = COPY [handle:space][[handle:offset+0]:8]
	4: register[1410:8] = COPY [handle:space][[handle:offset+0]:8]
	5: MULTIEQUAL const[2:4]
	6: [handle:space][[handle:offset+0]:8] = COPY register[1400:8]

Line ia.sinc:5041 :CMP^XmmCondSD^"SD"  XmmReg, m64^CMPSD_OPERAND  is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0xC2; (m64 & XmmReg ...); XmmCondSD & CMPSD_OPERAND
{ 
	xmmTmp1_Qa = XmmReg[0,64];
	xmmTmp2_Qa = m64;
	build XmmCondSD;
	XmmReg[0,64] = xmmTmp1_Qa;
}
3: Constructor line ia.sinc:5041(id0.843) printpiece=[CMP,  C, SD,  ,  B, ,,  ,  A,  D]
Operands 0: m64 : 2742  1: XmmReg : 2741  2: XmmCondSD : 2740  3: CMPSD_OPERAND : 2743  
Pattern id=843 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:C2:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: register[1400:8] = COPY [handle:space][[handle:offset+0]:8]
	4: register[1410:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[2:4]
	6: [handle:space][[handle:offset+0]:8] = COPY register[1400:8]

Line ia.sinc:5110 :CMP^XmmCondSS^"SS"  XmmReg1, XmmReg2^CMPSS_OPERAND  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xC2; xmmmod=3 & XmmReg1 & XmmReg2; XmmCondSS & CMPSS_OPERAND
{ 
	xmmTmp1_Da = XmmReg1[0,32];
	xmmTmp2_Da = XmmReg2[0,32];
	build XmmCondSS;
	XmmReg1[0,32] = xmmTmp1_Da;
}
4: Constructor line ia.sinc:5110(id0.846) printpiece=[CMP,  C, SS,  ,  A, ,,  ,  B,  D]
Operands 0: XmmReg1 : 2758  1: XmmReg2 : 2759  2: XmmCondSS : 2757  3: CMPSS_OPERAND : 2760  
Pattern id=846 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:C2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[0:4]
	3: register[1400:4] = COPY [handle:space][[handle:offset+0]:4]
	4: register[1410:4] = COPY [handle:space][[handle:offset+0]:4]
	5: MULTIEQUAL const[2:4]
	6: [handle:space][[handle:offset+0]:4] = COPY register[1400:4]

Line ia.sinc:5102 :CMP^XmmCondSS^"SS"  XmmReg, m32^CMPSS_OPERAND  is vexMode=0 & $(PRE_F3) & byte=0x0F; byte=0xC2; (m32 & XmmReg ...); XmmCondSS & CMPSS_OPERAND
{ 
	xmmTmp1_Da = XmmReg[0,32];
	xmmTmp2_Da = m32;
	build XmmCondSS;
	XmmReg[0,32] = xmmTmp1_Da;
}
5: Constructor line ia.sinc:5102(id0.845) printpiece=[CMP,  C, SS,  ,  B, ,,  ,  A,  D]
Operands 0: m32 : 2755  1: XmmReg : 2754  2: XmmCondSS : 2753  3: CMPSS_OPERAND : 2756  
Pattern id=845 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:C2:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: register[1400:4] = COPY [handle:space][[handle:offset+0]:4]
	4: register[1410:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[2:4]
	6: [handle:space][[handle:offset+0]:4] = COPY register[1400:4]

Line ia.sinc:3153 :MOVNTI Mem,Reg32       is vexMode=0 & opsize = 1; byte=0xf; byte=0xc3; Mem & Reg32 ...     { *Mem = Reg32; }
0: Constructor line ia.sinc:3153(id0.308) printpiece=[MOVNTI,  ,  A, ,,  B]
Operands 0: Mem : 1934  1: Reg32 : 1935  
Pattern id=308 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:C3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6867 :PINSRW        mmxreg, r32, imm8 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC4; mmxmod=3 & r32 & mmxreg; imm8 { mmxreg = pinsrw(mmxreg, r32, imm8:8); }
0: Constructor line ia.sinc:6867(id0.1136) printpiece=[PINSRW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: r32 : 3378  1: mmxreg : 3377  2: imm8 : 3379  
Pattern id=1136 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:C4:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[86:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:6868 :PINSRW        mmxreg, m16, imm8 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC4; m16 & mmxreg ... ; imm8 { mmxreg = pinsrw(mmxreg, m16, imm8:8); }
1: Constructor line ia.sinc:6868(id0.1137) printpiece=[PINSRW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m16 : 3381  1: mmxreg : 3380  2: imm8 : 3382  
Pattern id=1137 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:C4:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[86:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:6869 :PINSRW        XmmReg, r32, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC4; xmmmod=3 & r32 & XmmReg; imm8 { XmmReg = pinsrw(XmmReg, r32, imm8:8); }
0: Constructor line ia.sinc:6869(id0.1138) printpiece=[PINSRW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: r32 : 3384  1: XmmReg : 3383  2: imm8 : 3385  
Pattern id=1138 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C4:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[86:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:6870 :PINSRW        XmmReg, m16, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC4; m16 & XmmReg ...; imm8 { XmmReg = pinsrw(XmmReg, m16, imm8:8); }
1: Constructor line ia.sinc:6870(id0.1139) printpiece=[PINSRW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m16 : 3387  1: XmmReg : 3386  2: imm8 : 3388  
Pattern id=1139 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C4:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[86:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:6804 :PEXTRW        Reg32, mmxreg2, imm8 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xC5; Reg32 & mmxreg2; imm8
{
    temp:8 = mmxreg2 >> ( (imm8 & 0x03) * 16 );
    Reg32 = zext(temp:2);
}
0: Constructor line ia.sinc:6804(id0.1108) printpiece=[PEXTRW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: Reg32 : 3309  1: mmxreg2 : 3310  2: imm8 : 3311  
Pattern id=1108 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:C5:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[81080:4] = INT_AND [handle:space][[handle:offset]:4], const[3:4]
	2: unique[81100:4] = INT_MULT unique[81080:4], const[10:4]
	3: unique[81200:8] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[81100:4]
	4: unique[81280:2] = SUBPIECE unique[81200:8], const[0:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[81280:2]

Line ia.sinc:6810 :PEXTRW        Reg32, XmmReg2, imm8 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xC5; Reg32 & XmmReg2; imm8
{
    temp:16 = XmmReg2 >> ( (imm8 & 0x07) * 16 );
    Reg32 = zext(temp:2);
}
0: Constructor line ia.sinc:6810(id0.1109) printpiece=[PEXTRW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: Reg32 : 3312  1: XmmReg2 : 3313  2: imm8 : 3314  
Pattern id=1109 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C5:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[81380:4] = INT_AND [handle:space][[handle:offset]:4], const[7:4]
	3: unique[81400:4] = INT_MULT unique[81380:4], const[10:4]
	4: unique[81500:10] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[81400:4]
	5: unique[81580:2] = SUBPIECE unique[81500:10], const[0:4]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[81580:2]

Line ia.sinc:8064 :SHUFPS  XmmReg1, XmmReg2, imm8  is vexMode=0 & mandover=0 & byte=0x0F; byte=0xC6; xmmmod=3 & XmmReg1 & XmmReg2; imm8 & Order0 & Order1 & Order2 & Order3
{
    local xmm1_c0 = XmmReg1[0,32];
    local xmm1_c1 = XmmReg1[32,32];
    local xmm1_c2 = XmmReg1[64,32];
    local xmm1_c3 = XmmReg1[96,32];

    local xmm2_c0 = XmmReg2[0,32];
    local xmm2_c1 = XmmReg2[32,32];
    local xmm2_c2 = XmmReg2[64,32];
    local xmm2_c3 = XmmReg2[96,32];

    shuffle_4(XmmReg1[0,32],Order0,xmm1_c0,xmm1_c1,xmm1_c2,xmm1_c3);
    shuffle_4(XmmReg1[32,32],Order1,xmm1_c0,xmm1_c1,xmm1_c2,xmm1_c3);
    shuffle_4(XmmReg1[64,32],Order2,xmm2_c0,xmm2_c1,xmm2_c2,xmm2_c3);
    shuffle_4(XmmReg1[96,32],Order3,xmm2_c0,xmm2_c1,xmm2_c2,xmm2_c3);
}
0: Constructor line ia.sinc:8064(id0.1343) printpiece=[SHUFPS,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3859  1: XmmReg2 : 3860  2: imm8 : 3861  3: Order0 : 3862  4: Order1 : 3863  5: Order2 : 3864  6: Order3 : 3865  
Pattern id=1343 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:C6:[11xx]X:XX)
Template
	0: MULTIEQUAL const[6:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[3:4]
	4: MULTIEQUAL const[1:4]
	5: MULTIEQUAL const[0:4]
	6: unique[97f80:4] = COPY [handle:space][[handle:offset+0]:4]
	7: unique[98000:4] = COPY [handle:space][[handle:offset+40004]:4]
	8: unique[98080:4] = COPY [handle:space][[handle:offset+80008]:4]
	9: unique[98100:4] = COPY [handle:space][[handle:offset+c000c]:4]
	10: unique[98180:4] = COPY [handle:space][[handle:offset+0]:4]
	11: unique[98200:4] = COPY [handle:space][[handle:offset+40004]:4]
	12: unique[98280:4] = COPY [handle:space][[handle:offset+80008]:4]
	13: unique[98300:4] = COPY [handle:space][[handle:offset+c000c]:4]
	14: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	16: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[97f80:4]
	17: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	18: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	19: unique[8b080:4] = INT_MULT unique[8b000:4], unique[98000:4]
	20: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	21: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	22: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	23: unique[8b280:4] = INT_MULT unique[8b200:4], unique[98080:4]
	24: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	25: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	26: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	27: unique[8b480:4] = INT_MULT unique[8b400:4], unique[98100:4]
	28: [handle:space][[handle:offset+0]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	29: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	30: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	31: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[97f80:4]
	32: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	33: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	34: unique[8b080:4] = INT_MULT unique[8b000:4], unique[98000:4]
	35: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	36: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	37: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	38: unique[8b280:4] = INT_MULT unique[8b200:4], unique[98080:4]
	39: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	40: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	41: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	42: unique[8b480:4] = INT_MULT unique[8b400:4], unique[98100:4]
	43: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	44: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	45: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	46: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[98180:4]
	47: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	48: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	49: unique[8b080:4] = INT_MULT unique[8b000:4], unique[98200:4]
	50: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	51: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	52: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	53: unique[8b280:4] = INT_MULT unique[8b200:4], unique[98280:4]
	54: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	55: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	56: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	57: unique[8b480:4] = INT_MULT unique[8b400:4], unique[98300:4]
	58: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	59: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	60: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	61: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[98180:4]
	62: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	63: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	64: unique[8b080:4] = INT_MULT unique[8b000:4], unique[98200:4]
	65: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	66: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	67: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	68: unique[8b280:4] = INT_MULT unique[8b200:4], unique[98280:4]
	69: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	70: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	71: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	72: unique[8b480:4] = INT_MULT unique[8b400:4], unique[98300:4]
	73: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[8b300:4], unique[8b480:4]

Line ia.sinc:8046 :SHUFPS  XmmReg, m128, imm8  is vexMode=0 & mandover=0 & byte=0x0F; byte=0xC6; (m128 & XmmReg ...); imm8 & Order0 & Order1 & Order2 & Order3
{
    local m128_c0 = m128[0,32];
    local m128_c1 = m128[32,32];
    local m128_c2 = m128[64,32];
    local m128_c3 = m128[96,32];

    local xmm_c0 = XmmReg[0,32];
    local xmm_c1 = XmmReg[32,32];
    local xmm_c2 = XmmReg[64,32];
    local xmm_c3 = XmmReg[96,32];

    shuffle_4(XmmReg[0,32],Order0,xmm_c0,xmm_c1,xmm_c2,xmm_c3);
    shuffle_4(XmmReg[32,32],Order1,xmm_c0,xmm_c1,xmm_c2,xmm_c3);
    shuffle_4(XmmReg[64,32],Order2,m128_c0,m128_c1,m128_c2,m128_c3);
    shuffle_4(XmmReg[96,32],Order3,m128_c0,m128_c1,m128_c2,m128_c3);
}
1: Constructor line ia.sinc:8046(id0.1342) printpiece=[SHUFPS,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: m128 : 3853  1: XmmReg : 3852  2: imm8 : 3854  3: Order0 : 3855  4: Order1 : 3856  5: Order2 : 3857  6: Order3 : 3858  
Pattern id=1342 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:C6:XX:XX)
Template
	0: MULTIEQUAL const[6:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[3:4]
	4: MULTIEQUAL const[0:4]
	5: MULTIEQUAL const[1:4]
	6: unique[97b80:4] = COPY [handle:space][[handle:offset+0]:4]
	7: unique[97c00:4] = COPY [handle:space][[handle:offset+40004]:4]
	8: unique[97c80:4] = COPY [handle:space][[handle:offset+80008]:4]
	9: unique[97d00:4] = COPY [handle:space][[handle:offset+c000c]:4]
	10: unique[97d80:4] = COPY [handle:space][[handle:offset+0]:4]
	11: unique[97e00:4] = COPY [handle:space][[handle:offset+40004]:4]
	12: unique[97e80:4] = COPY [handle:space][[handle:offset+80008]:4]
	13: unique[97f00:4] = COPY [handle:space][[handle:offset+c000c]:4]
	14: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	16: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[97d80:4]
	17: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	18: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	19: unique[8b080:4] = INT_MULT unique[8b000:4], unique[97e00:4]
	20: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	21: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	22: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	23: unique[8b280:4] = INT_MULT unique[8b200:4], unique[97e80:4]
	24: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	25: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	26: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	27: unique[8b480:4] = INT_MULT unique[8b400:4], unique[97f00:4]
	28: [handle:space][[handle:offset+0]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	29: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	30: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	31: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[97d80:4]
	32: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	33: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	34: unique[8b080:4] = INT_MULT unique[8b000:4], unique[97e00:4]
	35: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	36: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	37: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	38: unique[8b280:4] = INT_MULT unique[8b200:4], unique[97e80:4]
	39: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	40: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	41: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	42: unique[8b480:4] = INT_MULT unique[8b400:4], unique[97f00:4]
	43: [handle:space][[handle:offset+40004]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	44: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	45: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	46: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[97b80:4]
	47: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	48: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	49: unique[8b080:4] = INT_MULT unique[8b000:4], unique[97c00:4]
	50: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	51: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	52: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	53: unique[8b280:4] = INT_MULT unique[8b200:4], unique[97c80:4]
	54: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	55: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	56: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	57: unique[8b480:4] = INT_MULT unique[8b400:4], unique[97d00:4]
	58: [handle:space][[handle:offset+80008]:4] = INT_ADD unique[8b300:4], unique[8b480:4]
	59: unique[8ae00:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	60: unique[8ae80:4] = INT_ZEXT unique[8ae00:1]
	61: unique[8af00:4] = INT_MULT unique[8ae80:4], unique[97b80:4]
	62: unique[8af80:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	63: unique[8b000:4] = INT_ZEXT unique[8af80:1]
	64: unique[8b080:4] = INT_MULT unique[8b000:4], unique[97c00:4]
	65: unique[8b100:4] = INT_ADD unique[8af00:4], unique[8b080:4]
	66: unique[8b180:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[2:[handle:size]]
	67: unique[8b200:4] = INT_ZEXT unique[8b180:1]
	68: unique[8b280:4] = INT_MULT unique[8b200:4], unique[97c80:4]
	69: unique[8b300:4] = INT_ADD unique[8b100:4], unique[8b280:4]
	70: unique[8b380:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	71: unique[8b400:4] = INT_ZEXT unique[8b380:1]
	72: unique[8b480:4] = INT_MULT unique[8b400:4], unique[97d00:4]
	73: [handle:space][[handle:offset+c000c]:4] = INT_ADD unique[8b300:4], unique[8b480:4]

Line ia.sinc:8044 :SHUFPD          XmmReg1, XmmReg2, imm8  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xC6; xmmmod=3 & XmmReg1 & XmmReg2; imm8 { XmmReg1 = shufpd(XmmReg1, XmmReg2, imm8:8); }
0: Constructor line ia.sinc:8044(id0.1341) printpiece=[SHUFPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 3849  1: XmmReg2 : 3850  2: imm8 : 3851  
Pattern id=1341 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C6:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:8043 :SHUFPD          XmmReg, m128, imm8     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xC6; XmmReg ... & m128; imm8 { XmmReg = shufpd(XmmReg, m128, imm8:8); }
1: Constructor line ia.sinc:8043(id0.1340) printpiece=[SHUFPD,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg : 3846  1: m128 : 3847  2: imm8 : 3848  
Pattern id=1340 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:C6:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[a1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:8]

Line ia.sinc:2267 :CMPXCHG8B  m64        is vexMode=0 & byte=0xf; byte=0xc7; ( mod != 0b11 & reg_opcode=1 ) ... & m64 {
  ZF = ((zext(EDX) << 32) | zext(EAX)) == m64;
  
  if (ZF == 1) goto <equal>;
    EDX = m64(4);
    EAX = m64:4;        
    goto <done>;
    
  <equal>
    m64 = (zext(ECX) << 32) | zext(EBX);
  <done>
}
0: Constructor line ia.sinc:2267(id0.157) printpiece=[CMPXCHG8B,  ,  A]
Operands 0: m64 : 1651  
Pattern id=157 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:0[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1ff00:[handle:size]] = INT_ZEXT register[8:4]
	2: unique[1ff80:[handle:size]] = INT_LEFT unique[1ff00:[handle:size]], const[20:4]
	3: unique[20000:[handle:size]] = INT_ZEXT register[0:4]
	4: unique[20080:[handle:size]] = INT_OR unique[1ff80:[handle:size]], unique[20000:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[20080:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[20180:1] = INT_EQUAL register[206:1], const[1:1]
	7: CBRANCH const[[rel:0]:4], unique[20180:1]
	8: register[8:4] = SUBPIECE [handle:space][[handle:offset]:[handle:size]], const[4:4]
	9: register[0:4] = COPY [handle:space][[handle:offset+0]:4]
	10: BRANCH const[[rel:1]:4]
	11: PTRADD const[0:4]
	12: unique[20280:[handle:size]] = INT_ZEXT register[4:4]
	13: unique[20300:[handle:size]] = INT_LEFT unique[20280:[handle:size]], const[20:4]
	14: unique[20380:[handle:size]] = INT_ZEXT register[c:4]
	15: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[20300:[handle:size]], unique[20380:[handle:size]]
	16: PTRADD const[1:4]

Line ia.sinc:2267 :CMPXCHG8B  m64        is vexMode=0 & byte=0xf; byte=0xc7; ( mod != 0b11 & reg_opcode=1 ) ... & m64 {
  ZF = ((zext(EDX) << 32) | zext(EAX)) == m64;
  
  if (ZF == 1) goto <equal>;
    EDX = m64(4);
    EAX = m64:4;        
    goto <done>;
    
  <equal>
    m64 = (zext(ECX) << 32) | zext(EBX);
  <done>
}
0: Constructor line ia.sinc:2267(id0.157) printpiece=[CMPXCHG8B,  ,  A]
Operands 0: m64 : 1651  
Pattern id=157 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:4[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1ff00:[handle:size]] = INT_ZEXT register[8:4]
	2: unique[1ff80:[handle:size]] = INT_LEFT unique[1ff00:[handle:size]], const[20:4]
	3: unique[20000:[handle:size]] = INT_ZEXT register[0:4]
	4: unique[20080:[handle:size]] = INT_OR unique[1ff80:[handle:size]], unique[20000:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[20080:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[20180:1] = INT_EQUAL register[206:1], const[1:1]
	7: CBRANCH const[[rel:0]:4], unique[20180:1]
	8: register[8:4] = SUBPIECE [handle:space][[handle:offset]:[handle:size]], const[4:4]
	9: register[0:4] = COPY [handle:space][[handle:offset+0]:4]
	10: BRANCH const[[rel:1]:4]
	11: PTRADD const[0:4]
	12: unique[20280:[handle:size]] = INT_ZEXT register[4:4]
	13: unique[20300:[handle:size]] = INT_LEFT unique[20280:[handle:size]], const[20:4]
	14: unique[20380:[handle:size]] = INT_ZEXT register[c:4]
	15: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[20300:[handle:size]], unique[20380:[handle:size]]
	16: PTRADD const[1:4]

Line ia.sinc:2267 :CMPXCHG8B  m64        is vexMode=0 & byte=0xf; byte=0xc7; ( mod != 0b11 & reg_opcode=1 ) ... & m64 {
  ZF = ((zext(EDX) << 32) | zext(EAX)) == m64;
  
  if (ZF == 1) goto <equal>;
    EDX = m64(4);
    EAX = m64:4;        
    goto <done>;
    
  <equal>
    m64 = (zext(ECX) << 32) | zext(EBX);
  <done>
}
0: Constructor line ia.sinc:2267(id0.157) printpiece=[CMPXCHG8B,  ,  A]
Operands 0: m64 : 1651  
Pattern id=157 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:8[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1ff00:[handle:size]] = INT_ZEXT register[8:4]
	2: unique[1ff80:[handle:size]] = INT_LEFT unique[1ff00:[handle:size]], const[20:4]
	3: unique[20000:[handle:size]] = INT_ZEXT register[0:4]
	4: unique[20080:[handle:size]] = INT_OR unique[1ff80:[handle:size]], unique[20000:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[20080:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[20180:1] = INT_EQUAL register[206:1], const[1:1]
	7: CBRANCH const[[rel:0]:4], unique[20180:1]
	8: register[8:4] = SUBPIECE [handle:space][[handle:offset]:[handle:size]], const[4:4]
	9: register[0:4] = COPY [handle:space][[handle:offset+0]:4]
	10: BRANCH const[[rel:1]:4]
	11: PTRADD const[0:4]
	12: unique[20280:[handle:size]] = INT_ZEXT register[4:4]
	13: unique[20300:[handle:size]] = INT_LEFT unique[20280:[handle:size]], const[20:4]
	14: unique[20380:[handle:size]] = INT_ZEXT register[c:4]
	15: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[20300:[handle:size]], unique[20380:[handle:size]]
	16: PTRADD const[1:4]

Line ia.sinc:2285 :bad_CMPXCHG8B  r32        is vexMode=0 & byte=0xf; byte=0xc7; ( mod = 0b11 & reg_opcode=0b001 ) & r32 {
  r32 = bad_CMPXCHG8B(r32);
}
0: Constructor line ia.sinc:2285(id0.158) printpiece=[bad_CMPXCHG8B,  ,  A]
Operands 0: r32 : 1653  
Pattern id=158 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:C[1xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[29:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4033 :XRSTORS Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=3 ) ... & Mem { tmp:4 = 512; xrstors(Mem, tmp); }
0: Constructor line ia.sinc:4033(id0.653) printpiece=[XRSTORS,  ,  A]
Operands 0: Mem : 2520  
Pattern id=653 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:1[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[5b:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4033 :XRSTORS Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=3 ) ... & Mem { tmp:4 = 512; xrstors(Mem, tmp); }
0: Constructor line ia.sinc:4033(id0.653) printpiece=[XRSTORS,  ,  A]
Operands 0: Mem : 2520  
Pattern id=653 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:5[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[5b:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4033 :XRSTORS Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=3 ) ... & Mem { tmp:4 = 512; xrstors(Mem, tmp); }
0: Constructor line ia.sinc:4033(id0.653) printpiece=[XRSTORS,  ,  A]
Operands 0: Mem : 2520  
Pattern id=653 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:9[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[5b:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4043 :XSAVEC  Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsavec(Mem, tmp); }
0: Constructor line ia.sinc:4043(id0.655) printpiece=[XSAVEC,  ,  A]
Operands 0: Mem : 2522  
Pattern id=655 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:2[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[53:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4043 :XSAVEC  Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsavec(Mem, tmp); }
0: Constructor line ia.sinc:4043(id0.655) printpiece=[XSAVEC,  ,  A]
Operands 0: Mem : 2522  
Pattern id=655 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:6[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[53:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4043 :XSAVEC  Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=4 ) ... & Mem { tmp:4 = 512; xsavec(Mem, tmp); }
0: Constructor line ia.sinc:4043(id0.655) printpiece=[XSAVEC,  ,  A]
Operands 0: Mem : 2522  
Pattern id=655 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:A[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[53:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4053 :XSAVES  Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xsaves(Mem, tmp); }
0: Constructor line ia.sinc:4053(id0.657) printpiece=[XSAVES,  ,  A]
Operands 0: Mem : 2524  
Pattern id=657 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:2[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[57:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4053 :XSAVES  Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xsaves(Mem, tmp); }
0: Constructor line ia.sinc:4053(id0.657) printpiece=[XSAVES,  ,  A]
Operands 0: Mem : 2524  
Pattern id=657 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:6[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[57:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:4053 :XSAVES  Mem    is vexMode=0 & byte=0x0F; byte=0xC7; ( mod != 0b11 & reg_opcode=5 ) ... & Mem { tmp:4 = 512; xsaves(Mem, tmp); }
0: Constructor line ia.sinc:4053(id0.657) printpiece=[XSAVES,  ,  A]
Operands 0: Mem : 2524  
Pattern id=657 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:A[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[57:4], [handle:space][[handle:offset]:[handle:size]], const[200:4]

Line ia.sinc:3921 :VMXON m64      is vexMode=0 & $(PRE_F3) & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=6 ) ... & m64  { vmxon(m64); }
0: Constructor line ia.sinc:3921(id0.617) printpiece=[VMXON,  ,  A]
Operands 0: m64 : 2439  
Pattern id=617 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:C7:3[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[24:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3905 :VMPTRLD m64    is vexMode=0 & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=6 ) ... & m64 { vmptrld(m64); }
1: Constructor line ia.sinc:3905(id0.612) printpiece=[VMPTRLD,  ,  A]
Operands 0: m64 : 2431  
Pattern id=612 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:3[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[1f:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3921 :VMXON m64      is vexMode=0 & $(PRE_F3) & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=6 ) ... & m64  { vmxon(m64); }
0: Constructor line ia.sinc:3921(id0.617) printpiece=[VMXON,  ,  A]
Operands 0: m64 : 2439  
Pattern id=617 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:C7:7[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[24:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3905 :VMPTRLD m64    is vexMode=0 & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=6 ) ... & m64 { vmptrld(m64); }
1: Constructor line ia.sinc:3905(id0.612) printpiece=[VMPTRLD,  ,  A]
Operands 0: m64 : 2431  
Pattern id=612 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:7[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[1f:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3921 :VMXON m64      is vexMode=0 & $(PRE_F3) & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=6 ) ... & m64  { vmxon(m64); }
0: Constructor line ia.sinc:3921(id0.617) printpiece=[VMXON,  ,  A]
Operands 0: m64 : 2439  
Pattern id=617 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:C7:B[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[24:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3905 :VMPTRLD m64    is vexMode=0 & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=6 ) ... & m64 { vmptrld(m64); }
1: Constructor line ia.sinc:3905(id0.612) printpiece=[VMPTRLD,  ,  A]
Operands 0: m64 : 2431  
Pattern id=612 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:B[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[1f:4], [handle:space][[handle:offset]:[handle:size]]

Line rdrand.sinc:8 :RDRAND Rmr16     is vexMode=0 & opsize=0 & byte=0x0f; byte=0xC7; mod=3 & Rmr16 & reg_opcode=6 
{ 
	Rmr16 = rdrand(); 
	CF=rdrandIsValid();
	rdflags();
	
}
0: Constructor line rdrand.sinc:8(id0.2147) printpiece=[RDRAND,  ,  A]
Operands 0: Rmr16 : 7227  
Pattern id=2147 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:C7:F[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[295:4]
	2: register[200:1] = CALLOTHER const[296:4]
	3: register[20b:1] = COPY const[0:1]
	4: register[207:1] = COPY const[0:1]
	5: register[206:1] = COPY const[0:1]
	6: register[204:1] = COPY const[0:1]
	7: register[202:1] = COPY const[0:1]

Line rdrand.sinc:15 :RDRAND Rmr32     is vexMode=0 & opsize=1 & byte=0x0f; byte=0xC7; mod=3 & Rmr32 & reg_opcode=6 
{ 
	Rmr32 = rdrand(); 
	CF=rdrandIsValid();
	rdflags();
}
0: Constructor line rdrand.sinc:15(id0.2148) printpiece=[RDRAND,  ,  A]
Operands 0: Rmr32 : 7228  
Pattern id=2148 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:C7:F[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[295:4]
	2: register[200:1] = CALLOTHER const[296:4]
	3: register[20b:1] = COPY const[0:1]
	4: register[207:1] = COPY const[0:1]
	5: register[206:1] = COPY const[0:1]
	6: register[204:1] = COPY const[0:1]
	7: register[202:1] = COPY const[0:1]

Line ia.sinc:3453 :RDPID r32      is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0f; byte=0xc7; reg_opcode=7 & r32 { r32 = readPID(); }
0: Constructor line ia.sinc:3453(id0.455) printpiece=[RDPID,  ,  A]
Operands 0: r32 : 2152  
Pattern id=455 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:C7:[xx11][1xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[43:4]

Line ia.sinc:3910 :VMPTRST m64    is vexMode=0 & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=7 ) ... & m64  { vmptrst(m64); }
1: Constructor line ia.sinc:3910(id0.613) printpiece=[VMPTRST,  ,  A]
Operands 0: m64 : 2432  
Pattern id=613 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:3[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[20:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3453 :RDPID r32      is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0f; byte=0xc7; reg_opcode=7 & r32 { r32 = readPID(); }
0: Constructor line ia.sinc:3453(id0.455) printpiece=[RDPID,  ,  A]
Operands 0: r32 : 2152  
Pattern id=455 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:C7:[xx11][1xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[43:4]

Line ia.sinc:3910 :VMPTRST m64    is vexMode=0 & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=7 ) ... & m64  { vmptrst(m64); }
1: Constructor line ia.sinc:3910(id0.613) printpiece=[VMPTRST,  ,  A]
Operands 0: m64 : 2432  
Pattern id=613 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:7[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[20:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3453 :RDPID r32      is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0f; byte=0xc7; reg_opcode=7 & r32 { r32 = readPID(); }
0: Constructor line ia.sinc:3453(id0.455) printpiece=[RDPID,  ,  A]
Operands 0: r32 : 2152  
Pattern id=455 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:C7:[xx11][1xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[43:4]

Line ia.sinc:3910 :VMPTRST m64    is vexMode=0 & byte=0x0f; byte=0xc7; ( mod != 0b11 & reg_opcode=7 ) ... & m64  { vmptrst(m64); }
1: Constructor line ia.sinc:3910(id0.613) printpiece=[VMPTRST,  ,  A]
Operands 0: m64 : 2432  
Pattern id=613 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C7:B[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[20:4], [handle:space][[handle:offset]:[handle:size]]

Line rdrand.sinc:32 :RDSEED Rmr16     is vexMode=0 & opsize=0 & byte=0x0f; byte=0xC7; mod=3 & Rmr16 & reg_opcode=7 
{ 
	Rmr16 = rdseed(); 
	CF=rdseedIsValid();
	rdflags();
}
0: Constructor line rdrand.sinc:32(id0.2149) printpiece=[RDSEED,  ,  A]
Operands 0: Rmr16 : 7231  
Pattern id=2149 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:0F:C7:F[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[297:4]
	2: register[200:1] = CALLOTHER const[298:4]
	3: register[20b:1] = COPY const[0:1]
	4: register[207:1] = COPY const[0:1]
	5: register[206:1] = COPY const[0:1]
	6: register[204:1] = COPY const[0:1]
	7: register[202:1] = COPY const[0:1]

Line ia.sinc:3453 :RDPID r32      is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x0f; byte=0xc7; reg_opcode=7 & r32 { r32 = readPID(); }
0: Constructor line ia.sinc:3453(id0.455) printpiece=[RDPID,  ,  A]
Operands 0: r32 : 2152  
Pattern id=455 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:0F:C7:[xx11][1xxx]:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[43:4]

Line rdrand.sinc:38 :RDSEED Rmr32     is vexMode=0 & opsize=1 & byte=0x0f; byte=0xC7; mod=3 & Rmr32 & reg_opcode=7 
{ 
	Rmr32 = rdseed(); 
	CF=rdseedIsValid();
	rdflags();
}
1: Constructor line rdrand.sinc:38(id0.2150) printpiece=[RDSEED,  ,  A]
Operands 0: Rmr32 : 7232  
Pattern id=2150 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:0F:C7:F[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[297:4]
	2: register[200:1] = CALLOTHER const[298:4]
	3: register[20b:1] = COPY const[0:1]
	4: register[207:1] = COPY const[0:1]
	5: register[206:1] = COPY const[0:1]
	6: register[204:1] = COPY const[0:1]
	7: register[202:1] = COPY const[0:1]

Line ia.sinc:1977 :BSWAP Rmr32        is vexMode=0 & byte=0xf; row=12 & page=1 & Rmr32 & check_Rmr32_dest
                                            { local tmp =        (Rmr32 & 0xff000000) >> 24 ;
                                              tmp = tmp | ((Rmr32 & 0x00ff0000) >> 8 );
                                              tmp = tmp | ((Rmr32 & 0x0000ff00) << 8 );
                                              Rmr32 = tmp | ((Rmr32 & 0x000000ff) << 24); 
                                              build check_Rmr32_dest; }
0: Constructor line ia.sinc:1977(id0.73) printpiece=[BSWAP,  ,  A]
Operands 0: Rmr32 : 1506  1: check_Rmr32_dest : 1507  
Pattern id=73 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:C[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[16080:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff000000:[handle:size]]
	2: unique[16180:[handle:size]] = INT_RIGHT unique[16080:[handle:size]], const[18:4]
	3: unique[16200:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff0000:[handle:size]]
	4: unique[16280:[handle:size]] = INT_RIGHT unique[16200:[handle:size]], const[8:4]
	5: unique[16180:[handle:size]] = INT_OR unique[16180:[handle:size]], unique[16280:[handle:size]]
	6: unique[16380:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff00:[handle:size]]
	7: unique[16400:[handle:size]] = INT_LEFT unique[16380:[handle:size]], const[8:4]
	8: unique[16180:[handle:size]] = INT_OR unique[16180:[handle:size]], unique[16400:[handle:size]]
	9: unique[16500:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	10: unique[16580:[handle:size]] = INT_LEFT unique[16500:[handle:size]], const[18:4]
	11: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[16180:[handle:size]], unique[16580:[handle:size]]
	12: MULTIEQUAL const[1:4]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:4714 :ADDSUBPD     XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xD0; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] f- XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] f+ XmmReg2[64,64];
}
0: Constructor line ia.sinc:4714(id0.828) printpiece=[ADDSUBPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2687  1: XmmReg2 : 2688  
Pattern id=828 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D0:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:4707 :ADDSUBPD     XmmReg, m128     is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xD0; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] f- m[0,64];
    XmmReg[64,64] = XmmReg[64,64] f+ m[64,64];
}
1: Constructor line ia.sinc:4707(id0.827) printpiece=[ADDSUBPD,  ,  B, ,,  ,  A]
Operands 0: m128 : 2686  1: XmmReg : 2685  
Pattern id=827 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D0:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[50700:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[50780:8] = SUBPIECE unique[50700:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = FLOAT_SUB [handle:space][[handle:offset+0]:8], unique[50780:8]
	5: unique[50880:8] = SUBPIECE unique[50700:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = FLOAT_ADD [handle:space][[handle:offset+80008]:8], unique[50880:8]

Line ia.sinc:4729 :ADDSUBPS     XmmReg1, XmmReg2 is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0xD0; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] f- XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] f+ XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] f- XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] f+ XmmReg2[96,32];
}
2: Constructor line ia.sinc:4729(id0.830) printpiece=[ADDSUBPS,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2691  1: XmmReg2 : 2692  
Pattern id=830 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:D0:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = FLOAT_ADD [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = FLOAT_SUB [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = FLOAT_ADD [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:4720 :ADDSUBPS     XmmReg, m128     is vexMode=0 & $(PRE_F2) & byte=0x0F; byte=0xD0; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] f- m[0,32];
    XmmReg[32,32] = XmmReg[32,32] f+ m[32,32];
    XmmReg[64,32] = XmmReg[64,32] f- m[64,32];
    XmmReg[96,32] = XmmReg[96,32] f+ m[96,32];
}
3: Constructor line ia.sinc:4720(id0.829) printpiece=[ADDSUBPS,  ,  B, ,,  ,  A]
Operands 0: m128 : 2690  1: XmmReg : 2689  
Pattern id=829 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:D0:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[50a80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[50b00:4] = SUBPIECE unique[50a80:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = FLOAT_SUB [handle:space][[handle:offset+0]:4], unique[50b00:4]
	5: unique[50c00:4] = SUBPIECE unique[50a80:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = FLOAT_ADD [handle:space][[handle:offset+40004]:4], unique[50c00:4]
	7: unique[50d00:4] = SUBPIECE unique[50a80:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = FLOAT_SUB [handle:space][[handle:offset+80008]:4], unique[50d00:4]
	9: unique[50e00:4] = SUBPIECE unique[50a80:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = FLOAT_ADD [handle:space][[handle:offset+c000c]:4], unique[50e00:4]

Line ia.sinc:7404 :PSRLW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD1; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16]  = mmxreg1[0,16]  >> mmxreg2;
    mmxreg1[16,16] = mmxreg1[16,16] >> mmxreg2;
    mmxreg1[32,16] = mmxreg1[32,16] >> mmxreg2;
    mmxreg1[48,16] = mmxreg1[48,16] >> mmxreg2;
}
0: Constructor line ia.sinc:7404(id0.1251) printpiece=[PSRLW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3658  1: mmxreg2 : 3659  
Pattern id=1251 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D1:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:2] = INT_RIGHT [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset]:[handle:size]]
	1: [handle:space][[handle:offset+20002]:2] = INT_RIGHT [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset+40004]:2] = INT_RIGHT [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+60006]:2] = INT_RIGHT [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7396 :PSRLW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD1; mmxreg ... & m64 ...
{
    mmxreg[0,16]  = mmxreg[0,16]  >> m64;
    mmxreg[16,16] = mmxreg[16,16] >> m64;
    mmxreg[32,16] = mmxreg[32,16] >> m64;
    mmxreg[48,16] = mmxreg[48,16] >> m64;
}
1: Constructor line ia.sinc:7396(id0.1250) printpiece=[PSRLW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3656  1: m64 : 3657  
Pattern id=1250 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D1:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:2] = INT_RIGHT [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset+20002]:2] = INT_RIGHT [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+40004]:2] = INT_RIGHT [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset+60006]:2] = INT_RIGHT [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7465 :PSRLW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD1; xmmmod = 3 & XmmReg1 & XmmReg2
{
    #save this off in case XmmReg1 and XmmReg2 are the same register
    local count:8 = XmmReg2[0,64];
    
    XmmReg1[0,16]   = XmmReg1[0,16]   >> count;
    XmmReg1[16,16]  = XmmReg1[16,16]  >> count;
    XmmReg1[32,16]  = XmmReg1[32,16]  >> count;
    XmmReg1[48,16]  = XmmReg1[48,16]  >> count;
    XmmReg1[64,16]  = XmmReg1[64,16]  >> count;
    XmmReg1[80,16]  = XmmReg1[80,16]  >> count;
    XmmReg1[96,16]  = XmmReg1[96,16]  >> count;
    XmmReg1[112,16] = XmmReg1[112,16] >> count;
}
0: Constructor line ia.sinc:7465(id0.1260) printpiece=[PSRLW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3676  1: XmmReg2 : 3677  
Pattern id=1260 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D1:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[8fb00:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+0]:2] = INT_RIGHT [handle:space][[handle:offset+0]:2], unique[8fb00:8]
	4: [handle:space][[handle:offset+20002]:2] = INT_RIGHT [handle:space][[handle:offset+20002]:2], unique[8fb00:8]
	5: [handle:space][[handle:offset+40004]:2] = INT_RIGHT [handle:space][[handle:offset+40004]:2], unique[8fb00:8]
	6: [handle:space][[handle:offset+60006]:2] = INT_RIGHT [handle:space][[handle:offset+60006]:2], unique[8fb00:8]
	7: [handle:space][[handle:offset+80008]:2] = INT_RIGHT [handle:space][[handle:offset+80008]:2], unique[8fb00:8]
	8: [handle:space][[handle:offset+a000a]:2] = INT_RIGHT [handle:space][[handle:offset+a000a]:2], unique[8fb00:8]
	9: [handle:space][[handle:offset+c000c]:2] = INT_RIGHT [handle:space][[handle:offset+c000c]:2], unique[8fb00:8]
	10: [handle:space][[handle:offset+e000e]:2] = INT_RIGHT [handle:space][[handle:offset+e000e]:2], unique[8fb00:8]

Line ia.sinc:7453 :PSRLW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD1; XmmReg ... & m128 ...
{
    XmmReg[0,16]   = XmmReg[0,16]   >> m128[0,64];
    XmmReg[16,16]  = XmmReg[16,16]  >> m128[0,64];
    XmmReg[32,16]  = XmmReg[32,16]  >> m128[0,64];
    XmmReg[48,16]  = XmmReg[48,16]  >> m128[0,64];
    XmmReg[64,16]  = XmmReg[64,16]  >> m128[0,64];
    XmmReg[80,16]  = XmmReg[80,16]  >> m128[0,64];
    XmmReg[96,16]  = XmmReg[96,16]  >> m128[0,64];
    XmmReg[112,16] = XmmReg[112,16] >> m128[0,64];
}
1: Constructor line ia.sinc:7453(id0.1259) printpiece=[PSRLW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3674  1: m128 : 3675  
Pattern id=1259 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D1:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:2] = INT_RIGHT [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+20002]:2] = INT_RIGHT [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+0]:8]
	4: [handle:space][[handle:offset+40004]:2] = INT_RIGHT [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+0]:8]
	5: [handle:space][[handle:offset+60006]:2] = INT_RIGHT [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+0]:8]
	6: [handle:space][[handle:offset+80008]:2] = INT_RIGHT [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+0]:8]
	7: [handle:space][[handle:offset+a000a]:2] = INT_RIGHT [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+0]:8]
	8: [handle:space][[handle:offset+c000c]:2] = INT_RIGHT [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+0]:8]
	9: [handle:space][[handle:offset+e000e]:2] = INT_RIGHT [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+0]:8]

Line ia.sinc:7426 :PSRLD          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD2; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32]  = mmxreg1[0,32]  >> mmxreg2;
    mmxreg1[32,32] = mmxreg1[32,32] >> mmxreg2;
}
0: Constructor line ia.sinc:7426(id0.1254) printpiece=[PSRLD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3664  1: mmxreg2 : 3665  
Pattern id=1254 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D2:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:4] = INT_RIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	1: [handle:space][[handle:offset+40004]:4] = INT_RIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7420 :PSRLD          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD2; mmxreg ... & m64 ...
{
    mmxreg[0,32]  = mmxreg[0,32]  >> m64;
    mmxreg[32,32] = mmxreg[32,32] >> m64;
}
1: Constructor line ia.sinc:7420(id0.1253) printpiece=[PSRLD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3662  1: m64 : 3663  
Pattern id=1253 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D2:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = INT_RIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset+40004]:4] = INT_RIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7500 :PSRLD          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD2; xmmmod = 3 & XmmReg1 & XmmReg2
{
    #save this off in case XmmReg1 and XmmReg2 are the same register
    local count = XmmReg2[0,64];
    
    XmmReg1[0,32]  = XmmReg1[0,32]  >> count;
    XmmReg1[32,32] = XmmReg1[32,32] >> count;
    XmmReg1[64,32] = XmmReg1[64,32] >> count;
    XmmReg1[96,32] = XmmReg1[96,32] >> count;
}
0: Constructor line ia.sinc:7500(id0.1263) printpiece=[PSRLD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3682  1: XmmReg2 : 3683  
Pattern id=1263 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[90580:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+0]:4] = INT_RIGHT [handle:space][[handle:offset+0]:4], unique[90580:8]
	4: [handle:space][[handle:offset+40004]:4] = INT_RIGHT [handle:space][[handle:offset+40004]:4], unique[90580:8]
	5: [handle:space][[handle:offset+80008]:4] = INT_RIGHT [handle:space][[handle:offset+80008]:4], unique[90580:8]
	6: [handle:space][[handle:offset+c000c]:4] = INT_RIGHT [handle:space][[handle:offset+c000c]:4], unique[90580:8]

Line ia.sinc:7492 :PSRLD          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD2; XmmReg ... & m128 ...
{
    XmmReg[0,32]  = XmmReg[0,32]  >> m128[0,64];
    XmmReg[32,32] = XmmReg[32,32] >> m128[0,64];
    XmmReg[64,32] = XmmReg[64,32] >> m128[0,64];
    XmmReg[96,32] = XmmReg[96,32] >> m128[0,64];
}
1: Constructor line ia.sinc:7492(id0.1262) printpiece=[PSRLD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3680  1: m128 : 3681  
Pattern id=1262 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D2:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = INT_RIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+40004]:4] = INT_RIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+0]:8]
	4: [handle:space][[handle:offset+80008]:4] = INT_RIGHT [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+0]:8]
	5: [handle:space][[handle:offset+c000c]:4] = INT_RIGHT [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+0]:8]

Line ia.sinc:7443 :PSRLQ          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD3; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1 = mmxreg1 >> mmxreg2;
}
0: Constructor line ia.sinc:7443(id0.1257) printpiece=[PSRLQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3670  1: mmxreg2 : 3671  
Pattern id=1257 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D3:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7438 :PSRLQ          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD3; mmxreg ... & m64 ...
{
    mmxreg = mmxreg >> m64;
 }
1: Constructor line ia.sinc:7438(id0.1256) printpiece=[PSRLQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3668  1: m64 : 3669  
Pattern id=1256 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7525 :PSRLQ          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD3; xmmmod = 3 & XmmReg1 & XmmReg2
{
    #save this off in case XmmReg1 and XmmReg2 are the same register
    local count = XmmReg2[0,64];
    
    XmmReg1[0,64]  = XmmReg1[0,64]  >> count;
    XmmReg1[64,64] = XmmReg1[64,64] >> count;
}
0: Constructor line ia.sinc:7525(id0.1266) printpiece=[PSRLQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3688  1: XmmReg2 : 3689  
Pattern id=1266 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D3:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[90b00:8] = COPY [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+0]:8] = INT_RIGHT [handle:space][[handle:offset+0]:8], unique[90b00:8]
	4: [handle:space][[handle:offset+80008]:8] = INT_RIGHT [handle:space][[handle:offset+80008]:8], unique[90b00:8]

Line ia.sinc:7519 :PSRLQ          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD3; XmmReg ... & m128 ...
{
    XmmReg[0,64]  = XmmReg[0,64]  >> m128[0,64];
    XmmReg[64,64] = XmmReg[64,64] >> m128[0,64];
}
1: Constructor line ia.sinc:7519(id0.1265) printpiece=[PSRLQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3686  1: m128 : 3687  
Pattern id=1265 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = INT_RIGHT [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = INT_RIGHT [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+0]:8]

Line ia.sinc:6337 :PADDQ          mmxreg1, mmxreg2  is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD4; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1 = mmxreg1 + mmxreg2;
}
0: Constructor line ia.sinc:6337(id0.1045) printpiece=[PADDQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3173  1: mmxreg2 : 3174  
Pattern id=1045 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D4:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6332 :PADDQ          mmxreg, m64       is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD4; mmxreg ... & m64
{
    mmxreg = mmxreg + m64;
}
1: Constructor line ia.sinc:6332(id0.1044) printpiece=[PADDQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3171  1: m64 : 3172  
Pattern id=1044 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D4:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6349 :PADDQ          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD4; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = XmmReg1[0,64] + XmmReg2[0,64];
    XmmReg1[64,64] = XmmReg1[64,64] + XmmReg2[64,64];
}
0: Constructor line ia.sinc:6349(id0.1047) printpiece=[PADDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3177  1: XmmReg2 : 3178  
Pattern id=1047 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D4:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = INT_ADD [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = INT_ADD [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:6342 :PADDQ          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD4; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,64] = XmmReg[0,64] + m[0,64];
    XmmReg[64,64] = XmmReg[64,64] + m[64,64];
}
1: Constructor line ia.sinc:6342(id0.1046) printpiece=[PADDQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 3176  1: XmmReg : 3175  
Pattern id=1046 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D4:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[6bb00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[6bb80:8] = SUBPIECE unique[6bb00:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = INT_ADD [handle:space][[handle:offset+0]:8], unique[6bb80:8]
	5: unique[6bc80:8] = SUBPIECE unique[6bb00:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = INT_ADD [handle:space][[handle:offset+80008]:8], unique[6bc80:8]

Line ia.sinc:7100 :PMULLW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD5; mmxmod = 3 & mmxreg1 & mmxreg2 {
  mmxreg1[0,16] = mmxreg1[0,16] * mmxreg2[0,16];
  mmxreg1[16,16] = mmxreg1[16,16] * mmxreg2[16,16];
  mmxreg1[32,16] = mmxreg1[32,16] * mmxreg2[32,16];
  mmxreg1[48,16] = mmxreg1[48,16] * mmxreg2[48,16];
}
0: Constructor line ia.sinc:7100(id0.1179) printpiece=[PMULLW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3476  1: mmxreg2 : 3477  
Pattern id=1179 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D5:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:2] = INT_MULT [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	1: [handle:space][[handle:offset+20002]:2] = INT_MULT [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	2: [handle:space][[handle:offset+40004]:2] = INT_MULT [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	3: [handle:space][[handle:offset+60006]:2] = INT_MULT [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]

Line ia.sinc:7092 :PMULLW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD5; mmxreg ... & m64 {
  local m:8 = m64;
  mmxreg[0,16] = mmxreg[0,16] * m[0,16];
  mmxreg[16,16] = mmxreg[16,16] * m[16,16];
  mmxreg[32,16] = mmxreg[32,16] * m[32,16];
  mmxreg[48,16] = mmxreg[48,16] * m[48,16];
}
1: Constructor line ia.sinc:7092(id0.1178) printpiece=[PMULLW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3474  1: m64 : 3475  
Pattern id=1178 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D5:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[88400:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[88480:2] = SUBPIECE unique[88400:8], const[0:4]
	3: [handle:space][[handle:offset+0]:2] = INT_MULT [handle:space][[handle:offset+0]:2], unique[88480:2]
	4: unique[88580:2] = SUBPIECE unique[88400:8], const[2:4]
	5: [handle:space][[handle:offset+20002]:2] = INT_MULT [handle:space][[handle:offset+20002]:2], unique[88580:2]
	6: unique[88680:2] = SUBPIECE unique[88400:8], const[4:4]
	7: [handle:space][[handle:offset+40004]:2] = INT_MULT [handle:space][[handle:offset+40004]:2], unique[88680:2]
	8: unique[88780:2] = SUBPIECE unique[88400:8], const[6:4]
	9: [handle:space][[handle:offset+60006]:2] = INT_MULT [handle:space][[handle:offset+60006]:2], unique[88780:2]

Line ia.sinc:7119 :PMULLW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD5; xmmmod = 3 & XmmReg1 & XmmReg2 {
  XmmReg1[0,16] = XmmReg1[0,16] * XmmReg2[0,16];
  XmmReg1[16,16] = XmmReg1[16,16] * XmmReg2[16,16];
  XmmReg1[32,16] = XmmReg1[32,16] * XmmReg2[32,16];
  XmmReg1[48,16] = XmmReg1[48,16] * XmmReg2[48,16];
  XmmReg1[64,16] = XmmReg1[64,16] * XmmReg2[64,16];
  XmmReg1[80,16] = XmmReg1[80,16] * XmmReg2[80,16];
  XmmReg1[96,16] = XmmReg1[96,16] * XmmReg2[96,16];
  XmmReg1[112,16] = XmmReg1[112,16] * XmmReg2[112,16];
 }
0: Constructor line ia.sinc:7119(id0.1181) printpiece=[PMULLW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3480  1: XmmReg2 : 3481  
Pattern id=1181 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D5:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:2] = INT_MULT [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: [handle:space][[handle:offset+20002]:2] = INT_MULT [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	4: [handle:space][[handle:offset+40004]:2] = INT_MULT [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	5: [handle:space][[handle:offset+60006]:2] = INT_MULT [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	6: [handle:space][[handle:offset+80008]:2] = INT_MULT [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	7: [handle:space][[handle:offset+a000a]:2] = INT_MULT [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	8: [handle:space][[handle:offset+c000c]:2] = INT_MULT [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	9: [handle:space][[handle:offset+e000e]:2] = INT_MULT [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]

Line ia.sinc:7107 :PMULLW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD5; XmmReg ... & m128 {
  local m:16 = m128;
  XmmReg[0,16] = XmmReg[0,16] * m[0,16];
  XmmReg[16,16] = XmmReg[16,16] * m[16,16];
  XmmReg[32,16] = XmmReg[32,16] * m[32,16];
  XmmReg[48,16] = XmmReg[48,16] * m[48,16];
  XmmReg[64,16] = XmmReg[64,16] * m[64,16];
  XmmReg[80,16] = XmmReg[80,16] * m[80,16];
  XmmReg[96,16] = XmmReg[96,16] * m[96,16];
  XmmReg[112,16] = XmmReg[112,16] * m[112,16];
}
1: Constructor line ia.sinc:7107(id0.1180) printpiece=[PMULLW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3478  1: m128 : 3479  
Pattern id=1180 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D5:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[88a80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[88b00:2] = SUBPIECE unique[88a80:10], const[0:4]
	4: [handle:space][[handle:offset+0]:2] = INT_MULT [handle:space][[handle:offset+0]:2], unique[88b00:2]
	5: unique[88c00:2] = SUBPIECE unique[88a80:10], const[2:4]
	6: [handle:space][[handle:offset+20002]:2] = INT_MULT [handle:space][[handle:offset+20002]:2], unique[88c00:2]
	7: unique[88d00:2] = SUBPIECE unique[88a80:10], const[4:4]
	8: [handle:space][[handle:offset+40004]:2] = INT_MULT [handle:space][[handle:offset+40004]:2], unique[88d00:2]
	9: unique[88e00:2] = SUBPIECE unique[88a80:10], const[6:4]
	10: [handle:space][[handle:offset+60006]:2] = INT_MULT [handle:space][[handle:offset+60006]:2], unique[88e00:2]
	11: unique[88f00:2] = SUBPIECE unique[88a80:10], const[8:4]
	12: [handle:space][[handle:offset+80008]:2] = INT_MULT [handle:space][[handle:offset+80008]:2], unique[88f00:2]
	13: unique[89000:2] = SUBPIECE unique[88a80:10], const[a:4]
	14: [handle:space][[handle:offset+a000a]:2] = INT_MULT [handle:space][[handle:offset+a000a]:2], unique[89000:2]
	15: unique[89100:2] = SUBPIECE unique[88a80:10], const[c:4]
	16: [handle:space][[handle:offset+c000c]:2] = INT_MULT [handle:space][[handle:offset+c000c]:2], unique[89100:2]
	17: unique[89200:2] = SUBPIECE unique[88a80:10], const[e:4]
	18: [handle:space][[handle:offset+e000e]:2] = INT_MULT [handle:space][[handle:offset+e000e]:2], unique[89200:2]

Line ia.sinc:5775 :MOVDQ2Q      mmxreg2, XmmReg1    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0xD6; XmmReg1 & mmxreg2 { mmxreg2 = movdq2q(mmxreg2, XmmReg1); }
0: Constructor line ia.sinc:5775(id0.954) printpiece=[MOVDQ2Q,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 2985  1: mmxreg2 : 2984  
Pattern id=954 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:D6:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[72:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5831 :MOVQ         XmmReg2, XmmReg1 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD6; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg2 = zext(XmmReg1[0,64]);
}
1: Constructor line ia.sinc:5831(id0.978) printpiece=[MOVQ,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 3035  1: XmmReg2 : 3034  
Pattern id=978 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D6:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset+0]:8]

Line ia.sinc:5826 :MOVQ         m64, XmmReg      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD6; m64 & XmmReg ...
{
    m64 = XmmReg[0,64];
}
2: Constructor line ia.sinc:5826(id0.977) printpiece=[MOVQ,  ,  A, ,,  ,  B]
Operands 0: m64 : 3032  1: XmmReg : 3033  
Pattern id=977 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D6:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:5836 :MOVQ2DQ      XmmReg, mmxreg2  is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0xD6; XmmReg & mmxreg2
{
    XmmReg = zext(mmxreg2);
# may need to model x87 FPU state changes too ?????
}
3: Constructor line ia.sinc:5836(id0.979) printpiece=[MOVQ2DQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3036  1: mmxreg2 : 3037  
Pattern id=979 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:D6:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7034 :PMOVMSKB       Reg32, mmxreg2   is vexMode=0 & mandover=0 & byte=0x0F; byte=0xD7; mod = 3 & Reg32 & mmxreg2 & check_Reg32_dest
{ 
	local byte_mask:1 = 0:1;
	byte_mask[0,1] = mmxreg2[7,1];
	byte_mask[1,1] = mmxreg2[15,1];
	byte_mask[2,1] = mmxreg2[23,1];
	byte_mask[3,1] = mmxreg2[31,1];
	byte_mask[4,1] = mmxreg2[39,1];
	byte_mask[5,1] = mmxreg2[47,1];
	byte_mask[6,1] = mmxreg2[55,1];
	byte_mask[7,1] = mmxreg2[63,1];
	Reg32 = zext(byte_mask);
	build check_Reg32_dest;
}
0: Constructor line ia.sinc:7034(id0.1164) printpiece=[PMOVMSKB,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 3441  1: mmxreg2 : 3442  2: check_Reg32_dest : 3443  
Pattern id=1164 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D7:[11xx]X:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[83900:1] = COPY const[0:1]
	2: unique[83b00:1] = INT_AND unique[83900:1], const[fffffffffffffffe:1]
	3: unique[83980:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[7:4]
	4: unique[83a00:1] = SUBPIECE unique[83980:[handle:size]], const[0:4]
	5: unique[83a80:1] = INT_AND unique[83a00:1], const[1:1]
	6: unique[83900:1] = INT_OR unique[83b00:1], unique[83a80:1]
	7: unique[83d00:1] = INT_AND unique[83900:1], const[fffffffffffffffd:1]
	8: unique[83b80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[f:4]
	9: unique[83c00:1] = SUBPIECE unique[83b80:[handle:size]], const[0:4]
	10: unique[83c80:1] = INT_AND unique[83c00:1], const[1:1]
	11: unique[83d80:1] = INT_LEFT unique[83c80:1], const[1:4]
	12: unique[83900:1] = INT_OR unique[83d00:1], unique[83d80:1]
	13: unique[83f80:1] = INT_AND unique[83900:1], const[fffffffffffffffb:1]
	14: unique[83e00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[17:4]
	15: unique[83e80:1] = SUBPIECE unique[83e00:[handle:size]], const[0:4]
	16: unique[83f00:1] = INT_AND unique[83e80:1], const[1:1]
	17: unique[84000:1] = INT_LEFT unique[83f00:1], const[2:4]
	18: unique[83900:1] = INT_OR unique[83f80:1], unique[84000:1]
	19: unique[84200:1] = INT_AND unique[83900:1], const[fffffffffffffff7:1]
	20: unique[84080:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1f:4]
	21: unique[84100:1] = SUBPIECE unique[84080:[handle:size]], const[0:4]
	22: unique[84180:1] = INT_AND unique[84100:1], const[1:1]
	23: unique[84280:1] = INT_LEFT unique[84180:1], const[3:4]
	24: unique[83900:1] = INT_OR unique[84200:1], unique[84280:1]
	25: unique[84480:1] = INT_AND unique[83900:1], const[ffffffffffffffef:1]
	26: unique[84300:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[27:4]
	27: unique[84380:1] = SUBPIECE unique[84300:[handle:size]], const[0:4]
	28: unique[84400:1] = INT_AND unique[84380:1], const[1:1]
	29: unique[84500:1] = INT_LEFT unique[84400:1], const[4:4]
	30: unique[83900:1] = INT_OR unique[84480:1], unique[84500:1]
	31: unique[84700:1] = INT_AND unique[83900:1], const[ffffffffffffffdf:1]
	32: unique[84580:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[2f:4]
	33: unique[84600:1] = SUBPIECE unique[84580:[handle:size]], const[0:4]
	34: unique[84680:1] = INT_AND unique[84600:1], const[1:1]
	35: unique[84780:1] = INT_LEFT unique[84680:1], const[5:4]
	36: unique[83900:1] = INT_OR unique[84700:1], unique[84780:1]
	37: unique[84980:1] = INT_AND unique[83900:1], const[ffffffffffffffbf:1]
	38: unique[84800:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[37:4]
	39: unique[84880:1] = SUBPIECE unique[84800:[handle:size]], const[0:4]
	40: unique[84900:1] = INT_AND unique[84880:1], const[1:1]
	41: unique[84a00:1] = INT_LEFT unique[84900:1], const[6:4]
	42: unique[83900:1] = INT_OR unique[84980:1], unique[84a00:1]
	43: unique[84c00:1] = INT_AND unique[83900:1], const[ffffffffffffff7f:1]
	44: unique[84a80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[3f:4]
	45: unique[84b00:1] = SUBPIECE unique[84a80:[handle:size]], const[0:4]
	46: unique[84b80:1] = INT_AND unique[84b00:1], const[1:1]
	47: unique[84c80:1] = INT_LEFT unique[84b80:1], const[7:4]
	48: unique[83900:1] = INT_OR unique[84c00:1], unique[84c80:1]
	49: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[83900:1]
	50: MULTIEQUAL const[2:4]

Line ia.sinc:7051 :PMOVMSKB       Reg32, XmmReg2   is vexMode=0 &   $(PRE_66) & byte=0x0F; byte=0xD7; mod = 3 & Reg32 & XmmReg2 & check_Reg32_dest
{ 
	local byte_mask:2 = 0:2;
	byte_mask[0,1] = XmmReg2[7,1];
	byte_mask[1,1] = XmmReg2[15,1];
	byte_mask[2,1] = XmmReg2[23,1];
	byte_mask[3,1] = XmmReg2[31,1];
	byte_mask[4,1] = XmmReg2[39,1];
	byte_mask[5,1] = XmmReg2[47,1];
	byte_mask[6,1] = XmmReg2[55,1];
	byte_mask[7,1] = XmmReg2[63,1];
	byte_mask[8,1] = XmmReg2[71,1];
	byte_mask[9,1] = XmmReg2[79,1];
	byte_mask[10,1] = XmmReg2[87,1];
	byte_mask[11,1] = XmmReg2[95,1];
	byte_mask[12,1] = XmmReg2[103,1];
	byte_mask[13,1] = XmmReg2[111,1];
	byte_mask[14,1] = XmmReg2[119,1];
	byte_mask[15,1] = XmmReg2[127,1];
	Reg32 = zext(byte_mask);
	build check_Reg32_dest;
}
0: Constructor line ia.sinc:7051(id0.1165) printpiece=[PMOVMSKB,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 3444  1: XmmReg2 : 3445  2: check_Reg32_dest : 3446  
Pattern id=1165 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D7:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[84d80:2] = COPY const[0:2]
	3: unique[84f80:2] = INT_AND unique[84d80:2], const[fffffffffffffffe:2]
	4: unique[84e00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[7:4]
	5: unique[84e80:1] = SUBPIECE unique[84e00:[handle:size]], const[0:4]
	6: unique[84f00:1] = INT_AND unique[84e80:1], const[1:1]
	7: unique[85000:2] = INT_ZEXT unique[84f00:1]
	8: unique[84d80:2] = INT_OR unique[84f80:2], unique[85000:2]
	9: unique[85200:2] = INT_AND unique[84d80:2], const[fffffffffffffffd:2]
	10: unique[85080:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[f:4]
	11: unique[85100:1] = SUBPIECE unique[85080:[handle:size]], const[0:4]
	12: unique[85180:1] = INT_AND unique[85100:1], const[1:1]
	13: unique[85280:2] = INT_ZEXT unique[85180:1]
	14: unique[85300:2] = INT_LEFT unique[85280:2], const[1:4]
	15: unique[84d80:2] = INT_OR unique[85200:2], unique[85300:2]
	16: unique[85500:2] = INT_AND unique[84d80:2], const[fffffffffffffffb:2]
	17: unique[85380:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[17:4]
	18: unique[85400:1] = SUBPIECE unique[85380:[handle:size]], const[0:4]
	19: unique[85480:1] = INT_AND unique[85400:1], const[1:1]
	20: unique[85580:2] = INT_ZEXT unique[85480:1]
	21: unique[85600:2] = INT_LEFT unique[85580:2], const[2:4]
	22: unique[84d80:2] = INT_OR unique[85500:2], unique[85600:2]
	23: unique[85800:2] = INT_AND unique[84d80:2], const[fffffffffffffff7:2]
	24: unique[85680:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1f:4]
	25: unique[85700:1] = SUBPIECE unique[85680:[handle:size]], const[0:4]
	26: unique[85780:1] = INT_AND unique[85700:1], const[1:1]
	27: unique[85880:2] = INT_ZEXT unique[85780:1]
	28: unique[85900:2] = INT_LEFT unique[85880:2], const[3:4]
	29: unique[84d80:2] = INT_OR unique[85800:2], unique[85900:2]
	30: unique[85b00:2] = INT_AND unique[84d80:2], const[ffffffffffffffef:2]
	31: unique[85980:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[27:4]
	32: unique[85a00:1] = SUBPIECE unique[85980:[handle:size]], const[0:4]
	33: unique[85a80:1] = INT_AND unique[85a00:1], const[1:1]
	34: unique[85b80:2] = INT_ZEXT unique[85a80:1]
	35: unique[85c00:2] = INT_LEFT unique[85b80:2], const[4:4]
	36: unique[84d80:2] = INT_OR unique[85b00:2], unique[85c00:2]
	37: unique[85e00:2] = INT_AND unique[84d80:2], const[ffffffffffffffdf:2]
	38: unique[85c80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[2f:4]
	39: unique[85d00:1] = SUBPIECE unique[85c80:[handle:size]], const[0:4]
	40: unique[85d80:1] = INT_AND unique[85d00:1], const[1:1]
	41: unique[85e80:2] = INT_ZEXT unique[85d80:1]
	42: unique[85f00:2] = INT_LEFT unique[85e80:2], const[5:4]
	43: unique[84d80:2] = INT_OR unique[85e00:2], unique[85f00:2]
	44: unique[86100:2] = INT_AND unique[84d80:2], const[ffffffffffffffbf:2]
	45: unique[85f80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[37:4]
	46: unique[86000:1] = SUBPIECE unique[85f80:[handle:size]], const[0:4]
	47: unique[86080:1] = INT_AND unique[86000:1], const[1:1]
	48: unique[86180:2] = INT_ZEXT unique[86080:1]
	49: unique[86200:2] = INT_LEFT unique[86180:2], const[6:4]
	50: unique[84d80:2] = INT_OR unique[86100:2], unique[86200:2]
	51: unique[86400:2] = INT_AND unique[84d80:2], const[ffffffffffffff7f:2]
	52: unique[86280:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[3f:4]
	53: unique[86300:1] = SUBPIECE unique[86280:[handle:size]], const[0:4]
	54: unique[86380:1] = INT_AND unique[86300:1], const[1:1]
	55: unique[86480:2] = INT_ZEXT unique[86380:1]
	56: unique[86500:2] = INT_LEFT unique[86480:2], const[7:4]
	57: unique[84d80:2] = INT_OR unique[86400:2], unique[86500:2]
	58: unique[86700:2] = INT_AND unique[84d80:2], const[fffffffffffffeff:2]
	59: unique[86580:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[47:4]
	60: unique[86600:1] = SUBPIECE unique[86580:[handle:size]], const[0:4]
	61: unique[86680:1] = INT_AND unique[86600:1], const[1:1]
	62: unique[86780:2] = INT_ZEXT unique[86680:1]
	63: unique[86800:2] = INT_LEFT unique[86780:2], const[8:4]
	64: unique[84d80:2] = INT_OR unique[86700:2], unique[86800:2]
	65: unique[86a00:2] = INT_AND unique[84d80:2], const[fffffffffffffdff:2]
	66: unique[86880:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[4f:4]
	67: unique[86900:1] = SUBPIECE unique[86880:[handle:size]], const[0:4]
	68: unique[86980:1] = INT_AND unique[86900:1], const[1:1]
	69: unique[86a80:2] = INT_ZEXT unique[86980:1]
	70: unique[86b00:2] = INT_LEFT unique[86a80:2], const[9:4]
	71: unique[84d80:2] = INT_OR unique[86a00:2], unique[86b00:2]
	72: unique[86d00:2] = INT_AND unique[84d80:2], const[fffffffffffffbff:2]
	73: unique[86b80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[57:4]
	74: unique[86c00:1] = SUBPIECE unique[86b80:[handle:size]], const[0:4]
	75: unique[86c80:1] = INT_AND unique[86c00:1], const[1:1]
	76: unique[86d80:2] = INT_ZEXT unique[86c80:1]
	77: unique[86e00:2] = INT_LEFT unique[86d80:2], const[a:4]
	78: unique[84d80:2] = INT_OR unique[86d00:2], unique[86e00:2]
	79: unique[87000:2] = INT_AND unique[84d80:2], const[fffffffffffff7ff:2]
	80: unique[86e80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[5f:4]
	81: unique[86f00:1] = SUBPIECE unique[86e80:[handle:size]], const[0:4]
	82: unique[86f80:1] = INT_AND unique[86f00:1], const[1:1]
	83: unique[87080:2] = INT_ZEXT unique[86f80:1]
	84: unique[87100:2] = INT_LEFT unique[87080:2], const[b:4]
	85: unique[84d80:2] = INT_OR unique[87000:2], unique[87100:2]
	86: unique[87300:2] = INT_AND unique[84d80:2], const[ffffffffffffefff:2]
	87: unique[87180:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[67:4]
	88: unique[87200:1] = SUBPIECE unique[87180:[handle:size]], const[0:4]
	89: unique[87280:1] = INT_AND unique[87200:1], const[1:1]
	90: unique[87380:2] = INT_ZEXT unique[87280:1]
	91: unique[87400:2] = INT_LEFT unique[87380:2], const[c:4]
	92: unique[84d80:2] = INT_OR unique[87300:2], unique[87400:2]
	93: unique[87600:2] = INT_AND unique[84d80:2], const[ffffffffffffdfff:2]
	94: unique[87480:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[6f:4]
	95: unique[87500:1] = SUBPIECE unique[87480:[handle:size]], const[0:4]
	96: unique[87580:1] = INT_AND unique[87500:1], const[1:1]
	97: unique[87680:2] = INT_ZEXT unique[87580:1]
	98: unique[87700:2] = INT_LEFT unique[87680:2], const[d:4]
	99: unique[84d80:2] = INT_OR unique[87600:2], unique[87700:2]
	100: unique[87900:2] = INT_AND unique[84d80:2], const[ffffffffffffbfff:2]
	101: unique[87780:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[77:4]
	102: unique[87800:1] = SUBPIECE unique[87780:[handle:size]], const[0:4]
	103: unique[87880:1] = INT_AND unique[87800:1], const[1:1]
	104: unique[87980:2] = INT_ZEXT unique[87880:1]
	105: unique[87a00:2] = INT_LEFT unique[87980:2], const[e:4]
	106: unique[84d80:2] = INT_OR unique[87900:2], unique[87a00:2]
	107: unique[87c00:2] = INT_AND unique[84d80:2], const[ffffffffffff7fff:2]
	108: unique[87a80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[7f:4]
	109: unique[87b00:1] = SUBPIECE unique[87a80:[handle:size]], const[0:4]
	110: unique[87b80:1] = INT_AND unique[87b00:1], const[1:1]
	111: unique[87c80:2] = INT_ZEXT unique[87b80:1]
	112: unique[87d00:2] = INT_LEFT unique[87c80:2], const[f:4]
	113: unique[84d80:2] = INT_OR unique[87c00:2], unique[87d00:2]
	114: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[84d80:2]
	115: MULTIEQUAL const[2:4]

Line ia.sinc:7708 :PSUBUSB         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD8; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = psubusb(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:7708(id0.1293) printpiece=[PSUBUSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3745  1: mmxreg2 : 3746  
Pattern id=1293 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D8:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7707 :PSUBUSB         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD8; mmxreg ... & m64 ... { mmxreg = psubusb(mmxreg, m64); }
1: Constructor line ia.sinc:7707(id0.1292) printpiece=[PSUBUSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3743  1: m64 : 3744  
Pattern id=1292 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D8:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7715 :PSUBUSB         XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD8; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = psubusb(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:7715(id0.1297) printpiece=[PSUBUSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3754  1: XmmReg2 : 3755  
Pattern id=1297 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D8:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7714 :PSUBUSB         XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD8; XmmReg ... & m128 { XmmReg = psubusb(XmmReg, m128); }
1: Constructor line ia.sinc:7714(id0.1296) printpiece=[PSUBUSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3752  1: m128 : 3753  
Pattern id=1296 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D8:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7712 :PSUBUSW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD9; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = psubusw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:7712(id0.1295) printpiece=[PSUBUSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3750  1: mmxreg2 : 3751  
Pattern id=1295 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D9:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7711 :PSUBUSW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xD9; mmxreg ... & m64 ... { mmxreg = psubusw(mmxreg, m64); }
1: Constructor line ia.sinc:7711(id0.1294) printpiece=[PSUBUSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3748  1: m64 : 3749  
Pattern id=1294 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:D9:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7718 :PSUBUSW         XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD9; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = psubusw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:7718(id0.1299) printpiece=[PSUBUSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3758  1: XmmReg2 : 3759  
Pattern id=1299 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D9:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7717 :PSUBUSW         XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xD9; XmmReg ... & m128 { XmmReg = psubusw(XmmReg, m128); }
1: Constructor line ia.sinc:7717(id0.1298) printpiece=[PSUBUSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3756  1: m128 : 3757  
Pattern id=1298 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:D9:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[9b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6980 :PMINUB        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDA; mmxmod = 3 & mmxreg1 & mmxreg2 
{ 
	assignUnsignedLesser(mmxreg1[0,8],mmxreg1[0,8],mmxreg2[0,8]);
	assignUnsignedLesser(mmxreg1[8,8],mmxreg1[8,8],mmxreg2[8,8]);
	assignUnsignedLesser(mmxreg1[16,8],mmxreg1[16,8],mmxreg2[16,8]);
	assignUnsignedLesser(mmxreg1[24,8],mmxreg1[24,8],mmxreg2[24,8]);
	assignUnsignedLesser(mmxreg1[32,8],mmxreg1[32,8],mmxreg2[32,8]);
	assignUnsignedLesser(mmxreg1[40,8],mmxreg1[40,8],mmxreg2[40,8]);
	assignUnsignedLesser(mmxreg1[48,8],mmxreg1[48,8],mmxreg2[48,8]);
	assignUnsignedLesser(mmxreg1[56,8],mmxreg1[56,8],mmxreg2[56,8]);
}
0: Constructor line ia.sinc:6980(id0.1161) printpiece=[PMINUB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3435  1: mmxreg2 : 3436  
Pattern id=1161 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DA:[11xx]X:XX)
Template
	0: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	1: unique[83600:1] = COPY unique[83580:1]
	2: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+0]:1]
	3: unique[83700:1] = INT_LESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	4: unique[83780:1] = COPY unique[83700:1]
	5: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+0]:1]
	6: [handle:space][[handle:offset+0]:1] = INT_ADD unique[83680:1], unique[83800:1]
	7: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	8: unique[83600:1] = COPY unique[83580:1]
	9: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+10001]:1]
	10: unique[83700:1] = INT_LESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	11: unique[83780:1] = COPY unique[83700:1]
	12: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+10001]:1]
	13: [handle:space][[handle:offset+10001]:1] = INT_ADD unique[83680:1], unique[83800:1]
	14: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	15: unique[83600:1] = COPY unique[83580:1]
	16: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+20002]:1]
	17: unique[83700:1] = INT_LESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	18: unique[83780:1] = COPY unique[83700:1]
	19: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+20002]:1]
	20: [handle:space][[handle:offset+20002]:1] = INT_ADD unique[83680:1], unique[83800:1]
	21: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	22: unique[83600:1] = COPY unique[83580:1]
	23: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+30003]:1]
	24: unique[83700:1] = INT_LESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	25: unique[83780:1] = COPY unique[83700:1]
	26: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+30003]:1]
	27: [handle:space][[handle:offset+30003]:1] = INT_ADD unique[83680:1], unique[83800:1]
	28: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	29: unique[83600:1] = COPY unique[83580:1]
	30: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+40004]:1]
	31: unique[83700:1] = INT_LESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	32: unique[83780:1] = COPY unique[83700:1]
	33: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+40004]:1]
	34: [handle:space][[handle:offset+40004]:1] = INT_ADD unique[83680:1], unique[83800:1]
	35: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	36: unique[83600:1] = COPY unique[83580:1]
	37: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+50005]:1]
	38: unique[83700:1] = INT_LESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	39: unique[83780:1] = COPY unique[83700:1]
	40: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+50005]:1]
	41: [handle:space][[handle:offset+50005]:1] = INT_ADD unique[83680:1], unique[83800:1]
	42: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	43: unique[83600:1] = COPY unique[83580:1]
	44: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+60006]:1]
	45: unique[83700:1] = INT_LESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	46: unique[83780:1] = COPY unique[83700:1]
	47: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+60006]:1]
	48: [handle:space][[handle:offset+60006]:1] = INT_ADD unique[83680:1], unique[83800:1]
	49: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	50: unique[83600:1] = COPY unique[83580:1]
	51: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+70007]:1]
	52: unique[83700:1] = INT_LESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	53: unique[83780:1] = COPY unique[83700:1]
	54: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+70007]:1]
	55: [handle:space][[handle:offset+70007]:1] = INT_ADD unique[83680:1], unique[83800:1]

Line ia.sinc:6968 :PMINUB        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDA; mmxreg ... & m64 
{ 
	assignUnsignedLesser(mmxreg[0,8],mmxreg[0,8],m64[0,8]);
	assignUnsignedLesser(mmxreg[8,8],mmxreg[8,8],m64[8,8]);
	assignUnsignedLesser(mmxreg[16,8],mmxreg[16,8],m64[16,8]);
	assignUnsignedLesser(mmxreg[24,8],mmxreg[24,8],m64[24,8]);
	assignUnsignedLesser(mmxreg[32,8],mmxreg[32,8],m64[32,8]);
	assignUnsignedLesser(mmxreg[40,8],mmxreg[40,8],m64[40,8]);
	assignUnsignedLesser(mmxreg[48,8],mmxreg[48,8],m64[48,8]);
	assignUnsignedLesser(mmxreg[56,8],mmxreg[56,8],m64[56,8]);
}
1: Constructor line ia.sinc:6968(id0.1160) printpiece=[PMINUB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3433  1: m64 : 3434  
Pattern id=1160 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DA:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	2: unique[83600:1] = COPY unique[83580:1]
	3: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+0]:1]
	4: unique[83700:1] = INT_LESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	5: unique[83780:1] = COPY unique[83700:1]
	6: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+0]:1]
	7: [handle:space][[handle:offset+0]:1] = INT_ADD unique[83680:1], unique[83800:1]
	8: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	9: unique[83600:1] = COPY unique[83580:1]
	10: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+10001]:1]
	11: unique[83700:1] = INT_LESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	12: unique[83780:1] = COPY unique[83700:1]
	13: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+10001]:1]
	14: [handle:space][[handle:offset+10001]:1] = INT_ADD unique[83680:1], unique[83800:1]
	15: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	16: unique[83600:1] = COPY unique[83580:1]
	17: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+20002]:1]
	18: unique[83700:1] = INT_LESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	19: unique[83780:1] = COPY unique[83700:1]
	20: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+20002]:1]
	21: [handle:space][[handle:offset+20002]:1] = INT_ADD unique[83680:1], unique[83800:1]
	22: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	23: unique[83600:1] = COPY unique[83580:1]
	24: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+30003]:1]
	25: unique[83700:1] = INT_LESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	26: unique[83780:1] = COPY unique[83700:1]
	27: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+30003]:1]
	28: [handle:space][[handle:offset+30003]:1] = INT_ADD unique[83680:1], unique[83800:1]
	29: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	30: unique[83600:1] = COPY unique[83580:1]
	31: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+40004]:1]
	32: unique[83700:1] = INT_LESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	33: unique[83780:1] = COPY unique[83700:1]
	34: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+40004]:1]
	35: [handle:space][[handle:offset+40004]:1] = INT_ADD unique[83680:1], unique[83800:1]
	36: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	37: unique[83600:1] = COPY unique[83580:1]
	38: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+50005]:1]
	39: unique[83700:1] = INT_LESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	40: unique[83780:1] = COPY unique[83700:1]
	41: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+50005]:1]
	42: [handle:space][[handle:offset+50005]:1] = INT_ADD unique[83680:1], unique[83800:1]
	43: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	44: unique[83600:1] = COPY unique[83580:1]
	45: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+60006]:1]
	46: unique[83700:1] = INT_LESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	47: unique[83780:1] = COPY unique[83700:1]
	48: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+60006]:1]
	49: [handle:space][[handle:offset+60006]:1] = INT_ADD unique[83680:1], unique[83800:1]
	50: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	51: unique[83600:1] = COPY unique[83580:1]
	52: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+70007]:1]
	53: unique[83700:1] = INT_LESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	54: unique[83780:1] = COPY unique[83700:1]
	55: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+70007]:1]
	56: [handle:space][[handle:offset+70007]:1] = INT_ADD unique[83680:1], unique[83800:1]

Line ia.sinc:7012 :PMINUB        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDA; xmmmod = 3 & XmmReg1 & XmmReg2 
{ 
	assignUnsignedLesser(XmmReg1[0,8],XmmReg1[0,8],XmmReg2[0,8]);
	assignUnsignedLesser(XmmReg1[8,8],XmmReg1[8,8],XmmReg2[8,8]);
	assignUnsignedLesser(XmmReg1[16,8],XmmReg1[16,8],XmmReg2[16,8]);
	assignUnsignedLesser(XmmReg1[24,8],XmmReg1[24,8],XmmReg2[24,8]);
	assignUnsignedLesser(XmmReg1[32,8],XmmReg1[32,8],XmmReg2[32,8]);
	assignUnsignedLesser(XmmReg1[40,8],XmmReg1[40,8],XmmReg2[40,8]);
	assignUnsignedLesser(XmmReg1[48,8],XmmReg1[48,8],XmmReg2[48,8]);
	assignUnsignedLesser(XmmReg1[56,8],XmmReg1[56,8],XmmReg2[56,8]);
	assignUnsignedLesser(XmmReg1[64,8],XmmReg1[64,8],XmmReg2[64,8]);
	assignUnsignedLesser(XmmReg1[72,8],XmmReg1[72,8],XmmReg2[72,8]);
	assignUnsignedLesser(XmmReg1[80,8],XmmReg1[80,8],XmmReg2[80,8]);
	assignUnsignedLesser(XmmReg1[88,8],XmmReg1[88,8],XmmReg2[88,8]);
	assignUnsignedLesser(XmmReg1[96,8],XmmReg1[96,8],XmmReg2[96,8]);
	assignUnsignedLesser(XmmReg1[104,8],XmmReg1[104,8],XmmReg2[104,8]);
	assignUnsignedLesser(XmmReg1[112,8],XmmReg1[112,8],XmmReg2[112,8]);
	assignUnsignedLesser(XmmReg1[120,8],XmmReg1[120,8],XmmReg2[120,8]);
}
0: Constructor line ia.sinc:7012(id0.1163) printpiece=[PMINUB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3439  1: XmmReg2 : 3440  
Pattern id=1163 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DA:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	3: unique[83600:1] = COPY unique[83580:1]
	4: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+0]:1]
	5: unique[83700:1] = INT_LESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	6: unique[83780:1] = COPY unique[83700:1]
	7: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+0]:1]
	8: [handle:space][[handle:offset+0]:1] = INT_ADD unique[83680:1], unique[83800:1]
	9: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	10: unique[83600:1] = COPY unique[83580:1]
	11: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+10001]:1]
	12: unique[83700:1] = INT_LESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	13: unique[83780:1] = COPY unique[83700:1]
	14: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+10001]:1]
	15: [handle:space][[handle:offset+10001]:1] = INT_ADD unique[83680:1], unique[83800:1]
	16: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	17: unique[83600:1] = COPY unique[83580:1]
	18: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+20002]:1]
	19: unique[83700:1] = INT_LESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	20: unique[83780:1] = COPY unique[83700:1]
	21: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+20002]:1]
	22: [handle:space][[handle:offset+20002]:1] = INT_ADD unique[83680:1], unique[83800:1]
	23: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	24: unique[83600:1] = COPY unique[83580:1]
	25: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+30003]:1]
	26: unique[83700:1] = INT_LESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	27: unique[83780:1] = COPY unique[83700:1]
	28: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+30003]:1]
	29: [handle:space][[handle:offset+30003]:1] = INT_ADD unique[83680:1], unique[83800:1]
	30: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	31: unique[83600:1] = COPY unique[83580:1]
	32: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+40004]:1]
	33: unique[83700:1] = INT_LESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	34: unique[83780:1] = COPY unique[83700:1]
	35: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+40004]:1]
	36: [handle:space][[handle:offset+40004]:1] = INT_ADD unique[83680:1], unique[83800:1]
	37: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	38: unique[83600:1] = COPY unique[83580:1]
	39: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+50005]:1]
	40: unique[83700:1] = INT_LESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	41: unique[83780:1] = COPY unique[83700:1]
	42: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+50005]:1]
	43: [handle:space][[handle:offset+50005]:1] = INT_ADD unique[83680:1], unique[83800:1]
	44: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	45: unique[83600:1] = COPY unique[83580:1]
	46: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+60006]:1]
	47: unique[83700:1] = INT_LESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	48: unique[83780:1] = COPY unique[83700:1]
	49: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+60006]:1]
	50: [handle:space][[handle:offset+60006]:1] = INT_ADD unique[83680:1], unique[83800:1]
	51: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	52: unique[83600:1] = COPY unique[83580:1]
	53: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+70007]:1]
	54: unique[83700:1] = INT_LESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	55: unique[83780:1] = COPY unique[83700:1]
	56: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+70007]:1]
	57: [handle:space][[handle:offset+70007]:1] = INT_ADD unique[83680:1], unique[83800:1]
	58: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	59: unique[83600:1] = COPY unique[83580:1]
	60: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+80008]:1]
	61: unique[83700:1] = INT_LESS [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	62: unique[83780:1] = COPY unique[83700:1]
	63: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+80008]:1]
	64: [handle:space][[handle:offset+80008]:1] = INT_ADD unique[83680:1], unique[83800:1]
	65: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	66: unique[83600:1] = COPY unique[83580:1]
	67: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+90009]:1]
	68: unique[83700:1] = INT_LESS [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	69: unique[83780:1] = COPY unique[83700:1]
	70: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+90009]:1]
	71: [handle:space][[handle:offset+90009]:1] = INT_ADD unique[83680:1], unique[83800:1]
	72: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	73: unique[83600:1] = COPY unique[83580:1]
	74: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+a000a]:1]
	75: unique[83700:1] = INT_LESS [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	76: unique[83780:1] = COPY unique[83700:1]
	77: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+a000a]:1]
	78: [handle:space][[handle:offset+a000a]:1] = INT_ADD unique[83680:1], unique[83800:1]
	79: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	80: unique[83600:1] = COPY unique[83580:1]
	81: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+b000b]:1]
	82: unique[83700:1] = INT_LESS [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	83: unique[83780:1] = COPY unique[83700:1]
	84: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+b000b]:1]
	85: [handle:space][[handle:offset+b000b]:1] = INT_ADD unique[83680:1], unique[83800:1]
	86: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	87: unique[83600:1] = COPY unique[83580:1]
	88: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+c000c]:1]
	89: unique[83700:1] = INT_LESS [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	90: unique[83780:1] = COPY unique[83700:1]
	91: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+c000c]:1]
	92: [handle:space][[handle:offset+c000c]:1] = INT_ADD unique[83680:1], unique[83800:1]
	93: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	94: unique[83600:1] = COPY unique[83580:1]
	95: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+d000d]:1]
	96: unique[83700:1] = INT_LESS [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	97: unique[83780:1] = COPY unique[83700:1]
	98: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+d000d]:1]
	99: [handle:space][[handle:offset+d000d]:1] = INT_ADD unique[83680:1], unique[83800:1]
	100: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	101: unique[83600:1] = COPY unique[83580:1]
	102: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+e000e]:1]
	103: unique[83700:1] = INT_LESS [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	104: unique[83780:1] = COPY unique[83700:1]
	105: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+e000e]:1]
	106: [handle:space][[handle:offset+e000e]:1] = INT_ADD unique[83680:1], unique[83800:1]
	107: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	108: unique[83600:1] = COPY unique[83580:1]
	109: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+f000f]:1]
	110: unique[83700:1] = INT_LESS [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	111: unique[83780:1] = COPY unique[83700:1]
	112: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+f000f]:1]
	113: [handle:space][[handle:offset+f000f]:1] = INT_ADD unique[83680:1], unique[83800:1]

Line ia.sinc:6992 :PMINUB        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDA; XmmReg ... & m128 
{ 
	assignUnsignedLesser(XmmReg[0,8],XmmReg[0,8],m128[0,8]);
	assignUnsignedLesser(XmmReg[8,8],XmmReg[8,8],m128[8,8]);
	assignUnsignedLesser(XmmReg[16,8],XmmReg[16,8],m128[16,8]);
	assignUnsignedLesser(XmmReg[24,8],XmmReg[24,8],m128[24,8]);
	assignUnsignedLesser(XmmReg[32,8],XmmReg[32,8],m128[32,8]);
	assignUnsignedLesser(XmmReg[40,8],XmmReg[40,8],m128[40,8]);
	assignUnsignedLesser(XmmReg[48,8],XmmReg[48,8],m128[48,8]);
	assignUnsignedLesser(XmmReg[56,8],XmmReg[56,8],m128[56,8]);
	assignUnsignedLesser(XmmReg[64,8],XmmReg[64,8],m128[64,8]);
	assignUnsignedLesser(XmmReg[72,8],XmmReg[72,8],m128[72,8]);
	assignUnsignedLesser(XmmReg[80,8],XmmReg[80,8],m128[80,8]);
	assignUnsignedLesser(XmmReg[88,8],XmmReg[88,8],m128[88,8]);
	assignUnsignedLesser(XmmReg[96,8],XmmReg[96,8],m128[96,8]);
	assignUnsignedLesser(XmmReg[104,8],XmmReg[104,8],m128[104,8]);
	assignUnsignedLesser(XmmReg[112,8],XmmReg[112,8],m128[112,8]);
	assignUnsignedLesser(XmmReg[120,8],XmmReg[120,8],m128[120,8]);
}
1: Constructor line ia.sinc:6992(id0.1162) printpiece=[PMINUB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3437  1: m128 : 3438  
Pattern id=1162 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DA:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	3: unique[83600:1] = COPY unique[83580:1]
	4: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+0]:1]
	5: unique[83700:1] = INT_LESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	6: unique[83780:1] = COPY unique[83700:1]
	7: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+0]:1]
	8: [handle:space][[handle:offset+0]:1] = INT_ADD unique[83680:1], unique[83800:1]
	9: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	10: unique[83600:1] = COPY unique[83580:1]
	11: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+10001]:1]
	12: unique[83700:1] = INT_LESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	13: unique[83780:1] = COPY unique[83700:1]
	14: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+10001]:1]
	15: [handle:space][[handle:offset+10001]:1] = INT_ADD unique[83680:1], unique[83800:1]
	16: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	17: unique[83600:1] = COPY unique[83580:1]
	18: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+20002]:1]
	19: unique[83700:1] = INT_LESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	20: unique[83780:1] = COPY unique[83700:1]
	21: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+20002]:1]
	22: [handle:space][[handle:offset+20002]:1] = INT_ADD unique[83680:1], unique[83800:1]
	23: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	24: unique[83600:1] = COPY unique[83580:1]
	25: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+30003]:1]
	26: unique[83700:1] = INT_LESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	27: unique[83780:1] = COPY unique[83700:1]
	28: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+30003]:1]
	29: [handle:space][[handle:offset+30003]:1] = INT_ADD unique[83680:1], unique[83800:1]
	30: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	31: unique[83600:1] = COPY unique[83580:1]
	32: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+40004]:1]
	33: unique[83700:1] = INT_LESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	34: unique[83780:1] = COPY unique[83700:1]
	35: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+40004]:1]
	36: [handle:space][[handle:offset+40004]:1] = INT_ADD unique[83680:1], unique[83800:1]
	37: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	38: unique[83600:1] = COPY unique[83580:1]
	39: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+50005]:1]
	40: unique[83700:1] = INT_LESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	41: unique[83780:1] = COPY unique[83700:1]
	42: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+50005]:1]
	43: [handle:space][[handle:offset+50005]:1] = INT_ADD unique[83680:1], unique[83800:1]
	44: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	45: unique[83600:1] = COPY unique[83580:1]
	46: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+60006]:1]
	47: unique[83700:1] = INT_LESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	48: unique[83780:1] = COPY unique[83700:1]
	49: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+60006]:1]
	50: [handle:space][[handle:offset+60006]:1] = INT_ADD unique[83680:1], unique[83800:1]
	51: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	52: unique[83600:1] = COPY unique[83580:1]
	53: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+70007]:1]
	54: unique[83700:1] = INT_LESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	55: unique[83780:1] = COPY unique[83700:1]
	56: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+70007]:1]
	57: [handle:space][[handle:offset+70007]:1] = INT_ADD unique[83680:1], unique[83800:1]
	58: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	59: unique[83600:1] = COPY unique[83580:1]
	60: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+80008]:1]
	61: unique[83700:1] = INT_LESS [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	62: unique[83780:1] = COPY unique[83700:1]
	63: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+80008]:1]
	64: [handle:space][[handle:offset+80008]:1] = INT_ADD unique[83680:1], unique[83800:1]
	65: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	66: unique[83600:1] = COPY unique[83580:1]
	67: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+90009]:1]
	68: unique[83700:1] = INT_LESS [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	69: unique[83780:1] = COPY unique[83700:1]
	70: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+90009]:1]
	71: [handle:space][[handle:offset+90009]:1] = INT_ADD unique[83680:1], unique[83800:1]
	72: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	73: unique[83600:1] = COPY unique[83580:1]
	74: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+a000a]:1]
	75: unique[83700:1] = INT_LESS [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	76: unique[83780:1] = COPY unique[83700:1]
	77: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+a000a]:1]
	78: [handle:space][[handle:offset+a000a]:1] = INT_ADD unique[83680:1], unique[83800:1]
	79: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	80: unique[83600:1] = COPY unique[83580:1]
	81: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+b000b]:1]
	82: unique[83700:1] = INT_LESS [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	83: unique[83780:1] = COPY unique[83700:1]
	84: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+b000b]:1]
	85: [handle:space][[handle:offset+b000b]:1] = INT_ADD unique[83680:1], unique[83800:1]
	86: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	87: unique[83600:1] = COPY unique[83580:1]
	88: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+c000c]:1]
	89: unique[83700:1] = INT_LESS [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	90: unique[83780:1] = COPY unique[83700:1]
	91: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+c000c]:1]
	92: [handle:space][[handle:offset+c000c]:1] = INT_ADD unique[83680:1], unique[83800:1]
	93: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	94: unique[83600:1] = COPY unique[83580:1]
	95: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+d000d]:1]
	96: unique[83700:1] = INT_LESS [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	97: unique[83780:1] = COPY unique[83700:1]
	98: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+d000d]:1]
	99: [handle:space][[handle:offset+d000d]:1] = INT_ADD unique[83680:1], unique[83800:1]
	100: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	101: unique[83600:1] = COPY unique[83580:1]
	102: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+e000e]:1]
	103: unique[83700:1] = INT_LESS [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	104: unique[83780:1] = COPY unique[83700:1]
	105: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+e000e]:1]
	106: [handle:space][[handle:offset+e000e]:1] = INT_ADD unique[83680:1], unique[83800:1]
	107: unique[83580:1] = INT_LESSEQUAL [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	108: unique[83600:1] = COPY unique[83580:1]
	109: unique[83680:1] = INT_MULT unique[83600:1], [handle:space][[handle:offset+f000f]:1]
	110: unique[83700:1] = INT_LESS [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	111: unique[83780:1] = COPY unique[83700:1]
	112: unique[83800:1] = INT_MULT unique[83780:1], [handle:space][[handle:offset+f000f]:1]
	113: [handle:space][[handle:offset+f000f]:1] = INT_ADD unique[83680:1], unique[83800:1]

Line ia.sinc:6406 :PAND           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDB; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1 = mmxreg1 & mmxreg2; }
0: Constructor line ia.sinc:6406(id0.1069) printpiece=[PAND,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3229  1: mmxreg2 : 3230  
Pattern id=1069 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DB:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6405 :PAND           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDB; mmxreg ... & m64	{ mmxreg = mmxreg & m64; }
1: Constructor line ia.sinc:6405(id0.1068) printpiece=[PAND,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3227  1: m64 : 3228  
Pattern id=1068 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6408 :PAND           XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDB; xmmmod = 3 & XmmReg1 & XmmReg2	{ XmmReg1 = XmmReg1 & XmmReg2; }
0: Constructor line ia.sinc:6408(id0.1071) printpiece=[PAND,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3233  1: XmmReg2 : 3234  
Pattern id=1071 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DB:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6407 :PAND           XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDB; XmmReg ... & m128	{ XmmReg = XmmReg & m128; }
1: Constructor line ia.sinc:6407(id0.1070) printpiece=[PAND,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3231  1: m128 : 3232  
Pattern id=1070 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6370 :PADDUSB        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDC; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = paddusb(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:6370(id0.1057) printpiece=[PADDUSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3200  1: mmxreg2 : 3201  
Pattern id=1057 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DC:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6369 :PADDUSB        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDC; mmxreg ... & m64 { mmxreg = paddusb(mmxreg, m64); }
1: Constructor line ia.sinc:6369(id0.1056) printpiece=[PADDUSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3198  1: m64 : 3199  
Pattern id=1056 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DC:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6377 :PADDUSB        XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDC; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = paddusb(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:6377(id0.1061) printpiece=[PADDUSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3209  1: XmmReg2 : 3210  
Pattern id=1061 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DC:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6376 :PADDUSB        XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDC; XmmReg ... & m128 { XmmReg = paddusb(XmmReg, m128); }
1: Constructor line ia.sinc:6376(id0.1060) printpiece=[PADDUSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3207  1: m128 : 3208  
Pattern id=1060 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DC:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6374 :PADDUSW        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDD; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = paddusw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:6374(id0.1059) printpiece=[PADDUSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3205  1: mmxreg2 : 3206  
Pattern id=1059 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DD:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6373 :PADDUSW        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDD; mmxreg ... & m64 { mmxreg = paddusw(mmxreg, m64); }
1: Constructor line ia.sinc:6373(id0.1058) printpiece=[PADDUSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3203  1: m64 : 3204  
Pattern id=1058 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DD:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6379 :PADDUSW        XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDD; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = paddusw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:6379(id0.1063) printpiece=[PADDUSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3213  1: XmmReg2 : 3214  
Pattern id=1063 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DD:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6378 :PADDUSW        XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDD; XmmReg ... & m128 { XmmReg = paddusw(XmmReg, m128); }
1: Constructor line ia.sinc:6378(id0.1062) printpiece=[PADDUSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3211  1: m128 : 3212  
Pattern id=1062 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DD:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6906 :PMAXUB        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDE; mmxmod = 3 & mmxreg1 & mmxreg2 
{ 
	assignUnsignedGreater(mmxreg1[0,8],mmxreg1[0,8],mmxreg2[0,8]);
	assignUnsignedGreater(mmxreg1[8,8],mmxreg1[8,8],mmxreg2[8,8]);
	assignUnsignedGreater(mmxreg1[16,8],mmxreg1[16,8],mmxreg2[16,8]);
	assignUnsignedGreater(mmxreg1[24,8],mmxreg1[24,8],mmxreg2[24,8]);
	assignUnsignedGreater(mmxreg1[32,8],mmxreg1[32,8],mmxreg2[32,8]);
	assignUnsignedGreater(mmxreg1[40,8],mmxreg1[40,8],mmxreg2[40,8]);
	assignUnsignedGreater(mmxreg1[48,8],mmxreg1[48,8],mmxreg2[48,8]);
	assignUnsignedGreater(mmxreg1[56,8],mmxreg1[56,8],mmxreg2[56,8]);
}
0: Constructor line ia.sinc:6906(id0.1153) printpiece=[PMAXUB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3418  1: mmxreg2 : 3419  
Pattern id=1153 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DE:[11xx]X:XX)
Template
	0: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	1: unique[83080:1] = COPY unique[83000:1]
	2: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+0]:1]
	3: unique[83180:1] = INT_LESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	4: unique[83200:1] = COPY unique[83180:1]
	5: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+0]:1]
	6: [handle:space][[handle:offset+0]:1] = INT_ADD unique[83100:1], unique[83280:1]
	7: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	8: unique[83080:1] = COPY unique[83000:1]
	9: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+10001]:1]
	10: unique[83180:1] = INT_LESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	11: unique[83200:1] = COPY unique[83180:1]
	12: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+10001]:1]
	13: [handle:space][[handle:offset+10001]:1] = INT_ADD unique[83100:1], unique[83280:1]
	14: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	15: unique[83080:1] = COPY unique[83000:1]
	16: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+20002]:1]
	17: unique[83180:1] = INT_LESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	18: unique[83200:1] = COPY unique[83180:1]
	19: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+20002]:1]
	20: [handle:space][[handle:offset+20002]:1] = INT_ADD unique[83100:1], unique[83280:1]
	21: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	22: unique[83080:1] = COPY unique[83000:1]
	23: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+30003]:1]
	24: unique[83180:1] = INT_LESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	25: unique[83200:1] = COPY unique[83180:1]
	26: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+30003]:1]
	27: [handle:space][[handle:offset+30003]:1] = INT_ADD unique[83100:1], unique[83280:1]
	28: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	29: unique[83080:1] = COPY unique[83000:1]
	30: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+40004]:1]
	31: unique[83180:1] = INT_LESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	32: unique[83200:1] = COPY unique[83180:1]
	33: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+40004]:1]
	34: [handle:space][[handle:offset+40004]:1] = INT_ADD unique[83100:1], unique[83280:1]
	35: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	36: unique[83080:1] = COPY unique[83000:1]
	37: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+50005]:1]
	38: unique[83180:1] = INT_LESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	39: unique[83200:1] = COPY unique[83180:1]
	40: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+50005]:1]
	41: [handle:space][[handle:offset+50005]:1] = INT_ADD unique[83100:1], unique[83280:1]
	42: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	43: unique[83080:1] = COPY unique[83000:1]
	44: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+60006]:1]
	45: unique[83180:1] = INT_LESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	46: unique[83200:1] = COPY unique[83180:1]
	47: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+60006]:1]
	48: [handle:space][[handle:offset+60006]:1] = INT_ADD unique[83100:1], unique[83280:1]
	49: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	50: unique[83080:1] = COPY unique[83000:1]
	51: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+70007]:1]
	52: unique[83180:1] = INT_LESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	53: unique[83200:1] = COPY unique[83180:1]
	54: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+70007]:1]
	55: [handle:space][[handle:offset+70007]:1] = INT_ADD unique[83100:1], unique[83280:1]

Line ia.sinc:6894 :PMAXUB        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDE; mmxreg ... & m64 
{ 
	assignUnsignedGreater(mmxreg[0,8],mmxreg[0,8],m64[0,8]);
	assignUnsignedGreater(mmxreg[8,8],mmxreg[8,8],m64[8,8]);
	assignUnsignedGreater(mmxreg[16,8],mmxreg[16,8],m64[16,8]);
	assignUnsignedGreater(mmxreg[24,8],mmxreg[24,8],m64[24,8]);
	assignUnsignedGreater(mmxreg[32,8],mmxreg[32,8],m64[32,8]);
	assignUnsignedGreater(mmxreg[40,8],mmxreg[40,8],m64[40,8]);
	assignUnsignedGreater(mmxreg[48,8],mmxreg[48,8],m64[48,8]);
	assignUnsignedGreater(mmxreg[56,8],mmxreg[56,8],m64[56,8]);
}
1: Constructor line ia.sinc:6894(id0.1152) printpiece=[PMAXUB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3416  1: m64 : 3417  
Pattern id=1152 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DE:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	2: unique[83080:1] = COPY unique[83000:1]
	3: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+0]:1]
	4: unique[83180:1] = INT_LESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	5: unique[83200:1] = COPY unique[83180:1]
	6: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+0]:1]
	7: [handle:space][[handle:offset+0]:1] = INT_ADD unique[83100:1], unique[83280:1]
	8: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	9: unique[83080:1] = COPY unique[83000:1]
	10: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+10001]:1]
	11: unique[83180:1] = INT_LESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	12: unique[83200:1] = COPY unique[83180:1]
	13: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+10001]:1]
	14: [handle:space][[handle:offset+10001]:1] = INT_ADD unique[83100:1], unique[83280:1]
	15: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	16: unique[83080:1] = COPY unique[83000:1]
	17: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+20002]:1]
	18: unique[83180:1] = INT_LESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	19: unique[83200:1] = COPY unique[83180:1]
	20: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+20002]:1]
	21: [handle:space][[handle:offset+20002]:1] = INT_ADD unique[83100:1], unique[83280:1]
	22: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	23: unique[83080:1] = COPY unique[83000:1]
	24: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+30003]:1]
	25: unique[83180:1] = INT_LESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	26: unique[83200:1] = COPY unique[83180:1]
	27: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+30003]:1]
	28: [handle:space][[handle:offset+30003]:1] = INT_ADD unique[83100:1], unique[83280:1]
	29: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	30: unique[83080:1] = COPY unique[83000:1]
	31: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+40004]:1]
	32: unique[83180:1] = INT_LESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	33: unique[83200:1] = COPY unique[83180:1]
	34: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+40004]:1]
	35: [handle:space][[handle:offset+40004]:1] = INT_ADD unique[83100:1], unique[83280:1]
	36: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	37: unique[83080:1] = COPY unique[83000:1]
	38: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+50005]:1]
	39: unique[83180:1] = INT_LESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	40: unique[83200:1] = COPY unique[83180:1]
	41: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+50005]:1]
	42: [handle:space][[handle:offset+50005]:1] = INT_ADD unique[83100:1], unique[83280:1]
	43: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	44: unique[83080:1] = COPY unique[83000:1]
	45: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+60006]:1]
	46: unique[83180:1] = INT_LESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	47: unique[83200:1] = COPY unique[83180:1]
	48: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+60006]:1]
	49: [handle:space][[handle:offset+60006]:1] = INT_ADD unique[83100:1], unique[83280:1]
	50: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	51: unique[83080:1] = COPY unique[83000:1]
	52: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+70007]:1]
	53: unique[83180:1] = INT_LESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	54: unique[83200:1] = COPY unique[83180:1]
	55: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+70007]:1]
	56: [handle:space][[handle:offset+70007]:1] = INT_ADD unique[83100:1], unique[83280:1]

Line ia.sinc:6938 :PMAXUB        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDE; xmmmod = 3 & XmmReg1 & XmmReg2 
{ 
	assignUnsignedGreater(XmmReg1[0,8],XmmReg1[0,8],XmmReg2[0,8]);
	assignUnsignedGreater(XmmReg1[8,8],XmmReg1[8,8],XmmReg2[8,8]);
	assignUnsignedGreater(XmmReg1[16,8],XmmReg1[16,8],XmmReg2[16,8]);
	assignUnsignedGreater(XmmReg1[24,8],XmmReg1[24,8],XmmReg2[24,8]);
	assignUnsignedGreater(XmmReg1[32,8],XmmReg1[32,8],XmmReg2[32,8]);
	assignUnsignedGreater(XmmReg1[40,8],XmmReg1[40,8],XmmReg2[40,8]);
	assignUnsignedGreater(XmmReg1[48,8],XmmReg1[48,8],XmmReg2[48,8]);
	assignUnsignedGreater(XmmReg1[56,8],XmmReg1[56,8],XmmReg2[56,8]);
	assignUnsignedGreater(XmmReg1[64,8],XmmReg1[64,8],XmmReg2[64,8]);
	assignUnsignedGreater(XmmReg1[72,8],XmmReg1[72,8],XmmReg2[72,8]);
	assignUnsignedGreater(XmmReg1[80,8],XmmReg1[80,8],XmmReg2[80,8]);
	assignUnsignedGreater(XmmReg1[88,8],XmmReg1[88,8],XmmReg2[88,8]);
	assignUnsignedGreater(XmmReg1[96,8],XmmReg1[96,8],XmmReg2[96,8]);
	assignUnsignedGreater(XmmReg1[104,8],XmmReg1[104,8],XmmReg2[104,8]);
	assignUnsignedGreater(XmmReg1[112,8],XmmReg1[112,8],XmmReg2[112,8]);
	assignUnsignedGreater(XmmReg1[120,8],XmmReg1[120,8],XmmReg2[120,8]);
}
0: Constructor line ia.sinc:6938(id0.1155) printpiece=[PMAXUB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3422  1: XmmReg2 : 3423  
Pattern id=1155 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DE:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	3: unique[83080:1] = COPY unique[83000:1]
	4: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+0]:1]
	5: unique[83180:1] = INT_LESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	6: unique[83200:1] = COPY unique[83180:1]
	7: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+0]:1]
	8: [handle:space][[handle:offset+0]:1] = INT_ADD unique[83100:1], unique[83280:1]
	9: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	10: unique[83080:1] = COPY unique[83000:1]
	11: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+10001]:1]
	12: unique[83180:1] = INT_LESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	13: unique[83200:1] = COPY unique[83180:1]
	14: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+10001]:1]
	15: [handle:space][[handle:offset+10001]:1] = INT_ADD unique[83100:1], unique[83280:1]
	16: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	17: unique[83080:1] = COPY unique[83000:1]
	18: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+20002]:1]
	19: unique[83180:1] = INT_LESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	20: unique[83200:1] = COPY unique[83180:1]
	21: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+20002]:1]
	22: [handle:space][[handle:offset+20002]:1] = INT_ADD unique[83100:1], unique[83280:1]
	23: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	24: unique[83080:1] = COPY unique[83000:1]
	25: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+30003]:1]
	26: unique[83180:1] = INT_LESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	27: unique[83200:1] = COPY unique[83180:1]
	28: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+30003]:1]
	29: [handle:space][[handle:offset+30003]:1] = INT_ADD unique[83100:1], unique[83280:1]
	30: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	31: unique[83080:1] = COPY unique[83000:1]
	32: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+40004]:1]
	33: unique[83180:1] = INT_LESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	34: unique[83200:1] = COPY unique[83180:1]
	35: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+40004]:1]
	36: [handle:space][[handle:offset+40004]:1] = INT_ADD unique[83100:1], unique[83280:1]
	37: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	38: unique[83080:1] = COPY unique[83000:1]
	39: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+50005]:1]
	40: unique[83180:1] = INT_LESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	41: unique[83200:1] = COPY unique[83180:1]
	42: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+50005]:1]
	43: [handle:space][[handle:offset+50005]:1] = INT_ADD unique[83100:1], unique[83280:1]
	44: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	45: unique[83080:1] = COPY unique[83000:1]
	46: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+60006]:1]
	47: unique[83180:1] = INT_LESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	48: unique[83200:1] = COPY unique[83180:1]
	49: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+60006]:1]
	50: [handle:space][[handle:offset+60006]:1] = INT_ADD unique[83100:1], unique[83280:1]
	51: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	52: unique[83080:1] = COPY unique[83000:1]
	53: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+70007]:1]
	54: unique[83180:1] = INT_LESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	55: unique[83200:1] = COPY unique[83180:1]
	56: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+70007]:1]
	57: [handle:space][[handle:offset+70007]:1] = INT_ADD unique[83100:1], unique[83280:1]
	58: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	59: unique[83080:1] = COPY unique[83000:1]
	60: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+80008]:1]
	61: unique[83180:1] = INT_LESS [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	62: unique[83200:1] = COPY unique[83180:1]
	63: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+80008]:1]
	64: [handle:space][[handle:offset+80008]:1] = INT_ADD unique[83100:1], unique[83280:1]
	65: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	66: unique[83080:1] = COPY unique[83000:1]
	67: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+90009]:1]
	68: unique[83180:1] = INT_LESS [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	69: unique[83200:1] = COPY unique[83180:1]
	70: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+90009]:1]
	71: [handle:space][[handle:offset+90009]:1] = INT_ADD unique[83100:1], unique[83280:1]
	72: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	73: unique[83080:1] = COPY unique[83000:1]
	74: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+a000a]:1]
	75: unique[83180:1] = INT_LESS [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	76: unique[83200:1] = COPY unique[83180:1]
	77: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+a000a]:1]
	78: [handle:space][[handle:offset+a000a]:1] = INT_ADD unique[83100:1], unique[83280:1]
	79: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	80: unique[83080:1] = COPY unique[83000:1]
	81: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+b000b]:1]
	82: unique[83180:1] = INT_LESS [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	83: unique[83200:1] = COPY unique[83180:1]
	84: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+b000b]:1]
	85: [handle:space][[handle:offset+b000b]:1] = INT_ADD unique[83100:1], unique[83280:1]
	86: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	87: unique[83080:1] = COPY unique[83000:1]
	88: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+c000c]:1]
	89: unique[83180:1] = INT_LESS [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	90: unique[83200:1] = COPY unique[83180:1]
	91: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+c000c]:1]
	92: [handle:space][[handle:offset+c000c]:1] = INT_ADD unique[83100:1], unique[83280:1]
	93: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	94: unique[83080:1] = COPY unique[83000:1]
	95: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+d000d]:1]
	96: unique[83180:1] = INT_LESS [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	97: unique[83200:1] = COPY unique[83180:1]
	98: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+d000d]:1]
	99: [handle:space][[handle:offset+d000d]:1] = INT_ADD unique[83100:1], unique[83280:1]
	100: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	101: unique[83080:1] = COPY unique[83000:1]
	102: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+e000e]:1]
	103: unique[83180:1] = INT_LESS [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	104: unique[83200:1] = COPY unique[83180:1]
	105: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+e000e]:1]
	106: [handle:space][[handle:offset+e000e]:1] = INT_ADD unique[83100:1], unique[83280:1]
	107: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	108: unique[83080:1] = COPY unique[83000:1]
	109: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+f000f]:1]
	110: unique[83180:1] = INT_LESS [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	111: unique[83200:1] = COPY unique[83180:1]
	112: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+f000f]:1]
	113: [handle:space][[handle:offset+f000f]:1] = INT_ADD unique[83100:1], unique[83280:1]

Line ia.sinc:6918 :PMAXUB        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDE; XmmReg ... & m128 
{ 
	assignUnsignedGreater(XmmReg[0,8],XmmReg[0,8],m128[0,8]);
	assignUnsignedGreater(XmmReg[8,8],XmmReg[8,8],m128[8,8]);
	assignUnsignedGreater(XmmReg[16,8],XmmReg[16,8],m128[16,8]);
	assignUnsignedGreater(XmmReg[24,8],XmmReg[24,8],m128[24,8]);
	assignUnsignedGreater(XmmReg[32,8],XmmReg[32,8],m128[32,8]);
	assignUnsignedGreater(XmmReg[40,8],XmmReg[40,8],m128[40,8]);
	assignUnsignedGreater(XmmReg[48,8],XmmReg[48,8],m128[48,8]);
	assignUnsignedGreater(XmmReg[56,8],XmmReg[56,8],m128[56,8]);
	assignUnsignedGreater(XmmReg[64,8],XmmReg[64,8],m128[64,8]);
	assignUnsignedGreater(XmmReg[72,8],XmmReg[72,8],m128[72,8]);
	assignUnsignedGreater(XmmReg[80,8],XmmReg[80,8],m128[80,8]);
	assignUnsignedGreater(XmmReg[88,8],XmmReg[88,8],m128[88,8]);
	assignUnsignedGreater(XmmReg[96,8],XmmReg[96,8],m128[96,8]);
	assignUnsignedGreater(XmmReg[104,8],XmmReg[104,8],m128[104,8]);
	assignUnsignedGreater(XmmReg[112,8],XmmReg[112,8],m128[112,8]);
	assignUnsignedGreater(XmmReg[120,8],XmmReg[120,8],m128[120,8]);
}
1: Constructor line ia.sinc:6918(id0.1154) printpiece=[PMAXUB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3420  1: m128 : 3421  
Pattern id=1154 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DE:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	3: unique[83080:1] = COPY unique[83000:1]
	4: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+0]:1]
	5: unique[83180:1] = INT_LESS [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	6: unique[83200:1] = COPY unique[83180:1]
	7: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+0]:1]
	8: [handle:space][[handle:offset+0]:1] = INT_ADD unique[83100:1], unique[83280:1]
	9: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	10: unique[83080:1] = COPY unique[83000:1]
	11: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+10001]:1]
	12: unique[83180:1] = INT_LESS [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	13: unique[83200:1] = COPY unique[83180:1]
	14: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+10001]:1]
	15: [handle:space][[handle:offset+10001]:1] = INT_ADD unique[83100:1], unique[83280:1]
	16: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	17: unique[83080:1] = COPY unique[83000:1]
	18: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+20002]:1]
	19: unique[83180:1] = INT_LESS [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	20: unique[83200:1] = COPY unique[83180:1]
	21: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+20002]:1]
	22: [handle:space][[handle:offset+20002]:1] = INT_ADD unique[83100:1], unique[83280:1]
	23: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	24: unique[83080:1] = COPY unique[83000:1]
	25: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+30003]:1]
	26: unique[83180:1] = INT_LESS [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	27: unique[83200:1] = COPY unique[83180:1]
	28: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+30003]:1]
	29: [handle:space][[handle:offset+30003]:1] = INT_ADD unique[83100:1], unique[83280:1]
	30: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	31: unique[83080:1] = COPY unique[83000:1]
	32: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+40004]:1]
	33: unique[83180:1] = INT_LESS [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	34: unique[83200:1] = COPY unique[83180:1]
	35: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+40004]:1]
	36: [handle:space][[handle:offset+40004]:1] = INT_ADD unique[83100:1], unique[83280:1]
	37: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	38: unique[83080:1] = COPY unique[83000:1]
	39: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+50005]:1]
	40: unique[83180:1] = INT_LESS [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	41: unique[83200:1] = COPY unique[83180:1]
	42: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+50005]:1]
	43: [handle:space][[handle:offset+50005]:1] = INT_ADD unique[83100:1], unique[83280:1]
	44: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	45: unique[83080:1] = COPY unique[83000:1]
	46: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+60006]:1]
	47: unique[83180:1] = INT_LESS [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	48: unique[83200:1] = COPY unique[83180:1]
	49: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+60006]:1]
	50: [handle:space][[handle:offset+60006]:1] = INT_ADD unique[83100:1], unique[83280:1]
	51: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	52: unique[83080:1] = COPY unique[83000:1]
	53: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+70007]:1]
	54: unique[83180:1] = INT_LESS [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	55: unique[83200:1] = COPY unique[83180:1]
	56: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+70007]:1]
	57: [handle:space][[handle:offset+70007]:1] = INT_ADD unique[83100:1], unique[83280:1]
	58: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	59: unique[83080:1] = COPY unique[83000:1]
	60: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+80008]:1]
	61: unique[83180:1] = INT_LESS [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	62: unique[83200:1] = COPY unique[83180:1]
	63: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+80008]:1]
	64: [handle:space][[handle:offset+80008]:1] = INT_ADD unique[83100:1], unique[83280:1]
	65: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	66: unique[83080:1] = COPY unique[83000:1]
	67: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+90009]:1]
	68: unique[83180:1] = INT_LESS [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	69: unique[83200:1] = COPY unique[83180:1]
	70: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+90009]:1]
	71: [handle:space][[handle:offset+90009]:1] = INT_ADD unique[83100:1], unique[83280:1]
	72: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	73: unique[83080:1] = COPY unique[83000:1]
	74: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+a000a]:1]
	75: unique[83180:1] = INT_LESS [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	76: unique[83200:1] = COPY unique[83180:1]
	77: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+a000a]:1]
	78: [handle:space][[handle:offset+a000a]:1] = INT_ADD unique[83100:1], unique[83280:1]
	79: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	80: unique[83080:1] = COPY unique[83000:1]
	81: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+b000b]:1]
	82: unique[83180:1] = INT_LESS [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	83: unique[83200:1] = COPY unique[83180:1]
	84: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+b000b]:1]
	85: [handle:space][[handle:offset+b000b]:1] = INT_ADD unique[83100:1], unique[83280:1]
	86: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	87: unique[83080:1] = COPY unique[83000:1]
	88: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+c000c]:1]
	89: unique[83180:1] = INT_LESS [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	90: unique[83200:1] = COPY unique[83180:1]
	91: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+c000c]:1]
	92: [handle:space][[handle:offset+c000c]:1] = INT_ADD unique[83100:1], unique[83280:1]
	93: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	94: unique[83080:1] = COPY unique[83000:1]
	95: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+d000d]:1]
	96: unique[83180:1] = INT_LESS [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	97: unique[83200:1] = COPY unique[83180:1]
	98: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+d000d]:1]
	99: [handle:space][[handle:offset+d000d]:1] = INT_ADD unique[83100:1], unique[83280:1]
	100: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	101: unique[83080:1] = COPY unique[83000:1]
	102: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+e000e]:1]
	103: unique[83180:1] = INT_LESS [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	104: unique[83200:1] = COPY unique[83180:1]
	105: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+e000e]:1]
	106: [handle:space][[handle:offset+e000e]:1] = INT_ADD unique[83100:1], unique[83280:1]
	107: unique[83000:1] = INT_LESSEQUAL [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	108: unique[83080:1] = COPY unique[83000:1]
	109: unique[83100:1] = INT_MULT unique[83080:1], [handle:space][[handle:offset+f000f]:1]
	110: unique[83180:1] = INT_LESS [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]
	111: unique[83200:1] = COPY unique[83180:1]
	112: unique[83280:1] = INT_MULT unique[83200:1], [handle:space][[handle:offset+f000f]:1]
	113: [handle:space][[handle:offset+f000f]:1] = INT_ADD unique[83100:1], unique[83280:1]

Line ia.sinc:6411 :PANDN          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDF; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1 = ~mmxreg1 & mmxreg2; }
0: Constructor line ia.sinc:6411(id0.1073) printpiece=[PANDN,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3237  1: mmxreg2 : 3238  
Pattern id=1073 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DF:[11xx]X:XX)
Template
	0: unique[6d980:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_AND unique[6d980:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6410 :PANDN          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xDF; mmxreg ... & m64				{ mmxreg = ~mmxreg & m64; }
1: Constructor line ia.sinc:6410(id0.1072) printpiece=[PANDN,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3235  1: m64 : 3236  
Pattern id=1072 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:DF:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[6d880:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_AND unique[6d880:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6413 :PANDN          XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDF; xmmmod = 3 & XmmReg1 & XmmReg2	{ XmmReg1 = ~XmmReg1 & XmmReg2; }
0: Constructor line ia.sinc:6413(id0.1075) printpiece=[PANDN,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3241  1: XmmReg2 : 3242  
Pattern id=1075 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DF:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[6db80:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_AND unique[6db80:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6412 :PANDN          XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xDF; XmmReg ... & m128			    { XmmReg = ~XmmReg & m128; }
1: Constructor line ia.sinc:6412(id0.1074) printpiece=[PANDN,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3239  1: m128 : 3240  
Pattern id=1074 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:DF:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[6da80:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_AND unique[6da80:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:6429 :PAVGB          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE0; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = pavgb(mmxreg1[0,8], mmxreg2[0,8]);
    mmxreg1[8,8] = pavgb(mmxreg1[8,8], mmxreg2[8,8]);
    mmxreg1[16,8] = pavgb(mmxreg1[16,8], mmxreg2[16,8]);
    mmxreg1[24,8] = pavgb(mmxreg1[24,8], mmxreg2[24,8]);
    mmxreg1[32,8] = pavgb(mmxreg1[32,8], mmxreg2[32,8]);
    mmxreg1[40,8] = pavgb(mmxreg1[40,8], mmxreg2[40,8]);
    mmxreg1[48,8] = pavgb(mmxreg1[48,8], mmxreg2[48,8]);
    mmxreg1[56,8] = pavgb(mmxreg1[56,8], mmxreg2[56,8]);
}
0: Constructor line ia.sinc:6429(id0.1077) printpiece=[PAVGB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3246  1: mmxreg2 : 3247  
Pattern id=1077 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E0:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	1: [handle:space][[handle:offset+10001]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	2: [handle:space][[handle:offset+20002]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	3: [handle:space][[handle:offset+30003]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	4: [handle:space][[handle:offset+40004]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	5: [handle:space][[handle:offset+50005]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	6: [handle:space][[handle:offset+60006]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	7: [handle:space][[handle:offset+70007]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]

Line ia.sinc:6416 :PAVGB          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE0; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = pavgb(mmxreg[0,8], m[0,8]);
    mmxreg[8,8] = pavgb(mmxreg[8,8], m[8,8]);
    mmxreg[16,8] = pavgb(mmxreg[16,8], m[16,8]);
    mmxreg[24,8] = pavgb(mmxreg[24,8], m[24,8]);
    mmxreg[32,8] = pavgb(mmxreg[32,8], m[32,8]);
    mmxreg[40,8] = pavgb(mmxreg[40,8], m[40,8]);
    mmxreg[48,8] = pavgb(mmxreg[48,8], m[48,8]);
    mmxreg[56,8] = pavgb(mmxreg[56,8], m[56,8]);
}
1: Constructor line ia.sinc:6416(id0.1076) printpiece=[PAVGB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3244  1: m64 : 3245  
Pattern id=1076 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E0:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[6dc80:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[6dd00:1] = SUBPIECE unique[6dc80:8], const[0:4]
	3: [handle:space][[handle:offset+0]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+0]:1], unique[6dd00:1]
	4: unique[6de00:1] = SUBPIECE unique[6dc80:8], const[1:4]
	5: [handle:space][[handle:offset+10001]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+10001]:1], unique[6de00:1]
	6: unique[6df00:1] = SUBPIECE unique[6dc80:8], const[2:4]
	7: [handle:space][[handle:offset+20002]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+20002]:1], unique[6df00:1]
	8: unique[6e000:1] = SUBPIECE unique[6dc80:8], const[3:4]
	9: [handle:space][[handle:offset+30003]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+30003]:1], unique[6e000:1]
	10: unique[6e100:1] = SUBPIECE unique[6dc80:8], const[4:4]
	11: [handle:space][[handle:offset+40004]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+40004]:1], unique[6e100:1]
	12: unique[6e200:1] = SUBPIECE unique[6dc80:8], const[5:4]
	13: [handle:space][[handle:offset+50005]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+50005]:1], unique[6e200:1]
	14: unique[6e300:1] = SUBPIECE unique[6dc80:8], const[6:4]
	15: [handle:space][[handle:offset+60006]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+60006]:1], unique[6e300:1]
	16: unique[6e400:1] = SUBPIECE unique[6dc80:8], const[7:4]
	17: [handle:space][[handle:offset+70007]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+70007]:1], unique[6e400:1]

Line ia.sinc:6481 :PAVGB  XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE0; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = pavgb(XmmReg1[0,8], XmmReg2[0,8]);
    XmmReg1[8,8] = pavgb(XmmReg1[8,8], XmmReg2[8,8]);
    XmmReg1[16,8] = pavgb(XmmReg1[16,8], XmmReg2[16,8]);
    XmmReg1[24,8] = pavgb(XmmReg1[24,8], XmmReg2[24,8]);
    XmmReg1[32,8] = pavgb(XmmReg1[32,8], XmmReg2[32,8]);
    XmmReg1[40,8] = pavgb(XmmReg1[40,8], XmmReg2[40,8]);
    XmmReg1[48,8] = pavgb(XmmReg1[48,8], XmmReg2[48,8]);
    XmmReg1[56,8] = pavgb(XmmReg1[56,8], XmmReg2[56,8]);
    XmmReg1[64,8] = pavgb(XmmReg1[64,8], XmmReg2[64,8]);
    XmmReg1[72,8] = pavgb(XmmReg1[72,8], XmmReg2[72,8]);
    XmmReg1[80,8] = pavgb(XmmReg1[80,8], XmmReg2[80,8]);
    XmmReg1[88,8] = pavgb(XmmReg1[88,8], XmmReg2[88,8]);
    XmmReg1[96,8] = pavgb(XmmReg1[96,8], XmmReg2[96,8]);
    XmmReg1[104,8] = pavgb(XmmReg1[104,8], XmmReg2[104,8]);
    XmmReg1[112,8] = pavgb(XmmReg1[112,8], XmmReg2[112,8]);
    XmmReg1[120,8] = pavgb(XmmReg1[120,8], XmmReg2[120,8]);
}
0: Constructor line ia.sinc:6481(id0.1081) printpiece=[PAVGB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3255  1: XmmReg2 : 3256  
Pattern id=1081 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E0:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	3: [handle:space][[handle:offset+10001]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	4: [handle:space][[handle:offset+20002]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	5: [handle:space][[handle:offset+30003]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	6: [handle:space][[handle:offset+40004]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	7: [handle:space][[handle:offset+50005]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	8: [handle:space][[handle:offset+60006]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	9: [handle:space][[handle:offset+70007]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	10: [handle:space][[handle:offset+80008]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	11: [handle:space][[handle:offset+90009]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	12: [handle:space][[handle:offset+a000a]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	13: [handle:space][[handle:offset+b000b]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	14: [handle:space][[handle:offset+c000c]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	15: [handle:space][[handle:offset+d000d]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	16: [handle:space][[handle:offset+e000e]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	17: [handle:space][[handle:offset+f000f]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]

Line ia.sinc:6459 :PAVGB          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE0; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = pavgb(XmmReg[0,8], m[0,8]);
    XmmReg[8,8] = pavgb(XmmReg[8,8], m[8,8]);
    XmmReg[16,8] = pavgb(XmmReg[16,8], m[16,8]);
    XmmReg[24,8] = pavgb(XmmReg[24,8], m[24,8]);
    XmmReg[32,8] = pavgb(XmmReg[32,8], m[32,8]);
    XmmReg[40,8] = pavgb(XmmReg[40,8], m[40,8]);
    XmmReg[48,8] = pavgb(XmmReg[48,8], m[48,8]);
    XmmReg[56,8] = pavgb(XmmReg[56,8], m[56,8]);
    XmmReg[64,8] = pavgb(XmmReg[64,8], m[64,8]);
    XmmReg[72,8] = pavgb(XmmReg[72,8], m[72,8]);
    XmmReg[80,8] = pavgb(XmmReg[80,8], m[80,8]);
    XmmReg[88,8] = pavgb(XmmReg[88,8], m[88,8]);
    XmmReg[96,8] = pavgb(XmmReg[96,8], m[96,8]);
    XmmReg[104,8] = pavgb(XmmReg[104,8], m[104,8]);
    XmmReg[112,8] = pavgb(XmmReg[112,8], m[112,8]);
    XmmReg[120,8] = pavgb(XmmReg[120,8], m[120,8]);
}
1: Constructor line ia.sinc:6459(id0.1080) printpiece=[PAVGB,  ,  B, ,,  ,  A]
Operands 0: m128 : 3254  1: XmmReg : 3253  
Pattern id=1080 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E0:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[6ef80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[6f000:1] = SUBPIECE unique[6ef80:10], const[0:4]
	4: [handle:space][[handle:offset+0]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+0]:1], unique[6f000:1]
	5: unique[6f100:1] = SUBPIECE unique[6ef80:10], const[1:4]
	6: [handle:space][[handle:offset+10001]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+10001]:1], unique[6f100:1]
	7: unique[6f200:1] = SUBPIECE unique[6ef80:10], const[2:4]
	8: [handle:space][[handle:offset+20002]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+20002]:1], unique[6f200:1]
	9: unique[6f300:1] = SUBPIECE unique[6ef80:10], const[3:4]
	10: [handle:space][[handle:offset+30003]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+30003]:1], unique[6f300:1]
	11: unique[6f400:1] = SUBPIECE unique[6ef80:10], const[4:4]
	12: [handle:space][[handle:offset+40004]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+40004]:1], unique[6f400:1]
	13: unique[6f500:1] = SUBPIECE unique[6ef80:10], const[5:4]
	14: [handle:space][[handle:offset+50005]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+50005]:1], unique[6f500:1]
	15: unique[6f600:1] = SUBPIECE unique[6ef80:10], const[6:4]
	16: [handle:space][[handle:offset+60006]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+60006]:1], unique[6f600:1]
	17: unique[6f700:1] = SUBPIECE unique[6ef80:10], const[7:4]
	18: [handle:space][[handle:offset+70007]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+70007]:1], unique[6f700:1]
	19: unique[6f800:1] = SUBPIECE unique[6ef80:10], const[8:4]
	20: [handle:space][[handle:offset+80008]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+80008]:1], unique[6f800:1]
	21: unique[6f900:1] = SUBPIECE unique[6ef80:10], const[9:4]
	22: [handle:space][[handle:offset+90009]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+90009]:1], unique[6f900:1]
	23: unique[6fa00:1] = SUBPIECE unique[6ef80:10], const[a:4]
	24: [handle:space][[handle:offset+a000a]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+a000a]:1], unique[6fa00:1]
	25: unique[6fb00:1] = SUBPIECE unique[6ef80:10], const[b:4]
	26: [handle:space][[handle:offset+b000b]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+b000b]:1], unique[6fb00:1]
	27: unique[6fc00:1] = SUBPIECE unique[6ef80:10], const[c:4]
	28: [handle:space][[handle:offset+c000c]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+c000c]:1], unique[6fc00:1]
	29: unique[6fd00:1] = SUBPIECE unique[6ef80:10], const[d:4]
	30: [handle:space][[handle:offset+d000d]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+d000d]:1], unique[6fd00:1]
	31: unique[6fe00:1] = SUBPIECE unique[6ef80:10], const[e:4]
	32: [handle:space][[handle:offset+e000e]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+e000e]:1], unique[6fe00:1]
	33: unique[6ff00:1] = SUBPIECE unique[6ef80:10], const[f:4]
	34: [handle:space][[handle:offset+f000f]:1] = CALLOTHER const[7e:4], [handle:space][[handle:offset+f000f]:1], unique[6ff00:1]

Line ia.sinc:7335 :PSRAW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE1; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = psraw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:7335(id0.1238) printpiece=[PSRAW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3632  1: mmxreg2 : 3633  
Pattern id=1238 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E1:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[97:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7334 :PSRAW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE1; mmxreg ... & m64 ... { mmxreg = psraw(mmxreg, m64); }
1: Constructor line ia.sinc:7334(id0.1237) printpiece=[PSRAW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3630  1: m64 : 3631  
Pattern id=1237 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E1:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[97:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7360 :PSRAW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE1; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = psraw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:7360(id0.1244) printpiece=[PSRAW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3644  1: XmmReg2 : 3645  
Pattern id=1244 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E1:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[97:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7359 :PSRAW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE1; XmmReg ... & m128 ... { XmmReg = psraw(XmmReg, m128); }
1: Constructor line ia.sinc:7359(id0.1243) printpiece=[PSRAW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3642  1: m128 : 3643  
Pattern id=1243 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E1:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[97:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7345 :PSRAD          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE2; mmxmod = 3 & mmxreg1 & mmxreg2
{
# a count greater than 31 just clears all the bits
    mmxreg1[0,32] = mmxreg1[0,32] s>> mmxreg2;
    mmxreg1[32,32] = mmxreg1[32,32] s>> mmxreg2;
}
0: Constructor line ia.sinc:7345(id0.1241) printpiece=[PSRAD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3638  1: mmxreg2 : 3639  
Pattern id=1241 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E2:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:4] = INT_SRIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	1: [handle:space][[handle:offset+40004]:4] = INT_SRIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7338 :PSRAD          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE2; mmxreg ... & m64
{
# a count greater than 31 just clears all the bits
    mmxreg[0,32] = mmxreg[0,32] s>> m64;
    mmxreg[32,32] = mmxreg[32,32] s>> m64;
}
1: Constructor line ia.sinc:7338(id0.1240) printpiece=[PSRAD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3636  1: m64 : 3637  
Pattern id=1240 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E2:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset+0]:4] = INT_SRIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset+40004]:4] = INT_SRIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7372 :PSRAD          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE2; xmmmod = 3 & XmmReg1 & XmmReg2
{
# a count greater than 31 just clears all the bits
    XmmReg1[0,32] = XmmReg1[0,32] s>> XmmReg2;
    XmmReg1[32,32] = XmmReg1[32,32] s>> XmmReg2;
    XmmReg1[64,32] = XmmReg1[64,32] s>> XmmReg2;
    XmmReg1[96,32] = XmmReg1[96,32] s>> XmmReg2;
}
0: Constructor line ia.sinc:7372(id0.1247) printpiece=[PSRAD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3650  1: XmmReg2 : 3651  
Pattern id=1247 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = INT_SRIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+40004]:4] = INT_SRIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset+80008]:4] = INT_SRIGHT [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset]:[handle:size]]
	5: [handle:space][[handle:offset+c000c]:4] = INT_SRIGHT [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7363 :PSRAD          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE2; m128 & XmmReg ...
{
# a count greater than 31 just clears all the bits
    XmmReg[0,32] = XmmReg[0,32] s>> m128;
    XmmReg[32,32] = XmmReg[32,32] s>> m128;
    XmmReg[64,32] = XmmReg[64,32] s>> m128;
    XmmReg[96,32] = XmmReg[96,32] s>> m128;
}
1: Constructor line ia.sinc:7363(id0.1246) printpiece=[PSRAD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3649  1: XmmReg : 3648  
Pattern id=1246 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E2:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset+0]:4] = INT_SRIGHT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset+40004]:4] = INT_SRIGHT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset+80008]:4] = INT_SRIGHT [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset]:[handle:size]]
	5: [handle:space][[handle:offset+c000c]:4] = INT_SRIGHT [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6451 :PAVGW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE3; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = pavgw(mmxreg1[0,16], mmxreg2[0,16]);
    mmxreg1[16,16] = pavgw(mmxreg1[16,16], mmxreg2[16,16]);
    mmxreg1[32,16] = pavgw(mmxreg1[32,16], mmxreg2[32,16]);
    mmxreg1[48,16] = pavgw(mmxreg1[48,16], mmxreg2[48,16]);
}
0: Constructor line ia.sinc:6451(id0.1079) printpiece=[PAVGW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3251  1: mmxreg2 : 3252  
Pattern id=1079 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E3:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	1: [handle:space][[handle:offset+20002]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	2: [handle:space][[handle:offset+40004]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	3: [handle:space][[handle:offset+60006]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]

Line ia.sinc:6442 :PAVGW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE3; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = pavgw(mmxreg[0,16], m[0,16]);
    mmxreg[16,16] = pavgw(mmxreg[16,16], m[16,16]);
    mmxreg[32,16] = pavgw(mmxreg[32,16], m[32,16]);
    mmxreg[48,16] = pavgw(mmxreg[48,16], m[48,16]);
}
1: Constructor line ia.sinc:6442(id0.1078) printpiece=[PAVGW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3249  1: m64 : 3250  
Pattern id=1078 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[6e900:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[6e980:2] = SUBPIECE unique[6e900:8], const[0:4]
	3: [handle:space][[handle:offset+0]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+0]:2], unique[6e980:2]
	4: unique[6ea80:2] = SUBPIECE unique[6e900:8], const[2:4]
	5: [handle:space][[handle:offset+20002]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+20002]:2], unique[6ea80:2]
	6: unique[6eb80:2] = SUBPIECE unique[6e900:8], const[4:4]
	7: [handle:space][[handle:offset+40004]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+40004]:2], unique[6eb80:2]
	8: unique[6ec80:2] = SUBPIECE unique[6e900:8], const[6:4]
	9: [handle:space][[handle:offset+60006]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+60006]:2], unique[6ec80:2]

Line ia.sinc:6514 :PAVGW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE3; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = pavgw(XmmReg1[0,16], XmmReg2[0,16]);
    XmmReg1[16,16] = pavgw(XmmReg1[16,16], XmmReg2[16,16]);
    XmmReg1[32,16] = pavgw(XmmReg1[32,16], XmmReg2[32,16]);
    XmmReg1[48,16] = pavgw(XmmReg1[48,16], XmmReg2[48,16]);
    XmmReg1[64,16] = pavgw(XmmReg1[64,16], XmmReg2[64,16]);
    XmmReg1[80,16] = pavgw(XmmReg1[80,16], XmmReg2[80,16]);
    XmmReg1[96,16] = pavgw(XmmReg1[96,16], XmmReg2[96,16]);
    XmmReg1[112,16] = pavgw(XmmReg1[112,16], XmmReg2[112,16]);
}
0: Constructor line ia.sinc:6514(id0.1083) printpiece=[PAVGW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3259  1: XmmReg2 : 3260  
Pattern id=1083 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E3:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: [handle:space][[handle:offset+20002]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	4: [handle:space][[handle:offset+40004]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	5: [handle:space][[handle:offset+60006]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	6: [handle:space][[handle:offset+80008]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	7: [handle:space][[handle:offset+a000a]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	8: [handle:space][[handle:offset+c000c]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	9: [handle:space][[handle:offset+e000e]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]

Line ia.sinc:6501 :PAVGW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE3; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = pavgw(XmmReg[0,16], m[0,16]);
    XmmReg[16,16] = pavgw(XmmReg[16,16], m[16,16]);
    XmmReg[32,16] = pavgw(XmmReg[32,16], m[32,16]);
    XmmReg[48,16] = pavgw(XmmReg[48,16], m[48,16]);
    XmmReg[64,16] = pavgw(XmmReg[64,16], m[64,16]);
    XmmReg[80,16] = pavgw(XmmReg[80,16], m[80,16]);
    XmmReg[96,16] = pavgw(XmmReg[96,16], m[96,16]);
    XmmReg[112,16] = pavgw(XmmReg[112,16], m[112,16]);
}
1: Constructor line ia.sinc:6501(id0.1082) printpiece=[PAVGW,  ,  B, ,,  ,  A]
Operands 0: m128 : 3258  1: XmmReg : 3257  
Pattern id=1082 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E3:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[70800:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[70880:2] = SUBPIECE unique[70800:10], const[0:4]
	4: [handle:space][[handle:offset+0]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+0]:2], unique[70880:2]
	5: unique[70980:2] = SUBPIECE unique[70800:10], const[2:4]
	6: [handle:space][[handle:offset+20002]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+20002]:2], unique[70980:2]
	7: unique[70a80:2] = SUBPIECE unique[70800:10], const[4:4]
	8: [handle:space][[handle:offset+40004]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+40004]:2], unique[70a80:2]
	9: unique[70b80:2] = SUBPIECE unique[70800:10], const[6:4]
	10: [handle:space][[handle:offset+60006]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+60006]:2], unique[70b80:2]
	11: unique[70c80:2] = SUBPIECE unique[70800:10], const[8:4]
	12: [handle:space][[handle:offset+80008]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+80008]:2], unique[70c80:2]
	13: unique[70d80:2] = SUBPIECE unique[70800:10], const[a:4]
	14: [handle:space][[handle:offset+a000a]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+a000a]:2], unique[70d80:2]
	15: unique[70e80:2] = SUBPIECE unique[70800:10], const[c:4]
	16: [handle:space][[handle:offset+c000c]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+c000c]:2], unique[70e80:2]
	17: unique[70f80:2] = SUBPIECE unique[70800:10], const[e:4]
	18: [handle:space][[handle:offset+e000e]:2] = CALLOTHER const[7f:4], [handle:space][[handle:offset+e000e]:2], unique[70f80:2]

Line ia.sinc:7082 :PMULHUW        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE4; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = pmulhuw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:7082(id0.1171) printpiece=[PMULHUW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3459  1: mmxreg2 : 3460  
Pattern id=1171 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E4:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7081 :PMULHUW        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE4; mmxreg ... & m64 { mmxreg = pmulhuw(mmxreg, m64); }
1: Constructor line ia.sinc:7081(id0.1170) printpiece=[PMULHUW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3457  1: m64 : 3458  
Pattern id=1170 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E4:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7084 :PMULHUW        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE4; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = pmulhuw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:7084(id0.1173) printpiece=[PMULHUW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3463  1: XmmReg2 : 3464  
Pattern id=1173 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E4:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7083 :PMULHUW        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE4; XmmReg ... & m128 { XmmReg = pmulhuw(XmmReg, m128); }
1: Constructor line ia.sinc:7083(id0.1172) printpiece=[PMULHUW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3461  1: m128 : 3462  
Pattern id=1172 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E4:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7088 :PMULHW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE5; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = pmulhw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:7088(id0.1175) printpiece=[PMULHW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3468  1: mmxreg2 : 3469  
Pattern id=1175 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E5:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7087 :PMULHW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE5; mmxreg ... & m64 { mmxreg = pmulhw(mmxreg, m64); }
1: Constructor line ia.sinc:7087(id0.1174) printpiece=[PMULHW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3466  1: m64 : 3467  
Pattern id=1174 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E5:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7090 :PMULHW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE5; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = pmulhw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:7090(id0.1177) printpiece=[PMULHW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3472  1: XmmReg2 : 3473  
Pattern id=1177 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E5:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7089 :PMULHW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE5; XmmReg ... & m128 { XmmReg = pmulhw(XmmReg, m128); }
1: Constructor line ia.sinc:7089(id0.1176) printpiece=[PMULHW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3470  1: m128 : 3471  
Pattern id=1176 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E5:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5146 :CVTDQ2PD     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0xE6; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,64] = int2float( XmmReg2[0,32] );
    XmmReg1[64,64] = int2float( XmmReg2[32,32] );
}
0: Constructor line ia.sinc:5146(id0.852) printpiece=[CVTDQ2PD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2771  1: XmmReg2 : 2772  
Pattern id=852 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:E6:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = INT2FLOAT [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+80008]:8] = INT2FLOAT [handle:space][[handle:offset+40004]:4]

Line ia.sinc:5139 :CVTDQ2PD     XmmReg, m64       is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0xE6; m64 & XmmReg ...
{
    local m:8 = m64;
    XmmReg[0,64] = int2float( m[0,32] );
    XmmReg[64,64] = int2float( m[32,32] );
}
1: Constructor line ia.sinc:5139(id0.851) printpiece=[CVTDQ2PD,  ,  B, ,,  ,  A]
Operands 0: m64 : 2770  1: XmmReg : 2769  
Pattern id=851 pattern=cmb:(ctx:SS:X[x1xx]:X[0xxx]:XX:XX,ins:0F:E6:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5af00:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5af80:4] = SUBPIECE unique[5af00:8], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = INT2FLOAT unique[5af80:4]
	5: unique[5b080:4] = SUBPIECE unique[5af00:8], const[4:4]
	6: [handle:space][[handle:offset+80008]:8] = INT2FLOAT unique[5b080:4]

Line ia.sinc:5178 :CVTPD2DQ     XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0xE6; xmmmod=3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = trunc( XmmReg2[0,64] );
    XmmReg1[32,32] = trunc( XmmReg2[64,64] );
    XmmReg1[64,32] = 0;
    XmmReg1[96,32] = 0;
}
2: Constructor line ia.sinc:5178(id0.856) printpiece=[CVTPD2DQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2779  1: XmmReg2 : 2780  
Pattern id=856 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:E6:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+80008]:8]
	4: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5169 :CVTPD2DQ     XmmReg, m128      is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0xE6; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = trunc( m[0,64] );
    XmmReg[32,32] = trunc( m[64,64] );
    XmmReg[64,32] = 0;
    XmmReg[96,32] = 0;
}
3: Constructor line ia.sinc:5169(id0.855) printpiece=[CVTPD2DQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 2778  1: XmmReg : 2777  
Pattern id=855 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:E6:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5b900:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5b980:8] = SUBPIECE unique[5b900:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = TRUNC unique[5b980:8]
	5: unique[5ba80:8] = SUBPIECE unique[5b900:10], const[8:4]
	6: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5ba80:8]
	7: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	8: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5399 :CVTTPD2DQ    XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE6; xmmmod=3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,32] = trunc(XmmReg2[0,64]);
  XmmReg1[32,32] = trunc(XmmReg2[64,64]);
  XmmReg1[64,32] = 0;
  XmmReg1[96,32] = 0;
}
4: Constructor line ia.sinc:5399(id0.884) printpiece=[CVTTPD2DQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2835  1: XmmReg2 : 2836  
Pattern id=884 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E6:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = TRUNC [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+40004]:4] = TRUNC [handle:space][[handle:offset+80008]:8]
	4: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	5: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5390 :CVTTPD2DQ    XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE6; m128 & XmmReg ...
{
  local m:16 = m128;
  XmmReg[0,32] = trunc(m[0,64]);
  XmmReg[32,32] = trunc(m[64,64]);
  XmmReg[64,32] = 0;
  XmmReg[96,32] = 0;
}
5: Constructor line ia.sinc:5390(id0.883) printpiece=[CVTTPD2DQ,  ,  B, ,,  ,  A]
Operands 0: m128 : 2834  1: XmmReg : 2833  
Pattern id=883 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E6:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[5e180:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[5e200:8] = SUBPIECE unique[5e180:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = TRUNC unique[5e200:8]
	5: unique[5e300:8] = SUBPIECE unique[5e180:10], const[8:4]
	6: [handle:space][[handle:offset+40004]:4] = TRUNC unique[5e300:8]
	7: [handle:space][[handle:offset+80008]:4] = COPY const[0:4]
	8: [handle:space][[handle:offset+c000c]:4] = COPY const[0:4]

Line ia.sinc:5803 :MOVNTQ       m64, mmxreg      is vexMode=0 & mandover=0 & byte=0x0F; byte=0xE7; mmxreg ... & m64   { m64 = mmxreg; }
0: Constructor line ia.sinc:5803(id0.967) printpiece=[MOVNTQ,  ,  B, ,,  ,  A]
Operands 0: mmxreg : 3013  1: m64 : 3012  
Pattern id=967 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5805 :MOVNTDQ      m128, XmmReg     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE7; XmmReg ... & m128  { m128 = XmmReg; }
0: Constructor line ia.sinc:5805(id0.968) printpiece=[MOVNTDQ,  ,  B, ,,  ,  A]
Operands 0: XmmReg : 3015  1: m128 : 3014  
Pattern id=968 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E7:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7694 :PSUBSB          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE8; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = psubsb(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:7694(id0.1285) printpiece=[PSUBSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3727  1: mmxreg2 : 3728  
Pattern id=1285 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E8:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[98:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7693 :PSUBSB          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE8; mmxreg ... & m64 ... { mmxreg = psubsb(mmxreg, m64); }
1: Constructor line ia.sinc:7693(id0.1284) printpiece=[PSUBSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3725  1: m64 : 3726  
Pattern id=1284 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E8:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[98:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7701 :PSUBSB          XmmReg1, XmmReg2 is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xE8; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = psubsb(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:7701(id0.1289) printpiece=[PSUBSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3736  1: XmmReg2 : 3737  
Pattern id=1289 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E8:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[98:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7700 :PSUBSB          XmmReg, m128      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xE8; XmmReg ... & m128 ... { XmmReg = psubsb(XmmReg, m128); }
1: Constructor line ia.sinc:7700(id0.1288) printpiece=[PSUBSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3734  1: m128 : 3735  
Pattern id=1288 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E8:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[98:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7698 :PSUBSW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE9; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = psubsw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:7698(id0.1287) printpiece=[PSUBSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3732  1: mmxreg2 : 3733  
Pattern id=1287 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E9:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[99:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7697 :PSUBSW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xE9; mmxreg ... & m64 ... { mmxreg = psubsw(mmxreg, m64); }
1: Constructor line ia.sinc:7697(id0.1286) printpiece=[PSUBSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3730  1: m64 : 3731  
Pattern id=1286 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:E9:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[99:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7704 :PSUBSW          XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xE9; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = psubsw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:7704(id0.1291) printpiece=[PSUBSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3740  1: XmmReg2 : 3741  
Pattern id=1291 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E9:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[99:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7703 :PSUBSW          XmmReg, m128      is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xE9; XmmReg ... & m128 ... { XmmReg = psubsw(XmmReg, m128); }
1: Constructor line ia.sinc:7703(id0.1290) printpiece=[PSUBSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3738  1: m128 : 3739  
Pattern id=1290 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:E9:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[99:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6960 :PMINSW        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEA; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = pminsw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:6960(id0.1157) printpiece=[PMINSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3427  1: mmxreg2 : 3428  
Pattern id=1157 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EA:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6959 :PMINSW        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEA; mmxreg ... & m64 { mmxreg = pminsw(mmxreg, m64); }
1: Constructor line ia.sinc:6959(id0.1156) printpiece=[PMINSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3425  1: m64 : 3426  
Pattern id=1156 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EA:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6962 :PMINSW        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEA; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = pminsw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:6962(id0.1159) printpiece=[PMINSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3431  1: XmmReg2 : 3432  
Pattern id=1159 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EA:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6961 :PMINSW        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEA; XmmReg ... & m128 { XmmReg = pminsw(XmmReg, m128); }
1: Constructor line ia.sinc:6961(id0.1158) printpiece=[PMINSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3429  1: m128 : 3430  
Pattern id=1158 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EA:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7165 :POR            mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEB; mmxmod = 3 & mmxreg1 & mmxreg2	{ mmxreg1 = mmxreg1 | mmxreg2; }
0: Constructor line ia.sinc:7165(id0.1187) printpiece=[POR,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3492  1: mmxreg2 : 3493  
Pattern id=1187 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EB:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7164 :POR            mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEB; mmxreg ... & m64				{ mmxreg = mmxreg | m64; }
1: Constructor line ia.sinc:7164(id0.1186) printpiece=[POR,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3490  1: m64 : 3491  
Pattern id=1186 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7167 :POR            XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEB; xmmmod = 3 & XmmReg1 & XmmReg2	{ XmmReg1 = XmmReg1 | XmmReg2; }
0: Constructor line ia.sinc:7167(id0.1189) printpiece=[POR,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3496  1: XmmReg2 : 3497  
Pattern id=1189 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EB:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7166 :POR            XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEB; XmmReg ... & m128			    { XmmReg = XmmReg | m128; }
1: Constructor line ia.sinc:7166(id0.1188) printpiece=[POR,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3494  1: m128 : 3495  
Pattern id=1188 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6357 :PADDSB         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEC; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = paddsb(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:6357(id0.1049) printpiece=[PADDSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3182  1: mmxreg2 : 3183  
Pattern id=1049 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EC:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6356 :PADDSB         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEC; mmxreg ... & m64 { mmxreg = paddsb(mmxreg, m64); }
1: Constructor line ia.sinc:6356(id0.1048) printpiece=[PADDSB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3180  1: m64 : 3181  
Pattern id=1048 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EC:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6364 :PADDSB         XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEC; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = paddsb(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:6364(id0.1053) printpiece=[PADDSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3191  1: XmmReg2 : 3192  
Pattern id=1053 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EC:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6363 :PADDSB         XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEC; XmmReg ... & m128 { XmmReg = paddsb(XmmReg, m128); }
1: Constructor line ia.sinc:6363(id0.1052) printpiece=[PADDSB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3189  1: m128 : 3190  
Pattern id=1052 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EC:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6361 :PADDSW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xED; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = paddsw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:6361(id0.1051) printpiece=[PADDSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3187  1: mmxreg2 : 3188  
Pattern id=1051 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:ED:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6360 :PADDSW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xED; mmxreg ... & m64 { mmxreg = paddsw(mmxreg, m64); }
1: Constructor line ia.sinc:6360(id0.1050) printpiece=[PADDSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3185  1: m64 : 3186  
Pattern id=1050 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:ED:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6366 :PADDSW         XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xED; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = paddsw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:6366(id0.1055) printpiece=[PADDSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3195  1: XmmReg2 : 3196  
Pattern id=1055 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:ED:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6365 :PADDSW         XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xED; XmmReg ... & m128 { XmmReg = paddsw(XmmReg, m128); }
1: Constructor line ia.sinc:6365(id0.1054) printpiece=[PADDSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3193  1: m128 : 3194  
Pattern id=1054 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:ED:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[7b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6886 :PMAXSW        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEE; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = pmaxsw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:6886(id0.1149) printpiece=[PMAXSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3410  1: mmxreg2 : 3411  
Pattern id=1149 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EE:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[89:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6885 :PMAXSW        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEE; mmxreg ... & m64 { mmxreg = pmaxsw(mmxreg, m64); }
1: Constructor line ia.sinc:6885(id0.1148) printpiece=[PMAXSW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3408  1: m64 : 3409  
Pattern id=1148 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EE:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[89:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6888 :PMAXSW        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEE; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = pmaxsw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:6888(id0.1151) printpiece=[PMAXSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3414  1: XmmReg2 : 3415  
Pattern id=1151 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EE:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[89:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6887 :PMAXSW        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEE; XmmReg ... & m128 { XmmReg = pmaxsw(XmmReg, m128); }
1: Constructor line ia.sinc:6887(id0.1150) printpiece=[PMAXSW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3412  1: m128 : 3413  
Pattern id=1150 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EE:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[89:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8022 :PXOR            mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEF; mmxmod = 3 & mmxreg1 & mmxreg2		{ mmxreg1 = mmxreg1 ^ mmxreg2; }
0: Constructor line ia.sinc:8022(id0.1329) printpiece=[PXOR,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3819  1: mmxreg2 : 3820  
Pattern id=1329 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EF:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8021 :PXOR            mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xEF; mmxreg ... & m64 { mmxreg = mmxreg ^ m64; }
1: Constructor line ia.sinc:8021(id0.1328) printpiece=[PXOR,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3817  1: m64 : 3818  
Pattern id=1328 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:EF:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8024 :PXOR            XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEF; xmmmod = 3 & XmmReg1 & XmmReg2	{ XmmReg1 = XmmReg1 ^ XmmReg2; }
0: Constructor line ia.sinc:8024(id0.1331) printpiece=[PXOR,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3823  1: XmmReg2 : 3824  
Pattern id=1331 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EF:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8023 :PXOR            XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xEF; XmmReg ... & m128 { XmmReg = XmmReg ^ m128; }
1: Constructor line ia.sinc:8023(id0.1330) printpiece=[PXOR,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3821  1: m128 : 3822  
Pattern id=1330 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:EF:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:5578 :LDDQU        XmmReg, m128        is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0xF0; XmmReg ... & m128 { XmmReg = lddqu(XmmReg, m128); }
0: Constructor line ia.sinc:5578(id0.910) printpiece=[LDDQU,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 2888  1: m128 : 2889  
Pattern id=910 pattern=cmb:(ctx:SS:X[1xxx]:X[0xxx]:XX:XX,ins:0F:F0:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7268 :PSLLW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF1; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = psllw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:7268(id0.1220) printpiece=[PSLLW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3595  1: mmxreg2 : 3596  
Pattern id=1220 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F1:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[96:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7267 :PSLLW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF1; mmxreg ... & m64 ... { mmxreg = psllw(mmxreg, m64); }
1: Constructor line ia.sinc:7267(id0.1219) printpiece=[PSLLW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3593  1: m64 : 3594  
Pattern id=1219 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F1:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[96:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7292 :PSLLW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF1; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = psllw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:7292(id0.1229) printpiece=[PSLLW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3613  1: XmmReg2 : 3614  
Pattern id=1229 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F1:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[96:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7291 :PSLLW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF1; XmmReg ... & m128 ... { XmmReg = psllw(XmmReg, m128); }
1: Constructor line ia.sinc:7291(id0.1228) printpiece=[PSLLW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3611  1: m128 : 3612  
Pattern id=1228 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F1:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[96:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7277 :PSLLD          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF2; mmxmod = 3 & mmxreg1 & mmxreg2 {
  mmxreg1[0,32] = mmxreg1[0,32] << mmxreg2[0,32];
  mmxreg1[32,32] = mmxreg1[32,32] << mmxreg2[32,32];
}
0: Constructor line ia.sinc:7277(id0.1223) printpiece=[PSLLD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3601  1: mmxreg2 : 3602  
Pattern id=1223 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F2:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:4] = INT_LEFT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	1: [handle:space][[handle:offset+40004]:4] = INT_LEFT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]

Line ia.sinc:7271 :PSLLD          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF2; mmxreg ... & m64 ... {
  local m:8 = m64;
  mmxreg[0,32] = mmxreg[0,32] << m[0,32];
  mmxreg[32,32] = mmxreg[32,32] << m[32,32];
}
1: Constructor line ia.sinc:7271(id0.1222) printpiece=[PSLLD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3599  1: m64 : 3600  
Pattern id=1222 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F2:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[8cb00:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[8cb80:4] = SUBPIECE unique[8cb00:8], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = INT_LEFT [handle:space][[handle:offset+0]:4], unique[8cb80:4]
	4: unique[8cc80:4] = SUBPIECE unique[8cb00:8], const[4:4]
	5: [handle:space][[handle:offset+40004]:4] = INT_LEFT [handle:space][[handle:offset+40004]:4], unique[8cc80:4]

Line ia.sinc:7303 :PSLLD          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF2; xmmmod = 3 & XmmReg1 & XmmReg2 {
  XmmReg1[0,32] = XmmReg1[0,32] << XmmReg2[0,32];
  XmmReg1[32,32] = XmmReg1[32,32] << XmmReg2[32,32];
  XmmReg1[64,32] = XmmReg1[64,32] << XmmReg2[64,32];
  XmmReg1[96,32] = XmmReg1[96,32] << XmmReg2[96,32];
}
0: Constructor line ia.sinc:7303(id0.1232) printpiece=[PSLLD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3619  1: XmmReg2 : 3620  
Pattern id=1232 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F2:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = INT_LEFT [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = INT_LEFT [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = INT_LEFT [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = INT_LEFT [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:7295 :PSLLD          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF2; XmmReg ... & m128 ... {
  local m:16 = m128;
  XmmReg[0,32] = XmmReg[0,32] << m[0,32];
  XmmReg[32,32] = XmmReg[32,32] << m[32,32];
  XmmReg[64,32] = XmmReg[64,32] << m[64,32];
  XmmReg[96,32] = XmmReg[96,32] << m[96,32];
}
1: Constructor line ia.sinc:7295(id0.1231) printpiece=[PSLLD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3617  1: m128 : 3618  
Pattern id=1231 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F2:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[8d280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[8d300:4] = SUBPIECE unique[8d280:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = INT_LEFT [handle:space][[handle:offset+0]:4], unique[8d300:4]
	5: unique[8d400:4] = SUBPIECE unique[8d280:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = INT_LEFT [handle:space][[handle:offset+40004]:4], unique[8d400:4]
	7: unique[8d500:4] = SUBPIECE unique[8d280:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = INT_LEFT [handle:space][[handle:offset+80008]:4], unique[8d500:4]
	9: unique[8d600:4] = SUBPIECE unique[8d280:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = INT_LEFT [handle:space][[handle:offset+c000c]:4], unique[8d600:4]

Line ia.sinc:7288 :PSLLQ          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF3; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = mmxreg1 << mmxreg2; }
0: Constructor line ia.sinc:7288(id0.1226) printpiece=[PSLLQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3607  1: mmxreg2 : 3608  
Pattern id=1226 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F3:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7287 :PSLLQ          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF3; mmxreg ... & m64 ... { mmxreg = mmxreg << m64; }
1: Constructor line ia.sinc:7287(id0.1225) printpiece=[PSLLQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3605  1: m64 : 3606  
Pattern id=1225 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7323 :PSLLQ          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF3; xmmmod = 3 & XmmReg1 & XmmReg2 {
  XmmReg1[0,64] = XmmReg1[0,64] << XmmReg2[0,64];
  XmmReg1[64,64] = XmmReg1[64,64] << XmmReg2[64,64];
}
0: Constructor line ia.sinc:7323(id0.1235) printpiece=[PSLLQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3625  1: XmmReg2 : 3626  
Pattern id=1235 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F3:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = INT_LEFT [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = INT_LEFT [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:7317 :PSLLQ          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF3; XmmReg ... & m128 ... {
  local m:16 = m128;
  XmmReg[0,64] = XmmReg[0,64] << m[0,64];
  XmmReg[64,64] = XmmReg[64,64] << m[64,64];
}
1: Constructor line ia.sinc:7317(id0.1234) printpiece=[PSLLQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3623  1: m128 : 3624  
Pattern id=1234 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F3:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[8db00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[8db80:8] = SUBPIECE unique[8db00:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = INT_LEFT [handle:space][[handle:offset+0]:8], unique[8db80:8]
	5: unique[8dc80:8] = SUBPIECE unique[8db00:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = INT_LEFT [handle:space][[handle:offset+80008]:8], unique[8dc80:8]

Line ia.sinc:7137 :PMULUDQ        mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF4; mmxmod = 3 & mmxreg1 & mmxreg2
{
    local a:8 = zext(mmxreg1[0,32]);
    local b:8 = zext(mmxreg2[0,32]);
    mmxreg1 = a * b;
}
0: Constructor line ia.sinc:7137(id0.1183) printpiece=[PMULUDQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3484  1: mmxreg2 : 3485  
Pattern id=1183 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F4:[11xx]X:XX)
Template
	0: unique[89a00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	1: unique[89b00:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_MULT unique[89a00:8], unique[89b00:8]

Line ia.sinc:7130 :PMULUDQ        mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF4; mmxreg ... & m64
{
    local a:8 = zext(mmxreg[0,32]);
    local b:8 = zext(m64[0,32]);
    mmxreg = a * b;
}
1: Constructor line ia.sinc:7130(id0.1182) printpiece=[PMULUDQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3482  1: m64 : 3483  
Pattern id=1182 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F4:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[89780:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	2: unique[89880:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_MULT unique[89780:8], unique[89880:8]

Line ia.sinc:7154 :PMULUDQ        XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF4; xmmmod = 3 & XmmReg1 & XmmReg2
{
    local a:8 = zext(XmmReg1[0,32]);
    local b:8 = zext(XmmReg2[0,32]);
    XmmReg1[0,64]  = a * b;
    local c:8 = zext(XmmReg1[64,32]);
    local d:8 = zext(XmmReg2[64,32]);
    XmmReg1[64,64] = c * d;
}
0: Constructor line ia.sinc:7154(id0.1185) printpiece=[PMULUDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3488  1: XmmReg2 : 3489  
Pattern id=1185 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F4:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[8a180:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	3: unique[8a280:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: [handle:space][[handle:offset+0]:8] = INT_MULT unique[8a180:8], unique[8a280:8]
	5: unique[8a400:8] = INT_ZEXT [handle:space][[handle:offset+80008]:4]
	6: unique[8a500:8] = INT_ZEXT [handle:space][[handle:offset+80008]:4]
	7: [handle:space][[handle:offset+80008]:8] = INT_MULT unique[8a400:8], unique[8a500:8]

Line ia.sinc:7144 :PMULUDQ        XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF4; XmmReg ... & m128
{
    local a:8 = zext(XmmReg[0,32]);
    local b:8 = zext(m128[0,32]);
    XmmReg[0,64]  = a * b;
    local c:8 = zext(XmmReg[64,32]);
    local d:8 = zext(m128[64,32]);
    XmmReg[64,64] = c * d;
}
1: Constructor line ia.sinc:7144(id0.1184) printpiece=[PMULUDQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3486  1: m128 : 3487  
Pattern id=1184 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F4:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[89c80:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	3: unique[89d80:8] = INT_ZEXT [handle:space][[handle:offset+0]:4]
	4: [handle:space][[handle:offset+0]:8] = INT_MULT unique[89c80:8], unique[89d80:8]
	5: unique[89f00:8] = INT_ZEXT [handle:space][[handle:offset+80008]:4]
	6: unique[8a000:8] = INT_ZEXT [handle:space][[handle:offset+80008]:4]
	7: [handle:space][[handle:offset+80008]:8] = INT_MULT unique[89f00:8], unique[8a000:8]

Line ia.sinc:6880 :PMADDWD       mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF5; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = pmaddwd(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:6880(id0.1145) printpiece=[PMADDWD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3401  1: mmxreg2 : 3402  
Pattern id=1145 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F5:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[88:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6879 :PMADDWD       mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF5; mmxreg ... & m64 { mmxreg = pmaddwd(mmxreg, m64); }
1: Constructor line ia.sinc:6879(id0.1144) printpiece=[PMADDWD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3399  1: m64 : 3400  
Pattern id=1144 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F5:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[88:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6882 :PMADDWD       XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF5; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = pmaddwd(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:6882(id0.1147) printpiece=[PMADDWD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3405  1: XmmReg2 : 3406  
Pattern id=1147 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F5:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[88:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:6881 :PMADDWD       XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF5; XmmReg ... & m128 { XmmReg = pmaddwd(XmmReg, m128); }
1: Constructor line ia.sinc:6881(id0.1146) printpiece=[PMADDWD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3403  1: m128 : 3404  
Pattern id=1146 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F5:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[88:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7171 :PSADBW         mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF6; mmxmod = 3 & mmxreg1 & mmxreg2 { mmxreg1 = psadbw(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:7171(id0.1191) printpiece=[PSADBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3501  1: mmxreg2 : 3502  
Pattern id=1191 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F6:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7170 :PSADBW         mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF6; mmxreg ... & m64 { mmxreg = psadbw(mmxreg, m64); }
1: Constructor line ia.sinc:7170(id0.1190) printpiece=[PSADBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3499  1: m64 : 3500  
Pattern id=1190 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F6:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7173 :PSADBW         XmmReg1, XmmReg2 is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF6; xmmmod = 3 & XmmReg1 & XmmReg2 { XmmReg1 = psadbw(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:7173(id0.1193) printpiece=[PSADBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3505  1: XmmReg2 : 3506  
Pattern id=1193 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F6:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7172 :PSADBW         XmmReg, m128     is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF6; XmmReg ... & m128 { XmmReg = psadbw(XmmReg, m128); }
1: Constructor line ia.sinc:7172(id0.1192) printpiece=[PSADBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3503  1: m128 : 3504  
Pattern id=1192 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F6:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[8e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8823 :MASKMOVQ            mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF7; mmxmod = 3 & mmxreg1 & mmxreg2		{ mmxreg1 = MaskedMoveQWord(mmxreg1, mmxreg2); }
0: Constructor line ia.sinc:8823(id0.1548) printpiece=[MASKMOVQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 4401  1: mmxreg2 : 4402  
Pattern id=1548 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F7:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[fb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:5581 :MASKMOVDQU        XmmReg1, XmmReg2   is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xF7; XmmReg1 & XmmReg2		{ XmmReg1 = maskmovdqu(XmmReg1, XmmReg2); }
0: Constructor line ia.sinc:5581(id0.911) printpiece=[MASKMOVDQU,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 2891  1: XmmReg2 : 2892  
Pattern id=911 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F7:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[6d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7553 :PSUBB           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF8; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] =  mmxreg1[0,8] -  mmxreg2[0,8];
    mmxreg1[16,8] = mmxreg1[16,8] - mmxreg2[16,8];
    mmxreg1[24,8] = mmxreg1[24,8] - mmxreg2[24,8];
    mmxreg1[32,8] = mmxreg1[32,8] - mmxreg2[32,8];
    mmxreg1[40,8] = mmxreg1[40,8] - mmxreg2[40,8];
    mmxreg1[48,8] = mmxreg1[48,8] - mmxreg2[48,8];
    mmxreg1[56,8] = mmxreg1[56,8] - mmxreg2[56,8];
}
0: Constructor line ia.sinc:7553(id0.1269) printpiece=[PSUBB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3694  1: mmxreg2 : 3695  
Pattern id=1269 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F8:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:1] = INT_SUB [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	1: [handle:space][[handle:offset+20002]:1] = INT_SUB [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	2: [handle:space][[handle:offset+30003]:1] = INT_SUB [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	3: [handle:space][[handle:offset+40004]:1] = INT_SUB [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	4: [handle:space][[handle:offset+50005]:1] = INT_SUB [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	5: [handle:space][[handle:offset+60006]:1] = INT_SUB [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	6: [handle:space][[handle:offset+70007]:1] = INT_SUB [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]

Line ia.sinc:7540 :PSUBB           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF8; mmxreg ... & m64 ...
{
    local m:8 = m64;
    mmxreg[0,8]  = mmxreg[0,8]  - m[0,8];
    mmxreg[8,8]  = mmxreg[8,8]  - m[8,8];
    mmxreg[16,8] = mmxreg[16,8] - m[16,8];
    mmxreg[24,8] = mmxreg[24,8] - m[24,8];
    mmxreg[32,8] = mmxreg[32,8] - m[32,8];
    mmxreg[40,8] = mmxreg[40,8] - m[40,8];
    mmxreg[48,8] = mmxreg[48,8] - m[48,8];
    mmxreg[56,8] = mmxreg[56,8] - m[56,8];
}
1: Constructor line ia.sinc:7540(id0.1268) printpiece=[PSUBB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3692  1: m64 : 3693  
Pattern id=1268 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F8:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[90d80:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[90e00:1] = SUBPIECE unique[90d80:8], const[0:4]
	3: [handle:space][[handle:offset+0]:1] = INT_SUB [handle:space][[handle:offset+0]:1], unique[90e00:1]
	4: unique[90f00:1] = SUBPIECE unique[90d80:8], const[1:4]
	5: [handle:space][[handle:offset+10001]:1] = INT_SUB [handle:space][[handle:offset+10001]:1], unique[90f00:1]
	6: unique[91000:1] = SUBPIECE unique[90d80:8], const[2:4]
	7: [handle:space][[handle:offset+20002]:1] = INT_SUB [handle:space][[handle:offset+20002]:1], unique[91000:1]
	8: unique[91100:1] = SUBPIECE unique[90d80:8], const[3:4]
	9: [handle:space][[handle:offset+30003]:1] = INT_SUB [handle:space][[handle:offset+30003]:1], unique[91100:1]
	10: unique[91200:1] = SUBPIECE unique[90d80:8], const[4:4]
	11: [handle:space][[handle:offset+40004]:1] = INT_SUB [handle:space][[handle:offset+40004]:1], unique[91200:1]
	12: unique[91300:1] = SUBPIECE unique[90d80:8], const[5:4]
	13: [handle:space][[handle:offset+50005]:1] = INT_SUB [handle:space][[handle:offset+50005]:1], unique[91300:1]
	14: unique[91400:1] = SUBPIECE unique[90d80:8], const[6:4]
	15: [handle:space][[handle:offset+60006]:1] = INT_SUB [handle:space][[handle:offset+60006]:1], unique[91400:1]
	16: unique[91500:1] = SUBPIECE unique[90d80:8], const[7:4]
	17: [handle:space][[handle:offset+70007]:1] = INT_SUB [handle:space][[handle:offset+70007]:1], unique[91500:1]

Line ia.sinc:7630 :PSUBB           XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF8; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8]   = XmmReg1[0,8]   - XmmReg2[0,8];
    XmmReg1[8,8]   = XmmReg1[8,8]   - XmmReg2[8,8];
    XmmReg1[16,8]  = XmmReg1[16,8]  - XmmReg2[16,8];
    XmmReg1[24,8]  = XmmReg1[24,8]  - XmmReg2[24,8];
    XmmReg1[32,8]  = XmmReg1[32,8]  - XmmReg2[32,8];
    XmmReg1[40,8]  = XmmReg1[40,8]  - XmmReg2[40,8];
    XmmReg1[48,8]  = XmmReg1[48,8]  - XmmReg2[48,8];
    XmmReg1[56,8]  = XmmReg1[56,8]  - XmmReg2[56,8];
    XmmReg1[64,8]  = XmmReg1[64,8]  - XmmReg2[64,8];
    XmmReg1[72,8]  = XmmReg1[72,8]  - XmmReg2[72,8];
    XmmReg1[80,8]  = XmmReg1[80,8]  - XmmReg2[80,8];
    XmmReg1[88,8]  = XmmReg1[88,8]  - XmmReg2[88,8];
    XmmReg1[96,8]  = XmmReg1[96,8]  - XmmReg2[96,8];
    XmmReg1[104,8] = XmmReg1[104,8] - XmmReg2[104,8];
    XmmReg1[112,8] = XmmReg1[112,8] - XmmReg2[112,8];
    XmmReg1[120,8] = XmmReg1[120,8] - XmmReg2[120,8];
}
0: Constructor line ia.sinc:7630(id0.1279) printpiece=[PSUBB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3714  1: XmmReg2 : 3715  
Pattern id=1279 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F8:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:1] = INT_SUB [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	3: [handle:space][[handle:offset+10001]:1] = INT_SUB [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	4: [handle:space][[handle:offset+20002]:1] = INT_SUB [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	5: [handle:space][[handle:offset+30003]:1] = INT_SUB [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	6: [handle:space][[handle:offset+40004]:1] = INT_SUB [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	7: [handle:space][[handle:offset+50005]:1] = INT_SUB [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	8: [handle:space][[handle:offset+60006]:1] = INT_SUB [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	9: [handle:space][[handle:offset+70007]:1] = INT_SUB [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	10: [handle:space][[handle:offset+80008]:1] = INT_SUB [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	11: [handle:space][[handle:offset+90009]:1] = INT_SUB [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	12: [handle:space][[handle:offset+a000a]:1] = INT_SUB [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	13: [handle:space][[handle:offset+b000b]:1] = INT_SUB [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	14: [handle:space][[handle:offset+c000c]:1] = INT_SUB [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	15: [handle:space][[handle:offset+d000d]:1] = INT_SUB [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	16: [handle:space][[handle:offset+e000e]:1] = INT_SUB [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	17: [handle:space][[handle:offset+f000f]:1] = INT_SUB [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]

Line ia.sinc:7609 :PSUBB           XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF8; XmmReg ... & m128 ...
{
    local m:16 = m128;
    XmmReg[0,8]   = XmmReg[0,8]   - m[0,8];
    XmmReg[8,8]   = XmmReg[8,8]   - m[8,8];
    XmmReg[16,8]  = XmmReg[16,8]  - m[16,8];
    XmmReg[24,8]  = XmmReg[24,8]  - m[24,8];
    XmmReg[32,8]  = XmmReg[32,8]  - m[32,8];
    XmmReg[40,8]  = XmmReg[40,8]  - m[40,8];
    XmmReg[48,8]  = XmmReg[48,8]  - m[48,8];
    XmmReg[56,8]  = XmmReg[56,8]  - m[56,8];
    XmmReg[64,8]  = XmmReg[64,8]  - m[64,8];
    XmmReg[72,8]  = XmmReg[72,8]  - m[72,8];
    XmmReg[80,8]  = XmmReg[80,8]  - m[80,8];
    XmmReg[88,8]  = XmmReg[88,8]  - m[88,8];
    XmmReg[96,8]  = XmmReg[96,8]  - m[96,8];
    XmmReg[104,8] = XmmReg[104,8] - m[104,8];
    XmmReg[112,8] = XmmReg[112,8] - m[112,8];
    XmmReg[120,8] = XmmReg[120,8] - m[120,8];
}
1: Constructor line ia.sinc:7609(id0.1278) printpiece=[PSUBB,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3712  1: m128 : 3713  
Pattern id=1278 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F8:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[92800:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[92880:1] = SUBPIECE unique[92800:10], const[0:4]
	4: [handle:space][[handle:offset+0]:1] = INT_SUB [handle:space][[handle:offset+0]:1], unique[92880:1]
	5: unique[92980:1] = SUBPIECE unique[92800:10], const[1:4]
	6: [handle:space][[handle:offset+10001]:1] = INT_SUB [handle:space][[handle:offset+10001]:1], unique[92980:1]
	7: unique[92a80:1] = SUBPIECE unique[92800:10], const[2:4]
	8: [handle:space][[handle:offset+20002]:1] = INT_SUB [handle:space][[handle:offset+20002]:1], unique[92a80:1]
	9: unique[92b80:1] = SUBPIECE unique[92800:10], const[3:4]
	10: [handle:space][[handle:offset+30003]:1] = INT_SUB [handle:space][[handle:offset+30003]:1], unique[92b80:1]
	11: unique[92c80:1] = SUBPIECE unique[92800:10], const[4:4]
	12: [handle:space][[handle:offset+40004]:1] = INT_SUB [handle:space][[handle:offset+40004]:1], unique[92c80:1]
	13: unique[92d80:1] = SUBPIECE unique[92800:10], const[5:4]
	14: [handle:space][[handle:offset+50005]:1] = INT_SUB [handle:space][[handle:offset+50005]:1], unique[92d80:1]
	15: unique[92e80:1] = SUBPIECE unique[92800:10], const[6:4]
	16: [handle:space][[handle:offset+60006]:1] = INT_SUB [handle:space][[handle:offset+60006]:1], unique[92e80:1]
	17: unique[92f80:1] = SUBPIECE unique[92800:10], const[7:4]
	18: [handle:space][[handle:offset+70007]:1] = INT_SUB [handle:space][[handle:offset+70007]:1], unique[92f80:1]
	19: unique[93080:1] = SUBPIECE unique[92800:10], const[8:4]
	20: [handle:space][[handle:offset+80008]:1] = INT_SUB [handle:space][[handle:offset+80008]:1], unique[93080:1]
	21: unique[93180:1] = SUBPIECE unique[92800:10], const[9:4]
	22: [handle:space][[handle:offset+90009]:1] = INT_SUB [handle:space][[handle:offset+90009]:1], unique[93180:1]
	23: unique[93280:1] = SUBPIECE unique[92800:10], const[a:4]
	24: [handle:space][[handle:offset+a000a]:1] = INT_SUB [handle:space][[handle:offset+a000a]:1], unique[93280:1]
	25: unique[93380:1] = SUBPIECE unique[92800:10], const[b:4]
	26: [handle:space][[handle:offset+b000b]:1] = INT_SUB [handle:space][[handle:offset+b000b]:1], unique[93380:1]
	27: unique[93480:1] = SUBPIECE unique[92800:10], const[c:4]
	28: [handle:space][[handle:offset+c000c]:1] = INT_SUB [handle:space][[handle:offset+c000c]:1], unique[93480:1]
	29: unique[93580:1] = SUBPIECE unique[92800:10], const[d:4]
	30: [handle:space][[handle:offset+d000d]:1] = INT_SUB [handle:space][[handle:offset+d000d]:1], unique[93580:1]
	31: unique[93680:1] = SUBPIECE unique[92800:10], const[e:4]
	32: [handle:space][[handle:offset+e000e]:1] = INT_SUB [handle:space][[handle:offset+e000e]:1], unique[93680:1]
	33: unique[93780:1] = SUBPIECE unique[92800:10], const[f:4]
	34: [handle:space][[handle:offset+f000f]:1] = INT_SUB [handle:space][[handle:offset+f000f]:1], unique[93780:1]

Line ia.sinc:7573 :PSUBW           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF9; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = mmxreg1[0,16] - mmxreg2[0,16];
    mmxreg1[16,16] = mmxreg1[16,16] - mmxreg2[16,16];
    mmxreg1[32,16] = mmxreg1[32,16] - mmxreg2[32,16];
    mmxreg1[48,16] = mmxreg1[48,16] - mmxreg2[48,16];
}
0: Constructor line ia.sinc:7573(id0.1271) printpiece=[PSUBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3698  1: mmxreg2 : 3699  
Pattern id=1271 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F9:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:2] = INT_SUB [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	1: [handle:space][[handle:offset+20002]:2] = INT_SUB [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	2: [handle:space][[handle:offset+40004]:2] = INT_SUB [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	3: [handle:space][[handle:offset+60006]:2] = INT_SUB [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]

Line ia.sinc:7564 :PSUBW           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xF9; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = mmxreg[0,16] - m[0,16];
    mmxreg[16,16] = mmxreg[16,16] - m[16,16];
    mmxreg[32,16] = mmxreg[32,16] - m[32,16];
    mmxreg[48,16] = mmxreg[48,16] - m[48,16];
}
1: Constructor line ia.sinc:7564(id0.1270) printpiece=[PSUBW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3696  1: m64 : 3697  
Pattern id=1270 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:F9:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[91980:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[91a00:2] = SUBPIECE unique[91980:8], const[0:4]
	3: [handle:space][[handle:offset+0]:2] = INT_SUB [handle:space][[handle:offset+0]:2], unique[91a00:2]
	4: unique[91b00:2] = SUBPIECE unique[91980:8], const[2:4]
	5: [handle:space][[handle:offset+20002]:2] = INT_SUB [handle:space][[handle:offset+20002]:2], unique[91b00:2]
	6: unique[91c00:2] = SUBPIECE unique[91980:8], const[4:4]
	7: [handle:space][[handle:offset+40004]:2] = INT_SUB [handle:space][[handle:offset+40004]:2], unique[91c00:2]
	8: unique[91d00:2] = SUBPIECE unique[91980:8], const[6:4]
	9: [handle:space][[handle:offset+60006]:2] = INT_SUB [handle:space][[handle:offset+60006]:2], unique[91d00:2]

Line ia.sinc:7663 :PSUBW           XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF9; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = XmmReg1[0,16] - XmmReg2[0,16];
    XmmReg1[16,16] = XmmReg1[16,16] - XmmReg2[16,16];
    XmmReg1[32,16] = XmmReg1[32,16] - XmmReg2[32,16];
    XmmReg1[48,16] = XmmReg1[48,16] - XmmReg2[48,16];
    XmmReg1[64,16] = XmmReg1[64,16] - XmmReg2[64,16];
    XmmReg1[80,16] = XmmReg1[80,16] - XmmReg2[80,16];
    XmmReg1[96,16] = XmmReg1[96,16] - XmmReg2[96,16];
    XmmReg1[112,16] = XmmReg1[112,16] - XmmReg2[112,16];
}
0: Constructor line ia.sinc:7663(id0.1281) printpiece=[PSUBW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3718  1: XmmReg2 : 3719  
Pattern id=1281 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F9:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:2] = INT_SUB [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: [handle:space][[handle:offset+20002]:2] = INT_SUB [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	4: [handle:space][[handle:offset+40004]:2] = INT_SUB [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	5: [handle:space][[handle:offset+60006]:2] = INT_SUB [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	6: [handle:space][[handle:offset+80008]:2] = INT_SUB [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	7: [handle:space][[handle:offset+a000a]:2] = INT_SUB [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	8: [handle:space][[handle:offset+c000c]:2] = INT_SUB [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	9: [handle:space][[handle:offset+e000e]:2] = INT_SUB [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]

Line ia.sinc:7650 :PSUBW           XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xF9; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = XmmReg[0,16] - m[0,16];
    XmmReg[16,16] = XmmReg[16,16] - m[16,16];
    XmmReg[32,16] = XmmReg[32,16] - m[32,16];
    XmmReg[48,16] = XmmReg[48,16] - m[48,16];
    XmmReg[64,16] = XmmReg[64,16] - m[64,16];
    XmmReg[80,16] = XmmReg[80,16] - m[80,16];
    XmmReg[96,16] = XmmReg[96,16] - m[96,16];
    XmmReg[112,16] = XmmReg[112,16] - m[112,16];
}
1: Constructor line ia.sinc:7650(id0.1280) printpiece=[PSUBW,  ,  B, ,,  ,  A]
Operands 0: m128 : 3717  1: XmmReg : 3716  
Pattern id=1280 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:F9:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[94080:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[94100:2] = SUBPIECE unique[94080:10], const[0:4]
	4: [handle:space][[handle:offset+0]:2] = INT_SUB [handle:space][[handle:offset+0]:2], unique[94100:2]
	5: unique[94200:2] = SUBPIECE unique[94080:10], const[2:4]
	6: [handle:space][[handle:offset+20002]:2] = INT_SUB [handle:space][[handle:offset+20002]:2], unique[94200:2]
	7: unique[94300:2] = SUBPIECE unique[94080:10], const[4:4]
	8: [handle:space][[handle:offset+40004]:2] = INT_SUB [handle:space][[handle:offset+40004]:2], unique[94300:2]
	9: unique[94400:2] = SUBPIECE unique[94080:10], const[6:4]
	10: [handle:space][[handle:offset+60006]:2] = INT_SUB [handle:space][[handle:offset+60006]:2], unique[94400:2]
	11: unique[94500:2] = SUBPIECE unique[94080:10], const[8:4]
	12: [handle:space][[handle:offset+80008]:2] = INT_SUB [handle:space][[handle:offset+80008]:2], unique[94500:2]
	13: unique[94600:2] = SUBPIECE unique[94080:10], const[a:4]
	14: [handle:space][[handle:offset+a000a]:2] = INT_SUB [handle:space][[handle:offset+a000a]:2], unique[94600:2]
	15: unique[94700:2] = SUBPIECE unique[94080:10], const[c:4]
	16: [handle:space][[handle:offset+c000c]:2] = INT_SUB [handle:space][[handle:offset+c000c]:2], unique[94700:2]
	17: unique[94800:2] = SUBPIECE unique[94080:10], const[e:4]
	18: [handle:space][[handle:offset+e000e]:2] = INT_SUB [handle:space][[handle:offset+e000e]:2], unique[94800:2]

Line ia.sinc:7588 :PSUBD           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFA; mmxmod = 3 & mmxreg1 & mmxreg2
{
	mmxreg1[0,32] = mmxreg1[0,32] - mmxreg2[0,32];
	mmxreg1[32,32] = mmxreg1[32,32] - mmxreg2[32,32];
}
0: Constructor line ia.sinc:7588(id0.1273) printpiece=[PSUBD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3702  1: mmxreg2 : 3703  
Pattern id=1273 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FA:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:4] = INT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	1: [handle:space][[handle:offset+40004]:4] = INT_SUB [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]

Line ia.sinc:7581 :PSUBD           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFA; mmxreg ... & m64 ...
{
	local m:8 = m64;
	mmxreg[0,32] = mmxreg[0,32] - m[0,32];
	mmxreg[32,32] = mmxreg[32,32] - m[32,32];
}
1: Constructor line ia.sinc:7581(id0.1272) printpiece=[PSUBD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3700  1: m64 : 3701  
Pattern id=1272 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FA:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[92000:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[92080:4] = SUBPIECE unique[92000:8], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = INT_SUB [handle:space][[handle:offset+0]:4], unique[92080:4]
	4: unique[92180:4] = SUBPIECE unique[92000:8], const[4:4]
	5: [handle:space][[handle:offset+40004]:4] = INT_SUB [handle:space][[handle:offset+40004]:4], unique[92180:4]

Line ia.sinc:7684 :PSUBD           XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFA; xmmmod = 3 & XmmReg1 & XmmReg2
{
  XmmReg1[0,32] = XmmReg1[0,32] - XmmReg2[0,32];
  XmmReg1[32,32] = XmmReg1[32,32] - XmmReg2[32,32];
  XmmReg1[64,32] = XmmReg1[64,32] - XmmReg2[64,32];
  XmmReg1[96,32] = XmmReg1[96,32] - XmmReg2[96,32];
}
0: Constructor line ia.sinc:7684(id0.1283) printpiece=[PSUBD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3722  1: XmmReg2 : 3723  
Pattern id=1283 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FA:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = INT_SUB [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = INT_SUB [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = INT_SUB [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = INT_SUB [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:7675 :PSUBD           XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFA; XmmReg ... & m128 ...
{
  local m:16 = m128;
  XmmReg[0,32] = XmmReg[0,32] - m[0,32];
  XmmReg[32,32] = XmmReg[32,32] - m[32,32];
  XmmReg[64,32] = XmmReg[64,32] - m[64,32];
  XmmReg[96,32] = XmmReg[96,32] - m[96,32];
}
1: Constructor line ia.sinc:7675(id0.1282) printpiece=[PSUBD,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3720  1: m128 : 3721  
Pattern id=1282 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FA:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[94d00:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[94d80:4] = SUBPIECE unique[94d00:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = INT_SUB [handle:space][[handle:offset+0]:4], unique[94d80:4]
	5: unique[94e80:4] = SUBPIECE unique[94d00:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = INT_SUB [handle:space][[handle:offset+40004]:4], unique[94e80:4]
	7: unique[94f80:4] = SUBPIECE unique[94d00:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = INT_SUB [handle:space][[handle:offset+80008]:4], unique[94f80:4]
	9: unique[95080:4] = SUBPIECE unique[94d00:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = INT_SUB [handle:space][[handle:offset+c000c]:4], unique[95080:4]

Line ia.sinc:7595 :PSUBQ           mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFB; mmxmod = 3 & mmxreg1 & mmxreg2		{ mmxreg1 = mmxreg1 - mmxreg2; }
0: Constructor line ia.sinc:7595(id0.1275) printpiece=[PSUBQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3706  1: mmxreg2 : 3707  
Pattern id=1275 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FB:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7594 :PSUBQ           mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFB; mmxreg ... & m64 ...			{ mmxreg = mmxreg - m64; }
1: Constructor line ia.sinc:7594(id0.1274) printpiece=[PSUBQ,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3704  1: m64 : 3705  
Pattern id=1274 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:7603 :PSUBQ           XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFB; xmmmod = 3 & XmmReg1 & XmmReg2
{
	XmmReg1[0,64] = XmmReg1[0,64] - XmmReg2[0,64];
	XmmReg1[64,64] = XmmReg1[64,64] - XmmReg2[64,64];
}
0: Constructor line ia.sinc:7603(id0.1277) printpiece=[PSUBQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3710  1: XmmReg2 : 3711  
Pattern id=1277 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FB:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:8] = INT_SUB [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: [handle:space][[handle:offset+80008]:8] = INT_SUB [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]

Line ia.sinc:7596 :PSUBQ           XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFB; XmmReg ... & m128 ...
{
	local m:16 = m128;
	XmmReg[0,64] = XmmReg[0,64] - m[0,64];
	XmmReg[64,64] = XmmReg[64,64] - m[64,64];
}
1: Constructor line ia.sinc:7596(id0.1276) printpiece=[PSUBQ,  ,  A, ,,  ,  B]
Operands 0: XmmReg : 3708  1: m128 : 3709  
Pattern id=1276 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FB:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[92480:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[92500:8] = SUBPIECE unique[92480:10], const[0:4]
	4: [handle:space][[handle:offset+0]:8] = INT_SUB [handle:space][[handle:offset+0]:8], unique[92500:8]
	5: unique[92600:8] = SUBPIECE unique[92480:10], const[8:4]
	6: [handle:space][[handle:offset+80008]:8] = INT_SUB [handle:space][[handle:offset+80008]:8], unique[92600:8]

Line ia.sinc:6185 :PADDB          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFC; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,8] = mmxreg1[0,8] + mmxreg2[0,8];
    mmxreg1[8,8] = mmxreg1[8,8] + mmxreg2[8,8];
    mmxreg1[16,8] = mmxreg1[16,8] + mmxreg2[16,8];
    mmxreg1[24,8] = mmxreg1[24,8] + mmxreg2[24,8];
    mmxreg1[32,8] = mmxreg1[32,8] + mmxreg2[32,8];
    mmxreg1[40,8] = mmxreg1[40,8] + mmxreg2[40,8];
    mmxreg1[48,8] = mmxreg1[48,8] + mmxreg2[48,8];
    mmxreg1[56,8] = mmxreg1[56,8] + mmxreg2[56,8];
}
0: Constructor line ia.sinc:6185(id0.1033) printpiece=[PADDB,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3149  1: mmxreg2 : 3150  
Pattern id=1033 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FC:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:1] = INT_ADD [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	1: [handle:space][[handle:offset+10001]:1] = INT_ADD [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	2: [handle:space][[handle:offset+20002]:1] = INT_ADD [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	3: [handle:space][[handle:offset+30003]:1] = INT_ADD [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	4: [handle:space][[handle:offset+40004]:1] = INT_ADD [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	5: [handle:space][[handle:offset+50005]:1] = INT_ADD [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	6: [handle:space][[handle:offset+60006]:1] = INT_ADD [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	7: [handle:space][[handle:offset+70007]:1] = INT_ADD [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]

Line ia.sinc:6172 :PADDB          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFC; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,8] = mmxreg[0,8] + m[0,8];
    mmxreg[8,8] = mmxreg[8,8] + m[8,8];
    mmxreg[16,8] = mmxreg[16,8] + m[16,8];
    mmxreg[24,8] = mmxreg[24,8] + m[24,8];
    mmxreg[32,8] = mmxreg[32,8] + m[32,8];
    mmxreg[40,8] = mmxreg[40,8] + m[40,8];
    mmxreg[48,8] = mmxreg[48,8] + m[48,8];
    mmxreg[56,8] = mmxreg[56,8] + m[56,8];
}
1: Constructor line ia.sinc:6172(id0.1032) printpiece=[PADDB,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3147  1: m64 : 3148  
Pattern id=1032 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FC:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[67800:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[67880:1] = SUBPIECE unique[67800:8], const[0:4]
	3: [handle:space][[handle:offset+0]:1] = INT_ADD [handle:space][[handle:offset+0]:1], unique[67880:1]
	4: unique[67980:1] = SUBPIECE unique[67800:8], const[1:4]
	5: [handle:space][[handle:offset+10001]:1] = INT_ADD [handle:space][[handle:offset+10001]:1], unique[67980:1]
	6: unique[67a80:1] = SUBPIECE unique[67800:8], const[2:4]
	7: [handle:space][[handle:offset+20002]:1] = INT_ADD [handle:space][[handle:offset+20002]:1], unique[67a80:1]
	8: unique[67b80:1] = SUBPIECE unique[67800:8], const[3:4]
	9: [handle:space][[handle:offset+30003]:1] = INT_ADD [handle:space][[handle:offset+30003]:1], unique[67b80:1]
	10: unique[67c80:1] = SUBPIECE unique[67800:8], const[4:4]
	11: [handle:space][[handle:offset+40004]:1] = INT_ADD [handle:space][[handle:offset+40004]:1], unique[67c80:1]
	12: unique[67d80:1] = SUBPIECE unique[67800:8], const[5:4]
	13: [handle:space][[handle:offset+50005]:1] = INT_ADD [handle:space][[handle:offset+50005]:1], unique[67d80:1]
	14: unique[67e80:1] = SUBPIECE unique[67800:8], const[6:4]
	15: [handle:space][[handle:offset+60006]:1] = INT_ADD [handle:space][[handle:offset+60006]:1], unique[67e80:1]
	16: unique[67f80:1] = SUBPIECE unique[67800:8], const[7:4]
	17: [handle:space][[handle:offset+70007]:1] = INT_ADD [handle:space][[handle:offset+70007]:1], unique[67f80:1]

Line ia.sinc:6270 :PADDB  XmmReg1, XmmReg2  is vexMode=0 & $(PRE_66) & byte=0x0F; byte=0xFC; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,8] = XmmReg1[0,8] + XmmReg2[0,8];
    XmmReg1[8,8] = XmmReg1[8,8] + XmmReg2[8,8];
    XmmReg1[16,8] = XmmReg1[16,8] + XmmReg2[16,8];
    XmmReg1[24,8] = XmmReg1[24,8] + XmmReg2[24,8];
    XmmReg1[32,8] = XmmReg1[32,8] + XmmReg2[32,8];
    XmmReg1[40,8] = XmmReg1[40,8] + XmmReg2[40,8];
    XmmReg1[48,8] = XmmReg1[48,8] + XmmReg2[48,8];
    XmmReg1[56,8] = XmmReg1[56,8] + XmmReg2[56,8];
    XmmReg1[64,8] = XmmReg1[64,8] + XmmReg2[64,8];
    XmmReg1[72,8] = XmmReg1[72,8] + XmmReg2[72,8];
    XmmReg1[80,8] = XmmReg1[80,8] + XmmReg2[80,8];
    XmmReg1[88,8] = XmmReg1[88,8] + XmmReg2[88,8];
    XmmReg1[96,8] = XmmReg1[96,8] + XmmReg2[96,8];
    XmmReg1[104,8] = XmmReg1[104,8] + XmmReg2[104,8];
    XmmReg1[112,8] = XmmReg1[112,8] + XmmReg2[112,8];
    XmmReg1[120,8] = XmmReg1[120,8] + XmmReg2[120,8];
}
0: Constructor line ia.sinc:6270(id0.1039) printpiece=[PADDB,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3161  1: XmmReg2 : 3162  
Pattern id=1039 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FC:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:1] = INT_ADD [handle:space][[handle:offset+0]:1], [handle:space][[handle:offset+0]:1]
	3: [handle:space][[handle:offset+10001]:1] = INT_ADD [handle:space][[handle:offset+10001]:1], [handle:space][[handle:offset+10001]:1]
	4: [handle:space][[handle:offset+20002]:1] = INT_ADD [handle:space][[handle:offset+20002]:1], [handle:space][[handle:offset+20002]:1]
	5: [handle:space][[handle:offset+30003]:1] = INT_ADD [handle:space][[handle:offset+30003]:1], [handle:space][[handle:offset+30003]:1]
	6: [handle:space][[handle:offset+40004]:1] = INT_ADD [handle:space][[handle:offset+40004]:1], [handle:space][[handle:offset+40004]:1]
	7: [handle:space][[handle:offset+50005]:1] = INT_ADD [handle:space][[handle:offset+50005]:1], [handle:space][[handle:offset+50005]:1]
	8: [handle:space][[handle:offset+60006]:1] = INT_ADD [handle:space][[handle:offset+60006]:1], [handle:space][[handle:offset+60006]:1]
	9: [handle:space][[handle:offset+70007]:1] = INT_ADD [handle:space][[handle:offset+70007]:1], [handle:space][[handle:offset+70007]:1]
	10: [handle:space][[handle:offset+80008]:1] = INT_ADD [handle:space][[handle:offset+80008]:1], [handle:space][[handle:offset+80008]:1]
	11: [handle:space][[handle:offset+90009]:1] = INT_ADD [handle:space][[handle:offset+90009]:1], [handle:space][[handle:offset+90009]:1]
	12: [handle:space][[handle:offset+a000a]:1] = INT_ADD [handle:space][[handle:offset+a000a]:1], [handle:space][[handle:offset+a000a]:1]
	13: [handle:space][[handle:offset+b000b]:1] = INT_ADD [handle:space][[handle:offset+b000b]:1], [handle:space][[handle:offset+b000b]:1]
	14: [handle:space][[handle:offset+c000c]:1] = INT_ADD [handle:space][[handle:offset+c000c]:1], [handle:space][[handle:offset+c000c]:1]
	15: [handle:space][[handle:offset+d000d]:1] = INT_ADD [handle:space][[handle:offset+d000d]:1], [handle:space][[handle:offset+d000d]:1]
	16: [handle:space][[handle:offset+e000e]:1] = INT_ADD [handle:space][[handle:offset+e000e]:1], [handle:space][[handle:offset+e000e]:1]
	17: [handle:space][[handle:offset+f000f]:1] = INT_ADD [handle:space][[handle:offset+f000f]:1], [handle:space][[handle:offset+f000f]:1]

Line ia.sinc:6227 :PADDB          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFC; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,8] = XmmReg[0,8] + m[0,8];
    XmmReg[8,8] = XmmReg[8,8] + m[8,8];
    XmmReg[16,8] = XmmReg[16,8] + m[16,8];
    XmmReg[24,8] = XmmReg[24,8] + m[24,8];
    XmmReg[32,8] = XmmReg[32,8] + m[32,8];
    XmmReg[40,8] = XmmReg[40,8] + m[40,8];
    XmmReg[48,8] = XmmReg[48,8] + m[48,8];
    XmmReg[56,8] = XmmReg[56,8] + m[56,8];
    XmmReg[64,8] = XmmReg[64,8] + m[64,8];
    XmmReg[72,8] = XmmReg[72,8] + m[72,8];
    XmmReg[80,8] = XmmReg[80,8] + m[80,8];
    XmmReg[88,8] = XmmReg[88,8] + m[88,8];
    XmmReg[96,8] = XmmReg[96,8] + m[96,8];
    XmmReg[104,8] = XmmReg[104,8] + m[104,8];
    XmmReg[112,8] = XmmReg[112,8] + m[112,8];
    XmmReg[120,8] = XmmReg[120,8] + m[120,8];
}
1: Constructor line ia.sinc:6227(id0.1038) printpiece=[PADDB,  ,  B, ,,  ,  A]
Operands 0: m128 : 3160  1: XmmReg : 3159  
Pattern id=1038 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FC:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[68e80:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[68f00:1] = SUBPIECE unique[68e80:10], const[0:4]
	4: [handle:space][[handle:offset+0]:1] = INT_ADD [handle:space][[handle:offset+0]:1], unique[68f00:1]
	5: unique[69000:1] = SUBPIECE unique[68e80:10], const[1:4]
	6: [handle:space][[handle:offset+10001]:1] = INT_ADD [handle:space][[handle:offset+10001]:1], unique[69000:1]
	7: unique[69100:1] = SUBPIECE unique[68e80:10], const[2:4]
	8: [handle:space][[handle:offset+20002]:1] = INT_ADD [handle:space][[handle:offset+20002]:1], unique[69100:1]
	9: unique[69200:1] = SUBPIECE unique[68e80:10], const[3:4]
	10: [handle:space][[handle:offset+30003]:1] = INT_ADD [handle:space][[handle:offset+30003]:1], unique[69200:1]
	11: unique[69300:1] = SUBPIECE unique[68e80:10], const[4:4]
	12: [handle:space][[handle:offset+40004]:1] = INT_ADD [handle:space][[handle:offset+40004]:1], unique[69300:1]
	13: unique[69400:1] = SUBPIECE unique[68e80:10], const[5:4]
	14: [handle:space][[handle:offset+50005]:1] = INT_ADD [handle:space][[handle:offset+50005]:1], unique[69400:1]
	15: unique[69500:1] = SUBPIECE unique[68e80:10], const[6:4]
	16: [handle:space][[handle:offset+60006]:1] = INT_ADD [handle:space][[handle:offset+60006]:1], unique[69500:1]
	17: unique[69600:1] = SUBPIECE unique[68e80:10], const[7:4]
	18: [handle:space][[handle:offset+70007]:1] = INT_ADD [handle:space][[handle:offset+70007]:1], unique[69600:1]
	19: unique[69700:1] = SUBPIECE unique[68e80:10], const[8:4]
	20: [handle:space][[handle:offset+80008]:1] = INT_ADD [handle:space][[handle:offset+80008]:1], unique[69700:1]
	21: unique[69800:1] = SUBPIECE unique[68e80:10], const[9:4]
	22: [handle:space][[handle:offset+90009]:1] = INT_ADD [handle:space][[handle:offset+90009]:1], unique[69800:1]
	23: unique[69900:1] = SUBPIECE unique[68e80:10], const[a:4]
	24: [handle:space][[handle:offset+a000a]:1] = INT_ADD [handle:space][[handle:offset+a000a]:1], unique[69900:1]
	25: unique[69a00:1] = SUBPIECE unique[68e80:10], const[b:4]
	26: [handle:space][[handle:offset+b000b]:1] = INT_ADD [handle:space][[handle:offset+b000b]:1], unique[69a00:1]
	27: unique[69b00:1] = SUBPIECE unique[68e80:10], const[c:4]
	28: [handle:space][[handle:offset+c000c]:1] = INT_ADD [handle:space][[handle:offset+c000c]:1], unique[69b00:1]
	29: unique[69c00:1] = SUBPIECE unique[68e80:10], const[d:4]
	30: [handle:space][[handle:offset+d000d]:1] = INT_ADD [handle:space][[handle:offset+d000d]:1], unique[69c00:1]
	31: unique[69d00:1] = SUBPIECE unique[68e80:10], const[e:4]
	32: [handle:space][[handle:offset+e000e]:1] = INT_ADD [handle:space][[handle:offset+e000e]:1], unique[69d00:1]
	33: unique[69e00:1] = SUBPIECE unique[68e80:10], const[f:4]
	34: [handle:space][[handle:offset+f000f]:1] = INT_ADD [handle:space][[handle:offset+f000f]:1], unique[69e00:1]

Line ia.sinc:6206 :PADDW          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFD; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,16] = mmxreg1[0,16] + mmxreg2[0,16];
    mmxreg1[16,16] = mmxreg1[16,16] + mmxreg2[16,16];
    mmxreg1[32,16] = mmxreg1[32,16] + mmxreg2[32,16];
    mmxreg1[48,16] = mmxreg1[48,16] + mmxreg2[48,16];
}
0: Constructor line ia.sinc:6206(id0.1035) printpiece=[PADDW,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3153  1: mmxreg2 : 3154  
Pattern id=1035 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FD:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:2] = INT_ADD [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	1: [handle:space][[handle:offset+20002]:2] = INT_ADD [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	2: [handle:space][[handle:offset+40004]:2] = INT_ADD [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	3: [handle:space][[handle:offset+60006]:2] = INT_ADD [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]

Line ia.sinc:6197 :PADDW          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFD; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,16] = mmxreg[0,16] + m[0,16];
    mmxreg[16,16] = mmxreg[16,16] + m[16,16];
    mmxreg[32,16] = mmxreg[32,16] + m[32,16];
    mmxreg[48,16] = mmxreg[48,16] + m[48,16];
}
1: Constructor line ia.sinc:6197(id0.1034) printpiece=[PADDW,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3151  1: m64 : 3152  
Pattern id=1034 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FD:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[68480:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[68500:2] = SUBPIECE unique[68480:8], const[0:4]
	3: [handle:space][[handle:offset+0]:2] = INT_ADD [handle:space][[handle:offset+0]:2], unique[68500:2]
	4: unique[68600:2] = SUBPIECE unique[68480:8], const[2:4]
	5: [handle:space][[handle:offset+20002]:2] = INT_ADD [handle:space][[handle:offset+20002]:2], unique[68600:2]
	6: unique[68700:2] = SUBPIECE unique[68480:8], const[4:4]
	7: [handle:space][[handle:offset+40004]:2] = INT_ADD [handle:space][[handle:offset+40004]:2], unique[68700:2]
	8: unique[68800:2] = SUBPIECE unique[68480:8], const[6:4]
	9: [handle:space][[handle:offset+60006]:2] = INT_ADD [handle:space][[handle:offset+60006]:2], unique[68800:2]

Line ia.sinc:6303 :PADDW          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFD; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,16] = XmmReg1[0,16] + XmmReg2[0,16];
    XmmReg1[16,16] = XmmReg1[16,16] + XmmReg2[16,16];
    XmmReg1[32,16] = XmmReg1[32,16] + XmmReg2[32,16];
    XmmReg1[48,16] = XmmReg1[48,16] + XmmReg2[48,16];
    XmmReg1[64,16] = XmmReg1[64,16] + XmmReg2[64,16];
    XmmReg1[80,16] = XmmReg1[80,16] + XmmReg2[80,16];
    XmmReg1[96,16] = XmmReg1[96,16] + XmmReg2[96,16];
    XmmReg1[112,16] = XmmReg1[112,16] + XmmReg2[112,16];
}
0: Constructor line ia.sinc:6303(id0.1041) printpiece=[PADDW,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3165  1: XmmReg2 : 3166  
Pattern id=1041 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FD:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:2] = INT_ADD [handle:space][[handle:offset+0]:2], [handle:space][[handle:offset+0]:2]
	3: [handle:space][[handle:offset+20002]:2] = INT_ADD [handle:space][[handle:offset+20002]:2], [handle:space][[handle:offset+20002]:2]
	4: [handle:space][[handle:offset+40004]:2] = INT_ADD [handle:space][[handle:offset+40004]:2], [handle:space][[handle:offset+40004]:2]
	5: [handle:space][[handle:offset+60006]:2] = INT_ADD [handle:space][[handle:offset+60006]:2], [handle:space][[handle:offset+60006]:2]
	6: [handle:space][[handle:offset+80008]:2] = INT_ADD [handle:space][[handle:offset+80008]:2], [handle:space][[handle:offset+80008]:2]
	7: [handle:space][[handle:offset+a000a]:2] = INT_ADD [handle:space][[handle:offset+a000a]:2], [handle:space][[handle:offset+a000a]:2]
	8: [handle:space][[handle:offset+c000c]:2] = INT_ADD [handle:space][[handle:offset+c000c]:2], [handle:space][[handle:offset+c000c]:2]
	9: [handle:space][[handle:offset+e000e]:2] = INT_ADD [handle:space][[handle:offset+e000e]:2], [handle:space][[handle:offset+e000e]:2]

Line ia.sinc:6290 :PADDW          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFD; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,16] = XmmReg[0,16] + m[0,16];
    XmmReg[16,16] = XmmReg[16,16] + m[16,16];
    XmmReg[32,16] = XmmReg[32,16] + m[32,16];
    XmmReg[48,16] = XmmReg[48,16] + m[48,16];
    XmmReg[64,16] = XmmReg[64,16] + m[64,16];
    XmmReg[80,16] = XmmReg[80,16] + m[80,16];
    XmmReg[96,16] = XmmReg[96,16] + m[96,16];
    XmmReg[112,16] = XmmReg[112,16] + m[112,16];
}
1: Constructor line ia.sinc:6290(id0.1040) printpiece=[PADDW,  ,  B, ,,  ,  A]
Operands 0: m128 : 3164  1: XmmReg : 3163  
Pattern id=1040 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FD:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[6a700:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[6a780:2] = SUBPIECE unique[6a700:10], const[0:4]
	4: [handle:space][[handle:offset+0]:2] = INT_ADD [handle:space][[handle:offset+0]:2], unique[6a780:2]
	5: unique[6a880:2] = SUBPIECE unique[6a700:10], const[2:4]
	6: [handle:space][[handle:offset+20002]:2] = INT_ADD [handle:space][[handle:offset+20002]:2], unique[6a880:2]
	7: unique[6a980:2] = SUBPIECE unique[6a700:10], const[4:4]
	8: [handle:space][[handle:offset+40004]:2] = INT_ADD [handle:space][[handle:offset+40004]:2], unique[6a980:2]
	9: unique[6aa80:2] = SUBPIECE unique[6a700:10], const[6:4]
	10: [handle:space][[handle:offset+60006]:2] = INT_ADD [handle:space][[handle:offset+60006]:2], unique[6aa80:2]
	11: unique[6ab80:2] = SUBPIECE unique[6a700:10], const[8:4]
	12: [handle:space][[handle:offset+80008]:2] = INT_ADD [handle:space][[handle:offset+80008]:2], unique[6ab80:2]
	13: unique[6ac80:2] = SUBPIECE unique[6a700:10], const[a:4]
	14: [handle:space][[handle:offset+a000a]:2] = INT_ADD [handle:space][[handle:offset+a000a]:2], unique[6ac80:2]
	15: unique[6ad80:2] = SUBPIECE unique[6a700:10], const[c:4]
	16: [handle:space][[handle:offset+c000c]:2] = INT_ADD [handle:space][[handle:offset+c000c]:2], unique[6ad80:2]
	17: unique[6ae80:2] = SUBPIECE unique[6a700:10], const[e:4]
	18: [handle:space][[handle:offset+e000e]:2] = INT_ADD [handle:space][[handle:offset+e000e]:2], unique[6ae80:2]

Line ia.sinc:6221 :PADDD          mmxreg1, mmxreg2 is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFE; mmxmod = 3 & mmxreg1 & mmxreg2
{
    mmxreg1[0,32] = mmxreg1[0,32] + mmxreg2[0,32];
    mmxreg1[32,32] = mmxreg1[32,32] + mmxreg2[32,32];
}
0: Constructor line ia.sinc:6221(id0.1037) printpiece=[PADDD,  ,  A, ,,  ,  B]
Operands 0: mmxreg1 : 3157  1: mmxreg2 : 3158  
Pattern id=1037 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FE:[11xx]X:XX)
Template
	0: [handle:space][[handle:offset+0]:4] = INT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	1: [handle:space][[handle:offset+40004]:4] = INT_ADD [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]

Line ia.sinc:6214 :PADDD          mmxreg, m64      is vexMode=0 &  mandover=0 & byte=0x0F; byte=0xFE; mmxreg ... & m64
{
    local m:8 = m64;
    mmxreg[0,32] = mmxreg[0,32] + m[0,32];
    mmxreg[32,32] = mmxreg[32,32] + m[32,32];
}
1: Constructor line ia.sinc:6214(id0.1036) printpiece=[PADDD,  ,  A, ,,  ,  B]
Operands 0: mmxreg : 3155  1: m64 : 3156  
Pattern id=1036 pattern=cmb:(ctx:SS:X[000x]:X[0xxx]:XX:XX,ins:0F:FE:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[68b00:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[68b80:4] = SUBPIECE unique[68b00:8], const[0:4]
	3: [handle:space][[handle:offset+0]:4] = INT_ADD [handle:space][[handle:offset+0]:4], unique[68b80:4]
	4: unique[68c80:4] = SUBPIECE unique[68b00:8], const[4:4]
	5: [handle:space][[handle:offset+40004]:4] = INT_ADD [handle:space][[handle:offset+40004]:4], unique[68c80:4]

Line ia.sinc:6324 :PADDD          XmmReg1, XmmReg2  is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFE; xmmmod = 3 & XmmReg1 & XmmReg2
{
    XmmReg1[0,32] = XmmReg1[0,32] + XmmReg2[0,32];
    XmmReg1[32,32] = XmmReg1[32,32] + XmmReg2[32,32];
    XmmReg1[64,32] = XmmReg1[64,32] + XmmReg2[64,32];
    XmmReg1[96,32] = XmmReg1[96,32] + XmmReg2[96,32];
}
0: Constructor line ia.sinc:6324(id0.1043) printpiece=[PADDD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 3169  1: XmmReg2 : 3170  
Pattern id=1043 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FE:[11xx]X:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset+0]:4] = INT_ADD [handle:space][[handle:offset+0]:4], [handle:space][[handle:offset+0]:4]
	3: [handle:space][[handle:offset+40004]:4] = INT_ADD [handle:space][[handle:offset+40004]:4], [handle:space][[handle:offset+40004]:4]
	4: [handle:space][[handle:offset+80008]:4] = INT_ADD [handle:space][[handle:offset+80008]:4], [handle:space][[handle:offset+80008]:4]
	5: [handle:space][[handle:offset+c000c]:4] = INT_ADD [handle:space][[handle:offset+c000c]:4], [handle:space][[handle:offset+c000c]:4]

Line ia.sinc:6315 :PADDD          XmmReg, m128      is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0xFE; m128 & XmmReg ...
{
    local m:16 = m128;
    XmmReg[0,32] = XmmReg[0,32] + m[0,32];
    XmmReg[32,32] = XmmReg[32,32] + m[32,32];
    XmmReg[64,32] = XmmReg[64,32] + m[64,32];
    XmmReg[96,32] = XmmReg[96,32] + m[96,32];
}
1: Constructor line ia.sinc:6315(id0.1042) printpiece=[PADDD,  ,  B, ,,  ,  A]
Operands 0: m128 : 3168  1: XmmReg : 3167  
Pattern id=1042 pattern=cmb:(ctx:SS:X[xx1x]:X[0xxx]:XX:XX,ins:0F:FE:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[6b380:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[6b400:4] = SUBPIECE unique[6b380:10], const[0:4]
	4: [handle:space][[handle:offset+0]:4] = INT_ADD [handle:space][[handle:offset+0]:4], unique[6b400:4]
	5: unique[6b500:4] = SUBPIECE unique[6b380:10], const[4:4]
	6: [handle:space][[handle:offset+40004]:4] = INT_ADD [handle:space][[handle:offset+40004]:4], unique[6b500:4]
	7: unique[6b600:4] = SUBPIECE unique[6b380:10], const[8:4]
	8: [handle:space][[handle:offset+80008]:4] = INT_ADD [handle:space][[handle:offset+80008]:4], unique[6b600:4]
	9: unique[6b700:4] = SUBPIECE unique[6b380:10], const[c:4]
	10: [handle:space][[handle:offset+c000c]:4] = INT_ADD [handle:space][[handle:offset+c000c]:4], unique[6b700:4]

Line ia.sinc:3854 :UD0  Reg32, rm32 is vexMode=0 & byte=0x0f; byte=0xff; rm32 & Reg32 ...           { invalidInstructionException(); goto inst_start; }
0: Constructor line ia.sinc:3854(id0.597) printpiece=[UD0,  ,  B, ,,  ,  A]
Operands 0: rm32 : 2416  1: Reg32 : 2415  
Pattern id=597 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:0F:FF:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[49:4]
	3: BRANCH [curspace][[start]:[curspace_size]]

Line avx.sinc:3291 :VTESTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; XmmReg1 ... & XmmReg2_m128
{
	vtestpd_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3291(id0.1901) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: XmmReg1 : 6155  1: XmmReg2_m128 : 6156  
Pattern id=1901 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1773 :VPALIGNR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x0F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpalignr_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1773(id0.1723) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5247  1: vexVVVV_XmmReg : 5244  2: XmmReg1 : 5243  3: YmmReg1 : 5248  4: XmmReg2_m128 : 5245  5: imm8 : 5246  
Pattern id=1723 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab680:10] = CALLOTHER const[165:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab680:10]

Line avx.sinc:3298 :VTESTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x0F; YmmReg1 ... & YmmReg2_m256
{
	vtestpd_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:3298(id0.1902) printpiece=[VTESTPD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6157  1: YmmReg2_m256 : 6158  
Pattern id=1902 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[1f2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:143 :VPALIGNR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x0F; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpalignr_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:143(id0.1942) printpiece=[VPALIGNR,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6333  1: vexVVVV_YmmReg : 6330  2: YmmReg1 : 6329  3: YmmReg2_m256 : 6331  4: imm8 : 6332  
Pattern id=1942 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:0F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[208:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:1661 :ADC rm8,Reg8      is vexMode=0 & byte=0x10; rm8 & Reg8 ...                 { addCarryFlags( rm8, Reg8 ); resultflags( rm8 ); }
0: Constructor line ia.sinc:1661(id0.32) printpiece=[ADC,  ,  A, ,,  B]
Operands 0: rm8 : 1410  1: Reg8 : 1411  
Pattern id=32 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:10:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d100:[handle:size]] = COPY register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx_manual.sinc:74 :VMOVUPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x10; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = XmmReg2_m128;
	YmmReg1[0,128] = tmp;
	YmmReg1[128,64] = 0;
	YmmReg1[192,64] = 0;
}
0: Constructor line avx_manual.sinc:74(id0.1918) printpiece=[VMOVUPS,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6223  1: XmmReg1 : 6221  2: YmmReg1 : 6224  3: XmmReg2_m128 : 6222  
Pattern id=1918 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:10:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: [handle:space][[handle:offset+0]:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset+100010]:8] = COPY const[0:8]
	5: [handle:space][[handle:offset+180018]:8] = COPY const[0:8]

Line avx_manual.sinc:97 :VMOVUPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x10; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = YmmReg2_m256;
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx_manual.sinc:97(id0.1921) printpiece=[VMOVUPS,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6234  1: YmmReg1 : 6232  2: YmmReg2_m256 : 6233  
Pattern id=1921 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:10:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1505 :VMOVUPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x10; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovupd_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1505(id0.1693) printpiece=[VMOVUPD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5090  1: XmmReg1 : 5088  2: YmmReg1 : 5091  3: XmmReg2_m128 : 5089  
Pattern id=1693 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:10:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a9080:10] = CALLOTHER const[14e:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a9080:10]

Line avx.sinc:1520 :VMOVUPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x10; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovupd_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1520(id0.1695) printpiece=[VMOVUPD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5097  1: YmmReg1 : 5095  2: YmmReg2_m256 : 5096  
Pattern id=1695 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:10:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[14e:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1474 :VMOVSS XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x10; (XmmReg1 & YmmReg1) & (mod=0x3 & XmmReg2)
{
	local tmp:16 = vmovss_avx( vexVVVV_XmmReg, XmmReg2 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1474(id0.1689) printpiece=[VMOVSS,  ,  D, ,,  ,  C, ,,  ,  F]
Operands 0: vexL : 5069  1: rexWprefix : 5070  2: vexVVVV_XmmReg : 5067  3: XmmReg1 : 5066  4: YmmReg1 : 5071  5: XmmReg2 : 5068  
Pattern id=1689 pattern=cmb:(ctx:SS:X[010x]:X[1xxx]:[xx00][001x]:XX,ins:10:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[4:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[3:4]
	3: unique[a8b80:10] = CALLOTHER const[14d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a8b80:10]

Line avx.sinc:1482 :VMOVSS XmmReg1, m32 is $(VEX_NONE) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x10; (XmmReg1 & YmmReg1) ... & m32
{
	local tmp:16 = vmovss_avx( m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:1482(id0.1690) printpiece=[VMOVSS,  ,  C, ,,  ,  E]
Operands 0: vexL : 5074  1: rexWprefix : 5075  2: XmmReg1 : 5072  3: YmmReg1 : 5076  4: m32 : 5073  
Pattern id=1690 pattern=cmb:(ctx:SS:X[010x]:X[1x00]:0[001x]:XX,ins:10:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a8d00:10] = CALLOTHER const[14d:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a8d00:10]

Line avx_manual.sinc:38 :VMOVSD XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x10; XmmReg1 & YmmReg1 & (mod=0x3 & XmmReg2)
{
	local tmpa:8 = XmmReg2[0,64];
	local tmpb:8 = vexVVVV_XmmReg[64,64];
	YmmReg1 = 0;
	XmmReg1[0,64] = tmpa;
	XmmReg1[64,64] = tmpb;
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx_manual.sinc:38(id0.1914) printpiece=[VMOVSD,  ,  D, ,,  ,  C, ,,  ,  F]
Operands 0: vexL : 6203  1: rexWprefix : 6204  2: vexVVVV_XmmReg : 6201  3: XmmReg1 : 6200  4: YmmReg1 : 6205  5: XmmReg2 : 6202  
Pattern id=1914 pattern=cmb:(ctx:SS:X[100x]:X[1xxx]:[xx00][001x]:XX,ins:10:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[4:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[3:4]
	3: unique[b8800:8] = COPY [handle:space][[handle:offset+0]:8]
	4: unique[b8880:8] = COPY [handle:space][[handle:offset+80008]:8]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]
	6: [handle:space][[handle:offset+0]:8] = COPY unique[b8800:8]
	7: [handle:space][[handle:offset+80008]:8] = COPY unique[b8880:8]

Line avx_manual.sinc:49 :VMOVSD XmmReg1, m64 is $(VEX_NONE) & $(VEX_LIG) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x10; (XmmReg1 & YmmReg1) ... & m64
{
	YmmReg1[0,64] = m64;
	YmmReg1[64,64] = 0;
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx_manual.sinc:49(id0.1915) printpiece=[VMOVSD,  ,  C, ,,  ,  E]
Operands 0: vexL : 6208  1: rexWprefix : 6209  2: XmmReg1 : 6206  3: YmmReg1 : 6210  4: m64 : 6207  
Pattern id=1915 pattern=cmb:(ctx:SS:X[100x]:X[1x00]:0[001x]:XX,ins:10:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: [handle:space][[handle:offset+0]:8] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset+80008]:8] = COPY const[0:8]

Line ia.sinc:1662 :ADC rm16,Reg16    is vexMode=0 & opsize=0 & byte=0x11; rm16 & Reg16 ...    { addCarryFlags( rm16, Reg16 ); resultflags( rm16 ); }
0: Constructor line ia.sinc:1662(id0.33) printpiece=[ADC,  ,  A, ,,  B]
Operands 0: rm16 : 1412  1: Reg16 : 1413  
Pattern id=33 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:11:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1663 :ADC rm32,Reg32    is vexMode=0 & opsize=1 & byte=0x11; rm32 & check_rm32_dest ... & Reg32 ...    { addCarryFlags( rm32, Reg32 ); build check_rm32_dest; resultflags( rm32 ); }
0: Constructor line ia.sinc:1663(id0.34) printpiece=[ADC,  ,  A, ,,  C]
Operands 0: rm32 : 1414  1: check_rm32_dest : 1416  2: Reg32 : 1415  
Pattern id=34 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:11:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: MULTIEQUAL const[1:4]
	12: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	15: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	16: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	17: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx_manual.sinc:84 :VMOVUPS XmmReg2, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 & (mod = 3 & XmmReg2 & YmmReg2) 
{
	XmmReg2 = XmmReg1;
	YmmReg2 = zext(XmmReg2);
}
0: Constructor line avx_manual.sinc:84(id0.1919) printpiece=[VMOVUPS,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 6227  1: XmmReg1 : 6226  2: XmmReg2 : 6225  3: YmmReg2 : 6228  
Pattern id=1919 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:11:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[2:4]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line avx_manual.sinc:91 :VMOVUPS m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 ... & m128
{
	m128 = XmmReg1;
}
1: Constructor line avx_manual.sinc:91(id0.1920) printpiece=[VMOVUPS,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 6231  1: XmmReg1 : 6230  2: m128 : 6229  
Pattern id=1920 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:11:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx_manual.sinc:105 :VMOVUPS YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x11; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = YmmReg1;
}
0: Constructor line avx_manual.sinc:105(id0.1922) printpiece=[VMOVUPS,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 6237  1: YmmReg1 : 6236  2: YmmReg2_m256 : 6235  
Pattern id=1922 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:11:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1513 :VMOVUPD XmmReg2_m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 ... & XmmReg2_m128
{
	XmmReg2_m128 = vmovupd_avx( XmmReg1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx.sinc:1513(id0.1694) printpiece=[VMOVUPD,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5094  1: XmmReg1 : 5093  2: XmmReg2_m128 : 5092  
Pattern id=1694 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:11:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[14e:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1527 :VMOVUPD YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x11; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = vmovupd_avx( YmmReg1 );
	# TODO ZmmReg2 = zext(YmmReg2)
}
0: Constructor line avx.sinc:1527(id0.1696) printpiece=[VMOVUPD,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5100  1: YmmReg1 : 5099  2: YmmReg2_m256 : 5098  
Pattern id=1696 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:11:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[14e:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1490 :VMOVSS XmmReg2, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x11; XmmReg1 & (mod=0x3 & (XmmReg2 & YmmReg2))
{
	local tmp:16 = vmovss_avx( vexVVVV_XmmReg, XmmReg1 );
	YmmReg2 = zext(tmp);
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx.sinc:1490(id0.1691) printpiece=[VMOVSS,  ,  E, ,,  ,  C, ,,  ,  D]
Operands 0: vexL : 5080  1: rexWprefix : 5081  2: vexVVVV_XmmReg : 5078  3: XmmReg1 : 5079  4: XmmReg2 : 5077  5: YmmReg2 : 5082  
Pattern id=1691 pattern=cmb:(ctx:SS:X[010x]:X[1xxx]:[xx00][001x]:XX,ins:11:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[5:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[4:4]
	3: unique[a8e80:10] = CALLOTHER const[14d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a8e80:10]

Line avx.sinc:1498 :VMOVSS m32, XmmReg1 is $(VEX_NONE) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 ... & m32
{
	m32 = vmovss_avx( XmmReg1 );
}
1: Constructor line avx.sinc:1498(id0.1692) printpiece=[VMOVSS,  ,  D, ,,  ,  C]
Operands 0: vexL : 5085  1: rexWprefix : 5086  2: XmmReg1 : 5084  3: m32 : 5083  
Pattern id=1692 pattern=cmb:(ctx:SS:X[010x]:X[1x00]:0[001x]:XX,ins:11:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[14d:4], [handle:space][[handle:offset]:[handle:size]]

Line avx_manual.sinc:57 :VMOVSD XmmReg2, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x11; XmmReg1 & (mod=0x3 & (XmmReg2 & YmmReg2))
{
	local tmpa:8 = XmmReg1[0,64];
	local tmpb:8 = vexVVVV_XmmReg[64,64];
	YmmReg2 = 0;
	XmmReg2[0,64] = tmpa;
	XmmReg2[64,64] = tmpb;
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx_manual.sinc:57(id0.1916) printpiece=[VMOVSD,  ,  E, ,,  ,  C, ,,  ,  D]
Operands 0: vexL : 6214  1: rexWprefix : 6215  2: vexVVVV_XmmReg : 6212  3: XmmReg1 : 6213  4: XmmReg2 : 6211  5: YmmReg2 : 6216  
Pattern id=1916 pattern=cmb:(ctx:SS:X[100x]:X[1xxx]:[xx00][001x]:XX,ins:11:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[5:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[4:4]
	3: unique[b8900:8] = COPY [handle:space][[handle:offset+0]:8]
	4: unique[b8980:8] = COPY [handle:space][[handle:offset+80008]:8]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]
	6: [handle:space][[handle:offset+0]:8] = COPY unique[b8900:8]
	7: [handle:space][[handle:offset+80008]:8] = COPY unique[b8980:8]

Line avx_manual.sinc:68 :VMOVSD m64, XmmReg1 is $(VEX_NONE) & $(VEX_LIG) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x11; XmmReg1 ... & m64
{
	m64 = XmmReg1[0,64];
}
1: Constructor line avx_manual.sinc:68(id0.1917) printpiece=[VMOVSD,  ,  D, ,,  ,  C]
Operands 0: vexL : 6219  1: rexWprefix : 6220  2: XmmReg1 : 6218  3: m64 : 6217  
Pattern id=1917 pattern=cmb:(ctx:SS:X[100x]:X[1x00]:0[001x]:XX,ins:11:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset+0]:8]

Line ia.sinc:1667 :ADC Reg8,rm8      is vexMode=0 & byte=0x12; rm8 & Reg8 ...                 { addCarryFlags( Reg8, rm8 ); resultflags( Reg8 ); }
0: Constructor line ia.sinc:1667(id0.35) printpiece=[ADC,  ,  B, ,,  A]
Operands 0: rm8 : 1418  1: Reg8 : 1417  
Pattern id=35 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:12:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d100:[handle:size]] = COPY register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1259 :VMOVHLPS XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x12; (XmmReg1 & YmmReg1) & (mod=0x3 & XmmReg2)
{
	local tmp:16 = vmovhlps_avx( vexVVVV_XmmReg, XmmReg2 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1259(id0.1662) printpiece=[VMOVHLPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4958  1: vexVVVV_XmmReg : 4956  2: XmmReg1 : 4955  3: YmmReg1 : 4959  4: XmmReg2 : 4957  
Pattern id=1662 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:12:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a7400:10] = CALLOTHER const[13f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a7400:10]

Line avx.sinc:1322 :VMOVLPS XmmReg1, vexVVVV_XmmReg, m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x12; (XmmReg1 & YmmReg1) ... & m64
{
	local tmp:16 = vmovlps_avx( vexVVVV_XmmReg, m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:1322(id0.1670) printpiece=[VMOVLPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4997  1: vexVVVV_XmmReg : 4995  2: XmmReg1 : 4994  3: YmmReg1 : 4998  4: m64 : 4996  
Pattern id=1670 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:12:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a7d00:10] = CALLOTHER const[144:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a7d00:10]

Line avx.sinc:1307 :VMOVLPD XmmReg1, vexVVVV_XmmReg, m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x12; (XmmReg1 & YmmReg1) ... & m64
{
	local tmp:16 = vmovlpd_avx( vexVVVV_XmmReg, m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1307(id0.1668) printpiece=[VMOVLPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4988  1: vexVVVV_XmmReg : 4986  2: XmmReg1 : 4985  3: YmmReg1 : 4989  4: m64 : 4987  
Pattern id=1668 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:12:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a7b00:10] = CALLOTHER const[143:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a7b00:10]

Line avx.sinc:1458 :VMOVSLDUP XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x12; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovsldup_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1458(id0.1687) printpiece=[VMOVSLDUP,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5060  1: XmmReg1 : 5058  2: YmmReg1 : 5061  3: XmmReg2_m128 : 5059  
Pattern id=1687 pattern=cmb:(ctx:SS:X[010x]:X8:0[001x]:XX,ins:12:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a8980:10] = CALLOTHER const[14c:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a8980:10]

Line avx.sinc:1466 :VMOVSLDUP YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x12; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovsldup_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1466(id0.1688) printpiece=[VMOVSLDUP,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5064  1: YmmReg1 : 5062  2: YmmReg2_m256 : 5063  
Pattern id=1688 pattern=cmb:(ctx:SS:X[010x]:XC:0[001x]:XX,ins:12:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[14c:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1213 :VMOVDDUP XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x12; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vmovddup_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1213(id0.1656) printpiece=[VMOVDDUP,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4935  1: XmmReg1 : 4933  2: YmmReg1 : 4936  3: XmmReg2_m64 : 4934  
Pattern id=1656 pattern=cmb:(ctx:SS:X[100x]:X8:0[001x]:XX,ins:12:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a6f00:10] = CALLOTHER const[13d:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a6f00:10]

Line avx.sinc:1221 :VMOVDDUP YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x12; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovddup_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1221(id0.1657) printpiece=[VMOVDDUP,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4939  1: YmmReg1 : 4937  2: YmmReg2_m256 : 4938  
Pattern id=1657 pattern=cmb:(ctx:SS:X[100x]:XC:0[001x]:XX,ins:12:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[13d:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1668 :ADC Reg16,rm16    is vexMode=0 & opsize=0 & byte=0x13; rm16 & Reg16 ...    { addCarryFlags( Reg16, rm16 ); resultflags( Reg16 ); }
0: Constructor line ia.sinc:1668(id0.36) printpiece=[ADC,  ,  B, ,,  A]
Operands 0: rm16 : 1420  1: Reg16 : 1419  
Pattern id=36 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:647 :VCVTPH2PS XmmReg1, XmmReg2_m64 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x13; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
        local tmp:16 = vcvtph2ps_f16c( XmmReg2_m64 );
        YmmReg1 = zext(tmp);
        # TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:647(id0.1595) printpiece=[VCVTPH2PS,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 4652  1: YmmReg1 : 4654  2: XmmReg2_m64 : 4653  
Pattern id=1595 pattern=cmb:(ctx:SS:X2:X[x0xx]:[xx00][010x]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[a3280:10] = CALLOTHER const[116:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3280:10]

Line ia.sinc:1668 :ADC Reg16,rm16    is vexMode=0 & opsize=0 & byte=0x13; rm16 & Reg16 ...    { addCarryFlags( Reg16, rm16 ); resultflags( Reg16 ); }
0: Constructor line ia.sinc:1668(id0.36) printpiece=[ADC,  ,  B, ,,  A]
Operands 0: rm16 : 1420  1: Reg16 : 1419  
Pattern id=36 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:655 :VCVTPH2PS YmmReg1, XmmReg2_m128 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x13; YmmReg1 ... & XmmReg2_m128
{
        YmmReg1 = vcvtph2ps_f16c( XmmReg2_m128 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx.sinc:655(id0.1596) printpiece=[VCVTPH2PS,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 4655  1: XmmReg2_m128 : 4656  
Pattern id=1596 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[116:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1669 :ADC Reg32,rm32    is vexMode=0 & opsize=1 & byte=0x13; rm32 & Reg32 ... & check_Reg32_dest ...   { addCarryFlags( Reg32, rm32 ); build check_Reg32_dest; resultflags( Reg32 ); }
0: Constructor line ia.sinc:1669(id0.37) printpiece=[ADC,  ,  B, ,,  A]
Operands 0: rm32 : 1422  1: Reg32 : 1421  2: check_Reg32_dest : 1423  
Pattern id=37 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: MULTIEQUAL const[2:4]
	12: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	15: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	16: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	17: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:647 :VCVTPH2PS XmmReg1, XmmReg2_m64 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x13; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
        local tmp:16 = vcvtph2ps_f16c( XmmReg2_m64 );
        YmmReg1 = zext(tmp);
        # TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:647(id0.1595) printpiece=[VCVTPH2PS,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 4652  1: YmmReg1 : 4654  2: XmmReg2_m64 : 4653  
Pattern id=1595 pattern=cmb:(ctx:SS:X2:X[x0xx]:[xx00][010x]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[a3280:10] = CALLOTHER const[116:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3280:10]

Line ia.sinc:1669 :ADC Reg32,rm32    is vexMode=0 & opsize=1 & byte=0x13; rm32 & Reg32 ... & check_Reg32_dest ...   { addCarryFlags( Reg32, rm32 ); build check_Reg32_dest; resultflags( Reg32 ); }
0: Constructor line ia.sinc:1669(id0.37) printpiece=[ADC,  ,  B, ,,  A]
Operands 0: rm32 : 1422  1: Reg32 : 1421  2: check_Reg32_dest : 1423  
Pattern id=37 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: MULTIEQUAL const[2:4]
	12: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	15: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	16: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	17: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:655 :VCVTPH2PS YmmReg1, XmmReg2_m128 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x13; YmmReg1 ... & XmmReg2_m128
{
        YmmReg1 = vcvtph2ps_f16c( XmmReg2_m128 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx.sinc:655(id0.1596) printpiece=[VCVTPH2PS,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 4655  1: XmmReg2_m128 : 4656  
Pattern id=1596 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[116:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1330 :VMOVLPS m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x13; XmmReg1 ... & m64
{
	m64 = vmovlps_avx( XmmReg1 );
}
0: Constructor line avx.sinc:1330(id0.1671) printpiece=[VMOVLPS,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5001  1: XmmReg1 : 5000  2: m64 : 4999  
Pattern id=1671 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[144:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1315 :VMOVLPD m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x13; XmmReg1 ... & m64
{
	m64 = vmovlpd_avx( XmmReg1 );
}
0: Constructor line avx.sinc:1315(id0.1669) printpiece=[VMOVLPD,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 4992  1: XmmReg1 : 4991  2: m64 : 4990  
Pattern id=1669 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[143:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:647 :VCVTPH2PS XmmReg1, XmmReg2_m64 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x13; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
        local tmp:16 = vcvtph2ps_f16c( XmmReg2_m64 );
        YmmReg1 = zext(tmp);
        # TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:647(id0.1595) printpiece=[VCVTPH2PS,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 4652  1: YmmReg1 : 4654  2: XmmReg2_m64 : 4653  
Pattern id=1595 pattern=cmb:(ctx:SS:X2:X[x0xx]:[xx00][010x]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[a3280:10] = CALLOTHER const[116:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3280:10]

Line avx.sinc:655 :VCVTPH2PS YmmReg1, XmmReg2_m128 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x13; YmmReg1 ... & XmmReg2_m128
{
        YmmReg1 = vcvtph2ps_f16c( XmmReg2_m128 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:655(id0.1596) printpiece=[VCVTPH2PS,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 4655  1: XmmReg2_m128 : 4656  
Pattern id=1596 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:13:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[116:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1644 :ADC AL,imm8		is vexMode=0 & byte=0x14; AL & imm8						{ addCarryFlags( AL, imm8:1 ); resultflags( AL ); }
0: Constructor line ia.sinc:1644(id0.24) printpiece=[ADC,  ,  A, ,,  B]
Operands 0: AL : 1391  1: imm8 : 1392  
Pattern id=24 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:14:XX:XX:XX)
Template
	0: unique[d100:1] = COPY register[200:1]
	1: register[200:1] = INT_CARRY register[0:1], [handle:space][[handle:offset]:1]
	2: register[20b:1] = INT_SCARRY register[0:1], [handle:space][[handle:offset]:1]
	3: unique[d300:1] = INT_ADD register[0:1], [handle:space][[handle:offset]:1]
	4: unique[d380:1] = INT_CARRY unique[d300:1], unique[d100:1]
	5: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	6: unique[d480:1] = INT_SCARRY unique[d300:1], unique[d100:1]
	7: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	8: register[0:1] = INT_ADD unique[d300:1], unique[d100:1]
	9: register[207:1] = INT_SLESS register[0:1], const[0:1]
	10: register[206:1] = INT_EQUAL register[0:1], const[0:1]
	11: unique[dc80:1] = INT_AND register[0:1], const[ff:1]
	12: unique[dd00:1] = POPCOUNT unique[dc80:1]
	13: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	14: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3057 :VUNPCKLPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x14; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vunpcklps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3057(id0.1871) printpiece=[VUNPCKLPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6050  1: vexVVVV_XmmReg : 6048  2: XmmReg1 : 6047  3: YmmReg1 : 6051  4: XmmReg2_m128 : 6049  
Pattern id=1871 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:14:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b6c80:10] = CALLOTHER const[1e4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b6c80:10]

Line avx.sinc:3065 :VUNPCKLPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x14; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vunpcklps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3065(id0.1872) printpiece=[VUNPCKLPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6055  1: vexVVVV_YmmReg : 6053  2: YmmReg1 : 6052  3: YmmReg2_m256 : 6054  
Pattern id=1872 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:14:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3041 :VUNPCKLPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x14; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vunpcklpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3041(id0.1869) printpiece=[VUNPCKLPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6040  1: vexVVVV_XmmReg : 6038  2: XmmReg1 : 6037  3: YmmReg1 : 6041  4: XmmReg2_m128 : 6039  
Pattern id=1869 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:14:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b6a80:10] = CALLOTHER const[1e3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b6a80:10]

Line avx.sinc:1934 :VPEXTRB Reg32_m8, XmmReg1, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x14; XmmReg1 ... & Reg32_m8; imm8
{
	Reg32_m8 = vpextrb_avx( XmmReg1, imm8:1 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:1934(id0.1741) printpiece=[VPEXTRB,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 5348  1: Reg32_m8 : 5347  2: imm8 : 5349  
Pattern id=1741 pattern=cmb:(ctx:SS:X2:X8:0[011x]:XX,ins:14:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[177:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:3049 :VUNPCKLPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x14; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vunpcklpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3049(id0.1870) printpiece=[VUNPCKLPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6045  1: vexVVVV_YmmReg : 6043  2: YmmReg1 : 6042  3: YmmReg2_m256 : 6044  
Pattern id=1870 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:14:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1645 :ADC AX,imm16		is vexMode=0 & opsize=0 & byte=0x15; AX & imm16			{ addCarryFlags( AX, imm16:2 ); resultflags( AX ); }
0: Constructor line ia.sinc:1645(id0.25) printpiece=[ADC,  ,  A, ,,  B]
Operands 0: AX : 1393  1: imm16 : 1394  
Pattern id=25 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:15:XX:XX:XX)
Template
	0: unique[d100:2] = INT_ZEXT register[200:1]
	1: register[200:1] = INT_CARRY register[0:2], [handle:space][[handle:offset]:2]
	2: register[20b:1] = INT_SCARRY register[0:2], [handle:space][[handle:offset]:2]
	3: unique[d300:2] = INT_ADD register[0:2], [handle:space][[handle:offset]:2]
	4: unique[d380:1] = INT_CARRY unique[d300:2], unique[d100:2]
	5: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	6: unique[d480:1] = INT_SCARRY unique[d300:2], unique[d100:2]
	7: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	8: register[0:2] = INT_ADD unique[d300:2], unique[d100:2]
	9: register[207:1] = INT_SLESS register[0:2], const[0:2]
	10: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	11: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	12: unique[dd00:1] = POPCOUNT unique[dc80:2]
	13: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	14: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1646 :ADC EAX,imm32		is vexMode=0 & opsize=1 & byte=0x15; EAX & check_EAX_dest & imm32 { addCarryFlags( EAX, imm32:4 ); build check_EAX_dest; resultflags( EAX ); }
0: Constructor line ia.sinc:1646(id0.26) printpiece=[ADC,  ,  A, ,,  C]
Operands 0: EAX : 1395  1: check_EAX_dest : 1397  2: imm32 : 1396  
Pattern id=26 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:15:XX:XX:XX)
Template
	0: unique[d100:4] = INT_ZEXT register[200:1]
	1: register[200:1] = INT_CARRY register[0:4], [handle:space][[handle:offset]:4]
	2: register[20b:1] = INT_SCARRY register[0:4], [handle:space][[handle:offset]:4]
	3: unique[d300:4] = INT_ADD register[0:4], [handle:space][[handle:offset]:4]
	4: unique[d380:1] = INT_CARRY unique[d300:4], unique[d100:4]
	5: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	6: unique[d480:1] = INT_SCARRY unique[d300:4], unique[d100:4]
	7: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	8: register[0:4] = INT_ADD unique[d300:4], unique[d100:4]
	9: MULTIEQUAL const[1:4]
	10: register[207:1] = INT_SLESS register[0:4], const[0:4]
	11: register[206:1] = INT_EQUAL register[0:4], const[0:4]
	12: unique[dc80:4] = INT_AND register[0:4], const[ff:4]
	13: unique[dd00:1] = POPCOUNT unique[dc80:4]
	14: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	15: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3025 :VUNPCKHPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x15; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vunpckhps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3025(id0.1867) printpiece=[VUNPCKHPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6030  1: vexVVVV_XmmReg : 6028  2: XmmReg1 : 6027  3: YmmReg1 : 6031  4: XmmReg2_m128 : 6029  
Pattern id=1867 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:15:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b6880:10] = CALLOTHER const[1e2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b6880:10]

Line avx.sinc:3033 :VUNPCKHPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x15; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vunpckhps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3033(id0.1868) printpiece=[VUNPCKHPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6035  1: vexVVVV_YmmReg : 6033  2: YmmReg1 : 6032  3: YmmReg2_m256 : 6034  
Pattern id=1868 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:15:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3009 :VUNPCKHPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x15; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vunpckhpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3009(id0.1865) printpiece=[VUNPCKHPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6020  1: vexVVVV_XmmReg : 6018  2: XmmReg1 : 6017  3: YmmReg1 : 6021  4: XmmReg2_m128 : 6019  
Pattern id=1865 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:15:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b6680:10] = CALLOTHER const[1e1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b6680:10]

Line avx.sinc:1965 :VPEXTRW Reg32_m16, XmmReg1, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x15; XmmReg1 ... & Reg32_m16; imm8
{
	Reg32_m16 = vpextrw_avx( XmmReg1, imm8:1 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:1965(id0.1744) printpiece=[VPEXTRW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 5360  1: Reg32_m16 : 5359  2: imm8 : 5361  
Pattern id=1744 pattern=cmb:(ctx:SS:X2:X8:0[011x]:XX,ins:15:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[17a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:3017 :VUNPCKHPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x15; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vunpckhpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3017(id0.1866) printpiece=[VUNPCKHPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6025  1: vexVVVV_YmmReg : 6023  2: YmmReg1 : 6022  3: YmmReg2_m256 : 6024  
Pattern id=1866 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:15:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3374 :PUSH SS        is vexMode=0 & addrsize=0 & byte=0x16 & SS              { push22(SS); }
0: Constructor line ia.sinc:3374(id0.418) printpiece=[PUSH,  ,  A]
Operands 0: SS : 2096  
Pattern id=418 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:16:XX:XX:XX)
Template
	0: unique[9400:2] = COPY register[104:2]
	1: register[10:2] = INT_SUB register[10:2], const[2:2]
	2: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	3: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3375 :PUSH SS        is vexMode=0 & addrsize=1 & byte=0x16 & SS              { pushseg44(SS); }
0: Constructor line ia.sinc:3375(id0.419) printpiece=[PUSH,  ,  A]
Operands 0: SS : 2097  
Pattern id=419 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:16:XX:XX:XX)
Template
	0: register[10:4] = INT_SUB register[10:4], const[4:4]
	1: STORE const[ram:8], register[10:4], register[104:2]

Line avx.sinc:1298 :VMOVLHPS XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x16; (XmmReg1 & YmmReg1) & (mod=0x3 & XmmReg2)
{
	local tmp:16 = vmovlhps_avx( vexVVVV_XmmReg, XmmReg2 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1298(id0.1667) printpiece=[VMOVLHPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4982  1: vexVVVV_XmmReg : 4980  2: XmmReg1 : 4979  3: YmmReg1 : 4983  4: XmmReg2 : 4981  
Pattern id=1667 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:16:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a7980:10] = CALLOTHER const[142:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a7980:10]

Line avx.sinc:1283 :VMOVHPS XmmReg1, vexVVVV_XmmReg, m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x16; (XmmReg1 & YmmReg1) ... & m64
{
	local tmp:16 = vmovhps_avx( vexVVVV_XmmReg, m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:1283(id0.1665) printpiece=[VMOVHPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4973  1: vexVVVV_XmmReg : 4971  2: XmmReg1 : 4970  3: YmmReg1 : 4974  4: m64 : 4972  
Pattern id=1665 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:16:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a7780:10] = CALLOTHER const[141:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a7780:10]

Line avx.sinc:1268 :VMOVHPD XmmReg1, vexVVVV_XmmReg, m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x16; (XmmReg1 & YmmReg1) ... & m64
{
	local tmp:16 = vmovhpd_avx( vexVVVV_XmmReg, m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1268(id0.1663) printpiece=[VMOVHPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4964  1: vexVVVV_XmmReg : 4962  2: XmmReg1 : 4961  3: YmmReg1 : 4965  4: m64 : 4963  
Pattern id=1663 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:16:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a7580:10] = CALLOTHER const[140:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a7580:10]

Line avx2.sinc:1072 :VPERMPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x16; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpermps_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1072(id0.2054) printpiece=[VPERMPS,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6845  1: YmmReg1 : 6844  2: YmmReg2_m256 : 6846  
Pattern id=2054 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:16:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1942 :VPEXTRD rm32, XmmReg1, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x16; XmmReg1 ... & rm32; imm8
{
	rm32 = vpextrd_avx( XmmReg1, imm8:1 );
}
0: Constructor line avx.sinc:1942(id0.1742) printpiece=[VPEXTRD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 5352  1: rm32 : 5351  2: imm8 : 5353  
Pattern id=1742 pattern=cmb:(ctx:SS:X2:X8:0[011x]:XX,ins:16:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[178:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:1442 :VMOVSHDUP XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x16; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovshdup_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1442(id0.1685) printpiece=[VMOVSHDUP,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5052  1: XmmReg1 : 5050  2: YmmReg1 : 5053  3: XmmReg2_m128 : 5051  
Pattern id=1685 pattern=cmb:(ctx:SS:X[010x]:X8:0[001x]:XX,ins:16:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a8780:10] = CALLOTHER const[14b:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a8780:10]

Line avx.sinc:1450 :VMOVSHDUP YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x16; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovshdup_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1450(id0.1686) printpiece=[VMOVSHDUP,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5056  1: YmmReg1 : 5054  2: YmmReg2_m256 : 5055  
Pattern id=1686 pattern=cmb:(ctx:SS:X[010x]:XC:0[001x]:XX,ins:16:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[14b:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3292 :POP SS         is vexMode=0 & addrsize=0 & byte=0x17 & SS              { pop22(SS); }
0: Constructor line ia.sinc:3292(id0.377) printpiece=[POP,  ,  A]
Operands 0: SS : 2061  
Pattern id=377 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:17:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[104:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]

Line ia.sinc:3293 :POP SS         is vexMode=0 & addrsize=1 & byte=0x17 & SS              { popseg44(SS); }
0: Constructor line ia.sinc:3293(id0.378) printpiece=[POP,  ,  A]
Operands 0: SS : 2062  
Pattern id=378 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:17:XX:XX:XX)
Template
	0: register[104:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]

Line avx.sinc:1291 :VMOVHPS m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x17; XmmReg1 ... & m64
{
	m64 = vmovhps_avx( XmmReg1 );
}
0: Constructor line avx.sinc:1291(id0.1666) printpiece=[VMOVHPS,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 4977  1: XmmReg1 : 4976  2: m64 : 4975  
Pattern id=1666 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:17:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[141:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1276 :VMOVHPD m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x17; XmmReg1 ... & m64
{
	m64 = vmovhpd_avx( XmmReg1 );
}
0: Constructor line avx.sinc:1276(id0.1664) printpiece=[VMOVHPD,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 4968  1: XmmReg1 : 4967  2: m64 : 4966  
Pattern id=1664 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:17:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[140:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2658 :VPTEST XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x17; XmmReg1 ... & XmmReg2_m128
{
	vptest_avx( XmmReg1, XmmReg2_m128 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:2658(id0.1823) printpiece=[VPTEST,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5797  1: XmmReg1 : 5795  2: XmmReg2_m128 : 5796  
Pattern id=1823 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:17:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[1c2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2665 :VPTEST YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x17; YmmReg1 ... & YmmReg2_m256
{
	vptest_avx( YmmReg1, YmmReg2_m256 );
	# TODO set flags AF, CF, PF, SF, ZF
}
0: Constructor line avx.sinc:2665(id0.1824) printpiece=[VPTEST,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5800  1: YmmReg1 : 5798  2: YmmReg2_m256 : 5799  
Pattern id=1824 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:17:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[1c2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:907 :VEXTRACTPS rm32, XmmReg1, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x17; XmmReg1 ... & rm32; imm8
{
	rm32 = vextractps_avx( XmmReg1, imm8:1 );
}
0: Constructor line avx.sinc:907(id0.1620) printpiece=[VEXTRACTPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4770  1: XmmReg1 : 4768  2: rm32 : 4767  3: imm8 : 4769  
Pattern id=1620 pattern=cmb:(ctx:SS:X[001x]:X8:0[011x]:XX,ins:17:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[128:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3593 :SBB  rm8,Reg8     is vexMode=0 & byte=0x18; rm8 & Reg8 ...											{ subCarryFlags(  rm8, Reg8 ); resultflags(rm8); }
0: Constructor line ia.sinc:3593(id0.513) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: rm8 : 2247  1: Reg8 : 2248  
Pattern id=513 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:18:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d680:[handle:size]] = COPY register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3107 :VBROADCASTSS XmmReg1, XmmReg2 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x18; (XmmReg1 & YmmReg1) & (mod=0x3 & XmmReg2)
{
        local tmp:16 = vbroadcastss_avx2( XmmReg2 );
        YmmReg1 = zext(tmp);
        # TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:3107(id0.1877) printpiece=[VBROADCASTSS,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 6069  1: YmmReg1 : 6071  2: XmmReg2 : 6070  
Pattern id=1877 pattern=cmb:(ctx:SS:X2:X[x0xx]:[xx00][010x]:XX,ins:18:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[b7180:10] = CALLOTHER const[1e8:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b7180:10]

Line avx.sinc:3074 :VBROADCASTSS XmmReg1, m32 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x18; (XmmReg1 & YmmReg1) ... & m32
{
        local tmp:16 = vbroadcastss_avx( m32 );
        YmmReg1 = zext(tmp);
        # TODO ZmmReg1 = zext(XmmReg1)
}
2: Constructor line avx.sinc:3074(id0.1873) printpiece=[VBROADCASTSS,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 6057  1: YmmReg1 : 6059  2: m32 : 6058  
Pattern id=1873 pattern=cmb:(ctx:SS:X2:X[x0xx]:[xx00][010x]:XX,ins:18:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[b6e80:10] = CALLOTHER const[1e5:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b6e80:10]

Line ia.sinc:3593 :SBB  rm8,Reg8     is vexMode=0 & byte=0x18; rm8 & Reg8 ...											{ subCarryFlags(  rm8, Reg8 ); resultflags(rm8); }
0: Constructor line ia.sinc:3593(id0.513) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: rm8 : 2247  1: Reg8 : 2248  
Pattern id=513 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:18:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d680:[handle:size]] = COPY register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3116 :VBROADCASTSS YmmReg1, XmmReg2 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x18; YmmReg1 & (mod=0x3 & XmmReg2)
{
        YmmReg1 = vbroadcastss_avx2( XmmReg2 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx.sinc:3116(id0.1878) printpiece=[VBROADCASTSS,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6072  1: XmmReg2 : 6073  
Pattern id=1878 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:18:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e8:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3082 :VBROADCASTSS YmmReg1, m32 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x18; YmmReg1 ... & m32
{
        YmmReg1 = vbroadcastss_avx( m32 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
2: Constructor line avx.sinc:3082(id0.1874) printpiece=[VBROADCASTSS,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6060  1: m32 : 6061  
Pattern id=1874 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:18:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e5:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3593 :SBB  rm8,Reg8     is vexMode=0 & byte=0x18; rm8 & Reg8 ...											{ subCarryFlags(  rm8, Reg8 ); resultflags(rm8); }
0: Constructor line ia.sinc:3593(id0.513) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: rm8 : 2247  1: Reg8 : 2248  
Pattern id=513 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:18:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d680:[handle:size]] = COPY register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3142 :VINSERTF128 YmmReg1, vexVVVV_YmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x18; YmmReg1 ... & XmmReg2_m128; imm8
{
	YmmReg1 = vinsertf128_avx( vexVVVV_YmmReg, XmmReg2_m128, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3142(id0.1881) printpiece=[VINSERTF128,  ,  B, ,,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: vexVVVV_YmmReg : 6083  1: YmmReg1 : 6082  2: XmmReg2_m128 : 6084  3: imm8 : 6085  
Pattern id=1881 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][011x]:XX,ins:18:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1eb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3594 :SBB  rm16,Reg16       is vexMode=0 & opsize=0 & byte=0x19; rm16 & Reg16 ...						{ subCarryFlags( rm16, Reg16 ); resultflags(rm16); }
0: Constructor line ia.sinc:3594(id0.514) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: rm16 : 2249  1: Reg16 : 2250  
Pattern id=514 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:19:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d680:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3125 :VBROADCASTSD YmmReg1, XmmReg2 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x19; YmmReg1 & (mod=0x3 & XmmReg2)
{
        YmmReg1 = vbroadcastsd_avx2( XmmReg2 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx.sinc:3125(id0.1879) printpiece=[VBROADCASTSD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6075  1: XmmReg2 : 6076  
Pattern id=1879 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:19:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e9:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3090 :VBROADCASTSD YmmReg1, m64 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x19; YmmReg1 ... & m64
{
        YmmReg1 = vbroadcastsd_avx( m64 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
2: Constructor line avx.sinc:3090(id0.1875) printpiece=[VBROADCASTSD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6063  1: m64 : 6064  
Pattern id=1875 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:19:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e6:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3595 :SBB  rm32,Reg32       is vexMode=0 & opsize=1 & byte=0x19; rm32 & check_rm32_dest ... & Reg32 ...	{ subCarryFlags( rm32, Reg32 ); build check_rm32_dest; resultflags(rm32); }
0: Constructor line ia.sinc:3595(id0.515) printpiece=[SBB,  ,  A, ,,  C]
Operands 0: rm32 : 2251  1: check_rm32_dest : 2253  2: Reg32 : 2252  
Pattern id=515 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:19:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d680:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: MULTIEQUAL const[1:4]
	12: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	15: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	16: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	17: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3125 :VBROADCASTSD YmmReg1, XmmReg2 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x19; YmmReg1 & (mod=0x3 & XmmReg2)
{
        YmmReg1 = vbroadcastsd_avx2( XmmReg2 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx.sinc:3125(id0.1879) printpiece=[VBROADCASTSD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6075  1: XmmReg2 : 6076  
Pattern id=1879 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:19:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e9:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3090 :VBROADCASTSD YmmReg1, m64 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x19; YmmReg1 ... & m64
{
        YmmReg1 = vbroadcastsd_avx( m64 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
2: Constructor line avx.sinc:3090(id0.1875) printpiece=[VBROADCASTSD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6063  1: m64 : 6064  
Pattern id=1875 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:19:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e6:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3125 :VBROADCASTSD YmmReg1, XmmReg2 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x19; YmmReg1 & (mod=0x3 & XmmReg2)
{
        YmmReg1 = vbroadcastsd_avx2( XmmReg2 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3125(id0.1879) printpiece=[VBROADCASTSD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6075  1: XmmReg2 : 6076  
Pattern id=1879 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:19:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e9:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3090 :VBROADCASTSD YmmReg1, m64 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x19; YmmReg1 ... & m64
{
        YmmReg1 = vbroadcastsd_avx( m64 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx.sinc:3090(id0.1875) printpiece=[VBROADCASTSD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6063  1: m64 : 6064  
Pattern id=1875 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:19:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e6:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3134 :VEXTRACTF128 XmmReg2_m128, YmmReg1, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x19; YmmReg1 ... & XmmReg2_m128; imm8
{
	XmmReg2_m128 = vextractf128_avx( YmmReg1, imm8:1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx.sinc:3134(id0.1880) printpiece=[VEXTRACTF128,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: YmmReg1 : 6079  1: XmmReg2_m128 : 6078  2: imm8 : 6080  
Pattern id=1880 pattern=cmb:(ctx:SS:X2:XC:0[011x]:XX,ins:19:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ea:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3600 :SBB  Reg8,rm8     is vexMode=0 & byte=0x1a; rm8 & Reg8 ...											{ subCarryFlags( Reg8, rm8 ); resultflags(Reg8); } 
0: Constructor line ia.sinc:3600(id0.516) printpiece=[SBB,  ,  B, ,,  A]
Operands 0: rm8 : 2255  1: Reg8 : 2254  
Pattern id=516 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:1A:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d680:[handle:size]] = COPY register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3098 :VBROADCASTF128 YmmReg1, m128 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x1A; YmmReg1 ... & m128
{
        YmmReg1 = vbroadcastf128_avx( m128 );
        # TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx.sinc:3098(id0.1876) printpiece=[VBROADCASTF128,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6066  1: m128 : 6067  
Pattern id=1876 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][010x]:XX,ins:1A:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1e7:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3601 :SBB  Reg16,rm16       is vexMode=0 & opsize=0 & byte=0x1b; rm16 & Reg16 ...						{ subCarryFlags( Reg16, rm16 ); resultflags(Reg16); }
0: Constructor line ia.sinc:3601(id0.517) printpiece=[SBB,  ,  B, ,,  A]
Operands 0: rm16 : 2257  1: Reg16 : 2256  
Pattern id=517 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:1B:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d680:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3602 :SBB  Reg32,rm32       is vexMode=0 & opsize=1 & byte=0x1b; rm32 & Reg32 ... & check_Reg32_dest ...	{ subCarryFlags( Reg32, rm32 ); build check_Reg32_dest; resultflags(Reg32); }
0: Constructor line ia.sinc:3602(id0.518) printpiece=[SBB,  ,  B, ,,  A]
Operands 0: rm32 : 2259  1: Reg32 : 2258  2: check_Reg32_dest : 2260  
Pattern id=518 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:1B:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d680:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: MULTIEQUAL const[2:4]
	12: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	15: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	16: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	17: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3574 :SBB  AL,imm8      is vexMode=0 & byte=0x1c; AL & imm8									{ subCarryFlags( AL, imm8 ); resultflags(AL); }
0: Constructor line ia.sinc:3574(id0.505) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: AL : 2228  1: imm8 : 2229  
Pattern id=505 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:1C:XX:XX:XX)
Template
	0: unique[d680:1] = COPY register[200:1]
	1: register[200:1] = INT_LESS register[0:1], [handle:space][[handle:offset]:1]
	2: register[20b:1] = INT_SBORROW register[0:1], [handle:space][[handle:offset]:1]
	3: unique[d880:1] = INT_SUB register[0:1], [handle:space][[handle:offset]:1]
	4: unique[d900:1] = INT_LESS unique[d880:1], unique[d680:1]
	5: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	6: unique[da00:1] = INT_SBORROW unique[d880:1], unique[d680:1]
	7: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	8: register[0:1] = INT_SUB unique[d880:1], unique[d680:1]
	9: register[207:1] = INT_SLESS register[0:1], const[0:1]
	10: register[206:1] = INT_EQUAL register[0:1], const[0:1]
	11: unique[dc80:1] = INT_AND register[0:1], const[ff:1]
	12: unique[dd00:1] = POPCOUNT unique[dc80:1]
	13: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	14: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1638 :VPABSB XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpabsb_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1638(id0.1708) printpiece=[VPABSB,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5159  1: XmmReg1 : 5157  2: YmmReg1 : 5160  3: XmmReg2_m128 : 5158  
Pattern id=1708 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:1C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[aa000:10] = CALLOTHER const[156:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aa000:10]

Line avx2.sinc:23 :VPABSB YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpabsb_avx2( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:23(id0.1927) printpiece=[VPABSB,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6260  1: YmmReg1 : 6258  2: YmmReg2_m256 : 6259  
Pattern id=1927 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:1C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1f9:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3575 :SBB  AX,imm16     is vexMode=0 & opsize=0 & byte=0x1d; AX & imm16						{ subCarryFlags( AX, imm16 ); resultflags(AX); }
0: Constructor line ia.sinc:3575(id0.506) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: AX : 2230  1: imm16 : 2231  
Pattern id=506 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:1D:XX:XX:XX)
Template
	0: unique[d680:2] = INT_ZEXT register[200:1]
	1: register[200:1] = INT_LESS register[0:2], [handle:space][[handle:offset]:2]
	2: register[20b:1] = INT_SBORROW register[0:2], [handle:space][[handle:offset]:2]
	3: unique[d880:2] = INT_SUB register[0:2], [handle:space][[handle:offset]:2]
	4: unique[d900:1] = INT_LESS unique[d880:2], unique[d680:2]
	5: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	6: unique[da00:1] = INT_SBORROW unique[d880:2], unique[d680:2]
	7: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	8: register[0:2] = INT_SUB unique[d880:2], unique[d680:2]
	9: register[207:1] = INT_SLESS register[0:2], const[0:2]
	10: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	11: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	12: unique[dd00:1] = POPCOUNT unique[dc80:2]
	13: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	14: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:663 :VCVTPS2PH XmmReg2_m64, XmmReg1, imm8 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x1D; XmmReg1 ... & XmmReg2_m64; imm8
{
        XmmReg2_m64 = vcvtps2ph_f16c( XmmReg1, imm8:1 );
        # TODO ZmmReg2 = zext(XmmReg2)
}
1: Constructor line avx.sinc:663(id0.1597) printpiece=[VCVTPS2PH,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 4659  1: XmmReg2_m64 : 4658  2: imm8 : 4660  
Pattern id=1597 pattern=cmb:(ctx:SS:X2:X[x0xx]:[xx00][011x]:XX,ins:1D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[117:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3575 :SBB  AX,imm16     is vexMode=0 & opsize=0 & byte=0x1d; AX & imm16						{ subCarryFlags( AX, imm16 ); resultflags(AX); }
0: Constructor line ia.sinc:3575(id0.506) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: AX : 2230  1: imm16 : 2231  
Pattern id=506 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:1D:XX:XX:XX)
Template
	0: unique[d680:2] = INT_ZEXT register[200:1]
	1: register[200:1] = INT_LESS register[0:2], [handle:space][[handle:offset]:2]
	2: register[20b:1] = INT_SBORROW register[0:2], [handle:space][[handle:offset]:2]
	3: unique[d880:2] = INT_SUB register[0:2], [handle:space][[handle:offset]:2]
	4: unique[d900:1] = INT_LESS unique[d880:2], unique[d680:2]
	5: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	6: unique[da00:1] = INT_SBORROW unique[d880:2], unique[d680:2]
	7: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	8: register[0:2] = INT_SUB unique[d880:2], unique[d680:2]
	9: register[207:1] = INT_SLESS register[0:2], const[0:2]
	10: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	11: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	12: unique[dd00:1] = POPCOUNT unique[dc80:2]
	13: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	14: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:670 :VCVTPS2PH XmmReg2_m128, YmmReg1, imm8 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x1D; YmmReg1 ... & XmmReg2_m128; imm8
{
        XmmReg2_m128 = vcvtps2ph_f16c( YmmReg1, imm8:1 );
        # TODO ZmmReg2 = zext(XmmReg2)
}
1: Constructor line avx.sinc:670(id0.1598) printpiece=[VCVTPS2PH,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: YmmReg1 : 4662  1: XmmReg2_m128 : 4661  2: imm8 : 4663  
Pattern id=1598 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][011x]:XX,ins:1D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[117:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3576 :SBB  EAX,imm32    is vexMode=0 & opsize=1 & byte=0x1d; EAX & check_EAX_dest & imm32	{ subCarryFlags( EAX, imm32 ); build check_EAX_dest; resultflags(EAX); }
0: Constructor line ia.sinc:3576(id0.507) printpiece=[SBB,  ,  A, ,,  C]
Operands 0: EAX : 2232  1: check_EAX_dest : 2234  2: imm32 : 2233  
Pattern id=507 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:1D:XX:XX:XX)
Template
	0: unique[d680:4] = INT_ZEXT register[200:1]
	1: register[200:1] = INT_LESS register[0:4], [handle:space][[handle:offset]:4]
	2: register[20b:1] = INT_SBORROW register[0:4], [handle:space][[handle:offset]:4]
	3: unique[d880:4] = INT_SUB register[0:4], [handle:space][[handle:offset]:4]
	4: unique[d900:1] = INT_LESS unique[d880:4], unique[d680:4]
	5: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	6: unique[da00:1] = INT_SBORROW unique[d880:4], unique[d680:4]
	7: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	8: register[0:4] = INT_SUB unique[d880:4], unique[d680:4]
	9: MULTIEQUAL const[1:4]
	10: register[207:1] = INT_SLESS register[0:4], const[0:4]
	11: register[206:1] = INT_EQUAL register[0:4], const[0:4]
	12: unique[dc80:4] = INT_AND register[0:4], const[ff:4]
	13: unique[dd00:1] = POPCOUNT unique[dc80:4]
	14: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	15: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:663 :VCVTPS2PH XmmReg2_m64, XmmReg1, imm8 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x1D; XmmReg1 ... & XmmReg2_m64; imm8
{
        XmmReg2_m64 = vcvtps2ph_f16c( XmmReg1, imm8:1 );
        # TODO ZmmReg2 = zext(XmmReg2)
}
1: Constructor line avx.sinc:663(id0.1597) printpiece=[VCVTPS2PH,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 4659  1: XmmReg2_m64 : 4658  2: imm8 : 4660  
Pattern id=1597 pattern=cmb:(ctx:SS:X2:X[x0xx]:[xx00][011x]:XX,ins:1D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[117:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3576 :SBB  EAX,imm32    is vexMode=0 & opsize=1 & byte=0x1d; EAX & check_EAX_dest & imm32	{ subCarryFlags( EAX, imm32 ); build check_EAX_dest; resultflags(EAX); }
0: Constructor line ia.sinc:3576(id0.507) printpiece=[SBB,  ,  A, ,,  C]
Operands 0: EAX : 2232  1: check_EAX_dest : 2234  2: imm32 : 2233  
Pattern id=507 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:1D:XX:XX:XX)
Template
	0: unique[d680:4] = INT_ZEXT register[200:1]
	1: register[200:1] = INT_LESS register[0:4], [handle:space][[handle:offset]:4]
	2: register[20b:1] = INT_SBORROW register[0:4], [handle:space][[handle:offset]:4]
	3: unique[d880:4] = INT_SUB register[0:4], [handle:space][[handle:offset]:4]
	4: unique[d900:1] = INT_LESS unique[d880:4], unique[d680:4]
	5: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	6: unique[da00:1] = INT_SBORROW unique[d880:4], unique[d680:4]
	7: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	8: register[0:4] = INT_SUB unique[d880:4], unique[d680:4]
	9: MULTIEQUAL const[1:4]
	10: register[207:1] = INT_SLESS register[0:4], const[0:4]
	11: register[206:1] = INT_EQUAL register[0:4], const[0:4]
	12: unique[dc80:4] = INT_AND register[0:4], const[ff:4]
	13: unique[dd00:1] = POPCOUNT unique[dc80:4]
	14: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	15: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:670 :VCVTPS2PH XmmReg2_m128, YmmReg1, imm8 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x1D; YmmReg1 ... & XmmReg2_m128; imm8
{
        XmmReg2_m128 = vcvtps2ph_f16c( YmmReg1, imm8:1 );
        # TODO ZmmReg2 = zext(XmmReg2)
}
1: Constructor line avx.sinc:670(id0.1598) printpiece=[VCVTPS2PH,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: YmmReg1 : 4662  1: XmmReg2_m128 : 4661  2: imm8 : 4663  
Pattern id=1598 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][011x]:XX,ins:1D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[117:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:1647 :VPABSW XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpabsw_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1647(id0.1709) printpiece=[VPABSW,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5164  1: XmmReg1 : 5162  2: YmmReg1 : 5165  3: XmmReg2_m128 : 5163  
Pattern id=1709 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:1D:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[aa180:10] = CALLOTHER const[157:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aa180:10]

Line avx.sinc:663 :VCVTPS2PH XmmReg2_m64, XmmReg1, imm8 is $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x1D; XmmReg1 ... & XmmReg2_m64; imm8
{
        XmmReg2_m64 = vcvtps2ph_f16c( XmmReg1, imm8:1 );
        # TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx.sinc:663(id0.1597) printpiece=[VCVTPS2PH,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 4659  1: XmmReg2_m64 : 4658  2: imm8 : 4660  
Pattern id=1597 pattern=cmb:(ctx:SS:X2:X[x0xx]:[xx00][011x]:XX,ins:1D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[117:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:31 :VPABSW YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpabsw_avx2( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:31(id0.1928) printpiece=[VPABSW,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6264  1: YmmReg1 : 6262  2: YmmReg2_m256 : 6263  
Pattern id=1928 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:1D:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1fa:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:670 :VCVTPS2PH XmmReg2_m128, YmmReg1, imm8 is $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x1D; YmmReg1 ... & XmmReg2_m128; imm8
{
        XmmReg2_m128 = vcvtps2ph_f16c( YmmReg1, imm8:1 );
        # TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx.sinc:670(id0.1598) printpiece=[VCVTPS2PH,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: YmmReg1 : 4662  1: XmmReg2_m128 : 4661  2: imm8 : 4663  
Pattern id=1598 pattern=cmb:(ctx:SS:X2:X[x1xx]:[xx00][011x]:XX,ins:1D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[117:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3376 :PUSH DS        is vexMode=0 & addrsize=0 & byte=0x1e & DS              { push22(DS); }
0: Constructor line ia.sinc:3376(id0.420) printpiece=[PUSH,  ,  A]
Operands 0: DS : 2098  
Pattern id=420 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:1E:XX:XX:XX)
Template
	0: unique[9400:2] = COPY register[106:2]
	1: register[10:2] = INT_SUB register[10:2], const[2:2]
	2: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	3: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3377 :PUSH DS        is vexMode=0 & addrsize=1 & byte=0x1e & DS              { pushseg44(DS); }
0: Constructor line ia.sinc:3377(id0.421) printpiece=[PUSH,  ,  A]
Operands 0: DS : 2099  
Pattern id=421 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:1E:XX:XX:XX)
Template
	0: register[10:4] = INT_SUB register[10:4], const[4:4]
	1: STORE const[ram:8], register[10:4], register[106:2]

Line avx.sinc:1656 :VPABSD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpabsd_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1656(id0.1710) printpiece=[VPABSD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5169  1: XmmReg1 : 5167  2: YmmReg1 : 5170  3: XmmReg2_m128 : 5168  
Pattern id=1710 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:1E:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[aa300:10] = CALLOTHER const[158:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aa300:10]

Line avx2.sinc:39 :VPABSD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x1E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpabsd_avx2( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:39(id0.1929) printpiece=[VPABSD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6268  1: YmmReg1 : 6266  2: YmmReg2_m256 : 6267  
Pattern id=1929 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:1E:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1fb:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3288 :POP DS         is vexMode=0 & addrsize=0 & byte=0x1f & DS              { pop22(DS); }
0: Constructor line ia.sinc:3288(id0.373) printpiece=[POP,  ,  A]
Operands 0: DS : 2057  
Pattern id=373 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:1F:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[106:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]

Line ia.sinc:3289 :POP DS         is vexMode=0 & addrsize=1 & byte=0x1f & DS              { popseg44(DS); }
0: Constructor line ia.sinc:3289(id0.374) printpiece=[POP,  ,  A]
Operands 0: DS : 2058  
Pattern id=374 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:1F:XX:XX:XX)
Template
	0: register[106:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]

Line ia.sinc:1721 :AND rm8,Reg8      is vexMode=0 & byte=0x20; rm8 & Reg8 ...                     { logicalflags();   rm8 =   rm8 &  Reg8; resultflags(  rm8); }
0: Constructor line ia.sinc:1721(id0.60) printpiece=[AND,  ,  A, ,,  B]
Operands 0: rm8 : 1476  1: Reg8 : 1477  
Pattern id=60 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:20:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2200 :VPMOVSXBW XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x20; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovsxbw_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2200(id0.1769) printpiece=[VPMOVSXBW,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5503  1: XmmReg1 : 5501  2: YmmReg1 : 5504  3: XmmReg2_m64 : 5502  
Pattern id=1769 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:20:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[af180:10] = CALLOTHER const[194:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[af180:10]

Line avx.sinc:2036 :VPINSRB XmmReg1, vexVVVV_XmmReg, Reg32_m8, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x20; (XmmReg1 & YmmReg1) ... & Reg32_m8; imm8
{
	local tmp:16 = vpinsrb_avx( vexVVVV_XmmReg, Reg32_m8, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2036(id0.1752) printpiece=[VPINSRB,  ,  B, ,,  ,  A, ,,  ,  D, ,,  ,  E]
Operands 0: vexVVVV_XmmReg : 5405  1: XmmReg1 : 5404  2: YmmReg1 : 5408  3: Reg32_m8 : 5406  4: imm8 : 5407  
Pattern id=1752 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][011x]:XX,ins:20:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[ad800:10] = CALLOTHER const[182:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ad800:10]

Line avx2.sinc:415 :VPMOVSXBW YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x20; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovsxbw_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:415(id0.1976) printpiece=[VPMOVSXBW,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6497  1: YmmReg1 : 6495  2: XmmReg2_m128 : 6496  
Pattern id=1976 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:20:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[22a:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1722 :AND rm16,Reg16    is vexMode=0 & opsize=0 & byte=0x21; rm16 & Reg16 ...        { logicalflags();  rm16 =  rm16 & Reg16; resultflags( rm16); }
0: Constructor line ia.sinc:1722(id0.61) printpiece=[AND,  ,  A, ,,  B]
Operands 0: rm16 : 1478  1: Reg16 : 1479  
Pattern id=61 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:21:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1723 :AND rm32,Reg32    is vexMode=0 & opsize=1 & byte=0x21; rm32 & check_rm32_dest ... & Reg32 ...        { logicalflags();  rm32 =  rm32 & Reg32; build check_rm32_dest; resultflags( rm32); }
0: Constructor line ia.sinc:1723(id0.62) printpiece=[AND,  ,  A, ,,  C]
Operands 0: rm32 : 1480  1: check_rm32_dest : 1482  2: Reg32 : 1481  
Pattern id=62 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:21:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2209 :VPMOVSXBD XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x21; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpmovsxbd_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2209(id0.1770) printpiece=[VPMOVSXBD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5508  1: XmmReg1 : 5506  2: YmmReg1 : 5509  3: XmmReg2_m32 : 5507  
Pattern id=1770 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:21:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[af300:10] = CALLOTHER const[195:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[af300:10]

Line avx.sinc:978 :VINSERTPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x21; (XmmReg1 & YmmReg1) ... & XmmReg2_m32; imm8
{
	local tmp:16 = vinsertps_avx( vexVVVV_XmmReg, XmmReg2_m32, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:978(id0.1629) printpiece=[VINSERTPS,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 4816  1: vexVVVV_XmmReg : 4813  2: XmmReg1 : 4812  3: YmmReg1 : 4817  4: XmmReg2_m32 : 4814  5: imm8 : 4815  
Pattern id=1629 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:21:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a5580:10] = CALLOTHER const[12d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a5580:10]

Line avx2.sinc:423 :VPMOVSXBD YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x21; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpmovsxbd_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:423(id0.1977) printpiece=[VPMOVSXBD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6501  1: YmmReg1 : 6499  2: XmmReg2_m64 : 6500  
Pattern id=1977 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:21:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[22b:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1727 :AND Reg8,rm8      is vexMode=0 & byte=0x22; rm8 & Reg8 ...                            { logicalflags();  Reg8 =  Reg8 &   rm8; resultflags( Reg8); } 
0: Constructor line ia.sinc:1727(id0.63) printpiece=[AND,  ,  B, ,,  A]
Operands 0: rm8 : 1484  1: Reg8 : 1483  
Pattern id=63 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:22:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2218 :VPMOVSXBQ XmmReg1, XmmReg2_m16 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x22; (XmmReg1 & YmmReg1) ... & XmmReg2_m16
{
	local tmp:16 = vpmovsxbq_avx( XmmReg2_m16 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2218(id0.1771) printpiece=[VPMOVSXBQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5513  1: XmmReg1 : 5511  2: YmmReg1 : 5514  3: XmmReg2_m16 : 5512  
Pattern id=1771 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:22:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[af480:10] = CALLOTHER const[196:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[af480:10]

Line avx.sinc:2045 :VPINSRD XmmReg1, vexVVVV_XmmReg, rm32, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x22; (XmmReg1 & YmmReg1) ... & rm32; imm8
{
	local tmp:16 = vpinsrd_avx( vexVVVV_XmmReg, rm32, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2045(id0.1753) printpiece=[VPINSRD,  ,  B, ,,  ,  A, ,,  ,  D, ,,  ,  E]
Operands 0: vexVVVV_XmmReg : 5411  1: XmmReg1 : 5410  2: YmmReg1 : 5414  3: rm32 : 5412  4: imm8 : 5413  
Pattern id=1753 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][011x]:XX,ins:22:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[ad980:10] = CALLOTHER const[183:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ad980:10]

Line avx2.sinc:431 :VPMOVSXBQ YmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x22; YmmReg1 ... & XmmReg2_m32
{
	YmmReg1 = vpmovsxbq_avx2( XmmReg2_m32 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:431(id0.1978) printpiece=[VPMOVSXBQ,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6505  1: YmmReg1 : 6503  2: XmmReg2_m32 : 6504  
Pattern id=1978 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:22:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[22c:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1728 :AND Reg16,rm16    is vexMode=0 & opsize=0 & byte=0x23; rm16 & Reg16 ...        { logicalflags(); Reg16 = Reg16 &  rm16; resultflags(Reg16); }
0: Constructor line ia.sinc:1728(id0.64) printpiece=[AND,  ,  B, ,,  A]
Operands 0: rm16 : 1486  1: Reg16 : 1485  
Pattern id=64 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:23:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1729 :AND Reg32,rm32    is vexMode=0 & opsize=1 & byte=0x23; rm32 & Reg32 ... & check_Reg32_dest ...        { logicalflags(); Reg32 = Reg32 &  rm32; build check_Reg32_dest; resultflags(Reg32); }
0: Constructor line ia.sinc:1729(id0.65) printpiece=[AND,  ,  B, ,,  A]
Operands 0: rm32 : 1488  1: Reg32 : 1487  2: check_Reg32_dest : 1489  
Pattern id=65 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:23:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[2:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2227 :VPMOVSXWD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x23; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovsxwd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2227(id0.1772) printpiece=[VPMOVSXWD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5518  1: XmmReg1 : 5516  2: YmmReg1 : 5519  3: XmmReg2_m64 : 5517  
Pattern id=1772 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:23:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[af600:10] = CALLOTHER const[197:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[af600:10]

Line avx2.sinc:439 :VPMOVSXWD YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x23; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovsxwd_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:439(id0.1979) printpiece=[VPMOVSXWD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6509  1: YmmReg1 : 6507  2: XmmReg2_m128 : 6508  
Pattern id=1979 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:23:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[22d:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1704 :AND AL,imm8       is vexMode=0 & byte=0x24; AL & imm8                                 { logicalflags();    AL =    AL &  imm8; resultflags(   AL); }
0: Constructor line ia.sinc:1704(id0.52) printpiece=[AND,  ,  A, ,,  B]
Operands 0: AL : 1457  1: imm8 : 1458  
Pattern id=52 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:24:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: register[0:1] = INT_AND register[0:1], [handle:space][[handle:offset]:1]
	3: register[207:1] = INT_SLESS register[0:1], const[0:1]
	4: register[206:1] = INT_EQUAL register[0:1], const[0:1]
	5: unique[dc80:1] = INT_AND register[0:1], const[ff:1]
	6: unique[dd00:1] = POPCOUNT unique[dc80:1]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2236 :VPMOVSXWQ XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x24; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpmovsxwq_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2236(id0.1773) printpiece=[VPMOVSXWQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5523  1: XmmReg1 : 5521  2: YmmReg1 : 5524  3: XmmReg2_m32 : 5522  
Pattern id=1773 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:24:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[af780:10] = CALLOTHER const[198:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[af780:10]

Line avx2.sinc:447 :VPMOVSXWQ YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x24; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpmovsxwq_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:447(id0.1980) printpiece=[VPMOVSXWQ,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6513  1: YmmReg1 : 6511  2: XmmReg2_m64 : 6512  
Pattern id=1980 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:24:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[22e:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1705 :AND AX,imm16      is vexMode=0 & opsize=0 & byte=0x25; AX & imm16          { logicalflags();    AX =    AX & imm16; resultflags(   AX); }
0: Constructor line ia.sinc:1705(id0.53) printpiece=[AND,  ,  A, ,,  B]
Operands 0: AX : 1459  1: imm16 : 1460  
Pattern id=53 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:25:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: register[0:2] = INT_AND register[0:2], [handle:space][[handle:offset]:2]
	3: register[207:1] = INT_SLESS register[0:2], const[0:2]
	4: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	5: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	6: unique[dd00:1] = POPCOUNT unique[dc80:2]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1706 :AND EAX,imm32     is vexMode=0 & opsize=1 & byte=0x25; EAX & check_EAX_dest & imm32         { logicalflags();   EAX =   EAX & imm32; build check_EAX_dest; resultflags(  EAX); }
0: Constructor line ia.sinc:1706(id0.54) printpiece=[AND,  ,  A, ,,  C]
Operands 0: EAX : 1461  1: check_EAX_dest : 1463  2: imm32 : 1462  
Pattern id=54 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:25:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: register[0:4] = INT_AND register[0:4], [handle:space][[handle:offset]:4]
	3: MULTIEQUAL const[1:4]
	4: register[207:1] = INT_SLESS register[0:4], const[0:4]
	5: register[206:1] = INT_EQUAL register[0:4], const[0:4]
	6: unique[dc80:4] = INT_AND register[0:4], const[ff:4]
	7: unique[dd00:1] = POPCOUNT unique[dc80:4]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2245 :VPMOVSXDQ XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x25; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovsxdq_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2245(id0.1774) printpiece=[VPMOVSXDQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5528  1: XmmReg1 : 5526  2: YmmReg1 : 5529  3: XmmReg2_m64 : 5527  
Pattern id=1774 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:25:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[af900:10] = CALLOTHER const[199:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[af900:10]

Line avx2.sinc:455 :VPMOVSXDQ YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x25; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovsxdq_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:455(id0.1981) printpiece=[VPMOVSXDQ,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6517  1: YmmReg1 : 6515  2: XmmReg2_m128 : 6516  
Pattern id=1981 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:25:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[22f:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1503 :^instruction is instrPhase=0 & over=0x26; instruction     [ segover=4; ]  {} # ES override
:^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1503(id0.3) printpiece=[ A]
Operands 0: instruction : 1338  
Pattern id=3 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:26:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:2410 :DAA            is vexMode=0 & bit64=0 & byte=0x27       { local car = ((AL & 0xf) > 9) | AF;
                           AL = AL + 6 * car;
                           CF = CF | car * carry(AL,6);
                           AF = car;
                           car = ((AL & 0xf0) > 0x90) | CF;
                           AL = AL + 0x60 * car;
                           CF = car; }
0: Constructor line ia.sinc:2410(id0.160) printpiece=[DAA]
Operands 
Pattern id=160 pattern=cmb:(ctx:X[0xxx]:XX:X[0xxx]:XX,ins:27:XX:XX:XX)
Template
	0: unique[21980:1] = INT_AND register[0:1], const[f:1]
	1: unique[21a00:1] = INT_LESS const[9:1], unique[21980:1]
	2: unique[21b00:1] = INT_OR unique[21a00:1], register[204:1]
	3: unique[21b80:1] = INT_MULT const[6:1], unique[21b00:1]
	4: register[0:1] = INT_ADD register[0:1], unique[21b80:1]
	5: unique[21c80:1] = INT_CARRY register[0:1], const[6:1]
	6: unique[21d00:1] = INT_MULT unique[21b00:1], unique[21c80:1]
	7: register[200:1] = INT_OR register[200:1], unique[21d00:1]
	8: register[204:1] = COPY unique[21b00:1]
	9: unique[21e00:1] = INT_AND register[0:1], const[f0:1]
	10: unique[21e80:1] = INT_LESS const[90:1], unique[21e00:1]
	11: unique[21b00:1] = INT_OR unique[21e80:1], register[200:1]
	12: unique[21f80:1] = INT_MULT const[60:1], unique[21b00:1]
	13: register[0:1] = INT_ADD register[0:1], unique[21f80:1]
	14: register[200:1] = COPY unique[21b00:1]

Line ia.sinc:3800 :SUB  rm8,Reg8     is vexMode=0 & byte=0x28; rm8 & Reg8 ...                 { subflags(  rm8,Reg8 );   rm8 =   rm8 -  Reg8; resultflags(  rm8); }
0: Constructor line ia.sinc:3800(id0.576) printpiece=[SUB,  ,  A, ,,  B]
Operands 0: rm8 : 2382  1: Reg8 : 2383  
Pattern id=576 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:28:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1149 :VMOVAPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x28; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovaps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1149(id0.1650) printpiece=[VMOVAPS,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4914  1: XmmReg1 : 4912  2: YmmReg1 : 4915  3: XmmReg2_m128 : 4913  
Pattern id=1650 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:28:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a6a00:10] = CALLOTHER const[13a:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a6a00:10]

Line avx.sinc:1119 :VMOVAPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x28; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovapd_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1119(id0.1646) printpiece=[VMOVAPD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4900  1: XmmReg1 : 4898  2: YmmReg1 : 4901  3: XmmReg2_m128 : 4899  
Pattern id=1646 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:28:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a6700:10] = CALLOTHER const[139:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a6700:10]

Line avx.sinc:2308 :VPMULDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x28; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmuldq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2308(id0.1781) printpiece=[VPMULDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5564  1: vexVVVV_XmmReg : 5562  2: XmmReg1 : 5561  3: YmmReg1 : 5565  4: XmmReg2_m128 : 5563  
Pattern id=1781 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:28:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b0380:10] = CALLOTHER const[1a0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0380:10]

Line avx.sinc:1164 :VMOVAPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x28; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovaps_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1164(id0.1652) printpiece=[VMOVAPS,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4921  1: YmmReg1 : 4919  2: YmmReg2_m256 : 4920  
Pattern id=1652 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:28:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[13a:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1134 :VMOVAPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x28; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovapd_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1134(id0.1648) printpiece=[VMOVAPD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4907  1: YmmReg1 : 4905  2: YmmReg2_m256 : 4906  
Pattern id=1648 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:28:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[139:4], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:511 :VPMULDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x28; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmuldq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:511(id0.1988) printpiece=[VPMULDQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6546  1: vexVVVV_YmmReg : 6544  2: YmmReg1 : 6543  3: YmmReg2_m256 : 6545  
Pattern id=1988 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:28:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[236:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3801 :SUB  rm16,Reg16       is vexMode=0 & opsize=0 & byte=0x29; rm16 & Reg16 ...        { subflags( rm16,Reg16);  rm16 =  rm16 - Reg16; resultflags( rm16); }
0: Constructor line ia.sinc:3801(id0.577) printpiece=[SUB,  ,  A, ,,  B]
Operands 0: rm16 : 2384  1: Reg16 : 2385  
Pattern id=577 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:29:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3802 :SUB  rm32,Reg32       is vexMode=0 & opsize=1 & byte=0x29; rm32 & check_rm32_dest ... & Reg32 ...        { subflags( rm32,Reg32);  rm32 =  rm32 - Reg32; build check_rm32_dest; resultflags( rm32); }
0: Constructor line ia.sinc:3802(id0.578) printpiece=[SUB,  ,  A, ,,  C]
Operands 0: rm32 : 2386  1: check_rm32_dest : 2388  2: Reg32 : 2387  
Pattern id=578 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:29:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1157 :VMOVAPS XmmReg2_m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x29; XmmReg1 ... & XmmReg2_m128
{
	XmmReg2_m128 = vmovaps_avx( XmmReg1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx.sinc:1157(id0.1651) printpiece=[VMOVAPS,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 4918  1: XmmReg1 : 4917  2: XmmReg2_m128 : 4916  
Pattern id=1651 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:29:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[13a:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1127 :VMOVAPD XmmReg2_m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x29; XmmReg1 ... & XmmReg2_m128
{
	XmmReg2_m128 = vmovapd_avx( XmmReg1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx.sinc:1127(id0.1647) printpiece=[VMOVAPD,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 4904  1: XmmReg1 : 4903  2: XmmReg2_m128 : 4902  
Pattern id=1647 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:29:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[139:4], [handle:space][[handle:offset]:[handle:size]]

Line avx_manual.sinc:111 :VPCMPEQQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x29; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	XmmReg1[0,64] = zext(vexVVVV_XmmReg[0,64] == XmmReg2_m128[0,64]) * 0xffffffffffffffff:8;
	XmmReg1[64,64] = zext(vexVVVV_XmmReg[64,64] == XmmReg2_m128[64,64]) * 0xffffffffffffffff:8;
	YmmReg1 = zext(XmmReg1);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx_manual.sinc:111(id0.1923) printpiece=[VPCMPEQQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6241  1: vexVVVV_XmmReg : 6239  2: XmmReg1 : 6238  3: YmmReg1 : 6242  4: XmmReg2_m128 : 6240  
Pattern id=1923 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:29:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b8b00:1] = INT_EQUAL [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	4: unique[b8b80:8] = INT_ZEXT unique[b8b00:1]
	5: [handle:space][[handle:offset+0]:8] = INT_MULT unique[b8b80:8], const[ffffffffffffffff:8]
	6: unique[b8c80:1] = INT_EQUAL [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]
	7: unique[b8d00:8] = INT_ZEXT unique[b8c80:1]
	8: [handle:space][[handle:offset+80008]:8] = INT_MULT unique[b8d00:8], const[ffffffffffffffff:8]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1171 :VMOVAPS YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x29; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = vmovaps_avx( YmmReg1 );
	# TODO ZmmReg2 = zext(YmmReg2)
}
0: Constructor line avx.sinc:1171(id0.1653) printpiece=[VMOVAPS,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 4924  1: YmmReg1 : 4923  2: YmmReg2_m256 : 4922  
Pattern id=1653 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:29:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[13a:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1141 :VMOVAPD YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x29; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = vmovapd_avx( YmmReg1 );
	# TODO ZmmReg2 = zext(YmmReg2)
}
0: Constructor line avx.sinc:1141(id0.1649) printpiece=[VMOVAPD,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 4910  1: YmmReg1 : 4909  2: YmmReg2_m256 : 4908  
Pattern id=1649 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:29:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[139:4], [handle:space][[handle:offset]:[handle:size]]

Line avx2_manual.sinc:113 :VPCMPEQQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x29; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1[0,64] = zext(vexVVVV_YmmReg[0,64] == YmmReg2_m256[0,64]) * 0xffffffffffffffff:8;
	YmmReg1[64,64] = zext(vexVVVV_YmmReg[64,64] == YmmReg2_m256[64,64]) * 0xffffffffffffffff:8;
	YmmReg1[128,64] = zext(vexVVVV_YmmReg[128,64] == YmmReg2_m256[128,64]) * 0xffffffffffffffff:8;
	YmmReg1[192,64] = zext(vexVVVV_YmmReg[192,64] == YmmReg2_m256[192,64]) * 0xffffffffffffffff:8;
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2_manual.sinc:113(id0.2079) printpiece=[VPCMPEQQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6944  1: vexVVVV_YmmReg : 6942  2: YmmReg1 : 6941  3: YmmReg2_m256 : 6943  
Pattern id=2079 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:29:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: unique[c1b00:1] = INT_EQUAL [handle:space][[handle:offset+0]:8], [handle:space][[handle:offset+0]:8]
	3: unique[c1b80:8] = INT_ZEXT unique[c1b00:1]
	4: [handle:space][[handle:offset+0]:8] = INT_MULT unique[c1b80:8], const[ffffffffffffffff:8]
	5: unique[c1c80:1] = INT_EQUAL [handle:space][[handle:offset+80008]:8], [handle:space][[handle:offset+80008]:8]
	6: unique[c1d00:8] = INT_ZEXT unique[c1c80:1]
	7: [handle:space][[handle:offset+80008]:8] = INT_MULT unique[c1d00:8], const[ffffffffffffffff:8]
	8: unique[c1e00:1] = INT_EQUAL [handle:space][[handle:offset+100010]:8], [handle:space][[handle:offset+100010]:8]
	9: unique[c1e80:8] = INT_ZEXT unique[c1e00:1]
	10: [handle:space][[handle:offset+100010]:8] = INT_MULT unique[c1e80:8], const[ffffffffffffffff:8]
	11: unique[c1f80:1] = INT_EQUAL [handle:space][[handle:offset+180018]:8], [handle:space][[handle:offset+180018]:8]
	12: unique[c2000:8] = INT_ZEXT unique[c1f80:1]
	13: [handle:space][[handle:offset+180018]:8] = INT_MULT unique[c2000:8], const[ffffffffffffffff:8]

Line ia.sinc:3806 :SUB  Reg8,rm8     is vexMode=0 & byte=0x2a; rm8 & Reg8 ...                 { subflags( Reg8,rm8  );  Reg8 =  Reg8 -   rm8; resultflags( Reg8); } 
0: Constructor line ia.sinc:3806(id0.579) printpiece=[SUB,  ,  B, ,,  A]
Operands 0: rm8 : 2390  1: Reg8 : 2389  
Pattern id=579 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:2A:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1367 :VMOVNTDQA XmmReg1, m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x2A; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vmovntdqa_avx( m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1367(id0.1676) printpiece=[VMOVNTDQA,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5019  1: XmmReg1 : 5017  2: YmmReg1 : 5020  3: m128 : 5018  
Pattern id=1676 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:2A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a8100:10] = CALLOTHER const[147:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a8100:10]

Line avx2.sinc:7 :VMOVNTDQA YmmReg1, m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x2A; YmmReg1 ... & m256
{
	YmmReg1 = vmovntdqa_avx2( m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:7(id0.1925) printpiece=[VMOVNTDQA,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6250  1: YmmReg1 : 6248  2: m256 : 6249  
Pattern id=1925 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:2A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1f7:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:723 :VCVTSI2SS XmmReg1, vexVVVV_XmmReg, rm32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2A; (XmmReg1 & YmmReg1) ... & rm32
{
	local tmp:16 = vcvtsi2ss_avx( vexVVVV_XmmReg, rm32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:723(id0.1602) printpiece=[VCVTSI2SS,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 4680  1: XmmReg1 : 4679  2: YmmReg1 : 4682  3: rm32 : 4681  
Pattern id=1602 pattern=cmb:(ctx:SS:X4:X[10xx]:[xx00][001x]:XX,ins:2A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a3900:10] = CALLOTHER const[11b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3900:10]

Line avx.sinc:704 :VCVTSI2SD XmmReg1, vexVVVV_XmmReg, rm32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2A; (XmmReg1 & YmmReg1) ... & rm32
{
	local tmp:16 = vcvtsi2sd_avx( vexVVVV_XmmReg, rm32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:704(id0.1601) printpiece=[VCVTSI2SD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 4675  1: XmmReg1 : 4674  2: YmmReg1 : 4677  3: rm32 : 4676  
Pattern id=1601 pattern=cmb:(ctx:SS:X8:X[10xx]:[xx00][001x]:XX,ins:2A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a3780:10] = CALLOTHER const[11a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3780:10]

Line ia.sinc:3807 :SUB  Reg16,rm16       is vexMode=0 & opsize=0 & byte=0x2b; rm16 & Reg16 ...        { subflags(Reg16,rm16 ); Reg16 = Reg16 -  rm16; resultflags(Reg16); }
0: Constructor line ia.sinc:3807(id0.580) printpiece=[SUB,  ,  B, ,,  A]
Operands 0: rm16 : 2392  1: Reg16 : 2391  
Pattern id=580 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:2B:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3808 :SUB  Reg32,rm32       is vexMode=0 & opsize=1 & byte=0x2b; rm32 & Reg32 ... & check_Reg32_dest ...       { subflags(Reg32,rm32 ); Reg32 = Reg32 -  rm32; build check_Reg32_dest; resultflags(Reg32); }
0: Constructor line ia.sinc:3808(id0.581) printpiece=[SUB,  ,  B, ,,  A]
Operands 0: rm32 : 2394  1: Reg32 : 2393  2: check_Reg32_dest : 2395  
Pattern id=581 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:2B:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[2:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1402 :VMOVNTPS m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x2B; XmmReg1 ... & m128
{
	m128 = vmovntps_avx( XmmReg1 );
}
0: Constructor line avx.sinc:1402(id0.1681) printpiece=[VMOVNTPS,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5038  1: XmmReg1 : 5037  2: m128 : 5036  
Pattern id=1681 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:2B:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[14a:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1389 :VMOVNTPD m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x2B; XmmReg1 ... & m128
{
	m128 = vmovntpd_avx( XmmReg1 );
}
0: Constructor line avx.sinc:1389(id0.1679) printpiece=[VMOVNTPD,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5031  1: XmmReg1 : 5030  2: m128 : 5029  
Pattern id=1679 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:2B:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[149:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1683 :VPACKUSDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_XmmReg; byte=0x2B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpackusdw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1683(id0.1713) printpiece=[VPACKUSDW,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 5185  1: XmmReg1 : 5184  2: YmmReg1 : 5187  3: XmmReg2_m128 : 5186  
Pattern id=1713 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:2B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[aa780:10] = CALLOTHER const[15b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aa780:10]

Line avx.sinc:1408 :VMOVNTPS m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x2B; YmmReg1 ... & m256
{
	m256 = vmovntps_avx( YmmReg1 );
}
0: Constructor line avx.sinc:1408(id0.1682) printpiece=[VMOVNTPS,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5041  1: YmmReg1 : 5040  2: m256 : 5039  
Pattern id=1682 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:2B:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[14a:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1395 :VMOVNTPD m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x2B; YmmReg1 ... & m256
{
	m256 = vmovntpd_avx( YmmReg1 );
}
0: Constructor line avx.sinc:1395(id0.1680) printpiece=[VMOVNTPD,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5034  1: YmmReg1 : 5033  2: m256 : 5032  
Pattern id=1680 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:2B:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[149:4], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:63 :VPACKUSDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0x2B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpackusdw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:63(id0.1932) printpiece=[VPACKUSDW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6281  1: YmmReg1 : 6280  2: YmmReg2_m256 : 6282  
Pattern id=1932 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:2B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1fe:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3783 :SUB  AL,imm8      is vexMode=0 & byte=0x2c; AL & imm8                          { subflags(   AL,imm8 );    AL =    AL -  imm8; resultflags(   AL); }
0: Constructor line ia.sinc:3783(id0.568) printpiece=[SUB,  ,  A, ,,  B]
Operands 0: AL : 2363  1: imm8 : 2364  
Pattern id=568 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:2C:XX:XX:XX)
Template
	0: register[200:1] = INT_LESS register[0:1], [handle:space][[handle:offset]:1]
	1: register[20b:1] = INT_SBORROW register[0:1], [handle:space][[handle:offset]:1]
	2: register[0:1] = INT_SUB register[0:1], [handle:space][[handle:offset]:1]
	3: register[207:1] = INT_SLESS register[0:1], const[0:1]
	4: register[206:1] = INT_EQUAL register[0:1], const[0:1]
	5: unique[dc80:1] = INT_AND register[0:1], const[ff:1]
	6: unique[dd00:1] = POPCOUNT unique[dc80:1]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3150 :VMASKMOVPS XmmReg1, vexVVVV_XmmReg, m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2C; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vmaskmovps_avx( vexVVVV_XmmReg, m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3150(id0.1882) printpiece=[VMASKMOVPS,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6088  1: XmmReg1 : 6087  2: YmmReg1 : 6090  3: m128 : 6089  
Pattern id=1882 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:2C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b7500:10] = CALLOTHER const[1ec:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b7500:10]

Line avx.sinc:3158 :VMASKMOVPS YmmReg1, vexVVVV_YmmReg, m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x2C; YmmReg1 ... & m256
{
	YmmReg1 = vmaskmovps_avx( vexVVVV_YmmReg, m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3158(id0.1883) printpiece=[VMASKMOVPS,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6092  1: YmmReg1 : 6091  2: m256 : 6093  
Pattern id=1883 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:2C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ec:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:816 :VCVTTSS2SI Reg32, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_W0); byte=0x2C; Reg32 ... & XmmReg2_m32
{
	Reg32 = vcvttss2si_avx( XmmReg2_m32 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:816(id0.1610) printpiece=[VCVTTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 4713  1: XmmReg2_m32 : 4714  
Pattern id=1610 pattern=cmb:(ctx:SS:X4:X8:0[001x]:XX,ins:2C:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[121:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:800 :VCVTTSD2SI Reg32, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_W0); byte=0x2C; Reg32 ... & XmmReg2_m64
{
	Reg32 = vcvttsd2si_avx( XmmReg2_m64 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:800(id0.1609) printpiece=[VCVTTSD2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 4710  1: XmmReg2_m64 : 4711  
Pattern id=1609 pattern=cmb:(ctx:SS:X8:X8:0[001x]:XX,ins:2C:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[120:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3784 :SUB  AX,imm16     is vexMode=0 & opsize=0 & byte=0x2d; AX & imm16              { subflags(   AX,imm16);    AX =    AX - imm16; resultflags(   AX); }
0: Constructor line ia.sinc:3784(id0.569) printpiece=[SUB,  ,  A, ,,  B]
Operands 0: AX : 2365  1: imm16 : 2366  
Pattern id=569 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:2D:XX:XX:XX)
Template
	0: register[200:1] = INT_LESS register[0:2], [handle:space][[handle:offset]:2]
	1: register[20b:1] = INT_SBORROW register[0:2], [handle:space][[handle:offset]:2]
	2: register[0:2] = INT_SUB register[0:2], [handle:space][[handle:offset]:2]
	3: register[207:1] = INT_SLESS register[0:2], const[0:2]
	4: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	5: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	6: unique[dd00:1] = POPCOUNT unique[dc80:2]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3785 :SUB  EAX,imm32        is vexMode=0 & opsize=1 & byte=0x2d; EAX & check_EAX_dest & imm32         { subflags(  EAX,imm32);   EAX =   EAX - imm32; build check_EAX_dest; resultflags(  EAX); }
0: Constructor line ia.sinc:3785(id0.570) printpiece=[SUB,  ,  A, ,,  C]
Operands 0: EAX : 2367  1: check_EAX_dest : 2369  2: imm32 : 2368  
Pattern id=570 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:2D:XX:XX:XX)
Template
	0: register[200:1] = INT_LESS register[0:4], [handle:space][[handle:offset]:4]
	1: register[20b:1] = INT_SBORROW register[0:4], [handle:space][[handle:offset]:4]
	2: register[0:4] = INT_SUB register[0:4], [handle:space][[handle:offset]:4]
	3: MULTIEQUAL const[1:4]
	4: register[207:1] = INT_SLESS register[0:4], const[0:4]
	5: register[206:1] = INT_EQUAL register[0:4], const[0:4]
	6: unique[dc80:4] = INT_AND register[0:4], const[ff:4]
	7: unique[dd00:1] = POPCOUNT unique[dc80:4]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:3166 :VMASKMOVPD XmmReg1, vexVVVV_XmmReg, m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2D; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vmaskmovpd_avx( vexVVVV_XmmReg, m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3166(id0.1884) printpiece=[VMASKMOVPD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6096  1: XmmReg1 : 6095  2: YmmReg1 : 6098  3: m128 : 6097  
Pattern id=1884 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:2D:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b7700:10] = CALLOTHER const[1ed:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b7700:10]

Line avx.sinc:3174 :VMASKMOVPD YmmReg1, vexVVVV_YmmReg, m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x2D; YmmReg1 ... & m256
{
	YmmReg1 = vmaskmovpd_avx( vexVVVV_YmmReg, m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3174(id0.1885) printpiece=[VMASKMOVPD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6100  1: YmmReg1 : 6099  2: m256 : 6101  
Pattern id=1885 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:2D:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ed:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:751 :VCVTSS2SI Reg32, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_W0); byte=0x2D; Reg32 ... & XmmReg2_m32
{
	Reg32 = vcvtss2si_avx( XmmReg2_m32 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:751(id0.1604) printpiece=[VCVTSS2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 4690  1: XmmReg2_m32 : 4691  
Pattern id=1604 pattern=cmb:(ctx:SS:X4:X8:0[001x]:XX,ins:2D:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[11d:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:679 :VCVTSD2SI Reg32, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_W0); byte=0x2D; Reg32 ... & XmmReg2_m64
{
	Reg32 = vcvtsd2si_avx( XmmReg2_m64 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:679(id0.1599) printpiece=[VCVTSD2SI,  ,  A, ,,  ,  B]
Operands 0: Reg32 : 4665  1: XmmReg2_m64 : 4666  
Pattern id=1599 pattern=cmb:(ctx:SS:X8:X8:0[001x]:XX,ins:2D:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[118:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1500 :^instruction is instrPhase=0 & over=0x2e; instruction     [ segover=1; ]  {} # CS override
:^instruction is instrPhase=0 & over=0x36; instruction     [ segover=2; ]  {} # SS override
:^instruction is instrPhase=0 & over=0x3e; instruction     [ segover=3; ]  {} # DS override
:^instruction is instrPhase=0 & over=0x26; instruction     [ segover=4; ]  {} # ES override
:^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1500(id0.0) printpiece=[ A]
Operands 0: instruction : 1335  
Pattern id=0 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:2E:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:3001 :VUCOMISS XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x2E; XmmReg1 ... & XmmReg2_m32
{
	vucomiss_avx( XmmReg1, XmmReg2_m32 );
	# TODO set flags AF, CF, OF, PF, SF, ZF
}
1: Constructor line avx.sinc:3001(id0.1864) printpiece=[VUCOMISS,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6015  1: XmmReg1 : 6013  2: XmmReg2_m32 : 6014  
Pattern id=1864 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:2E:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[1e0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1500 :^instruction is instrPhase=0 & over=0x2e; instruction     [ segover=1; ]  {} # CS override
:^instruction is instrPhase=0 & over=0x36; instruction     [ segover=2; ]  {} # SS override
:^instruction is instrPhase=0 & over=0x3e; instruction     [ segover=3; ]  {} # DS override
:^instruction is instrPhase=0 & over=0x26; instruction     [ segover=4; ]  {} # ES override
:^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1500(id0.0) printpiece=[ A]
Operands 0: instruction : 1335  
Pattern id=0 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:2E:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:2993 :VUCOMISD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x2E; XmmReg1 ... & XmmReg2_m64
{
	vucomisd_avx( XmmReg1, XmmReg2_m64 );
	# TODO set flags AF, CF, OF, PF, SF, ZF
}
1: Constructor line avx.sinc:2993(id0.1863) printpiece=[VUCOMISD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6011  1: XmmReg1 : 6009  2: XmmReg2_m64 : 6010  
Pattern id=1863 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:2E:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[1df:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1500 :^instruction is instrPhase=0 & over=0x2e; instruction     [ segover=1; ]  {} # CS override
:^instruction is instrPhase=0 & over=0x36; instruction     [ segover=2; ]  {} # SS override
:^instruction is instrPhase=0 & over=0x3e; instruction     [ segover=3; ]  {} # DS override
:^instruction is instrPhase=0 & over=0x26; instruction     [ segover=4; ]  {} # ES override
:^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1500(id0.0) printpiece=[ A]
Operands 0: instruction : 1335  
Pattern id=0 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:2E:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:3181 :VMASKMOVPS m128, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2E; XmmReg1 ... & m128
{
	m128 = vmaskmovps_avx( vexVVVV_XmmReg, XmmReg1 );
}
1: Constructor line avx.sinc:3181(id0.1886) printpiece=[VMASKMOVPS,  ,  C, ,,  ,  A, ,,  ,  B]
Operands 0: vexVVVV_XmmReg : 6103  1: XmmReg1 : 6104  2: m128 : 6102  
Pattern id=1886 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:2E:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ec:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1500 :^instruction is instrPhase=0 & over=0x2e; instruction     [ segover=1; ]  {} # CS override
:^instruction is instrPhase=0 & over=0x36; instruction     [ segover=2; ]  {} # SS override
:^instruction is instrPhase=0 & over=0x3e; instruction     [ segover=3; ]  {} # DS override
:^instruction is instrPhase=0 & over=0x26; instruction     [ segover=4; ]  {} # ES override
:^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1500(id0.0) printpiece=[ A]
Operands 0: instruction : 1335  
Pattern id=0 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:2E:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:3187 :VMASKMOVPS m256, vexVVVV_YmmReg, YmmReg1 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x2E; YmmReg1 ... & m256
{
	m256 = vmaskmovps_avx( vexVVVV_YmmReg, YmmReg1 );
}
1: Constructor line avx.sinc:3187(id0.1887) printpiece=[VMASKMOVPS,  ,  C, ,,  ,  A, ,,  ,  B]
Operands 0: vexVVVV_YmmReg : 6106  1: YmmReg1 : 6107  2: m256 : 6105  
Pattern id=1887 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:2E:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ec:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2417 :DAS            is vexMode=0 & bit64=0 & byte=0x2f       { local car = ((AL & 0xf) > 9) | AF;
                           AL = AL - 6 * car;
                           CF = CF | car * (AL < 6);
                           AF = car;
                           car = (AL > 0x9f) | CF;
                           AL = AL - 0x60 * car;
                           CF = car; }
0: Constructor line ia.sinc:2417(id0.161) printpiece=[DAS]
Operands 
Pattern id=161 pattern=cmb:(ctx:X[0xxx]:XX:X[0xxx]:XX,ins:2F:XX:XX:XX)
Template
	0: unique[22080:1] = INT_AND register[0:1], const[f:1]
	1: unique[22100:1] = INT_LESS const[9:1], unique[22080:1]
	2: unique[22200:1] = INT_OR unique[22100:1], register[204:1]
	3: unique[22280:1] = INT_MULT const[6:1], unique[22200:1]
	4: register[0:1] = INT_SUB register[0:1], unique[22280:1]
	5: unique[22380:1] = INT_LESS register[0:1], const[6:1]
	6: unique[22400:1] = INT_MULT unique[22200:1], unique[22380:1]
	7: register[200:1] = INT_OR register[200:1], unique[22400:1]
	8: register[204:1] = COPY unique[22200:1]
	9: unique[22500:1] = INT_LESS const[9f:1], register[0:1]
	10: unique[22200:1] = INT_OR unique[22500:1], register[200:1]
	11: unique[22600:1] = INT_MULT const[60:1], unique[22200:1]
	12: register[0:1] = INT_SUB register[0:1], unique[22600:1]
	13: register[200:1] = COPY unique[22200:1]

Line avx.sinc:540 :VCOMISS XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x2F; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vcomiss_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:540(id0.1582) printpiece=[VCOMISS,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4599  1: XmmReg1 : 4597  2: YmmReg1 : 4600  3: XmmReg2_m32 : 4598  
Pattern id=1582 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:2F:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a2300:10] = CALLOTHER const[10f:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2300:10]

Line avx.sinc:531 :VCOMISD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x2F; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vcomisd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:531(id0.1581) printpiece=[VCOMISD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4594  1: XmmReg1 : 4592  2: YmmReg1 : 4595  3: XmmReg2_m64 : 4593  
Pattern id=1581 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:2F:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a2180:10] = CALLOTHER const[10e:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2180:10]

Line avx.sinc:3193 :VMASKMOVPD m128, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x2F; XmmReg1 ... & m128
{
	m128 = vmaskmovpd_avx( vexVVVV_XmmReg, XmmReg1 );
}
0: Constructor line avx.sinc:3193(id0.1888) printpiece=[VMASKMOVPD,  ,  C, ,,  ,  A, ,,  ,  B]
Operands 0: vexVVVV_XmmReg : 6109  1: XmmReg1 : 6110  2: m128 : 6108  
Pattern id=1888 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:2F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ed:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3199 :VMASKMOVPD m256, vexVVVV_YmmReg, YmmReg1 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x2F; YmmReg1 ... & m256
{
	m256 = vmaskmovpd_avx( vexVVVV_YmmReg, YmmReg1 );
}
0: Constructor line avx.sinc:3199(id0.1889) printpiece=[VMASKMOVPD,  ,  C, ,,  ,  A, ,,  ,  B]
Operands 0: vexVVVV_YmmReg : 6112  1: YmmReg1 : 6113  2: m256 : 6111  
Pattern id=1889 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:2F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ed:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3999 :XOR rm8,Reg8      is vexMode=0 & byte=0x30; rm8 & Reg8 ...                     { logicalflags();   rm8 =   rm8 ^  Reg8; resultflags(  rm8); }
0: Constructor line ia.sinc:3999(id0.644) printpiece=[XOR,  ,  A, ,,  B]
Operands 0: rm8 : 2493  1: Reg8 : 2494  
Pattern id=644 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:30:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2254 :VPMOVZXBW XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x30; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovzxbw_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2254(id0.1775) printpiece=[VPMOVZXBW,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5533  1: XmmReg1 : 5531  2: YmmReg1 : 5534  3: XmmReg2_m64 : 5532  
Pattern id=1775 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:30:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[afa80:10] = CALLOTHER const[19a:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[afa80:10]

Line avx2.sinc:463 :VPMOVZXBW YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x30; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovzxbw_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:463(id0.1982) printpiece=[VPMOVZXBW,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6521  1: YmmReg1 : 6519  2: XmmReg2_m128 : 6520  
Pattern id=1982 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:30:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[230:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4000 :XOR rm16,Reg16    is vexMode=0 & opsize=0 & byte=0x31; rm16 & Reg16 ...        { logicalflags();  rm16 =  rm16 ^ Reg16; resultflags( rm16); }
0: Constructor line ia.sinc:4000(id0.645) printpiece=[XOR,  ,  A, ,,  B]
Operands 0: rm16 : 2495  1: Reg16 : 2496  
Pattern id=645 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:31:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:4001 :XOR rm32,Reg32    is vexMode=0 & opsize=1 & byte=0x31; rm32 & check_rm32_dest ... & Reg32 ... { logicalflags();  rm32 =  rm32 ^ Reg32; build check_rm32_dest; resultflags( rm32); }
0: Constructor line ia.sinc:4001(id0.646) printpiece=[XOR,  ,  A, ,,  C]
Operands 0: rm32 : 2497  1: check_rm32_dest : 2499  2: Reg32 : 2498  
Pattern id=646 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:31:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2263 :VPMOVZXBD XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x31; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpmovzxbd_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2263(id0.1776) printpiece=[VPMOVZXBD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5538  1: XmmReg1 : 5536  2: YmmReg1 : 5539  3: XmmReg2_m32 : 5537  
Pattern id=1776 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:31:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[afc00:10] = CALLOTHER const[19b:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[afc00:10]

Line avx2.sinc:471 :VPMOVZXBD YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x31; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpmovzxbd_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:471(id0.1983) printpiece=[VPMOVZXBD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6525  1: YmmReg1 : 6523  2: XmmReg2_m64 : 6524  
Pattern id=1983 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:31:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[231:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4005 :XOR Reg8,rm8      is vexMode=0 & byte=0x32; rm8 & Reg8 ...                     { logicalflags();  Reg8 =  Reg8 ^   rm8; resultflags( Reg8); } 
0: Constructor line ia.sinc:4005(id0.647) printpiece=[XOR,  ,  B, ,,  A]
Operands 0: rm8 : 2501  1: Reg8 : 2500  
Pattern id=647 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:32:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2272 :VPMOVZXBQ XmmReg1, XmmReg2_m16 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x32; (XmmReg1 & YmmReg1) ... & XmmReg2_m16
{
	local tmp:16 = vpmovzxbq_avx( XmmReg2_m16 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2272(id0.1777) printpiece=[VPMOVZXBQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5543  1: XmmReg1 : 5541  2: YmmReg1 : 5544  3: XmmReg2_m16 : 5542  
Pattern id=1777 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:32:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[afd80:10] = CALLOTHER const[19c:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[afd80:10]

Line avx2.sinc:479 :VPMOVZXBQ YmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x32; YmmReg1 ... & XmmReg2_m32
{
	YmmReg1 = vpmovzxbq_avx2( XmmReg2_m32 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:479(id0.1984) printpiece=[VPMOVZXBQ,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6529  1: YmmReg1 : 6527  2: XmmReg2_m32 : 6528  
Pattern id=1984 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:32:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[232:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4006 :XOR Reg16,rm16    is vexMode=0 & opsize=0 & byte=0x33; rm16 & Reg16 ...        { logicalflags(); Reg16 = Reg16 ^  rm16; resultflags(Reg16); }
0: Constructor line ia.sinc:4006(id0.648) printpiece=[XOR,  ,  B, ,,  A]
Operands 0: rm16 : 2503  1: Reg16 : 2502  
Pattern id=648 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:33:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:4007 :XOR Reg32,rm32    is vexMode=0 & opsize=1 & byte=0x33; rm32 & Reg32 ... & check_Reg32_dest ... { logicalflags(); Reg32 = Reg32 ^  rm32; build check_Reg32_dest; resultflags(Reg32); }
0: Constructor line ia.sinc:4007(id0.649) printpiece=[XOR,  ,  B, ,,  A]
Operands 0: rm32 : 2505  1: Reg32 : 2504  2: check_Reg32_dest : 2506  
Pattern id=649 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:33:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[2:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2281 :VPMOVZXWD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x33; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovzxwd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2281(id0.1778) printpiece=[VPMOVZXWD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5548  1: XmmReg1 : 5546  2: YmmReg1 : 5549  3: XmmReg2_m64 : 5547  
Pattern id=1778 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:33:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[aff00:10] = CALLOTHER const[19d:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aff00:10]

Line avx2.sinc:487 :VPMOVZXWD YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x33; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovzxwd_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:487(id0.1985) printpiece=[VPMOVZXWD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6533  1: YmmReg1 : 6531  2: XmmReg2_m128 : 6532  
Pattern id=1985 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:33:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[233:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3982 :XOR AL,imm8       is vexMode=0 & byte=0x34; AL & imm8                          { logicalflags();    AL =    AL ^  imm8; resultflags(   AL); }
0: Constructor line ia.sinc:3982(id0.636) printpiece=[XOR,  ,  A, ,,  B]
Operands 0: AL : 2474  1: imm8 : 2475  
Pattern id=636 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:34:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: register[0:1] = INT_XOR register[0:1], [handle:space][[handle:offset]:1]
	3: register[207:1] = INT_SLESS register[0:1], const[0:1]
	4: register[206:1] = INT_EQUAL register[0:1], const[0:1]
	5: unique[dc80:1] = INT_AND register[0:1], const[ff:1]
	6: unique[dd00:1] = POPCOUNT unique[dc80:1]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2290 :VPMOVZXWQ XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x34; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpmovzxwq_avx( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2290(id0.1779) printpiece=[VPMOVZXWQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5553  1: XmmReg1 : 5551  2: YmmReg1 : 5554  3: XmmReg2_m32 : 5552  
Pattern id=1779 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:34:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b0080:10] = CALLOTHER const[19e:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0080:10]

Line avx2.sinc:495 :VPMOVZXWQ YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x34; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpmovzxwq_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:495(id0.1986) printpiece=[VPMOVZXWQ,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6537  1: YmmReg1 : 6535  2: XmmReg2_m64 : 6536  
Pattern id=1986 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:34:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[234:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3983 :XOR AX,imm16      is vexMode=0 & opsize=0 & byte=0x35; AX & imm16              { logicalflags();    AX =    AX ^ imm16; resultflags(   AX); }
0: Constructor line ia.sinc:3983(id0.637) printpiece=[XOR,  ,  A, ,,  B]
Operands 0: AX : 2476  1: imm16 : 2477  
Pattern id=637 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:35:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: register[0:2] = INT_XOR register[0:2], [handle:space][[handle:offset]:2]
	3: register[207:1] = INT_SLESS register[0:2], const[0:2]
	4: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	5: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	6: unique[dd00:1] = POPCOUNT unique[dc80:2]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3984 :XOR EAX,imm32     is vexMode=0 & opsize=1 & byte=0x35; EAX & imm32 & check_EAX_dest	{ logicalflags();  EAX = EAX ^ imm32; build check_EAX_dest; resultflags(  EAX);}
0: Constructor line ia.sinc:3984(id0.638) printpiece=[XOR,  ,  A, ,,  B]
Operands 0: EAX : 2478  1: imm32 : 2479  2: check_EAX_dest : 2480  
Pattern id=638 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:35:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: register[0:4] = INT_XOR register[0:4], [handle:space][[handle:offset]:4]
	3: MULTIEQUAL const[2:4]
	4: register[207:1] = INT_SLESS register[0:4], const[0:4]
	5: register[206:1] = INT_EQUAL register[0:4], const[0:4]
	6: unique[dc80:4] = INT_AND register[0:4], const[ff:4]
	7: unique[dd00:1] = POPCOUNT unique[dc80:4]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2299 :VPMOVZXDQ XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x35; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpmovzxdq_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2299(id0.1780) printpiece=[VPMOVZXDQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5558  1: XmmReg1 : 5556  2: YmmReg1 : 5559  3: XmmReg2_m64 : 5557  
Pattern id=1780 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:35:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b0200:10] = CALLOTHER const[19f:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0200:10]

Line avx2.sinc:503 :VPMOVZXDQ YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x35; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpmovzxdq_avx2( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:503(id0.1987) printpiece=[VPMOVZXDQ,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6541  1: YmmReg1 : 6539  2: XmmReg2_m128 : 6540  
Pattern id=1987 pattern=cmb:(ctx:SS:X[001x]:XC:0[010x]:XX,ins:35:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[235:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1501 :^instruction is instrPhase=0 & over=0x36; instruction     [ segover=2; ]  {} # SS override
:^instruction is instrPhase=0 & over=0x3e; instruction     [ segover=3; ]  {} # DS override
:^instruction is instrPhase=0 & over=0x26; instruction     [ segover=4; ]  {} # ES override
:^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1501(id0.1) printpiece=[ A]
Operands 0: instruction : 1336  
Pattern id=1 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:36:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx2.sinc:1056 :VPERMD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x36; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpermd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:1056(id0.2052) printpiece=[VPERMD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6837  1: YmmReg1 : 6836  2: YmmReg2_m256 : 6838  
Pattern id=2052 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:36:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[269:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1639 :AAA			is vexMode=0 & bit64=0 & byte=0x37		{ local car = ((AL & 0xf) > 9) | AF; AL = (AL+6*car)&0xf; AH=AH+car; CF=car; AF=car; }
0: Constructor line ia.sinc:1639(id0.20) printpiece=[AAA]
Operands 
Pattern id=20 pattern=cmb:(ctx:X[0xxx]:XX:X[0xxx]:XX,ins:37:XX:XX:XX)
Template
	0: unique[13680:1] = INT_AND register[0:1], const[f:1]
	1: unique[13700:1] = INT_LESS const[9:1], unique[13680:1]
	2: unique[13800:1] = INT_OR unique[13700:1], register[204:1]
	3: unique[13880:1] = INT_MULT const[6:1], unique[13800:1]
	4: unique[13900:1] = INT_ADD register[0:1], unique[13880:1]
	5: register[0:1] = INT_AND unique[13900:1], const[f:1]
	6: register[1:1] = INT_ADD register[1:1], unique[13800:1]
	7: register[200:1] = COPY unique[13800:1]
	8: register[204:1] = COPY unique[13800:1]

Line avx.sinc:1909 :VPCMPGTQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x37; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpgtq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1909(id0.1738) printpiece=[VPCMPGTQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5334  1: vexVVVV_XmmReg : 5332  2: XmmReg1 : 5331  3: YmmReg1 : 5335  4: XmmReg2_m128 : 5333  
Pattern id=1738 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:37:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[aca00:10] = CALLOTHER const[174:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aca00:10]

Line avx2.sinc:247 :VPCMPGTQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x37; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpgtq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:247(id0.1955) printpiece=[VPCMPGTQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6399  1: vexVVVV_YmmReg : 6397  2: YmmReg1 : 6396  3: YmmReg2_m256 : 6398  
Pattern id=1955 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:37:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[215:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2214 :CMP rm8,Reg8       is vexMode=0 & byte=0x38; rm8 & Reg8 ...                { subflags(  rm8,Reg8 ); local tmp =   rm8 -   Reg8; resultflags(tmp); }
0: Constructor line ia.sinc:2214(id0.142) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: rm8 : 1612  1: Reg8 : 1613  
Pattern id=142 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:38:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1e900:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1e900:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[1e900:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[1e900:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2146 :VPMINSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_XmmReg; byte=0x38; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminsb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2146(id0.1763) printpiece=[VPMINSB,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 5470  1: XmmReg1 : 5469  2: YmmReg1 : 5472  3: XmmReg2_m128 : 5471  
Pattern id=1763 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:38:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[ae880:10] = CALLOTHER const[18e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ae880:10]

Line avx2.sinc:367 :VPMINSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0x38; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminsb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:367(id0.1970) printpiece=[VPMINSB,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6470  1: YmmReg1 : 6469  2: YmmReg2_m256 : 6471  
Pattern id=1970 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:38:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[224:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2_manual.sinc:3 :VINSERTI128 YmmReg1, vexVVVV_YmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x38; YmmReg1 ... & XmmReg2_m128; imm8 & imm8_0 {
	local tmp:16 = XmmReg2_m128;

	# ignoring all but the least significant bit
	if (imm8_0:1 == 0) goto <case0>;
	if (imm8_0:1 == 1) goto <case1>;

 <case0>
	YmmReg1[0,128] = tmp;
	YmmReg1[128,128] = vexVVVV_YmmReg[128,128];
	goto <done>;

 <case1>
	YmmReg1[0,128] = vexVVVV_YmmReg[0,128];
	YmmReg1[128,128] = tmp;

 <done>
}
0: Constructor line avx2_manual.sinc:3(id0.2074) printpiece=[VINSERTI128,  ,  B, ,,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: vexVVVV_YmmReg : 6921  1: YmmReg1 : 6920  2: XmmReg2_m128 : 6922  3: imm8 : 6923  4: imm8_0 : 6924  
Pattern id=2074 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][011x]:XX,ins:38:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: unique[c1580:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[c1600:1] = INT_EQUAL [handle:space][[handle:offset]:1], const[0:1]
	4: CBRANCH const[[rel:0]:4], unique[c1600:1]
	5: unique[c1680:1] = INT_EQUAL [handle:space][[handle:offset]:1], const[1:1]
	6: CBRANCH const[[rel:1]:4], unique[c1680:1]
	7: PTRADD const[0:4]
	8: [handle:space][[handle:offset+0]:10] = COPY unique[c1580:10]
	9: [handle:space][[handle:offset+100010]:10] = COPY [handle:space][[handle:offset+100010]:10]
	10: BRANCH const[[rel:2]:4]
	11: PTRADD const[1:4]
	12: [handle:space][[handle:offset+0]:10] = COPY [handle:space][[handle:offset+0]:10]
	13: [handle:space][[handle:offset+100010]:10] = COPY unique[c1580:10]
	14: PTRADD const[2:4]

Line ia.sinc:2215 :CMP rm16,Reg16     is vexMode=0 & opsize=0 & byte=0x39; rm16 & Reg16 ...       { subflags( rm16,Reg16); local tmp =  rm16 -  Reg16; resultflags(tmp); }
0: Constructor line ia.sinc:2215(id0.143) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: rm16 : 1614  1: Reg16 : 1615  
Pattern id=143 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:39:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1ea00:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1ea00:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[1ea00:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[1ea00:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2216 :CMP rm32,Reg32     is vexMode=0 & opsize=1 & byte=0x39; rm32 & Reg32 ...       { subflags( rm32, Reg32 ); local tmp =  rm32 -  Reg32; resultflags(tmp); }
0: Constructor line ia.sinc:2216(id0.144) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: rm32 : 1616  1: Reg32 : 1617  
Pattern id=144 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:39:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1eb00:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1eb00:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[1eb00:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[1eb00:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2164 :VPMINSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x39; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminsd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2164(id0.1765) printpiece=[VPMINSD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5482  1: vexVVVV_XmmReg : 5480  2: XmmReg1 : 5479  3: YmmReg1 : 5483  4: XmmReg2_m128 : 5481  
Pattern id=1765 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:39:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[aeb80:10] = CALLOTHER const[190:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aeb80:10]

Line avx2.sinc:383 :VPMINSD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x39; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminsd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:383(id0.1972) printpiece=[VPMINSD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6480  1: vexVVVV_YmmReg : 6478  2: YmmReg1 : 6477  3: YmmReg2_m256 : 6479  
Pattern id=1972 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:39:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[226:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:901 :VEXTRACTI128 XmmReg2_m128, YmmReg1, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0); byte=0x39; YmmReg1 ... & XmmReg2_m128; imm8
{
	XmmReg2_m128 = vextracti128_avx2( YmmReg1, imm8:1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx2.sinc:901(id0.2039) printpiece=[VEXTRACTI128,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: YmmReg1 : 6791  1: XmmReg2_m128 : 6790  2: imm8 : 6792  
Pattern id=2039 pattern=cmb:(ctx:SS:X2:XC:0[011x]:XX,ins:39:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[261:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:2220 :CMP Reg8,rm8       is vexMode=0 & byte=0x3a; rm8 & Reg8 ...                            { subflags( Reg8,rm8  ); local tmp =  Reg8 -    rm8; resultflags(tmp); } 
0: Constructor line ia.sinc:2220(id0.145) printpiece=[CMP,  ,  B, ,,  A]
Operands 0: rm8 : 1619  1: Reg8 : 1618  
Pattern id=145 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:3A:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1ec00:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1ec00:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[1ec00:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[1ec00:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2182 :VPMINUW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_XmmReg; byte=0x3A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminuw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2182(id0.1767) printpiece=[VPMINUW,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 5491  1: XmmReg1 : 5490  2: YmmReg1 : 5493  3: XmmReg2_m128 : 5492  
Pattern id=1767 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:3A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[aee80:10] = CALLOTHER const[192:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aee80:10]

Line avx2.sinc:399 :VPMINUW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0x3A; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminuw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:399(id0.1974) printpiece=[VPMINUW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6487  1: YmmReg1 : 6486  2: YmmReg2_m256 : 6488  
Pattern id=1974 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:3A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[228:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2221 :CMP Reg16,rm16     is vexMode=0 & opsize=0 & byte=0x3b; rm16 & Reg16 ...       { subflags(Reg16,rm16 ); local tmp = Reg16 -   rm16; resultflags(tmp); }
0: Constructor line ia.sinc:2221(id0.146) printpiece=[CMP,  ,  B, ,,  A]
Operands 0: rm16 : 1621  1: Reg16 : 1620  
Pattern id=146 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:3B:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1ed00:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1ed00:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[1ed00:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[1ed00:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2222 :CMP Reg32,Rmr32     is vexMode=0 & opsize=1 & byte=0x3b; Reg32 & mod=3 & Rmr32       { subflags(Reg32,Rmr32 ); local tmp = Reg32 -   Rmr32; resultflags(tmp); }
0: Constructor line ia.sinc:2222(id0.147) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: Reg32 : 1622  1: Rmr32 : 1623  
Pattern id=147 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:3B:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1ee00:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1ee00:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[1ee00:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[1ee00:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2223 :CMP Reg32,m32     is vexMode=0 & opsize=1 & byte=0x3b; Reg32 ... & m32      {subflags(Reg32,m32 ); local tmp = Reg32 -   m32; resultflags(tmp); }
1: Constructor line ia.sinc:2223(id0.148) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: Reg32 : 1624  1: m32 : 1625  
Pattern id=148 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:3B:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1ef00:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1ef00:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[1ef00:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[1ef00:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2191 :VPMINUD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x3B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminud_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2191(id0.1768) printpiece=[VPMINUD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5498  1: vexVVVV_XmmReg : 5496  2: XmmReg1 : 5495  3: YmmReg1 : 5499  4: XmmReg2_m128 : 5497  
Pattern id=1768 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:3B:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[af000:10] = CALLOTHER const[193:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[af000:10]

Line avx2.sinc:407 :VPMINUD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x3B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminud_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:407(id0.1975) printpiece=[VPMINUD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6493  1: vexVVVV_YmmReg : 6491  2: YmmReg1 : 6490  3: YmmReg2_m256 : 6492  
Pattern id=1975 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:3B:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[229:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2197 :CMP AL,imm8        is vexMode=0 & byte=0x3c; AL & imm8                                 { subflags(   AL,imm8 ); local tmp =    AL -   imm8; resultflags(tmp); }
0: Constructor line ia.sinc:2197(id0.134) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: AL : 1596  1: imm8 : 1597  
Pattern id=134 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:3C:XX:XX:XX)
Template
	0: register[200:1] = INT_LESS register[0:1], [handle:space][[handle:offset]:1]
	1: register[20b:1] = INT_SBORROW register[0:1], [handle:space][[handle:offset]:1]
	2: unique[1e100:1] = INT_SUB register[0:1], [handle:space][[handle:offset]:1]
	3: register[207:1] = INT_SLESS unique[1e100:1], const[0:1]
	4: register[206:1] = INT_EQUAL unique[1e100:1], const[0:1]
	5: unique[dc80:1] = INT_AND unique[1e100:1], const[ff:1]
	6: unique[dd00:1] = POPCOUNT unique[dc80:1]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2092 :VPMAXSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x3C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxsb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2092(id0.1757) printpiece=[VPMAXSB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5438  1: vexVVVV_XmmReg : 5436  2: XmmReg1 : 5435  3: YmmReg1 : 5439  4: XmmReg2_m128 : 5437  
Pattern id=1757 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:3C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[adf80:10] = CALLOTHER const[188:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[adf80:10]

Line avx2.sinc:319 :VPMAXSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x3C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxsb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:319(id0.1964) printpiece=[VPMAXSB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6444  1: vexVVVV_YmmReg : 6442  2: YmmReg1 : 6441  3: YmmReg2_m256 : 6443  
Pattern id=1964 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:3C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[21e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2198 :CMP AX,imm16       is vexMode=0 & opsize=0 & byte=0x3d; AX & imm16         { subflags(   AX,imm16); local tmp =    AX -  imm16; resultflags(tmp); }
0: Constructor line ia.sinc:2198(id0.135) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: AX : 1598  1: imm16 : 1599  
Pattern id=135 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:3D:XX:XX:XX)
Template
	0: register[200:1] = INT_LESS register[0:2], [handle:space][[handle:offset]:2]
	1: register[20b:1] = INT_SBORROW register[0:2], [handle:space][[handle:offset]:2]
	2: unique[1e200:2] = INT_SUB register[0:2], [handle:space][[handle:offset]:2]
	3: register[207:1] = INT_SLESS unique[1e200:2], const[0:2]
	4: register[206:1] = INT_EQUAL unique[1e200:2], const[0:2]
	5: unique[dc80:2] = INT_AND unique[1e200:2], const[ff:2]
	6: unique[dd00:1] = POPCOUNT unique[dc80:2]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2199 :CMP EAX,imm32      is vexMode=0 & opsize=1 & byte=0x3d; EAX & imm32            { subflags(  EAX,imm32); local tmp =   EAX -  imm32; resultflags(tmp); }
0: Constructor line ia.sinc:2199(id0.136) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: EAX : 1600  1: imm32 : 1601  
Pattern id=136 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:3D:XX:XX:XX)
Template
	0: register[200:1] = INT_LESS register[0:4], [handle:space][[handle:offset]:4]
	1: register[20b:1] = INT_SBORROW register[0:4], [handle:space][[handle:offset]:4]
	2: unique[1e300:4] = INT_SUB register[0:4], [handle:space][[handle:offset]:4]
	3: register[207:1] = INT_SLESS unique[1e300:4], const[0:4]
	4: register[206:1] = INT_EQUAL unique[1e300:4], const[0:4]
	5: unique[dc80:4] = INT_AND unique[1e300:4], const[ff:4]
	6: unique[dd00:1] = POPCOUNT unique[dc80:4]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2110 :VPMAXSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x3D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxsd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2110(id0.1759) printpiece=[VPMAXSD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5450  1: vexVVVV_XmmReg : 5448  2: XmmReg1 : 5447  3: YmmReg1 : 5451  4: XmmReg2_m128 : 5449  
Pattern id=1759 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:3D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ae280:10] = CALLOTHER const[18a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ae280:10]

Line avx2.sinc:335 :VPMAXSD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x3D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxsd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:335(id0.1966) printpiece=[VPMAXSD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6454  1: vexVVVV_YmmReg : 6452  2: YmmReg1 : 6451  3: YmmReg2_m256 : 6453  
Pattern id=1966 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:3D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[220:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1502 :^instruction is instrPhase=0 & over=0x3e; instruction     [ segover=3; ]  {} # DS override
:^instruction is instrPhase=0 & over=0x26; instruction     [ segover=4; ]  {} # ES override
:^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1502(id0.2) printpiece=[ A]
Operands 0: instruction : 1337  
Pattern id=2 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:3E:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:2128 :VPMAXUW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_XmmReg; byte=0x3E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxuw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:2128(id0.1761) printpiece=[VPMAXUW,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 5459  1: XmmReg1 : 5458  2: YmmReg1 : 5461  3: XmmReg2_m128 : 5460  
Pattern id=1761 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:3E:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[ae580:10] = CALLOTHER const[18c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ae580:10]

Line ia.sinc:1502 :^instruction is instrPhase=0 & over=0x3e; instruction     [ segover=3; ]  {} # DS override
:^instruction is instrPhase=0 & over=0x26; instruction     [ segover=4; ]  {} # ES override
:^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1502(id0.2) printpiece=[ A]
Operands 0: instruction : 1337  
Pattern id=2 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:3E:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx2.sinc:351 :VPMAXUW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & vexVVVV_YmmReg; byte=0x3E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxuw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:351(id0.1968) printpiece=[VPMAXUW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6461  1: YmmReg1 : 6460  2: YmmReg2_m256 : 6462  
Pattern id=1968 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:3E:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[222:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1642 :AAS			is vexMode=0 & bit64=0 & byte=0x3f		{ local car = ((AL & 0xf) > 9) | AF; AL = (AL-6*car)&0xf; AH=AH-car; CF=car; AF=car; }
0: Constructor line ia.sinc:1642(id0.23) printpiece=[AAS]
Operands 
Pattern id=23 pattern=cmb:(ctx:X[0xxx]:XX:X[0xxx]:XX,ins:3F:XX:XX:XX)
Template
	0: unique[13c80:1] = INT_AND register[0:1], const[f:1]
	1: unique[13d00:1] = INT_LESS const[9:1], unique[13c80:1]
	2: unique[13e00:1] = INT_OR unique[13d00:1], register[204:1]
	3: unique[13e80:1] = INT_MULT const[6:1], unique[13e00:1]
	4: unique[13f00:1] = INT_SUB register[0:1], unique[13e80:1]
	5: register[0:1] = INT_AND unique[13f00:1], const[f:1]
	6: register[1:1] = INT_SUB register[1:1], unique[13e00:1]
	7: register[200:1] = COPY unique[13e00:1]
	8: register[204:1] = COPY unique[13e00:1]

Line avx.sinc:2137 :VPMAXUD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x3F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxud_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2137(id0.1762) printpiece=[VPMAXUD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5466  1: vexVVVV_XmmReg : 5464  2: XmmReg1 : 5463  3: YmmReg1 : 5467  4: XmmReg2_m128 : 5465  
Pattern id=1762 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:3F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ae700:10] = CALLOTHER const[18d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ae700:10]

Line avx2.sinc:359 :VPMAXUD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x3F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxud_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:359(id0.1969) printpiece=[VPMAXUD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6467  1: vexVVVV_YmmReg : 6465  2: YmmReg1 : 6464  3: YmmReg2_m256 : 6466  
Pattern id=1969 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:3F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[223:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2786 :INC  Rmr16        is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & row = 4 & page = 0 & Rmr16 { OF = scarry(Rmr16,1);   Rmr16 =  Rmr16 + 1; resultflags( Rmr16); }
0: Constructor line ia.sinc:2786(id0.201) printpiece=[INC,  ,  A]
Operands 0: Rmr16 : 1750  
Pattern id=201 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:4[0xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	6: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2787 :INC  Rmr32        is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & row = 4 & page = 0 & Rmr32 { OF = scarry(Rmr32,1);   Rmr32 =  Rmr32 + 1; resultflags( Rmr32); }
0: Constructor line ia.sinc:2787(id0.202) printpiece=[INC,  ,  A]
Operands 0: Rmr32 : 1751  
Pattern id=202 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:4[0xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	6: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2344 :VPMULLD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x40; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmulld_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2344(id0.1785) printpiece=[VPMULLD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5588  1: vexVVVV_XmmReg : 5586  2: XmmReg1 : 5585  3: YmmReg1 : 5589  4: XmmReg2_m128 : 5587  
Pattern id=1785 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:40:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b0980:10] = CALLOTHER const[1a4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0980:10]

Line avx.sinc:891 :VDPPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x40; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vdpps_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:891(id0.1618) printpiece=[VDPPS,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 4759  1: vexVVVV_XmmReg : 4756  2: XmmReg1 : 4755  3: YmmReg1 : 4760  4: XmmReg2_m128 : 4757  5: imm8 : 4758  
Pattern id=1618 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:40:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a4b00:10] = CALLOTHER const[127:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a4b00:10]

Line avx2.sinc:543 :VPMULLD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x40; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmulld_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:543(id0.1992) printpiece=[VPMULLD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6566  1: vexVVVV_YmmReg : 6564  2: YmmReg1 : 6563  3: YmmReg2_m256 : 6565  
Pattern id=1992 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][010x]:XX,ins:40:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[23a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:899 :VDPPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x40; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vdpps_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:899(id0.1619) printpiece=[VDPPS,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 4765  1: vexVVVV_YmmReg : 4762  2: YmmReg1 : 4761  3: YmmReg2_m256 : 4763  4: imm8 : 4764  
Pattern id=1619 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:40:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[127:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2000 :VPHMINPOSUW XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0x41; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vphminposuw_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2000(id0.1748) printpiece=[VPHMINPOSUW,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5383  1: XmmReg1 : 5381  2: YmmReg1 : 5384  3: XmmReg2_m128 : 5382  
Pattern id=1748 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:41:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[ad200:10] = CALLOTHER const[17e:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ad200:10]

Line avx.sinc:882 :VDPPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x41; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vdppd_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:882(id0.1617) printpiece=[VDPPD,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 4752  1: vexVVVV_XmmReg : 4749  2: XmmReg1 : 4748  3: YmmReg1 : 4753  4: XmmReg2_m128 : 4750  5: imm8 : 4751  
Pattern id=1617 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:41:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a4980:10] = CALLOTHER const[126:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a4980:10]

Line avx.sinc:1547 :VMPSADBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x42; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vmpsadbw_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1547(id0.1697) printpiece=[VMPSADBW,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5106  1: vexVVVV_XmmReg : 5103  2: XmmReg1 : 5102  3: YmmReg1 : 5107  4: XmmReg2_m128 : 5104  5: imm8 : 5105  
Pattern id=1697 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:42:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a9380:10] = CALLOTHER const[14f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a9380:10]

Line avx2.sinc:15 :VMPSADBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x42; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vmpsadbw_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:15(id0.1926) printpiece=[VMPSADBW,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 6256  1: vexVVVV_YmmReg : 6253  2: YmmReg1 : 6252  3: YmmReg2_m256 : 6254  4: imm8 : 6255  
Pattern id=1926 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][011x]:XX,ins:42:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1f8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line pclmulqdq.sinc:93 :VPCLMULLQLQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; byte=0x00
{
    local src1:16 = zext(vexVVVV_XmmReg[0,64]);
    local src2:16 = zext(XmmReg2[0,64]);
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:93(id0.2094) printpiece=[VPCLMULLQLQDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6994  1: vexVVVV_XmmReg : 6992  2: XmmReg1 : 6991  3: YmmReg1 : 6995  4: XmmReg2 : 6993  
Pattern id=2094 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:00:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ca400:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: unique[ca500:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: unique[c8f80:4] = COPY const[0:4]
	6: unique[c9000:10] = COPY const[0:10]
	7: PTRADD const[0:4]
	8: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	9: CBRANCH const[[rel:1]:4], unique[c9080:1]
	10: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	11: unique[c9180:10] = INT_AND unique[ca400:10], unique[c9100:10]
	12: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	13: CBRANCH const[[rel:2]:4], unique[c9200:1]
	14: unique[c9280:10] = INT_LEFT unique[ca500:10], unique[c8f80:4]
	15: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	16: PTRADD const[2:4]
	17: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	18: BRANCH const[[rel:0]:4]
	19: PTRADD const[1:4]
	20: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	21: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
2: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:101 :VPCLMULHQLQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; byte=0x01
{
    local src1:16 = zext(vexVVVV_XmmReg[64,64]);
    local src2:16 = zext(XmmReg2[0,64]);
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:101(id0.2095) printpiece=[VPCLMULHQLQDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6999  1: vexVVVV_XmmReg : 6997  2: XmmReg1 : 6996  3: YmmReg1 : 7000  4: XmmReg2 : 6998  
Pattern id=2095 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:01:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ca680:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	4: unique[ca780:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: unique[c8f80:4] = COPY const[0:4]
	6: unique[c9000:10] = COPY const[0:10]
	7: PTRADD const[0:4]
	8: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	9: CBRANCH const[[rel:1]:4], unique[c9080:1]
	10: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	11: unique[c9180:10] = INT_AND unique[ca680:10], unique[c9100:10]
	12: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	13: CBRANCH const[[rel:2]:4], unique[c9200:1]
	14: unique[c9280:10] = INT_LEFT unique[ca780:10], unique[c8f80:4]
	15: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	16: PTRADD const[2:4]
	17: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	18: BRANCH const[[rel:0]:4]
	19: PTRADD const[1:4]
	20: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	21: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
2: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:109 :VPCLMULLQHQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; byte=0x10
{
    local src1:16 = zext(vexVVVV_XmmReg[0,64]);
    local src2:16 = zext(XmmReg2[64,64]);
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:109(id0.2096) printpiece=[VPCLMULLQHQDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 7004  1: vexVVVV_XmmReg : 7002  2: XmmReg1 : 7001  3: YmmReg1 : 7005  4: XmmReg2 : 7003  
Pattern id=2096 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:10:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ca900:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	4: unique[caa00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	5: unique[c8f80:4] = COPY const[0:4]
	6: unique[c9000:10] = COPY const[0:10]
	7: PTRADD const[0:4]
	8: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	9: CBRANCH const[[rel:1]:4], unique[c9080:1]
	10: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	11: unique[c9180:10] = INT_AND unique[ca900:10], unique[c9100:10]
	12: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	13: CBRANCH const[[rel:2]:4], unique[c9200:1]
	14: unique[c9280:10] = INT_LEFT unique[caa00:10], unique[c8f80:4]
	15: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	16: PTRADD const[2:4]
	17: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	18: BRANCH const[[rel:0]:4]
	19: PTRADD const[1:4]
	20: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	21: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
2: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:117 :VPCLMULHQHQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; byte=0x11
{
    local src1:16 = zext(vexVVVV_XmmReg[64,64]);
    local src2:16 = zext(XmmReg2[64,64]);
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:117(id0.2097) printpiece=[VPCLMULHQHQDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 7009  1: vexVVVV_XmmReg : 7007  2: XmmReg1 : 7006  3: YmmReg1 : 7010  4: XmmReg2 : 7008  
Pattern id=2097 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:11:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[cab80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	4: unique[cac80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	5: unique[c8f80:4] = COPY const[0:4]
	6: unique[c9000:10] = COPY const[0:10]
	7: PTRADD const[0:4]
	8: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	9: CBRANCH const[[rel:1]:4], unique[c9080:1]
	10: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	11: unique[c9180:10] = INT_AND unique[cab80:10], unique[c9100:10]
	12: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	13: CBRANCH const[[rel:2]:4], unique[c9200:1]
	14: unique[c9280:10] = INT_LEFT unique[cac80:10], unique[c8f80:4]
	15: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	16: PTRADD const[2:4]
	17: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	18: BRANCH const[[rel:0]:4]
	19: PTRADD const[1:4]
	20: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	21: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
2: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:125 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; xmmmod=3 & (XmmReg1 & YmmReg1) & XmmReg2; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>
		
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(XmmReg2[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(XmmReg2[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line pclmulqdq.sinc:125(id0.2098) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7015  1: vexVVVV_XmmReg : 7012  2: XmmReg1 : 7011  3: YmmReg1 : 7016  4: XmmReg2 : 7013  5: imm8 : 7014  6: imm8_4 : 7017  7: imm8_0 : 7018  
Pattern id=2098 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cae00:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	10: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	11: BRANCH const[[rel:3]:4]
	12: PTRADD const[2:4]
	13: unique[caf80:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	14: PTRADD const[3:4]
	15: unique[c8f80:4] = COPY const[0:4]
	16: unique[c9000:10] = COPY const[0:10]
	17: PTRADD const[4:4]
	18: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	19: CBRANCH const[[rel:5]:4], unique[c9080:1]
	20: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	21: unique[c9180:10] = INT_AND unique[cae00:10], unique[c9100:10]
	22: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	23: CBRANCH const[[rel:6]:4], unique[c9200:1]
	24: unique[c9280:10] = INT_LEFT unique[caf80:10], unique[c8f80:4]
	25: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	26: PTRADD const[6:4]
	27: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	28: BRANCH const[[rel:4]:4]
	29: PTRADD const[5:4]
	30: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	31: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line pclmulqdq.sinc:149 :VPCLMULQDQ XmmReg1, vexVVVV_XmmReg, m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x44; (XmmReg1 & YmmReg1) ... & m128; imm8 & imm8_4 & imm8_0
{
	if (imm8_0:1) goto <src1_b>;
		src1:16 = zext(vexVVVV_XmmReg[0,64]);
		goto <done1>;
		
	<src1_b>
		src1 = zext(vexVVVV_XmmReg[64,64]);
	
	<done1>

        local m:16 = m128;
	if (imm8_4:1) goto <src2_b>;
		src2:16 = zext(m[0,64]);
		goto <done2>;
		
	<src2_b>
		src2 = zext(m[64,64]);
		
	<done2>
	
    pclmul(src1,src2,XmmReg1);
	YmmReg1 = zext(XmmReg1);
}
1: Constructor line pclmulqdq.sinc:149(id0.2099) printpiece=[VPCLMULQDQ,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 7023  1: vexVVVV_XmmReg : 7020  2: XmmReg1 : 7019  3: YmmReg1 : 7024  4: m128 : 7021  5: imm8 : 7022  6: imm8_4 : 7025  7: imm8_0 : 7026  
Pattern id=2099 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][011x]:XX,ins:44:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: CBRANCH const[[rel:0]:4], [handle:space][[handle:offset]:1]
	4: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+0]:8]
	5: BRANCH const[[rel:1]:4]
	6: PTRADD const[0:4]
	7: unique[cb180:10] = INT_ZEXT [handle:space][[handle:offset+80008]:8]
	8: PTRADD const[1:4]
	9: unique[cb280:10] = COPY [handle:space][[handle:offset]:[handle:size]]
	10: CBRANCH const[[rel:2]:4], [handle:space][[handle:offset]:1]
	11: unique[cb300:8] = SUBPIECE unique[cb280:10], const[0:4]
	12: unique[cb400:10] = INT_ZEXT unique[cb300:8]
	13: BRANCH const[[rel:3]:4]
	14: PTRADD const[2:4]
	15: unique[cb480:8] = SUBPIECE unique[cb280:10], const[8:4]
	16: unique[cb400:10] = INT_ZEXT unique[cb480:8]
	17: PTRADD const[3:4]
	18: unique[c8f80:4] = COPY const[0:4]
	19: unique[c9000:10] = COPY const[0:10]
	20: PTRADD const[4:4]
	21: unique[c9080:1] = INT_LESS const[3f:4], unique[c8f80:4]
	22: CBRANCH const[[rel:5]:4], unique[c9080:1]
	23: unique[c9100:10] = INT_LEFT const[1:10], unique[c8f80:4]
	24: unique[c9180:10] = INT_AND unique[cb180:10], unique[c9100:10]
	25: unique[c9200:1] = INT_EQUAL unique[c9180:10], const[0:10]
	26: CBRANCH const[[rel:6]:4], unique[c9200:1]
	27: unique[c9280:10] = INT_LEFT unique[cb400:10], unique[c8f80:4]
	28: unique[c9000:10] = INT_XOR unique[c9000:10], unique[c9280:10]
	29: PTRADD const[6:4]
	30: unique[c8f80:4] = INT_ADD unique[c8f80:4], const[1:4]
	31: BRANCH const[[rel:4]:4]
	32: PTRADD const[5:4]
	33: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c9000:10]
	34: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1192 :VPSRLVD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x45; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrlvd_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:1192(id0.2070) printpiece=[VPSRLVD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6905  1: XmmReg1 : 6904  2: YmmReg1 : 6907  3: XmmReg2_m128 : 6906  
Pattern id=2070 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:45:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c1200:10] = CALLOTHER const[272:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c1200:10]

Line avx2.sinc:1209 :VPSRLVD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x45; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsrlvd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1209(id0.2072) printpiece=[VPSRLVD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6914  1: YmmReg1 : 6913  2: YmmReg2_m256 : 6915  
Pattern id=2072 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:45:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[272:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1201 :VPSRLVQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x45; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrlvq_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:1201(id0.2071) printpiece=[VPSRLVQ,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6910  1: XmmReg1 : 6909  2: YmmReg1 : 6912  3: XmmReg2_m128 : 6911  
Pattern id=2071 pattern=cmb:(ctx:SS:X3:X[10xx]:[xx00][010x]:XX,ins:45:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c1380:10] = CALLOTHER const[273:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c1380:10]

Line avx2.sinc:1216 :VPSRLVQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x45; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsrlvq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1216(id0.2073) printpiece=[VPSRLVQ,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6917  1: YmmReg1 : 6916  2: YmmReg2_m256 : 6918  
Pattern id=2073 pattern=cmb:(ctx:SS:X3:X[11xx]:[xx00][010x]:XX,ins:45:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[273:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1176 :VPSRAVD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x46; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsravd_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:1176(id0.2068) printpiece=[VPSRAVD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6897  1: XmmReg1 : 6896  2: YmmReg1 : 6899  3: XmmReg2_m128 : 6898  
Pattern id=2068 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:46:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c1000:10] = CALLOTHER const[271:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c1000:10]

Line avx2.sinc:1184 :VPSRAVD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x46; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsravd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1184(id0.2069) printpiece=[VPSRAVD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6901  1: YmmReg1 : 6900  2: YmmReg2_m256 : 6902  
Pattern id=2069 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:46:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[271:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1048 :VPERM2I128 YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x46; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vperm2i128_avx2( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1048(id0.2051) printpiece=[VPERM2I128,  ,  B, ,,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: vexVVVV_YmmReg : 6832  1: YmmReg1 : 6831  2: YmmReg2_m256 : 6833  3: imm8 : 6834  
Pattern id=2051 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][011x]:XX,ins:46:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[268:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:1144 :VPSLLVD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x47; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsllvd_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:1144(id0.2064) printpiece=[VPSLLVD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6881  1: XmmReg1 : 6880  2: YmmReg1 : 6883  3: XmmReg2_m128 : 6882  
Pattern id=2064 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:47:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c0c00:10] = CALLOTHER const[26f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c0c00:10]

Line avx2.sinc:1161 :VPSLLVD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x47; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsllvd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1161(id0.2066) printpiece=[VPSLLVD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6890  1: YmmReg1 : 6889  2: YmmReg2_m256 : 6891  
Pattern id=2066 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:47:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1153 :VPSLLVQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x47; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsllvq_avx2( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:1153(id0.2065) printpiece=[VPSLLVQ,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6886  1: XmmReg1 : 6885  2: YmmReg1 : 6888  3: XmmReg2_m128 : 6887  
Pattern id=2065 pattern=cmb:(ctx:SS:X3:X[10xx]:[xx00][010x]:XX,ins:47:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c0d80:10] = CALLOTHER const[270:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c0d80:10]

Line avx2.sinc:1168 :VPSLLVQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x47; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsllvq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1168(id0.2067) printpiece=[VPSLLVQ,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6893  1: YmmReg1 : 6892  2: YmmReg2_m256 : 6894  
Pattern id=2067 pattern=cmb:(ctx:SS:X3:X[11xx]:[xx00][010x]:XX,ins:47:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[270:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2432 :DEC Rmr16     is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & row=4 & page=1 & Rmr16  { OF = sborrow(Rmr16,1);   Rmr16 =  Rmr16 - 1; resultflags( Rmr16); }
0: Constructor line ia.sinc:2432(id0.165) printpiece=[DEC,  ,  A]
Operands 0: Rmr16 : 1675  
Pattern id=165 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:4[1xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	6: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2433 :DEC Rmr32     is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & row=4 & page=1 & Rmr32 & check_Rmr32_dest  { OF = sborrow(Rmr32,1);   Rmr32 =  Rmr32 - 1; build check_Rmr32_dest; resultflags( Rmr32); }
0: Constructor line ia.sinc:2433(id0.166) printpiece=[DEC,  ,  A]
Operands 0: Rmr32 : 1676  1: check_Rmr32_dest : 1677  
Pattern id=166 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:4[1xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: MULTIEQUAL const[1:4]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1818 :VPBLENDVB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x4C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; Xmm_imm8_7_4
{
	local tmp:16 = vpblendvb_avx( vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1818(id0.1728) printpiece=[VPBLENDVB,  ,  B, ,,  ,  A, ,,  ,  D, ,,  ,  E]
Operands 0: vexVVVV_XmmReg : 5275  1: XmmReg1 : 5274  2: YmmReg1 : 5278  3: XmmReg2_m128 : 5276  4: Xmm_imm8_7_4 : 5277  
Pattern id=1728 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][011x]:XX,ins:4C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[abe00:10] = CALLOTHER const[16a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[abe00:10]

Line avx2.sinc:183 :VPBLENDVB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x4C; YmmReg1 ... & YmmReg2_m256; Ymm_imm8_7_4
{
	YmmReg1 = vpblendvb_avx2( vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:183(id0.1947) printpiece=[VPBLENDVB,  ,  B, ,,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: vexVVVV_YmmReg : 6356  1: YmmReg1 : 6355  2: YmmReg2_m256 : 6357  3: Ymm_imm8_7_4 : 6358  
Pattern id=1947 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][011x]:XX,ins:4C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[20d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:201 :VBLENDVPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x4A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; Xmm_imm8_7_4
{
	local tmp:16 = vblendvps_avx( vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:201(id0.1573) printpiece=[VBLENDVPS,  ,  B, ,,  ,  A, ,,  ,  D, ,,  ,  E]
Operands 0: vexVVVV_XmmReg : 4523  1: XmmReg1 : 4522  2: YmmReg1 : 4526  3: XmmReg2_m128 : 4524  4: Xmm_imm8_7_4 : 4525  
Pattern id=1573 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][011x]:XX,ins:4A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a1680:10] = CALLOTHER const[109:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a1680:10]

Line avx.sinc:209 :VBLENDVPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x4A; YmmReg1 ... & YmmReg2_m256; Ymm_imm8_7_4
{
	YmmReg1 = vblendvps_avx( vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:209(id0.1574) printpiece=[VBLENDVPS,  ,  B, ,,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: vexVVVV_YmmReg : 4528  1: YmmReg1 : 4527  2: YmmReg2_m256 : 4529  3: Ymm_imm8_7_4 : 4530  
Pattern id=1574 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][011x]:XX,ins:4A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[109:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:185 :VBLENDVPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x4B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; Xmm_imm8_7_4
{
	local tmp:16 = vblendvpd_avx( vexVVVV_XmmReg, XmmReg2_m128, Xmm_imm8_7_4 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:185(id0.1571) printpiece=[VBLENDVPD,  ,  B, ,,  ,  A, ,,  ,  D, ,,  ,  E]
Operands 0: vexVVVV_XmmReg : 4513  1: XmmReg1 : 4512  2: YmmReg1 : 4516  3: XmmReg2_m128 : 4514  4: Xmm_imm8_7_4 : 4515  
Pattern id=1571 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][011x]:XX,ins:4B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a1480:10] = CALLOTHER const[108:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a1480:10]

Line avx.sinc:193 :VBLENDVPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x4B; YmmReg1 ... & YmmReg2_m256; Ymm_imm8_7_4
{
	YmmReg1 = vblendvpd_avx( vexVVVV_YmmReg, YmmReg2_m256, Ymm_imm8_7_4 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:193(id0.1572) printpiece=[VBLENDVPD,  ,  B, ,,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: vexVVVV_YmmReg : 4518  1: YmmReg1 : 4517  2: YmmReg2_m256 : 4519  3: Ymm_imm8_7_4 : 4520  
Pattern id=1572 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][011x]:XX,ins:4B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[108:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3341 :PUSH Rmr16     is vexMode=0 & addrsize=0 & opsize=0 & row=5 & page=0 & Rmr16       { push22(Rmr16); }
0: Constructor line ia.sinc:3341(id0.404) printpiece=[PUSH,  ,  A]
Operands 0: Rmr16 : 2082  
Pattern id=404 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:5[0xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9400:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3343 :PUSH Rmr32     is vexMode=0 & addrsize=0 & opsize=1 & row=5 & page=0 & Rmr32       { push24(Rmr32); }
0: Constructor line ia.sinc:3343(id0.406) printpiece=[PUSH,  ,  A]
Operands 0: Rmr32 : 2084  
Pattern id=406 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:5[0xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9600:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:2] = INT_SUB register[10:2], const[4:2]
	3: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9780:4], unique[9600:4]

Line ia.sinc:3342 :PUSH Rmr16     is vexMode=0 & addrsize=1 & opsize=0 & row=5 & page=0 & Rmr16       { push42(Rmr16); }
0: Constructor line ia.sinc:3342(id0.405) printpiece=[PUSH,  ,  A]
Operands 0: Rmr16 : 2083  
Pattern id=405 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:5[0xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9a00:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[2:4]
	3: STORE const[ram:8], register[10:4], unique[9a00:2]

Line ia.sinc:3344 :PUSH Rmr32     is vexMode=0 & addrsize=1 & opsize=1 & row=5 & page=0 & Rmr32       { push44(Rmr32); }
0: Constructor line ia.sinc:3344(id0.407) printpiece=[PUSH,  ,  A]
Operands 0: Rmr32 : 2085  
Pattern id=407 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:5[0xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9b00:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[9b00:4]

Line avx.sinc:1352 :VMOVMSKPS Reg32, XmmReg2 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x50; Reg32 & (mod=0x3 & XmmReg2)
{
	Reg32 = vmovmskps_avx( XmmReg2 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:1352(id0.1674) printpiece=[VMOVMSKPS,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5012  1: Reg32 : 5010  2: XmmReg2 : 5011  
Pattern id=1674 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:50:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[146:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1359 :VMOVMSKPS Reg32, YmmReg2 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x50; Reg32 & (mod=0x3 & YmmReg2)
{
	Reg32 = vmovmskps_avx( YmmReg2 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:1359(id0.1675) printpiece=[VMOVMSKPS,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5015  1: Reg32 : 5013  2: YmmReg2 : 5014  
Pattern id=1675 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:50:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[146:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1337 :VMOVMSKPD Reg32, XmmReg2 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x50; Reg32 & (mod=0x3 & XmmReg2)
{
	Reg32 = vmovmskpd_avx( XmmReg2 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:1337(id0.1672) printpiece=[VMOVMSKPD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5005  1: Reg32 : 5003  2: XmmReg2 : 5004  
Pattern id=1672 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:50:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[145:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1344 :VMOVMSKPD Reg32, YmmReg2 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x50; Reg32 & (mod=0x3 & YmmReg2)
{
	Reg32 = vmovmskpd_avx( YmmReg2 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:1344(id0.1673) printpiece=[VMOVMSKPD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5008  1: Reg32 : 5006  2: YmmReg2 : 5007  
Pattern id=1673 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:50:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[145:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2902 :VSQRTPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x51; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vsqrtps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2902(id0.1852) printpiece=[VSQRTPS,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5956  1: XmmReg1 : 5954  2: YmmReg1 : 5957  3: XmmReg2_m128 : 5955  
Pattern id=1852 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:51:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b5a00:10] = CALLOTHER const[1d7:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b5a00:10]

Line avx.sinc:2910 :VSQRTPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x51; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vsqrtps_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2910(id0.1853) printpiece=[VSQRTPS,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5960  1: YmmReg1 : 5958  2: YmmReg2_m256 : 5959  
Pattern id=1853 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:51:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1d7:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2886 :VSQRTPD XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x51; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vsqrtpd_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2886(id0.1850) printpiece=[VSQRTPD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5948  1: XmmReg1 : 5946  2: YmmReg1 : 5949  3: XmmReg2_m128 : 5947  
Pattern id=1850 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:51:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b5800:10] = CALLOTHER const[1d6:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b5800:10]

Line avx.sinc:2894 :VSQRTPD YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x51; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vsqrtpd_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2894(id0.1851) printpiece=[VSQRTPD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5952  1: YmmReg1 : 5950  2: YmmReg2_m256 : 5951  
Pattern id=1851 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:51:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1d6:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2927 :VSQRTSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x51; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vsqrtss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2927(id0.1855) printpiece=[VSQRTSS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5971  1: vexVVVV_XmmReg : 5969  2: XmmReg1 : 5968  3: YmmReg1 : 5972  4: XmmReg2_m32 : 5970  
Pattern id=1855 pattern=cmb:(ctx:SS:X[010x]:X[10xx]:[xx00][001x]:XX,ins:51:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b5d80:10] = CALLOTHER const[1d9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b5d80:10]

Line avx.sinc:2918 :VSQRTSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x51; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vsqrtsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2918(id0.1854) printpiece=[VSQRTSD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5965  1: vexVVVV_XmmReg : 5963  2: XmmReg1 : 5962  3: YmmReg1 : 5966  4: XmmReg2_m64 : 5964  
Pattern id=1854 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:51:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b5c00:10] = CALLOTHER const[1d8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b5c00:10]

Line avx.sinc:2829 :VRSQRTPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x52; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vrsqrtps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2829(id0.1843) printpiece=[VRSQRTPS,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5909  1: XmmReg1 : 5907  2: YmmReg1 : 5910  3: XmmReg2_m128 : 5908  
Pattern id=1843 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:52:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b5080:10] = CALLOTHER const[1d2:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b5080:10]

Line avx.sinc:2837 :VRSQRTPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x52; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vrsqrtps_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2837(id0.1844) printpiece=[VRSQRTPS,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5913  1: YmmReg1 : 5911  2: YmmReg2_m256 : 5912  
Pattern id=1844 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:52:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1d2:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2845 :VRSQRTSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x52; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vrsqrtss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2845(id0.1845) printpiece=[VRSQRTSS,  ,  D, ,,  ,  C, ,,  ,  F]
Operands 0: vexL : 5918  1: rexWprefix : 5919  2: vexVVVV_XmmReg : 5916  3: XmmReg1 : 5915  4: YmmReg1 : 5920  5: XmmReg2_m32 : 5917  
Pattern id=1845 pattern=cmb:(ctx:SS:X[010x]:X[1xxx]:[xx00][001x]:XX,ins:52:XX:XX:XX)
Template
	0: MULTIEQUAL const[4:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[3:4]
	3: unique[b5280:10] = CALLOTHER const[1d3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b5280:10]

Line avx.sinc:2754 :VRCPPS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x53; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vrcpps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2754(id0.1834) printpiece=[VRCPPS,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5858  1: XmmReg1 : 5856  2: YmmReg1 : 5859  3: XmmReg2_m128 : 5857  
Pattern id=1834 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:53:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b4600:10] = CALLOTHER const[1cc:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4600:10]

Line avx.sinc:2762 :VRCPPS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x53; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vrcpps_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2762(id0.1835) printpiece=[VRCPPS,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 5862  1: YmmReg1 : 5860  2: YmmReg2_m256 : 5861  
Pattern id=1835 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:53:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1cc:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2770 :VRCPSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_LIG) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x53; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vrcpss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2770(id0.1836) printpiece=[VRCPSS,  ,  D, ,,  ,  C, ,,  ,  F]
Operands 0: vexL : 5867  1: rexWprefix : 5868  2: vexVVVV_XmmReg : 5865  3: XmmReg1 : 5864  4: YmmReg1 : 5869  5: XmmReg2_m32 : 5866  
Pattern id=1836 pattern=cmb:(ctx:SS:X[010x]:X[1xxx]:[xx00][001x]:XX,ins:53:XX:XX:XX)
Template
	0: MULTIEQUAL const[4:4]
	1: MULTIEQUAL const[5:4]
	2: MULTIEQUAL const[3:4]
	3: unique[b4800:10] = CALLOTHER const[1cd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4800:10]

Line avx.sinc:105 :VANDPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x54; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vandps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:105(id0.1561) printpiece=[VANDPS,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 4465  1: XmmReg1 : 4464  2: YmmReg1 : 4467  3: XmmReg2_m128 : 4466  
Pattern id=1561 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:54:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a0a80:10] = CALLOTHER const[103:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a0a80:10]

Line avx.sinc:113 :VANDPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x54; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vandps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:113(id0.1562) printpiece=[VANDPS,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 4469  1: YmmReg1 : 4468  2: YmmReg2_m256 : 4470  
Pattern id=1562 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:54:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[103:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:89 :VANDPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x54; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vandpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:89(id0.1559) printpiece=[VANDPD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 4457  1: XmmReg1 : 4456  2: YmmReg1 : 4459  3: XmmReg2_m128 : 4458  
Pattern id=1559 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:54:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a0880:10] = CALLOTHER const[102:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a0880:10]

Line avx.sinc:97 :VANDPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x54; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vandpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:97(id0.1560) printpiece=[VANDPD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 4461  1: YmmReg1 : 4460  2: YmmReg2_m256 : 4462  
Pattern id=1560 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:54:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[102:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:137 :VANDNPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x55; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vandnps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:137(id0.1565) printpiece=[VANDNPS,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 4481  1: XmmReg1 : 4480  2: YmmReg1 : 4483  3: XmmReg2_m128 : 4482  
Pattern id=1565 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:55:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a0e80:10] = CALLOTHER const[105:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a0e80:10]

Line avx.sinc:145 :VANDNPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x55; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vandnps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:145(id0.1566) printpiece=[VANDNPS,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 4485  1: YmmReg1 : 4484  2: YmmReg2_m256 : 4486  
Pattern id=1566 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:55:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[105:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:121 :VANDNPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x55; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vandnpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:121(id0.1563) printpiece=[VANDNPD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 4473  1: XmmReg1 : 4472  2: YmmReg1 : 4475  3: XmmReg2_m128 : 4474  
Pattern id=1563 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:55:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a0c80:10] = CALLOTHER const[104:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a0c80:10]

Line avx.sinc:129 :VANDNPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x55; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vandnpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:129(id0.1564) printpiece=[VANDNPD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 4477  1: YmmReg1 : 4476  2: YmmReg2_m256 : 4478  
Pattern id=1564 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:55:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[104:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1622 :VORPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x56; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vorps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1622(id0.1706) printpiece=[VORPS,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 5150  1: XmmReg1 : 5149  2: YmmReg1 : 5152  3: XmmReg2_m128 : 5151  
Pattern id=1706 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:56:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a9e00:10] = CALLOTHER const[155:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a9e00:10]

Line avx.sinc:1630 :VORPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x56; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vorps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1630(id0.1707) printpiece=[VORPS,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 5154  1: YmmReg1 : 5153  2: YmmReg2_m256 : 5155  
Pattern id=1707 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:56:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[155:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1606 :VORPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0x56; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vorpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1606(id0.1704) printpiece=[VORPD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 5142  1: XmmReg1 : 5141  2: YmmReg1 : 5144  3: XmmReg2_m128 : 5143  
Pattern id=1704 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:56:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a9c00:10] = CALLOTHER const[154:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a9c00:10]

Line avx.sinc:1614 :VORPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0x56; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vorpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1614(id0.1705) printpiece=[VORPD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 5146  1: YmmReg1 : 5145  2: YmmReg2_m256 : 5147  
Pattern id=1705 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:56:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[154:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3338 :VXORPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x57; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vxorps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3338(id0.1907) printpiece=[VXORPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6177  1: vexVVVV_XmmReg : 6175  2: XmmReg1 : 6174  3: YmmReg1 : 6178  4: XmmReg2_m128 : 6176  
Pattern id=1907 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:57:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b8580:10] = CALLOTHER const[1f6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b8580:10]

Line avx.sinc:3346 :VXORPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x57; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vxorps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3346(id0.1908) printpiece=[VXORPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6182  1: vexVVVV_YmmReg : 6180  2: YmmReg1 : 6179  3: YmmReg2_m256 : 6181  
Pattern id=1908 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:57:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1f6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3322 :VXORPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x57; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vxorpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:3322(id0.1905) printpiece=[VXORPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6167  1: vexVVVV_XmmReg : 6165  2: XmmReg1 : 6164  3: YmmReg1 : 6168  4: XmmReg2_m128 : 6166  
Pattern id=1905 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:57:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b8380:10] = CALLOTHER const[1f5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b8380:10]

Line avx.sinc:3330 :VXORPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x57; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vxorpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:3330(id0.1906) printpiece=[VXORPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6172  1: vexVVVV_YmmReg : 6170  2: YmmReg1 : 6169  3: YmmReg2_m256 : 6171  
Pattern id=1906 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:57:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1f5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3279 :POP Rmr16      is vexMode=0 & addrsize=0 & opsize=0 & row=5 & page=1 & Rmr16       { pop22(Rmr16); }
0: Constructor line ia.sinc:3279(id0.369) printpiece=[POP,  ,  A]
Operands 0: Rmr16 : 2053  
Pattern id=369 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:5[1xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	2: [handle:space][[handle:offset]:[handle:size]] = LOAD const[ram:8], unique[9e80:4]
	3: register[10:2] = INT_ADD register[10:2], const[2:2]

Line ia.sinc:3281 :POP Rmr32      is vexMode=0 & addrsize=0 & opsize=1 & row=5 & page=1 & Rmr32 		{ pop24(Rmr32); }
0: Constructor line ia.sinc:3281(id0.371) printpiece=[POP,  ,  A]
Operands 0: Rmr32 : 2055  
Pattern id=371 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:5[1xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	2: [handle:space][[handle:offset]:[handle:size]] = LOAD const[ram:8], unique[a080:4]
	3: register[10:2] = INT_ADD register[10:2], const[4:2]

Line ia.sinc:3280 :POP Rmr16      is vexMode=0 & addrsize=1 & opsize=0 & row=5 & page=1 & Rmr16       { pop42(Rmr16); }
0: Constructor line ia.sinc:3280(id0.370) printpiece=[POP,  ,  A]
Operands 0: Rmr16 : 2054  
Pattern id=370 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:5[1xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = LOAD const[ram:8], register[10:4]
	2: register[10:4] = INT_ADD register[10:4], const[2:4]

Line ia.sinc:3282 :POP Rmr32      is vexMode=0 & addrsize=1 & opsize=1 & row=5 & page=1 & Rmr32 		{ pop44(Rmr32); }
0: Constructor line ia.sinc:3282(id0.372) printpiece=[POP,  ,  A]
Operands 0: Rmr32 : 2056  
Pattern id=372 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:5[1xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = LOAD const[ram:8], register[10:4]
	2: register[10:4] = INT_ADD register[10:4], const[4:4]

Line avx.sinc:23 :VADDPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vaddps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:23(id0.1551) printpiece=[VADDPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4417  1: vexVVVV_XmmReg : 4415  2: XmmReg1 : 4414  3: YmmReg1 : 4418  4: XmmReg2_m128 : 4416  
Pattern id=1551 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:58:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[9ff80:10] = CALLOTHER const[fd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[9ff80:10]

Line avx.sinc:31 :VADDPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x58; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vaddps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:31(id0.1552) printpiece=[VADDPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4422  1: vexVVVV_YmmReg : 4420  2: YmmReg1 : 4419  3: YmmReg2_m256 : 4421  
Pattern id=1552 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:58:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[fd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:7 :VADDPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vaddpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:7(id0.1549) printpiece=[VADDPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4407  1: vexVVVV_XmmReg : 4405  2: XmmReg1 : 4404  3: YmmReg1 : 4408  4: XmmReg2_m128 : 4406  
Pattern id=1549 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:58:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[9fd80:10] = CALLOTHER const[fc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[9fd80:10]

Line avx2.sinc:1008 :VPBROADCASTD XmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vpbroadcastd_avx2( XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:1008(id0.2046) printpiece=[VPBROADCASTD,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 6816  1: YmmReg1 : 6818  2: XmmReg2_m32 : 6817  
Pattern id=2046 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:58:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[bff00:10] = CALLOTHER const[265:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[bff00:10]

Line avx.sinc:15 :VADDPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x58; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vaddpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:15(id0.1550) printpiece=[VADDPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4412  1: vexVVVV_YmmReg : 4410  2: YmmReg1 : 4409  3: YmmReg2_m256 : 4411  
Pattern id=1550 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:58:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[fc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1016 :VPBROADCASTD YmmReg1, XmmReg2_m32 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x58; YmmReg1 ... & XmmReg2_m32
{
	YmmReg1 = vpbroadcastd_avx2( XmmReg2_m32 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1016(id0.2047) printpiece=[VPBROADCASTD,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6819  1: XmmReg2_m32 : 6820  
Pattern id=2047 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:58:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[265:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:48 :VADDSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vaddss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:48(id0.1554) printpiece=[VADDSS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4433  1: vexVVVV_XmmReg : 4431  2: XmmReg1 : 4430  3: YmmReg1 : 4434  4: XmmReg2_m32 : 4432  
Pattern id=1554 pattern=cmb:(ctx:SS:X[010x]:X[10xx]:[xx00][001x]:XX,ins:58:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a0300:10] = CALLOTHER const[ff:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a0300:10]

Line avx.sinc:39 :VADDSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x58; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vaddsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:39(id0.1553) printpiece=[VADDSD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4427  1: vexVVVV_XmmReg : 4425  2: XmmReg1 : 4424  3: YmmReg1 : 4428  4: XmmReg2_m64 : 4426  
Pattern id=1553 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:58:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a0180:10] = CALLOTHER const[fe:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a0180:10]

Line avx.sinc:1572 :VMULPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmulps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1572(id0.1700) printpiece=[VMULPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5122  1: vexVVVV_XmmReg : 5120  2: XmmReg1 : 5119  3: YmmReg1 : 5123  4: XmmReg2_m128 : 5121  
Pattern id=1700 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:59:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a9700:10] = CALLOTHER const[151:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a9700:10]

Line avx.sinc:1580 :VMULPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x59; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmulps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1580(id0.1701) printpiece=[VMULPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5127  1: vexVVVV_YmmReg : 5125  2: YmmReg1 : 5124  3: YmmReg2_m256 : 5126  
Pattern id=1701 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:59:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[151:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1556 :VMULPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmulpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1556(id0.1698) printpiece=[VMULPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5112  1: vexVVVV_XmmReg : 5110  2: XmmReg1 : 5109  3: YmmReg1 : 5113  4: XmmReg2_m128 : 5111  
Pattern id=1698 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:59:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a9500:10] = CALLOTHER const[150:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a9500:10]

Line avx2.sinc:1024 :VPBROADCASTQ XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vpbroadcastq_avx2( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:1024(id0.2048) printpiece=[VPBROADCASTQ,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 6822  1: YmmReg1 : 6824  2: XmmReg2_m64 : 6823  
Pattern id=2048 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:59:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[c0100:10] = CALLOTHER const[266:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c0100:10]

Line avx.sinc:1564 :VMULPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x59; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmulpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1564(id0.1699) printpiece=[VMULPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5117  1: vexVVVV_YmmReg : 5115  2: YmmReg1 : 5114  3: YmmReg2_m256 : 5116  
Pattern id=1699 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:59:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[150:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1032 :VPBROADCASTQ YmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x59; YmmReg1 ... & XmmReg2_m64
{
	YmmReg1 = vpbroadcastq_avx2( XmmReg2_m64 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1032(id0.2049) printpiece=[VPBROADCASTQ,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6825  1: XmmReg2_m64 : 6826  
Pattern id=2049 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:59:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[266:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1597 :VMULSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vmulss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1597(id0.1703) printpiece=[VMULSS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5138  1: vexVVVV_XmmReg : 5136  2: XmmReg1 : 5135  3: YmmReg1 : 5139  4: XmmReg2_m32 : 5137  
Pattern id=1703 pattern=cmb:(ctx:SS:X[010x]:X[10xx]:[xx00][001x]:XX,ins:59:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a9a80:10] = CALLOTHER const[153:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a9a80:10]

Line avx.sinc:1588 :VMULSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x59; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vmulsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1588(id0.1702) printpiece=[VMULSD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5132  1: vexVVVV_XmmReg : 5130  2: XmmReg1 : 5129  3: YmmReg1 : 5133  4: XmmReg2_m64 : 5131  
Pattern id=1702 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:59:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a9900:10] = CALLOTHER const[152:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a9900:10]

Line avx.sinc:631 :VCVTPS2PD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x5A; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vcvtps2pd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:631(id0.1593) printpiece=[VCVTPS2PD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4646  1: XmmReg1 : 4644  2: YmmReg1 : 4647  3: XmmReg2_m64 : 4645  
Pattern id=1593 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:5A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a3080:10] = CALLOTHER const[115:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3080:10]

Line avx.sinc:639 :VCVTPS2PD YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x5A; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vcvtps2pd_avx( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:639(id0.1594) printpiece=[VCVTPS2PD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4650  1: YmmReg1 : 4648  2: XmmReg2_m128 : 4649  
Pattern id=1594 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:5A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[115:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:598 :VCVTPD2PS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x5A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvtpd2ps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:598(id0.1589) printpiece=[VCVTPD2PS,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4629  1: XmmReg1 : 4627  2: YmmReg1 : 4630  3: XmmReg2_m128 : 4628  
Pattern id=1589 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:5A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a2b80:10] = CALLOTHER const[113:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2b80:10]

Line avx.sinc:606 :VCVTPD2PS XmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x5A; (XmmReg1 & YmmReg1) ... & YmmReg2_m256
{
	local tmp:16 = vcvtpd2ps_avx( YmmReg2_m256 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:606(id0.1590) printpiece=[VCVTPD2PS,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4633  1: XmmReg1 : 4631  2: YmmReg1 : 4634  3: YmmReg2_m256 : 4632  
Pattern id=1590 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:5A:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a2d00:10] = CALLOTHER const[113:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2d00:10]

Line avx2.sinc:1040 :VBROADCASTI128 YmmReg1, m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x5A; YmmReg1 ... & m128
{
	YmmReg1 = vbroadcasti128_avx2( m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1040(id0.2050) printpiece=[VBROADCASTI128,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6828  1: m128 : 6829  
Pattern id=2050 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:5A:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[267:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:742 :VCVTSS2SD XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5A; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vcvtss2sd_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:742(id0.1603) printpiece=[VCVTSS2SD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4687  1: vexVVVV_XmmReg : 4685  2: XmmReg1 : 4684  3: YmmReg1 : 4688  4: XmmReg2_m32 : 4686  
Pattern id=1603 pattern=cmb:(ctx:SS:X[010x]:X[10xx]:[xx00][001x]:XX,ins:5A:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a3a80:10] = CALLOTHER const[11c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3a80:10]

Line avx.sinc:695 :VCVTSD2SS XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5A; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vcvtsd2ss_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:695(id0.1600) printpiece=[VCVTSD2SS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4671  1: vexVVVV_XmmReg : 4669  2: XmmReg1 : 4668  3: YmmReg1 : 4672  4: XmmReg2_m64 : 4670  
Pattern id=1600 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:5A:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a3600:10] = CALLOTHER const[119:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3600:10]

Line avx.sinc:565 :VCVTDQ2PS XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvtdq2ps_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:565(id0.1585) printpiece=[VCVTDQ2PS,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4612  1: XmmReg1 : 4610  2: YmmReg1 : 4613  3: XmmReg2_m128 : 4611  
Pattern id=1585 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:5B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a2680:10] = CALLOTHER const[111:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2680:10]

Line avx.sinc:573 :VCVTDQ2PS YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vcvtdq2ps_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:573(id0.1586) printpiece=[VCVTDQ2PS,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4616  1: YmmReg1 : 4614  2: YmmReg2_m256 : 4615  
Pattern id=1586 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:5B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[111:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:615 :VCVTPS2DQ XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvtps2dq_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:615(id0.1591) printpiece=[VCVTPS2DQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4638  1: XmmReg1 : 4636  2: YmmReg1 : 4639  3: XmmReg2_m128 : 4637  
Pattern id=1591 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:5B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a2e80:10] = CALLOTHER const[114:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2e80:10]

Line avx.sinc:623 :VCVTPS2DQ YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vcvtps2dq_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:623(id0.1592) printpiece=[VCVTPS2DQ,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4642  1: YmmReg1 : 4640  2: YmmReg2_m256 : 4641  
Pattern id=1592 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:5B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[114:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:784 :VCVTTPS2DQ XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvttps2dq_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:784(id0.1607) printpiece=[VCVTTPS2DQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4704  1: XmmReg1 : 4702  2: YmmReg1 : 4705  3: XmmReg2_m128 : 4703  
Pattern id=1607 pattern=cmb:(ctx:SS:X[010x]:X8:0[001x]:XX,ins:5B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a3f80:10] = CALLOTHER const[11f:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3f80:10]

Line avx.sinc:792 :VCVTTPS2DQ YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x5B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vcvttps2dq_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:792(id0.1608) printpiece=[VCVTTPS2DQ,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4708  1: YmmReg1 : 4706  2: YmmReg2_m256 : 4707  
Pattern id=1608 pattern=cmb:(ctx:SS:X[010x]:XC:0[001x]:XX,ins:5B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[11f:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2959 :VSUBPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vsubps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2959(id0.1859) printpiece=[VSUBPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5990  1: vexVVVV_XmmReg : 5988  2: XmmReg1 : 5987  3: YmmReg1 : 5991  4: XmmReg2_m128 : 5989  
Pattern id=1859 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:5C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b6180:10] = CALLOTHER const[1dc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b6180:10]

Line avx.sinc:2967 :VSUBPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vsubps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2967(id0.1860) printpiece=[VSUBPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5995  1: vexVVVV_YmmReg : 5993  2: YmmReg1 : 5992  3: YmmReg2_m256 : 5994  
Pattern id=1860 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:5C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1dc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2943 :VSUBPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vsubpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2943(id0.1857) printpiece=[VSUBPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5980  1: vexVVVV_XmmReg : 5978  2: XmmReg1 : 5977  3: YmmReg1 : 5981  4: XmmReg2_m128 : 5979  
Pattern id=1857 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:5C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b5f80:10] = CALLOTHER const[1db:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b5f80:10]

Line avx.sinc:2951 :VSUBPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vsubpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2951(id0.1858) printpiece=[VSUBPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5985  1: vexVVVV_YmmReg : 5983  2: YmmReg1 : 5982  3: YmmReg2_m256 : 5984  
Pattern id=1858 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:5C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1db:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2984 :VSUBSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5C; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vsubss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2984(id0.1862) printpiece=[VSUBSS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6006  1: vexVVVV_XmmReg : 6004  2: XmmReg1 : 6003  3: YmmReg1 : 6007  4: XmmReg2_m32 : 6005  
Pattern id=1862 pattern=cmb:(ctx:SS:X[010x]:X[10xx]:[xx00][001x]:XX,ins:5C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b6500:10] = CALLOTHER const[1de:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b6500:10]

Line avx.sinc:2975 :VSUBSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5C; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vsubsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2975(id0.1861) printpiece=[VSUBSD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 6000  1: vexVVVV_XmmReg : 5998  2: XmmReg1 : 5997  3: YmmReg1 : 6001  4: XmmReg2_m64 : 5999  
Pattern id=1861 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:5C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b6380:10] = CALLOTHER const[1dd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b6380:10]

Line avx.sinc:1085 :VMINPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vminps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1085(id0.1642) printpiece=[VMINPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4879  1: vexVVVV_XmmReg : 4877  2: XmmReg1 : 4876  3: YmmReg1 : 4880  4: XmmReg2_m128 : 4878  
Pattern id=1642 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:5D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a6200:10] = CALLOTHER const[136:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a6200:10]

Line avx.sinc:1093 :VMINPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vminps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1093(id0.1643) printpiece=[VMINPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4884  1: vexVVVV_YmmReg : 4882  2: YmmReg1 : 4881  3: YmmReg2_m256 : 4883  
Pattern id=1643 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:5D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[136:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1069 :VMINPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vminpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1069(id0.1640) printpiece=[VMINPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4869  1: vexVVVV_XmmReg : 4867  2: XmmReg1 : 4866  3: YmmReg1 : 4870  4: XmmReg2_m128 : 4868  
Pattern id=1640 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:5D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a6000:10] = CALLOTHER const[135:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a6000:10]

Line avx.sinc:1077 :VMINPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vminpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1077(id0.1641) printpiece=[VMINPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4874  1: vexVVVV_YmmReg : 4872  2: YmmReg1 : 4871  3: YmmReg2_m256 : 4873  
Pattern id=1641 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:5D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[135:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1110 :VMINSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5D; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vminss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1110(id0.1645) printpiece=[VMINSS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4895  1: vexVVVV_XmmReg : 4893  2: XmmReg1 : 4892  3: YmmReg1 : 4896  4: XmmReg2_m32 : 4894  
Pattern id=1645 pattern=cmb:(ctx:SS:X[010x]:X[10xx]:[xx00][001x]:XX,ins:5D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a6580:10] = CALLOTHER const[138:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a6580:10]

Line avx.sinc:1101 :VMINSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5D; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vminsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1101(id0.1644) printpiece=[VMINSD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4889  1: vexVVVV_XmmReg : 4887  2: XmmReg1 : 4886  3: YmmReg1 : 4890  4: XmmReg2_m64 : 4888  
Pattern id=1644 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:5D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a6400:10] = CALLOTHER const[137:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a6400:10]

Line avx.sinc:848 :VDIVPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vdivps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:848(id0.1613) printpiece=[VDIVPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4729  1: vexVVVV_XmmReg : 4727  2: XmmReg1 : 4726  3: YmmReg1 : 4730  4: XmmReg2_m128 : 4728  
Pattern id=1613 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:5E:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a4480:10] = CALLOTHER const[123:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a4480:10]

Line avx.sinc:856 :VDIVPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vdivps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:856(id0.1614) printpiece=[VDIVPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4734  1: vexVVVV_YmmReg : 4732  2: YmmReg1 : 4731  3: YmmReg2_m256 : 4733  
Pattern id=1614 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:5E:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[123:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:832 :VDIVPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5E; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vdivpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:832(id0.1611) printpiece=[VDIVPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4719  1: vexVVVV_XmmReg : 4717  2: XmmReg1 : 4716  3: YmmReg1 : 4720  4: XmmReg2_m128 : 4718  
Pattern id=1611 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:5E:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a4280:10] = CALLOTHER const[122:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a4280:10]

Line avx.sinc:840 :VDIVPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5E; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vdivpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:840(id0.1612) printpiece=[VDIVPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4724  1: vexVVVV_YmmReg : 4722  2: YmmReg1 : 4721  3: YmmReg2_m256 : 4723  
Pattern id=1612 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:5E:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[122:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:873 :VDIVSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5E; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vdivss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:873(id0.1616) printpiece=[VDIVSS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4745  1: vexVVVV_XmmReg : 4743  2: XmmReg1 : 4742  3: YmmReg1 : 4746  4: XmmReg2_m32 : 4744  
Pattern id=1616 pattern=cmb:(ctx:SS:X[010x]:X[10xx]:[xx00][001x]:XX,ins:5E:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a4800:10] = CALLOTHER const[125:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a4800:10]

Line avx.sinc:864 :VDIVSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5E; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vdivsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:864(id0.1615) printpiece=[VDIVSD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4739  1: vexVVVV_XmmReg : 4737  2: XmmReg1 : 4736  3: YmmReg1 : 4740  4: XmmReg2_m64 : 4738  
Pattern id=1615 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:5E:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a4680:10] = CALLOTHER const[124:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a4680:10]

Line avx.sinc:1035 :VMAXPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmaxps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1035(id0.1636) printpiece=[VMAXPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4847  1: vexVVVV_XmmReg : 4845  2: XmmReg1 : 4844  3: YmmReg1 : 4848  4: XmmReg2_m128 : 4846  
Pattern id=1636 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:5F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a5b00:10] = CALLOTHER const[132:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a5b00:10]

Line avx.sinc:1043 :VMAXPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmaxps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1043(id0.1637) printpiece=[VMAXPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4852  1: vexVVVV_YmmReg : 4850  2: YmmReg1 : 4849  3: YmmReg2_m256 : 4851  
Pattern id=1637 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:5F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[132:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1019 :VMAXPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmaxpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1019(id0.1634) printpiece=[VMAXPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4837  1: vexVVVV_XmmReg : 4835  2: XmmReg1 : 4834  3: YmmReg1 : 4838  4: XmmReg2_m128 : 4836  
Pattern id=1634 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:5F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a5900:10] = CALLOTHER const[131:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a5900:10]

Line avx.sinc:1027 :VMAXPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x5F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmaxpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1027(id0.1635) printpiece=[VMAXPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4842  1: vexVVVV_YmmReg : 4840  2: YmmReg1 : 4839  3: YmmReg2_m256 : 4841  
Pattern id=1635 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:5F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[131:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1060 :VMAXSS XmmReg1, vexVVVV_XmmReg, XmmReg2_m32 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5F; (XmmReg1 & YmmReg1) ... & XmmReg2_m32
{
	local tmp:16 = vmaxss_avx( vexVVVV_XmmReg, XmmReg2_m32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1060(id0.1639) printpiece=[VMAXSS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4863  1: vexVVVV_XmmReg : 4861  2: XmmReg1 : 4860  3: YmmReg1 : 4864  4: XmmReg2_m32 : 4862  
Pattern id=1639 pattern=cmb:(ctx:SS:X[010x]:X[10xx]:[xx00][001x]:XX,ins:5F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a5e80:10] = CALLOTHER const[134:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a5e80:10]

Line avx.sinc:1051 :VMAXSD XmmReg1, vexVVVV_XmmReg, XmmReg2_m64 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x5F; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vmaxsd_avx( vexVVVV_XmmReg, XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1051(id0.1638) printpiece=[VMAXSD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4857  1: vexVVVV_XmmReg : 4855  2: XmmReg1 : 4854  3: YmmReg1 : 4858  4: XmmReg2_m64 : 4856  
Pattern id=1638 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:5F:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a5d00:10] = CALLOTHER const[133:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a5d00:10]

Line ia.sinc:3391 :PUSHA          is vexMode=0 & addrsize=0 & opsize=0 & byte=0x60            { local tmp=SP; push22(AX); push22(CX); push22(DX); push22(BX); push22(tmp); push22(BP); push22(SI); push22(DI); }
0: Constructor line ia.sinc:3391(id0.428) printpiece=[PUSHA]
Operands 
Pattern id=428 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:60:XX:XX:XX)
Template
	0: unique[2fc00:2] = COPY register[10:2]
	1: unique[9400:2] = COPY register[0:2]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]
	5: unique[9400:2] = COPY register[4:2]
	6: register[10:2] = INT_SUB register[10:2], const[2:2]
	7: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	8: STORE const[ram:8], unique[9580:4], unique[9400:2]
	9: unique[9400:2] = COPY register[8:2]
	10: register[10:2] = INT_SUB register[10:2], const[2:2]
	11: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	12: STORE const[ram:8], unique[9580:4], unique[9400:2]
	13: unique[9400:2] = COPY register[c:2]
	14: register[10:2] = INT_SUB register[10:2], const[2:2]
	15: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	16: STORE const[ram:8], unique[9580:4], unique[9400:2]
	17: unique[9400:2] = COPY unique[2fc00:2]
	18: register[10:2] = INT_SUB register[10:2], const[2:2]
	19: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	20: STORE const[ram:8], unique[9580:4], unique[9400:2]
	21: unique[9400:2] = COPY register[14:2]
	22: register[10:2] = INT_SUB register[10:2], const[2:2]
	23: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	24: STORE const[ram:8], unique[9580:4], unique[9400:2]
	25: unique[9400:2] = COPY register[18:2]
	26: register[10:2] = INT_SUB register[10:2], const[2:2]
	27: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	28: STORE const[ram:8], unique[9580:4], unique[9400:2]
	29: unique[9400:2] = COPY register[1c:2]
	30: register[10:2] = INT_SUB register[10:2], const[2:2]
	31: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	32: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3393 :PUSHAD         is vexMode=0 & addrsize=0 & opsize=1 & byte=0x60            { local tmp=ESP; push24(EAX); push24(ECX); push24(EDX); push24(EBX); push24(tmp); push24(EBP); push24(ESI); push24(EDI); }
0: Constructor line ia.sinc:3393(id0.430) printpiece=[PUSHAD]
Operands 
Pattern id=430 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:60:XX:XX:XX)
Template
	0: unique[2fd00:4] = COPY register[10:4]
	1: unique[9600:4] = COPY register[0:4]
	2: register[10:2] = INT_SUB register[10:2], const[4:2]
	3: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9780:4], unique[9600:4]
	5: unique[9600:4] = COPY register[4:4]
	6: register[10:2] = INT_SUB register[10:2], const[4:2]
	7: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	8: STORE const[ram:8], unique[9780:4], unique[9600:4]
	9: unique[9600:4] = COPY register[8:4]
	10: register[10:2] = INT_SUB register[10:2], const[4:2]
	11: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	12: STORE const[ram:8], unique[9780:4], unique[9600:4]
	13: unique[9600:4] = COPY register[c:4]
	14: register[10:2] = INT_SUB register[10:2], const[4:2]
	15: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	16: STORE const[ram:8], unique[9780:4], unique[9600:4]
	17: unique[9600:4] = COPY unique[2fd00:4]
	18: register[10:2] = INT_SUB register[10:2], const[4:2]
	19: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	20: STORE const[ram:8], unique[9780:4], unique[9600:4]
	21: unique[9600:4] = COPY register[14:4]
	22: register[10:2] = INT_SUB register[10:2], const[4:2]
	23: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	24: STORE const[ram:8], unique[9780:4], unique[9600:4]
	25: unique[9600:4] = COPY register[18:4]
	26: register[10:2] = INT_SUB register[10:2], const[4:2]
	27: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	28: STORE const[ram:8], unique[9780:4], unique[9600:4]
	29: unique[9600:4] = COPY register[1c:4]
	30: register[10:2] = INT_SUB register[10:2], const[4:2]
	31: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	32: STORE const[ram:8], unique[9780:4], unique[9600:4]

Line ia.sinc:3392 :PUSHA          is vexMode=0 & addrsize=1 & opsize=0 & byte=0x60            { local tmp=SP; push42(AX); push42(CX); push42(DX); push42(BX); push42(tmp); push42(BP); push42(SI); push42(DI); }
0: Constructor line ia.sinc:3392(id0.429) printpiece=[PUSHA]
Operands 
Pattern id=429 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:60:XX:XX:XX)
Template
	0: unique[2fc80:2] = COPY register[10:2]
	1: unique[9a00:2] = COPY register[0:2]
	2: register[10:4] = INT_SUB register[10:4], const[2:4]
	3: STORE const[ram:8], register[10:4], unique[9a00:2]
	4: unique[9a00:2] = COPY register[4:2]
	5: register[10:4] = INT_SUB register[10:4], const[2:4]
	6: STORE const[ram:8], register[10:4], unique[9a00:2]
	7: unique[9a00:2] = COPY register[8:2]
	8: register[10:4] = INT_SUB register[10:4], const[2:4]
	9: STORE const[ram:8], register[10:4], unique[9a00:2]
	10: unique[9a00:2] = COPY register[c:2]
	11: register[10:4] = INT_SUB register[10:4], const[2:4]
	12: STORE const[ram:8], register[10:4], unique[9a00:2]
	13: unique[9a00:2] = COPY unique[2fc80:2]
	14: register[10:4] = INT_SUB register[10:4], const[2:4]
	15: STORE const[ram:8], register[10:4], unique[9a00:2]
	16: unique[9a00:2] = COPY register[14:2]
	17: register[10:4] = INT_SUB register[10:4], const[2:4]
	18: STORE const[ram:8], register[10:4], unique[9a00:2]
	19: unique[9a00:2] = COPY register[18:2]
	20: register[10:4] = INT_SUB register[10:4], const[2:4]
	21: STORE const[ram:8], register[10:4], unique[9a00:2]
	22: unique[9a00:2] = COPY register[1c:2]
	23: register[10:4] = INT_SUB register[10:4], const[2:4]
	24: STORE const[ram:8], register[10:4], unique[9a00:2]

Line ia.sinc:3394 :PUSHAD         is vexMode=0 & addrsize=1 & opsize=1 & byte=0x60            { local tmp=ESP; push44(EAX); push44(ECX); push44(EDX); push44(EBX); push44(tmp); push44(EBP); push44(ESI); push44(EDI); }
0: Constructor line ia.sinc:3394(id0.431) printpiece=[PUSHAD]
Operands 
Pattern id=431 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:60:XX:XX:XX)
Template
	0: unique[2fd80:4] = COPY register[10:4]
	1: unique[9b00:4] = COPY register[0:4]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[9b00:4]
	4: unique[9b00:4] = COPY register[4:4]
	5: register[10:4] = INT_SUB register[10:4], const[4:4]
	6: STORE const[ram:8], register[10:4], unique[9b00:4]
	7: unique[9b00:4] = COPY register[8:4]
	8: register[10:4] = INT_SUB register[10:4], const[4:4]
	9: STORE const[ram:8], register[10:4], unique[9b00:4]
	10: unique[9b00:4] = COPY register[c:4]
	11: register[10:4] = INT_SUB register[10:4], const[4:4]
	12: STORE const[ram:8], register[10:4], unique[9b00:4]
	13: unique[9b00:4] = COPY unique[2fd80:4]
	14: register[10:4] = INT_SUB register[10:4], const[4:4]
	15: STORE const[ram:8], register[10:4], unique[9b00:4]
	16: unique[9b00:4] = COPY register[14:4]
	17: register[10:4] = INT_SUB register[10:4], const[4:4]
	18: STORE const[ram:8], register[10:4], unique[9b00:4]
	19: unique[9b00:4] = COPY register[18:4]
	20: register[10:4] = INT_SUB register[10:4], const[4:4]
	21: STORE const[ram:8], register[10:4], unique[9b00:4]
	22: unique[9b00:4] = COPY register[1c:4]
	23: register[10:4] = INT_SUB register[10:4], const[4:4]
	24: STORE const[ram:8], register[10:4], unique[9b00:4]

Line avx.sinc:2709 :VPUNPCKLBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x60; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpcklbw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2709(id0.1829) printpiece=[VPUNPCKLBW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5829  1: vexVVVV_XmmReg : 5827  2: XmmReg1 : 5826  3: YmmReg1 : 5830  4: XmmReg2_m128 : 5828  
Pattern id=1829 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:60:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3e80:10] = CALLOTHER const[1c7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3e80:10]

Line avx.sinc:1874 :VPCMPESTRM XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A); byte=0x60; XmmReg1 ... & XmmReg2_m128; imm8
{
	vpcmpestrm_avx( XmmReg1, XmmReg2_m128, imm8:1 );
	# TODO missing destination or side effects
}
0: Constructor line avx.sinc:1874(id0.1734) printpiece=[VPCMPESTRM,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 5309  1: XmmReg2_m128 : 5310  2: imm8 : 5311  
Pattern id=1734 pattern=cmb:(ctx:SS:X[001x]:X8:0[011x]:XX,ins:60:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[170:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:861 :VPUNPCKLBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x60; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpcklbw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:861(id0.2034) printpiece=[VPUNPCKLBW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6768  1: vexVVVV_YmmReg : 6766  2: YmmReg1 : 6765  3: YmmReg2_m256 : 6767  
Pattern id=2034 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:60:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[25c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3305 :POPA           is vexMode=0 & addrsize=0 & opsize=0 & byte=0x61            { pop22(DI); pop22(SI); pop22(BP); tmp:2=0; pop22(tmp); pop22(BX); pop22(DX); pop22(CX); pop22(AX); }
0: Constructor line ia.sinc:3305(id0.383) printpiece=[POPA]
Operands 
Pattern id=383 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:61:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[1c:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]
	3: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: register[18:2] = LOAD const[ram:8], unique[9e80:4]
	5: register[10:2] = INT_ADD register[10:2], const[2:2]
	6: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	7: register[14:2] = LOAD const[ram:8], unique[9e80:4]
	8: register[10:2] = INT_ADD register[10:2], const[2:2]
	9: unique[2f600:2] = COPY const[0:2]
	10: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	11: unique[2f600:2] = LOAD const[ram:8], unique[9e80:4]
	12: register[10:2] = INT_ADD register[10:2], const[2:2]
	13: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	14: register[c:2] = LOAD const[ram:8], unique[9e80:4]
	15: register[10:2] = INT_ADD register[10:2], const[2:2]
	16: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	17: register[8:2] = LOAD const[ram:8], unique[9e80:4]
	18: register[10:2] = INT_ADD register[10:2], const[2:2]
	19: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	20: register[4:2] = LOAD const[ram:8], unique[9e80:4]
	21: register[10:2] = INT_ADD register[10:2], const[2:2]
	22: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	23: register[0:2] = LOAD const[ram:8], unique[9e80:4]
	24: register[10:2] = INT_ADD register[10:2], const[2:2]

Line ia.sinc:3307 :POPAD          is vexMode=0 & addrsize=0 & opsize=1 & byte=0x61            { pop24(EDI); pop24(ESI); pop24(EBP); tmp:4=0; pop24(tmp); pop24(EBX); pop24(EDX); pop24(ECX); pop24(EAX); }
0: Constructor line ia.sinc:3307(id0.385) printpiece=[POPAD]
Operands 
Pattern id=385 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:61:XX:XX:XX)
Template
	0: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[1c:4] = LOAD const[ram:8], unique[a080:4]
	2: register[10:2] = INT_ADD register[10:2], const[4:2]
	3: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: register[18:4] = LOAD const[ram:8], unique[a080:4]
	5: register[10:2] = INT_ADD register[10:2], const[4:2]
	6: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	7: register[14:4] = LOAD const[ram:8], unique[a080:4]
	8: register[10:2] = INT_ADD register[10:2], const[4:2]
	9: unique[2f700:4] = COPY const[0:4]
	10: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	11: unique[2f700:4] = LOAD const[ram:8], unique[a080:4]
	12: register[10:2] = INT_ADD register[10:2], const[4:2]
	13: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	14: register[c:4] = LOAD const[ram:8], unique[a080:4]
	15: register[10:2] = INT_ADD register[10:2], const[4:2]
	16: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	17: register[8:4] = LOAD const[ram:8], unique[a080:4]
	18: register[10:2] = INT_ADD register[10:2], const[4:2]
	19: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	20: register[4:4] = LOAD const[ram:8], unique[a080:4]
	21: register[10:2] = INT_ADD register[10:2], const[4:2]
	22: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	23: register[0:4] = LOAD const[ram:8], unique[a080:4]
	24: register[10:2] = INT_ADD register[10:2], const[4:2]

Line ia.sinc:3306 :POPA           is vexMode=0 & addrsize=1 & opsize=0 & byte=0x61            { pop42(DI); pop42(SI); pop42(BP); tmp:2=0; pop42(tmp); pop42(BX); pop42(DX); pop42(CX); pop42(AX); }
0: Constructor line ia.sinc:3306(id0.384) printpiece=[POPA]
Operands 
Pattern id=384 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:61:XX:XX:XX)
Template
	0: register[1c:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[2:4]
	2: register[18:2] = LOAD const[ram:8], register[10:4]
	3: register[10:4] = INT_ADD register[10:4], const[2:4]
	4: register[14:2] = LOAD const[ram:8], register[10:4]
	5: register[10:4] = INT_ADD register[10:4], const[2:4]
	6: unique[2f680:2] = COPY const[0:2]
	7: unique[2f680:2] = LOAD const[ram:8], register[10:4]
	8: register[10:4] = INT_ADD register[10:4], const[2:4]
	9: register[c:2] = LOAD const[ram:8], register[10:4]
	10: register[10:4] = INT_ADD register[10:4], const[2:4]
	11: register[8:2] = LOAD const[ram:8], register[10:4]
	12: register[10:4] = INT_ADD register[10:4], const[2:4]
	13: register[4:2] = LOAD const[ram:8], register[10:4]
	14: register[10:4] = INT_ADD register[10:4], const[2:4]
	15: register[0:2] = LOAD const[ram:8], register[10:4]
	16: register[10:4] = INT_ADD register[10:4], const[2:4]

Line ia.sinc:3308 :POPAD          is vexMode=0 & addrsize=1 & opsize=1 & byte=0x61            { pop44(EDI); pop44(ESI); pop44(EBP); tmp:4=0; pop44(tmp); pop44(EBX); pop44(EDX); pop44(ECX); pop44(EAX); }
0: Constructor line ia.sinc:3308(id0.386) printpiece=[POPAD]
Operands 
Pattern id=386 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:61:XX:XX:XX)
Template
	0: register[1c:4] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]
	2: register[18:4] = LOAD const[ram:8], register[10:4]
	3: register[10:4] = INT_ADD register[10:4], const[4:4]
	4: register[14:4] = LOAD const[ram:8], register[10:4]
	5: register[10:4] = INT_ADD register[10:4], const[4:4]
	6: unique[2f780:4] = COPY const[0:4]
	7: unique[2f780:4] = LOAD const[ram:8], register[10:4]
	8: register[10:4] = INT_ADD register[10:4], const[4:4]
	9: register[c:4] = LOAD const[ram:8], register[10:4]
	10: register[10:4] = INT_ADD register[10:4], const[4:4]
	11: register[8:4] = LOAD const[ram:8], register[10:4]
	12: register[10:4] = INT_ADD register[10:4], const[4:4]
	13: register[4:4] = LOAD const[ram:8], register[10:4]
	14: register[10:4] = INT_ADD register[10:4], const[4:4]
	15: register[0:4] = LOAD const[ram:8], register[10:4]
	16: register[10:4] = INT_ADD register[10:4], const[4:4]

Line avx.sinc:2718 :VPUNPCKLWD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x61; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpcklwd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2718(id0.1830) printpiece=[VPUNPCKLWD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5835  1: vexVVVV_XmmReg : 5833  2: XmmReg1 : 5832  3: YmmReg1 : 5836  4: XmmReg2_m128 : 5834  
Pattern id=1830 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:61:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b4000:10] = CALLOTHER const[1c8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4000:10]

Line avx.sinc:1866 :VPCMPESTRI XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A); byte=0x61; XmmReg1 ... & XmmReg2_m128; imm8
{
	vpcmpestri_avx( XmmReg1, XmmReg2_m128, imm8:1 );
	# TODO missing destination or side effects
}
0: Constructor line avx.sinc:1866(id0.1733) printpiece=[VPCMPESTRI,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: XmmReg1 : 5305  1: XmmReg2_m128 : 5306  2: imm8 : 5307  
Pattern id=1733 pattern=cmb:(ctx:SS:X[001x]:X8:0[011x]:XX,ins:61:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CALLOTHER const[16f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:869 :VPUNPCKLWD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x61; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpcklwd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:869(id0.2035) printpiece=[VPUNPCKLWD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6773  1: vexVVVV_YmmReg : 6771  2: YmmReg1 : 6770  3: YmmReg2_m256 : 6772  
Pattern id=2035 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:61:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[25d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1738 :BOUND Reg16,m16    is vexMode=0 & bit64=0 & opsize=0 & byte=0x62; m16 & Reg16 ...      { }
0: Constructor line ia.sinc:1738(id0.67) printpiece=[BOUND,  ,  B, ,,  A]
Operands 0: m16 : 1493  1: Reg16 : 1492  
Pattern id=67 pattern=cmb:(ctx:X[0x00]:XX:X[0xxx]:XX,ins:62:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:1739 :BOUND Reg32,m32    is vexMode=0 & bit64=0 & opsize=1 & byte=0x62; m32 & Reg32 ...      { }
0: Constructor line ia.sinc:1739(id0.68) printpiece=[BOUND,  ,  B, ,,  A]
Operands 0: m32 : 1495  1: Reg32 : 1494  
Pattern id=68 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:62:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line avx.sinc:2727 :VPUNPCKLDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x62; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckldq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2727(id0.1831) printpiece=[VPUNPCKLDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5841  1: vexVVVV_XmmReg : 5839  2: XmmReg1 : 5838  3: YmmReg1 : 5842  4: XmmReg2_m128 : 5840  
Pattern id=1831 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:62:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b4180:10] = CALLOTHER const[1c9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4180:10]

Line avx.sinc:1926 :VPCMPISTRM XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x62; XmmReg1 ... & XmmReg2_m128; imm8
{
	vpcmpistrm_avx( XmmReg1, XmmReg2_m128, imm8:1 );
	# TODO missing destination or side effects
}
0: Constructor line avx.sinc:1926(id0.1740) printpiece=[VPCMPISTRM,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5345  1: XmmReg1 : 5342  2: XmmReg2_m128 : 5343  3: imm8 : 5344  
Pattern id=1740 pattern=cmb:(ctx:SS:X[001x]:X8:0[011x]:XX,ins:62:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[176:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:877 :VPUNPCKLDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x62; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckldq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:877(id0.2036) printpiece=[VPUNPCKLDQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6778  1: vexVVVV_YmmReg : 6776  2: YmmReg1 : 6775  3: YmmReg2_m256 : 6777  
Pattern id=2036 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:62:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[25e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1735 :ARPL rm16,Reg16    is $(LONGMODE_OFF) & vexMode=0 & bit64=0 & byte=0x63; rm16 & Reg16 ...                { local rpldest=rm16&3; local rplsrc=Reg16&3; local rpldiff=rplsrc-rpldest;
                                          ZF = rpldiff s> 0; rm16 = rm16 + (zext(CF) * rpldiff); }
0: Constructor line ia.sinc:1735(id0.66) printpiece=[ARPL,  ,  A, ,,  B]
Operands 0: rm16 : 1490  1: Reg16 : 1491  
Pattern id=66 pattern=cmb:(ctx:X[0x00]:XX:X[0xxx]:XX,ins:63:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[14f00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	3: unique[15000:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	4: unique[15100:[handle:size]] = INT_SUB unique[15000:[handle:size]], unique[14f00:[handle:size]]
	5: register[206:1] = INT_SLESS const[0:[handle:size]], unique[15100:[handle:size]]
	6: unique[15200:[handle:size]] = INT_ZEXT register[200:1]
	7: unique[15280:[handle:size]] = INT_MULT unique[15200:[handle:size]], unique[15100:[handle:size]]
	8: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[15280:[handle:size]]

Line ia.sinc:1735 :ARPL rm16,Reg16    is $(LONGMODE_OFF) & vexMode=0 & bit64=0 & byte=0x63; rm16 & Reg16 ...                { local rpldest=rm16&3; local rplsrc=Reg16&3; local rpldiff=rplsrc-rpldest;
                                          ZF = rpldiff s> 0; rm16 = rm16 + (zext(CF) * rpldiff); }
0: Constructor line ia.sinc:1735(id0.66) printpiece=[ARPL,  ,  A, ,,  B]
Operands 0: rm16 : 1490  1: Reg16 : 1491  
Pattern id=66 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:63:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[14f00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	3: unique[15000:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	4: unique[15100:[handle:size]] = INT_SUB unique[15000:[handle:size]], unique[14f00:[handle:size]]
	5: register[206:1] = INT_SLESS const[0:[handle:size]], unique[15100:[handle:size]]
	6: unique[15200:[handle:size]] = INT_ZEXT register[200:1]
	7: unique[15280:[handle:size]] = INT_MULT unique[15200:[handle:size]], unique[15100:[handle:size]]
	8: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[15280:[handle:size]]

Line ia.sinc:3175 :MOVSXD Reg32,rm32  is vexMode=0 & bit64=1 & opsize=1 & byte=0x63; rm32 & Reg32 ... & check_Reg32_dest ... { Reg32 = rm32; build check_Reg32_dest; }
0: Constructor line ia.sinc:3175(id0.315) printpiece=[MOVSXD,  ,  B, ,,  A]
Operands 0: rm32 : 1957  1: Reg32 : 1956  2: check_Reg32_dest : 1958  
Pattern id=315 pattern=cmb:(ctx:X[1x01]:XX:X[0xxx]:XX,ins:63:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[2:4]

Line ia.sinc:1735 :ARPL rm16,Reg16    is $(LONGMODE_OFF) & vexMode=0 & bit64=0 & byte=0x63; rm16 & Reg16 ...                { local rpldest=rm16&3; local rplsrc=Reg16&3; local rpldiff=rplsrc-rpldest;
                                          ZF = rpldiff s> 0; rm16 = rm16 + (zext(CF) * rpldiff); }
0: Constructor line ia.sinc:1735(id0.66) printpiece=[ARPL,  ,  A, ,,  B]
Operands 0: rm16 : 1490  1: Reg16 : 1491  
Pattern id=66 pattern=cmb:(ctx:X[0x10]:XX:X[0xxx]:XX,ins:63:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[14f00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	3: unique[15000:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	4: unique[15100:[handle:size]] = INT_SUB unique[15000:[handle:size]], unique[14f00:[handle:size]]
	5: register[206:1] = INT_SLESS const[0:[handle:size]], unique[15100:[handle:size]]
	6: unique[15200:[handle:size]] = INT_ZEXT register[200:1]
	7: unique[15280:[handle:size]] = INT_MULT unique[15200:[handle:size]], unique[15100:[handle:size]]
	8: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[15280:[handle:size]]

Line ia.sinc:1735 :ARPL rm16,Reg16    is $(LONGMODE_OFF) & vexMode=0 & bit64=0 & byte=0x63; rm16 & Reg16 ...                { local rpldest=rm16&3; local rplsrc=Reg16&3; local rpldiff=rplsrc-rpldest;
                                          ZF = rpldiff s> 0; rm16 = rm16 + (zext(CF) * rpldiff); }
0: Constructor line ia.sinc:1735(id0.66) printpiece=[ARPL,  ,  A, ,,  B]
Operands 0: rm16 : 1490  1: Reg16 : 1491  
Pattern id=66 pattern=cmb:(ctx:X[0x11]:XX:X[0xxx]:XX,ins:63:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[14f00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	3: unique[15000:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[3:[handle:size]]
	4: unique[15100:[handle:size]] = INT_SUB unique[15000:[handle:size]], unique[14f00:[handle:size]]
	5: register[206:1] = INT_SLESS const[0:[handle:size]], unique[15100:[handle:size]]
	6: unique[15200:[handle:size]] = INT_ZEXT register[200:1]
	7: unique[15280:[handle:size]] = INT_MULT unique[15200:[handle:size]], unique[15100:[handle:size]]
	8: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[15280:[handle:size]]

Line avx.sinc:1665 :VPACKSSWB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x63; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpacksswb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1665(id0.1711) printpiece=[VPACKSSWB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5175  1: vexVVVV_XmmReg : 5173  2: XmmReg1 : 5172  3: YmmReg1 : 5176  4: XmmReg2_m128 : 5174  
Pattern id=1711 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:63:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[aa480:10] = CALLOTHER const[159:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aa480:10]

Line avx.sinc:1918 :VPCMPISTRI XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0x63; XmmReg1 ... & XmmReg2_m128; imm8
{
	vpcmpistri_avx( XmmReg1, XmmReg2_m128, imm8:1 );
	# TODO missing destination or side effects
}
0: Constructor line avx.sinc:1918(id0.1739) printpiece=[VPCMPISTRI,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5340  1: XmmReg1 : 5337  2: XmmReg2_m128 : 5338  3: imm8 : 5339  
Pattern id=1739 pattern=cmb:(ctx:SS:X[001x]:X8:0[011x]:XX,ins:63:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[175:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:47 :VPACKSSWB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x63; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpacksswb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:47(id0.1930) printpiece=[VPACKSSWB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6273  1: vexVVVV_YmmReg : 6271  2: YmmReg1 : 6270  3: YmmReg2_m256 : 6272  
Pattern id=1930 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:63:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1fc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1504 :^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1504(id0.4) printpiece=[ A]
Operands 0: instruction : 1339  
Pattern id=4 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:64:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:1882 :VPCMPGTB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x64; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpgtb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:1882(id0.1735) printpiece=[VPCMPGTB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5316  1: vexVVVV_XmmReg : 5314  2: XmmReg1 : 5313  3: YmmReg1 : 5317  4: XmmReg2_m128 : 5315  
Pattern id=1735 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:64:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ac580:10] = CALLOTHER const[171:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ac580:10]

Line ia.sinc:1504 :^instruction is instrPhase=0 & over=0x64; instruction     [ segover=5; ]  {} # FS override
:^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1504(id0.4) printpiece=[ A]
Operands 0: instruction : 1339  
Pattern id=4 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:64:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx2.sinc:223 :VPCMPGTB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x64; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpgtb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:223(id0.1952) printpiece=[VPCMPGTB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6384  1: vexVVVV_YmmReg : 6382  2: YmmReg1 : 6381  3: YmmReg2_m256 : 6383  
Pattern id=1952 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:64:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[212:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1505 :^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1505(id0.5) printpiece=[ A]
Operands 0: instruction : 1340  
Pattern id=5 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:65:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:1891 :VPCMPGTW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x65; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpgtw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:1891(id0.1736) printpiece=[VPCMPGTW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5322  1: vexVVVV_XmmReg : 5320  2: XmmReg1 : 5319  3: YmmReg1 : 5323  4: XmmReg2_m128 : 5321  
Pattern id=1736 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:65:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ac700:10] = CALLOTHER const[172:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ac700:10]

Line ia.sinc:1505 :^instruction is instrPhase=0 & over=0x65; instruction     [ segover=6; ]  {} # GS override
:^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1505(id0.5) printpiece=[ A]
Operands 0: instruction : 1340  
Pattern id=5 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:65:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx2.sinc:231 :VPCMPGTW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x65; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpgtw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:231(id0.1953) printpiece=[VPCMPGTW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6389  1: vexVVVV_YmmReg : 6387  2: YmmReg1 : 6386  3: YmmReg2_m256 : 6388  
Pattern id=1953 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:65:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[213:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1506 :^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1506(id0.6) printpiece=[ A]
Operands 0: instruction : 1341  
Pattern id=6 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:66:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:1900 :VPCMPGTD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x66; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpgtd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:1900(id0.1737) printpiece=[VPCMPGTD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5328  1: vexVVVV_XmmReg : 5326  2: XmmReg1 : 5325  3: YmmReg1 : 5329  4: XmmReg2_m128 : 5327  
Pattern id=1737 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:66:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ac880:10] = CALLOTHER const[173:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ac880:10]

Line ia.sinc:1506 :^instruction is instrPhase=0 & over=0x66; instruction     [ opsize=opsize $xor 1; mandover = mandover $xor 1; ] {} # Operand size override
:^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1506(id0.6) printpiece=[ A]
Operands 0: instruction : 1341  
Pattern id=6 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:66:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx2.sinc:239 :VPCMPGTD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x66; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpgtd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:239(id0.1954) printpiece=[VPCMPGTD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6394  1: vexVVVV_YmmReg : 6392  2: YmmReg1 : 6391  3: YmmReg2_m256 : 6393  
Pattern id=1954 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:66:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[214:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1507 :^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1507(id0.7) printpiece=[ A]
Operands 0: instruction : 1342  
Pattern id=7 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:67:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:1692 :VPACKUSWB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x67; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpackuswb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:1692(id0.1714) printpiece=[VPACKUSWB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5192  1: vexVVVV_XmmReg : 5190  2: XmmReg1 : 5189  3: YmmReg1 : 5193  4: XmmReg2_m128 : 5191  
Pattern id=1714 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:67:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[aa900:10] = CALLOTHER const[15c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aa900:10]

Line ia.sinc:1507 :^instruction is instrPhase=0 & over=0x67; instruction     [ addrsize=addrsize $xor 1; ] {} # Address size override
:^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1507(id0.7) printpiece=[ A]
Operands 0: instruction : 1342  
Pattern id=7 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:67:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx2.sinc:71 :VPACKUSWB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x67; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpackuswb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:71(id0.1933) printpiece=[VPACKUSWB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6287  1: vexVVVV_YmmReg : 6285  2: YmmReg1 : 6284  3: YmmReg2_m256 : 6286  
Pattern id=1933 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:67:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1ff:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3360 :PUSH simm16_16    is vexMode=0 & addrsize=0 & opsize=0 & byte=0x68; simm16_16    { tmp:2=simm16_16; push22(tmp); }
0: Constructor line ia.sinc:3360(id0.412) printpiece=[PUSH,  ,  A]
Operands 0: simm16_16 : 2090  
Pattern id=412 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:68:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9400:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3365 :PUSH imm32     is vexMode=0 & addrsize=0 & opsize=1 & byte=0x68; imm32     { tmp:4=imm32; push24(tmp); }
0: Constructor line ia.sinc:3365(id0.414) printpiece=[PUSH,  ,  A]
Operands 0: imm32 : 2092  
Pattern id=414 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:68:XX:XX:XX)
Template
	0: unique[9600:4] = COPY [handle:space][[handle:offset]:4]
	1: register[10:2] = INT_SUB register[10:2], const[4:2]
	2: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	3: STORE const[ram:8], unique[9780:4], unique[9600:4]

Line ia.sinc:3361 :PUSH simm16_16    is vexMode=0 & addrsize=1 & opsize=0 & byte=0x68; simm16_16    { tmp:2=simm16_16; push42(tmp); }
0: Constructor line ia.sinc:3361(id0.413) printpiece=[PUSH,  ,  A]
Operands 0: simm16_16 : 2091  
Pattern id=413 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:68:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2fa80:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[2:4]
	3: STORE const[ram:8], register[10:4], unique[2fa80:2]

Line ia.sinc:3366 :PUSH imm32     is vexMode=0 & addrsize=1 & opsize=1 & byte=0x68; imm32     { tmp:4=imm32; push44(tmp); }
0: Constructor line ia.sinc:3366(id0.415) printpiece=[PUSH,  ,  A]
Operands 0: imm32 : 2093  
Pattern id=415 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:68:XX:XX:XX)
Template
	0: unique[2fb80:4] = COPY [handle:space][[handle:offset]:4]
	1: register[10:4] = INT_SUB register[10:4], const[4:4]
	2: STORE const[ram:8], register[10:4], unique[2fb80:4]

Line avx.sinc:2673 :VPUNPCKHBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x68; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckhbw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2673(id0.1825) printpiece=[VPUNPCKHBW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5805  1: vexVVVV_XmmReg : 5803  2: XmmReg1 : 5802  3: YmmReg1 : 5806  4: XmmReg2_m128 : 5804  
Pattern id=1825 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:68:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3880:10] = CALLOTHER const[1c3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3880:10]

Line avx2.sinc:829 :VPUNPCKHBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x68; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckhbw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:829(id0.2030) printpiece=[VPUNPCKHBW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6748  1: vexVVVV_YmmReg : 6746  2: YmmReg1 : 6745  3: YmmReg2_m256 : 6747  
Pattern id=2030 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:68:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[258:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2751 :IMUL Reg16,rm16,simm16_16 is vexMode=0 & opsize=0 & byte=0x69; (rm16 & Reg16 ...) ; simm16_16    { tmp:4 = sext(rm16) * sext(simm16_16);
                                          Reg16 = tmp(0); high:2 = tmp(2); imultflags(Reg16,tmp);}
0: Constructor line ia.sinc:2751(id0.190) printpiece=[IMUL,  ,  B, ,,  A, ,,  C]
Operands 0: rm16 : 1726  1: Reg16 : 1725  2: simm16_16 : 1727  
Pattern id=190 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:69:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: unique[28e00:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[28e80:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[28f80:4] = INT_MULT unique[28e00:4], unique[28e80:4]
	6: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[28f80:4], const[0:4]
	7: unique[29100:2] = SUBPIECE unique[28f80:4], const[2:4]
	8: unique[ec00:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	9: register[200:1] = INT_NOTEQUAL unique[ec00:4], unique[28f80:4]
	10: register[20b:1] = COPY register[200:1]

Line ia.sinc:2753 :IMUL Reg32,rm32,simm32_32 is vexMode=0 & opsize=1 & byte=0x69; (rm32 & Reg32 ... & check_Reg32_dest ...) ; simm32_32    { tmp:8 = sext(rm32) * sext(simm32_32);
                                          Reg32 = tmp(0); high:4 = tmp(4); imultflags(Reg32,tmp); build check_Reg32_dest; }
0: Constructor line ia.sinc:2753(id0.191) printpiece=[IMUL,  ,  B, ,,  A, ,,  D]
Operands 0: rm32 : 1729  1: Reg32 : 1728  2: check_Reg32_dest : 1731  3: simm32_32 : 1730  
Pattern id=191 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:69:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: unique[29180:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[29200:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[29300:8] = INT_MULT unique[29180:8], unique[29200:8]
	6: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[29300:8], const[0:4]
	7: unique[29480:4] = SUBPIECE unique[29300:8], const[4:4]
	8: unique[ec00:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	9: register[200:1] = INT_NOTEQUAL unique[ec00:8], unique[29300:8]
	10: register[20b:1] = COPY register[200:1]
	11: MULTIEQUAL const[2:4]

Line avx.sinc:2682 :VPUNPCKHWD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x69; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckhwd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2682(id0.1826) printpiece=[VPUNPCKHWD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5811  1: vexVVVV_XmmReg : 5809  2: XmmReg1 : 5808  3: YmmReg1 : 5812  4: XmmReg2_m128 : 5810  
Pattern id=1826 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:69:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3a00:10] = CALLOTHER const[1c4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3a00:10]

Line avx2.sinc:837 :VPUNPCKHWD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x69; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckhwd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:837(id0.2031) printpiece=[VPUNPCKHWD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6753  1: vexVVVV_YmmReg : 6751  2: YmmReg1 : 6750  3: YmmReg2_m256 : 6752  
Pattern id=2031 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:69:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[259:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3349 :PUSH simm8_16     is vexMode=0 & addrsize=0 & opsize=0 & byte=0x6a; simm8_16     { tmp:2=simm8_16; push22(tmp); }
0: Constructor line ia.sinc:3349(id0.408) printpiece=[PUSH,  ,  A]
Operands 0: simm8_16 : 2086  
Pattern id=408 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:6A:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9400:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3354 :PUSH simm8_32     is vexMode=0 & addrsize=0 & opsize=1 & byte=0x6a; simm8_32     { tmp:4=simm8_32; push24(tmp); }
0: Constructor line ia.sinc:3354(id0.410) printpiece=[PUSH,  ,  A]
Operands 0: simm8_32 : 2088  
Pattern id=410 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:6A:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9600:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:2] = INT_SUB register[10:2], const[4:2]
	3: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9780:4], unique[9600:4]

Line ia.sinc:3350 :PUSH simm8_16     is vexMode=0 & addrsize=1 & opsize=0 & byte=0x6a; simm8_16     { tmp:2=simm8_16; push42(tmp); }
0: Constructor line ia.sinc:3350(id0.409) printpiece=[PUSH,  ,  A]
Operands 0: simm8_16 : 2087  
Pattern id=409 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:6A:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2f880:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[2:4]
	3: STORE const[ram:8], register[10:4], unique[2f880:2]

Line ia.sinc:3355 :PUSH simm8_32     is vexMode=0 & addrsize=1 & opsize=1 & byte=0x6a; simm8_32     { tmp:4=simm8_32; push44(tmp); }
0: Constructor line ia.sinc:3355(id0.411) printpiece=[PUSH,  ,  A]
Operands 0: simm8_32 : 2089  
Pattern id=411 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:6A:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2f980:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[2f980:4]

Line avx.sinc:2691 :VPUNPCKHDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x6A; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckhdq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2691(id0.1827) printpiece=[VPUNPCKHDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5817  1: vexVVVV_XmmReg : 5815  2: XmmReg1 : 5814  3: YmmReg1 : 5818  4: XmmReg2_m128 : 5816  
Pattern id=1827 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:6A:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3b80:10] = CALLOTHER const[1c5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3b80:10]

Line avx2.sinc:845 :VPUNPCKHDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x6A; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckhdq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:845(id0.2032) printpiece=[VPUNPCKHDQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6758  1: vexVVVV_YmmReg : 6756  2: YmmReg1 : 6755  3: YmmReg2_m256 : 6757  
Pattern id=2032 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:6A:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[25a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2742 :IMUL Reg16,rm16,simm8_16  is vexMode=0 & opsize=0 & byte=0x6b; (rm16 & Reg16 ...) ; simm8_16 { tmp:4 = sext(rm16) * sext(simm8_16);
                                          Reg16 = tmp(0); high:2 = tmp(2); imultflags(Reg16,tmp);}
0: Constructor line ia.sinc:2742(id0.188) printpiece=[IMUL,  ,  B, ,,  A, ,,  C]
Operands 0: rm16 : 1719  1: Reg16 : 1718  2: simm8_16 : 1720  
Pattern id=188 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:6B:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: unique[28700:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[28780:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[28880:4] = INT_MULT unique[28700:4], unique[28780:4]
	6: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[28880:4], const[0:4]
	7: unique[28a00:2] = SUBPIECE unique[28880:4], const[2:4]
	8: unique[ec00:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	9: register[200:1] = INT_NOTEQUAL unique[ec00:4], unique[28880:4]
	10: register[20b:1] = COPY register[200:1]

Line ia.sinc:2744 :IMUL Reg32,rm32,simm8_32  is vexMode=0 & opsize=1 & byte=0x6b; (rm32 & Reg32 ... & check_Reg32_dest ... ) ; simm8_32 { tmp:8 = sext(rm32) * sext(simm8_32);
                                          Reg32 = tmp(0); high:4 = tmp(4); imultflags(Reg32,tmp); build check_Reg32_dest; }
0: Constructor line ia.sinc:2744(id0.189) printpiece=[IMUL,  ,  B, ,,  A, ,,  D]
Operands 0: rm32 : 1722  1: Reg32 : 1721  2: check_Reg32_dest : 1724  3: simm8_32 : 1723  
Pattern id=189 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:6B:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: unique[28a80:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[28b00:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[28c00:8] = INT_MULT unique[28a80:8], unique[28b00:8]
	6: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[28c00:8], const[0:4]
	7: unique[28d80:4] = SUBPIECE unique[28c00:8], const[4:4]
	8: unique[ec00:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	9: register[200:1] = INT_NOTEQUAL unique[ec00:8], unique[28c00:8]
	10: register[20b:1] = COPY register[200:1]
	11: MULTIEQUAL const[2:4]

Line avx.sinc:1674 :VPACKSSDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x6B; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpackssdw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1674(id0.1712) printpiece=[VPACKSSDW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5181  1: vexVVVV_XmmReg : 5179  2: XmmReg1 : 5178  3: YmmReg1 : 5182  4: XmmReg2_m128 : 5180  
Pattern id=1712 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:6B:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[aa600:10] = CALLOTHER const[15a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aa600:10]

Line avx2.sinc:55 :VPACKSSDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x6B; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpackssdw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:55(id0.1931) printpiece=[VPACKSSDW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6278  1: vexVVVV_YmmReg : 6276  2: YmmReg1 : 6275  3: YmmReg2_m256 : 6277  
Pattern id=1931 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:6B:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1fd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2789 :INSB^rep^reptail eseDI1,DX is vexMode=0 & rep & reptail & byte=0x6c & eseDI1 & DX      { build rep; build eseDI1; eseDI1 = in(DX); build reptail; }
0: Constructor line ia.sinc:2789(id0.203) printpiece=[INSB,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 1752  1: reptail : 1753  2: eseDI1 : 1754  3: DX : 1755  
Pattern id=203 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:6C:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1:4], register[8:2]
	3: MULTIEQUAL const[1:4]

Line avx.sinc:2736 :VPUNPCKLQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x6C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpcklqdq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2736(id0.1832) printpiece=[VPUNPCKLQDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5847  1: vexVVVV_XmmReg : 5845  2: XmmReg1 : 5844  3: YmmReg1 : 5848  4: XmmReg2_m128 : 5846  
Pattern id=1832 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:6C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b4300:10] = CALLOTHER const[1ca:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4300:10]

Line avx2.sinc:885 :VPUNPCKLQDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x6C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpcklqdq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:885(id0.2037) printpiece=[VPUNPCKLQDQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6783  1: vexVVVV_YmmReg : 6781  2: YmmReg1 : 6780  3: YmmReg2_m256 : 6782  
Pattern id=2037 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:6C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[25f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2790 :INSW^rep^reptail eseDI2,DX is vexMode=0 & rep & reptail & opsize=0 & byte=0x6d & eseDI2 & DX   { build rep; build eseDI2; eseDI2 = in(DX); build reptail; }
0: Constructor line ia.sinc:2790(id0.204) printpiece=[INSW,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 1756  1: reptail : 1757  2: eseDI2 : 1758  3: DX : 1759  
Pattern id=204 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:6D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1:4], register[8:2]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:2791 :INSD^rep^reptail eseDI4,DX is vexMode=0 & rep & reptail & opsize=1 & byte=0x6d & eseDI4 & DX   { build rep; build eseDI4; eseDI4 = in(DX); build reptail; }
0: Constructor line ia.sinc:2791(id0.205) printpiece=[INSD,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 1760  1: reptail : 1761  2: eseDI4 : 1762  3: DX : 1763  
Pattern id=205 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:6D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1:4], register[8:2]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:2792 :INSD^rep^reptail eseDI4,DX is vexMode=0 & rep & reptail & opsize=2 & byte=0x6d & eseDI4 & DX   { build rep; build eseDI4; eseDI4 = in(DX); build reptail; }
0: Constructor line ia.sinc:2792(id0.206) printpiece=[INSD,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 1764  1: reptail : 1765  2: eseDI4 : 1766  3: DX : 1767  
Pattern id=206 pattern=cmb:(ctx:X[xx10]:XX:X[0xxx]:XX,ins:6D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1:4], register[8:2]
	3: MULTIEQUAL const[1:4]

Line avx.sinc:2700 :VPUNPCKHQDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x6D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpunpckhqdq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2700(id0.1828) printpiece=[VPUNPCKHQDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5823  1: vexVVVV_XmmReg : 5821  2: XmmReg1 : 5820  3: YmmReg1 : 5824  4: XmmReg2_m128 : 5822  
Pattern id=1828 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:6D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3d00:10] = CALLOTHER const[1c6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3d00:10]

Line avx2.sinc:853 :VPUNPCKHQDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x6D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpunpckhqdq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:853(id0.2033) printpiece=[VPUNPCKHQDQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6763  1: vexVVVV_YmmReg : 6761  2: YmmReg1 : 6760  3: YmmReg2_m256 : 6762  
Pattern id=2033 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:6D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[25b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3263 :OUTSB^rep^reptail DX,dseSI1    is vexMode=0 & rep & reptail & byte=0x6e & DX & dseSI1      { build rep; build dseSI1; out(dseSI1,DX); build reptail;}
0: Constructor line ia.sinc:3263(id0.360) printpiece=[OUTSB,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 2037  1: reptail : 2038  2: DX : 2039  3: dseSI1 : 2040  
Pattern id=360 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:6E:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[3:4]
	2: CALLOTHER const[2:4], [handle:space][[handle:offset]:[handle:size]], register[8:2]
	3: MULTIEQUAL const[1:4]

Line avx.sinc:1179 :VMOVD XmmReg1, rm32 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W0); byte=0x6E; (XmmReg1 & YmmReg1) ... & rm32
{
	local tmp:16 = vmovd_avx( rm32 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1179(id0.1654) printpiece=[VMOVD,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 4926  1: YmmReg1 : 4928  2: rm32 : 4927  
Pattern id=1654 pattern=cmb:(ctx:SS:X2:X8:0[001x]:XX,ins:6E:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[a6d00:10] = CALLOTHER const[13b:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a6d00:10]

Line ia.sinc:3264 :OUTSW^rep^reptail DX,dseSI2    is vexMode=0 & rep & reptail & opsize=0 & byte=0x6f & DX & dseSI2   { build rep; build dseSI2; out(dseSI2,DX); build reptail;}
0: Constructor line ia.sinc:3264(id0.361) printpiece=[OUTSW,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 2041  1: reptail : 2042  2: DX : 2043  3: dseSI2 : 2044  
Pattern id=361 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:6F:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[3:4]
	2: CALLOTHER const[2:4], [handle:space][[handle:offset]:[handle:size]], register[8:2]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:3265 :OUTSD^rep^reptail DX,dseSI4    is vexMode=0 & rep & reptail &            byte=0x6f & DX & dseSI4   { build rep; build dseSI4; out(dseSI4,DX); build reptail;}
1: Constructor line ia.sinc:3265(id0.362) printpiece=[OUTSD,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 2045  1: reptail : 2046  2: DX : 2047  3: dseSI4 : 2048  
Pattern id=362 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:6F:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[3:4]
	2: CALLOTHER const[2:4], [handle:space][[handle:offset]:[handle:size]], register[8:2]
	3: MULTIEQUAL const[1:4]

Line avx_manual.sinc:3 :VMOVDQA XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x6F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	YmmReg1 = zext(XmmReg2_m128);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx_manual.sinc:3(id0.1909) printpiece=[VMOVDQA,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6185  1: XmmReg1 : 6183  2: YmmReg1 : 6186  3: XmmReg2_m128 : 6184  
Pattern id=1909 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:6F:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line avx_manual.sinc:24 :VMOVDQA YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x6F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = YmmReg2_m256;
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx_manual.sinc:24(id0.1912) printpiece=[VMOVDQA,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6196  1: YmmReg1 : 6194  2: YmmReg2_m256 : 6195  
Pattern id=1912 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:6F:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1229 :VMOVDQU XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x6F; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vmovdqu_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1229(id0.1658) printpiece=[VMOVDQU,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4943  1: XmmReg1 : 4941  2: YmmReg1 : 4944  3: XmmReg2_m128 : 4942  
Pattern id=1658 pattern=cmb:(ctx:SS:X[010x]:X8:0[001x]:XX,ins:6F:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a7100:10] = CALLOTHER const[13e:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a7100:10]

Line avx.sinc:1244 :VMOVDQU YmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x6F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vmovdqu_avx( YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:1244(id0.1660) printpiece=[VMOVDQU,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4950  1: YmmReg1 : 4948  2: YmmReg2_m256 : 4949  
Pattern id=1660 pattern=cmb:(ctx:SS:X[010x]:XC:0[001x]:XX,ins:6F:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[13e:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2833 :J^cc rel8      is vexMode=0 & row=7 & cc; rel8                                       { if (cc) goto rel8; }
0: Constructor line ia.sinc:2833(id0.220) printpiece=[J,  A,  ,  B]
Operands 0: cc : 1772  1: rel8 : 1773  
Pattern id=220 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:7X:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: CBRANCH [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2398 :VPSHUFD XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x70; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpshufd_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2398(id0.1791) printpiece=[VPSHUFD,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 5624  1: XmmReg1 : 5621  2: YmmReg1 : 5625  3: XmmReg2_m128 : 5622  4: imm8 : 5623  
Pattern id=1791 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:70:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b1280:10] = CALLOTHER const[1aa:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b1280:10]

Line avx2.sinc:591 :VPSHUFD YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x70; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpshufd_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:591(id0.1998) printpiece=[VPSHUFD,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6596  1: YmmReg1 : 6593  2: YmmReg2_m256 : 6594  3: imm8 : 6595  
Pattern id=1998 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:70:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[240:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2407 :VPSHUFHW XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x70; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpshufhw_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2407(id0.1792) printpiece=[VPSHUFHW,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 5630  1: XmmReg1 : 5627  2: YmmReg1 : 5631  3: XmmReg2_m128 : 5628  4: imm8 : 5629  
Pattern id=1792 pattern=cmb:(ctx:SS:X[010x]:X8:0[001x]:XX,ins:70:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b1400:10] = CALLOTHER const[1ab:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b1400:10]

Line avx2.sinc:599 :VPSHUFHW YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x70; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpshufhw_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:599(id0.1999) printpiece=[VPSHUFHW,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6601  1: YmmReg1 : 6598  2: YmmReg2_m256 : 6599  3: imm8 : 6600  
Pattern id=1999 pattern=cmb:(ctx:SS:X[010x]:XC:0[001x]:XX,ins:70:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[241:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2416 :VPSHUFLW XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x70; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vpshuflw_avx( XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2416(id0.1793) printpiece=[VPSHUFLW,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 5636  1: XmmReg1 : 5633  2: YmmReg1 : 5637  3: XmmReg2_m128 : 5634  4: imm8 : 5635  
Pattern id=1793 pattern=cmb:(ctx:SS:X[100x]:X8:0[001x]:XX,ins:70:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[b1580:10] = CALLOTHER const[1ac:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b1580:10]

Line avx2.sinc:607 :VPSHUFLW YmmReg1, YmmReg2_m256, imm8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0x70; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vpshuflw_avx2( YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:607(id0.2000) printpiece=[VPSHUFLW,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6606  1: YmmReg1 : 6603  2: YmmReg2_m256 : 6604  3: imm8 : 6605  
Pattern id=2000 pattern=cmb:(ctx:SS:X[100x]:XC:0[001x]:XX,ins:70:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[242:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2549 :VPSRLW vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x71; reg_opcode=2 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrlw_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2549(id0.1810) printpiece=[VPSRLW,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5725  1: vexVVVV_XmmReg : 5722  2: XmmReg2 : 5723  3: imm8 : 5724  
Pattern id=1810 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:71:D[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:730 :VPSRLW vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x71; reg_opcode=2 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrlw_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:730(id0.2017) printpiece=[VPSRLW,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6685  1: vexVVVV_YmmReg : 6682  2: YmmReg2 : 6683  3: imm8 : 6684  
Pattern id=2017 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:71:D[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2512 :VPSRAW vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x71; reg_opcode=4 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsraw_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2512(id0.1805) printpiece=[VPSRAW,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5700  1: vexVVVV_XmmReg : 5697  2: XmmReg2 : 5698  3: imm8 : 5699  
Pattern id=1805 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:71:E[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:695 :VPSRAW vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x71; reg_opcode=4 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsraw_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:695(id0.2012) printpiece=[VPSRAW,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6662  1: vexVVVV_YmmReg : 6659  2: YmmReg2 : 6660  3: imm8 : 6661  
Pattern id=2012 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:71:E[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2467 :VPSLLW vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x71; reg_opcode=6 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsllw_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2467(id0.1799) printpiece=[VPSLLW,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5670  1: vexVVVV_XmmReg : 5667  2: XmmReg2 : 5668  3: imm8 : 5669  
Pattern id=1799 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:71:F[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:653 :VPSLLW vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x71; reg_opcode=6 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsllw_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:653(id0.2006) printpiece=[VPSLLW,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6635  1: vexVVVV_YmmReg : 6632  2: YmmReg2 : 6633  3: imm8 : 6634  
Pattern id=2006 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:71:F[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[247:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2564 :VPSRLD vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x72; reg_opcode=2 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrld_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2564(id0.1812) printpiece=[VPSRLD,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5735  1: vexVVVV_XmmReg : 5732  2: XmmReg2 : 5733  3: imm8 : 5734  
Pattern id=1812 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:72:D[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:744 :VPSRLD vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x72; reg_opcode=2 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrld_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:744(id0.2019) printpiece=[VPSRLD,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6694  1: vexVVVV_YmmReg : 6691  2: YmmReg2 : 6692  3: imm8 : 6693  
Pattern id=2019 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:72:D[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2527 :VPSRAD vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x72; reg_opcode=4 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrad_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2527(id0.1807) printpiece=[VPSRAD,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5710  1: vexVVVV_XmmReg : 5707  2: XmmReg2 : 5708  3: imm8 : 5709  
Pattern id=1807 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:72:E[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:709 :VPSRAD vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x72; reg_opcode=4 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrad_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:709(id0.2014) printpiece=[VPSRAD,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6671  1: vexVVVV_YmmReg : 6668  2: YmmReg2 : 6669  3: imm8 : 6670  
Pattern id=2014 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:72:E[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2482 :VPSLLD vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x72; reg_opcode=6 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpslld_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2482(id0.1801) printpiece=[VPSLLD,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5680  1: vexVVVV_XmmReg : 5677  2: XmmReg2 : 5678  3: imm8 : 5679  
Pattern id=1801 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:72:F[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:667 :VPSLLD vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x72; reg_opcode=6 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpslld_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:667(id0.2008) printpiece=[VPSLLD,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6644  1: vexVVVV_YmmReg : 6641  2: YmmReg2 : 6642  3: imm8 : 6643  
Pattern id=2008 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:72:F[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[248:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2579 :VPSRLQ vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x73; reg_opcode=2 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrlq_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2579(id0.1814) printpiece=[VPSRLQ,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5745  1: vexVVVV_XmmReg : 5742  2: XmmReg2 : 5743  3: imm8 : 5744  
Pattern id=1814 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:73:D[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:758 :VPSRLQ vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x73; reg_opcode=2 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrlq_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:758(id0.2021) printpiece=[VPSRLQ,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6703  1: vexVVVV_YmmReg : 6700  2: YmmReg2 : 6701  3: imm8 : 6702  
Pattern id=2021 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:73:D[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2534 :VPSRLDQ vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x73; reg_opcode=3 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsrldq_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2534(id0.1808) printpiece=[VPSRLDQ,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5715  1: vexVVVV_XmmReg : 5712  2: XmmReg2 : 5713  3: imm8 : 5714  
Pattern id=1808 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:73:D[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:716 :VPSRLDQ vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x73; reg_opcode=3 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsrldq_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:716(id0.2015) printpiece=[VPSRLDQ,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6676  1: vexVVVV_YmmReg : 6673  2: YmmReg2 : 6674  3: imm8 : 6675  
Pattern id=2015 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:73:D[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2497 :VPSLLQ vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x73; reg_opcode=6 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpsllq_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2497(id0.1803) printpiece=[VPSLLQ,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5690  1: vexVVVV_XmmReg : 5687  2: XmmReg2 : 5688  3: imm8 : 5689  
Pattern id=1803 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:73:F[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:681 :VPSLLQ vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x73; reg_opcode=6 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpsllq_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:681(id0.2010) printpiece=[VPSLLQ,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6653  1: vexVVVV_YmmReg : 6650  2: YmmReg2 : 6651  3: imm8 : 6652  
Pattern id=2010 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:73:F[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[249:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2452 :VPSLLDQ vexVVVV_XmmReg, XmmReg2, imm8 is $(VEX_NDD) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x73; reg_opcode=7 & (mod=0x3 & XmmReg2); imm8
{
	vexVVVV_XmmReg = vpslldq_avx( XmmReg2, imm8:1 );
}
0: Constructor line avx.sinc:2452(id0.1797) printpiece=[VPSLLDQ,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 5660  1: vexVVVV_XmmReg : 5657  2: XmmReg2 : 5658  3: imm8 : 5659  
Pattern id=1797 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:73:F[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1b0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx2.sinc:639 :VPSLLDQ vexVVVV_YmmReg, YmmReg2, imm8 is $(VEX_NDD) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x73; reg_opcode=7 & (mod=0x3 & YmmReg2); imm8
{
	vexVVVV_YmmReg = vpslldq_avx2( YmmReg2, imm8:1 );
}
0: Constructor line avx2.sinc:639(id0.2004) printpiece=[VPSLLDQ,  ,  B, ,,  ,  C, ,,  ,  D]
Operands 0: rexWprefix : 6626  1: vexVVVV_YmmReg : 6623  2: YmmReg2 : 6624  3: imm8 : 6625  
Pattern id=2004 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:73:F[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[246:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:1839 :VPCMPEQB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x74; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpeqb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1839(id0.1730) printpiece=[VPCMPEQB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5290  1: vexVVVV_XmmReg : 5288  2: XmmReg1 : 5287  3: YmmReg1 : 5291  4: XmmReg2_m128 : 5289  
Pattern id=1730 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:74:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ac100:10] = CALLOTHER const[16c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ac100:10]

Line avx2.sinc:199 :VPCMPEQB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x74; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpeqb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:199(id0.1949) printpiece=[VPCMPEQB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6369  1: vexVVVV_YmmReg : 6367  2: YmmReg1 : 6366  3: YmmReg2_m256 : 6368  
Pattern id=1949 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:74:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[20f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1848 :VPCMPEQW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x75; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpeqw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1848(id0.1731) printpiece=[VPCMPEQW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5296  1: vexVVVV_XmmReg : 5294  2: XmmReg1 : 5293  3: YmmReg1 : 5297  4: XmmReg2_m128 : 5295  
Pattern id=1731 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:75:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ac280:10] = CALLOTHER const[16d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ac280:10]

Line avx2.sinc:207 :VPCMPEQW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x75; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpeqw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:207(id0.1950) printpiece=[VPCMPEQW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6374  1: vexVVVV_YmmReg : 6372  2: YmmReg1 : 6371  3: YmmReg2_m256 : 6373  
Pattern id=1950 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:75:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[210:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1857 :VPCMPEQD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x76; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpcmpeqd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1857(id0.1732) printpiece=[VPCMPEQD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5302  1: vexVVVV_XmmReg : 5300  2: XmmReg1 : 5299  3: YmmReg1 : 5303  4: XmmReg2_m128 : 5301  
Pattern id=1732 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:76:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ac400:10] = CALLOTHER const[16e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ac400:10]

Line avx2.sinc:215 :VPCMPEQD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x76; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpcmpeqd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:215(id0.1951) printpiece=[VPCMPEQD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6379  1: vexVVVV_YmmReg : 6377  2: YmmReg1 : 6376  3: YmmReg2_m256 : 6378  
Pattern id=1951 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:76:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[211:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:3314 :VZEROUPPER  is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x77
{
	vzeroupper_avx(  );
	# TODO missing destination or side effects
}
0: Constructor line avx.sinc:3314(id0.1904) printpiece=[VZEROUPPER]
Operands 0: rexWprefix : 6162  
Pattern id=1904 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:77:XX:XX:XX)
Template
	0: CALLOTHER const[1f4:4]

Line avx.sinc:3306 :VZEROALL  is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0x77
{
	vzeroall_avx(  );
	# TODO missing destination or side effects
}
0: Constructor line avx.sinc:3306(id0.1903) printpiece=[VZEROALL]
Operands 0: rexWprefix : 6160  
Pattern id=1903 pattern=cmb:(ctx:SS:X[000x]:XC:0[001x]:XX,ins:77:XX:XX:XX)
Template
	0: CALLOTHER const[1f3:4]

Line avx2.sinc:976 :VPBROADCASTB XmmReg1, XmmReg2_m8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x78; (XmmReg1 & YmmReg1) ... & XmmReg2_m8
{
	local tmp:16 = vpbroadcastb_avx2( XmmReg2_m8 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:976(id0.2042) printpiece=[VPBROADCASTB,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 6804  1: YmmReg1 : 6806  2: XmmReg2_m8 : 6805  
Pattern id=2042 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:78:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[bfb00:10] = CALLOTHER const[263:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[bfb00:10]

Line avx2.sinc:984 :VPBROADCASTB YmmReg1, XmmReg2_m8 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x78; YmmReg1 ... & XmmReg2_m8
{
	YmmReg1 = vpbroadcastb_avx2( XmmReg2_m8 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:984(id0.2043) printpiece=[VPBROADCASTB,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6807  1: XmmReg2_m8 : 6808  
Pattern id=2043 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:78:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[263:4], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:992 :VPBROADCASTW XmmReg1, XmmReg2_m16 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x79; (XmmReg1 & YmmReg1) ... & XmmReg2_m16
{
	local tmp:16 = vpbroadcastw_avx2( XmmReg2_m16 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:992(id0.2044) printpiece=[VPBROADCASTW,  ,  A, ,,  ,  C]
Operands 0: XmmReg1 : 6810  1: YmmReg1 : 6812  2: XmmReg2_m16 : 6811  
Pattern id=2044 pattern=cmb:(ctx:SS:X2:X8:0[010x]:XX,ins:79:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[0:4]
	3: unique[bfd00:10] = CALLOTHER const[264:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[bfd00:10]

Line avx2.sinc:1000 :VPBROADCASTW YmmReg1, XmmReg2_m16 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0); byte=0x79; YmmReg1 ... & XmmReg2_m16
{
	YmmReg1 = vpbroadcastw_avx2( XmmReg2_m16 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1000(id0.2045) printpiece=[VPBROADCASTW,  ,  A, ,,  ,  B]
Operands 0: YmmReg1 : 6813  1: XmmReg2_m16 : 6814  
Pattern id=2045 pattern=cmb:(ctx:SS:X2:XC:0[010x]:XX,ins:79:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[264:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:914 :VHADDPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x7C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vhaddpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:914(id0.1621) printpiece=[VHADDPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4775  1: vexVVVV_XmmReg : 4773  2: XmmReg1 : 4772  3: YmmReg1 : 4776  4: XmmReg2_m128 : 4774  
Pattern id=1621 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:7C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a4d80:10] = CALLOTHER const[129:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a4d80:10]

Line avx.sinc:922 :VHADDPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x7C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vhaddpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:922(id0.1622) printpiece=[VHADDPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4780  1: vexVVVV_YmmReg : 4778  2: YmmReg1 : 4777  3: YmmReg2_m256 : 4779  
Pattern id=1622 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:7C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[129:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:930 :VHADDPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x7C; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vhaddps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:930(id0.1623) printpiece=[VHADDPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4785  1: vexVVVV_XmmReg : 4783  2: XmmReg1 : 4782  3: YmmReg1 : 4786  4: XmmReg2_m128 : 4784  
Pattern id=1623 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:7C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a4f80:10] = CALLOTHER const[12a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a4f80:10]

Line avx.sinc:938 :VHADDPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x7C; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vhaddps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:938(id0.1624) printpiece=[VHADDPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4790  1: vexVVVV_YmmReg : 4788  2: YmmReg1 : 4787  3: YmmReg2_m256 : 4789  
Pattern id=1624 pattern=cmb:(ctx:SS:X[100x]:X[11xx]:[xx00][001x]:XX,ins:7C:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[12a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:946 :VHSUBPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x7D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vhsubpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:946(id0.1625) printpiece=[VHSUBPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4795  1: vexVVVV_XmmReg : 4793  2: XmmReg1 : 4792  3: YmmReg1 : 4796  4: XmmReg2_m128 : 4794  
Pattern id=1625 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:7D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a5180:10] = CALLOTHER const[12b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a5180:10]

Line avx.sinc:954 :VHSUBPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x7D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vhsubpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:954(id0.1626) printpiece=[VHSUBPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4800  1: vexVVVV_YmmReg : 4798  2: YmmReg1 : 4797  3: YmmReg2_m256 : 4799  
Pattern id=1626 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:7D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[12b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:962 :VHSUBPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0x7D; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vhsubps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:962(id0.1627) printpiece=[VHSUBPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4805  1: vexVVVV_XmmReg : 4803  2: XmmReg1 : 4802  3: YmmReg1 : 4806  4: XmmReg2_m128 : 4804  
Pattern id=1627 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:7D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a5380:10] = CALLOTHER const[12c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a5380:10]

Line avx.sinc:970 :VHSUBPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0x7D; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vhsubps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:970(id0.1628) printpiece=[VHSUBPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4810  1: vexVVVV_YmmReg : 4808  2: YmmReg1 : 4807  3: YmmReg2_m256 : 4809  
Pattern id=1628 pattern=cmb:(ctx:SS:X[100x]:X[11xx]:[xx00][001x]:XX,ins:7D:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[12c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1198 :VMOVD rm32, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W0); byte=0x7E; XmmReg1 ... & rm32
{
	rm32 = vmovd_avx( XmmReg1 );
}
0: Constructor line avx.sinc:1198(id0.1655) printpiece=[VMOVD,  ,  B, ,,  ,  A]
Operands 0: XmmReg1 : 4931  1: rm32 : 4930  
Pattern id=1655 pattern=cmb:(ctx:SS:X2:X8:0[001x]:XX,ins:7E:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[13b:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1414 :VMOVQ XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x7E; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vmovq_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1414(id0.1683) printpiece=[VMOVQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 5044  1: XmmReg1 : 5042  2: YmmReg1 : 5045  3: XmmReg2_m64 : 5043  
Pattern id=1683 pattern=cmb:(ctx:SS:X[010x]:X8:0[001x]:XX,ins:7E:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a8580:10] = CALLOTHER const[13c:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a8580:10]

Line avx_manual.sinc:10 :VMOVDQA XmmReg2, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; XmmReg1 & (mod = 3 & XmmReg2 & YmmReg2)
{
	YmmReg2 = zext(XmmReg1);
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx_manual.sinc:10(id0.1910) printpiece=[VMOVDQA,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 6189  1: XmmReg1 : 6188  2: XmmReg2 : 6187  3: YmmReg2 : 6190  
Pattern id=1910 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:7F:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: MULTIEQUAL const[2:4]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line avx_manual.sinc:17 :VMOVDQA m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; XmmReg1 ... & m128
{
	m128 = XmmReg1;
	# TODO ZmmReg2 = zext(XmmReg2)
}
1: Constructor line avx_manual.sinc:17(id0.1911) printpiece=[VMOVDQA,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 6193  1: XmmReg1 : 6192  2: m128 : 6191  
Pattern id=1911 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:7F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx_manual.sinc:31 :VMOVDQA YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = YmmReg1;
	# TODO ZmmReg2 = zext(YmmReg2)
}
0: Constructor line avx_manual.sinc:31(id0.1913) printpiece=[VMOVDQA,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 6199  1: YmmReg1 : 6198  2: YmmReg2_m256 : 6197  
Pattern id=1913 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:7F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1237 :VMOVDQU XmmReg2_m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; XmmReg1 ... & XmmReg2_m128
{
	XmmReg2_m128 = vmovdqu_avx( XmmReg1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx.sinc:1237(id0.1659) printpiece=[VMOVDQU,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 4947  1: XmmReg1 : 4946  2: XmmReg2_m128 : 4945  
Pattern id=1659 pattern=cmb:(ctx:SS:X[010x]:X8:0[001x]:XX,ins:7F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[13e:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1251 :VMOVDQU YmmReg2_m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0x7F; YmmReg1 ... & YmmReg2_m256
{
	YmmReg2_m256 = vmovdqu_avx( YmmReg1 );
	# TODO ZmmReg2 = zext(YmmReg2)
}
0: Constructor line avx.sinc:1251(id0.1661) printpiece=[VMOVDQU,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 4953  1: YmmReg1 : 4952  2: YmmReg2_m256 : 4951  
Pattern id=1661 pattern=cmb:(ctx:SS:X[010x]:XC:0[001x]:XX,ins:7F:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[13e:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1680 :ADD spec_rm8,imm8		is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=0 ...; imm8		{ addflags(  spec_rm8,imm8 );   spec_rm8 =   spec_rm8 +  imm8; resultflags(  spec_rm8); }
0: Constructor line ia.sinc:1680(id0.41) printpiece=[ADD,  ,  A, ,,  B]
Operands 0: spec_rm8 : 1431  1: imm8 : 1432  
Pattern id=41 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:80:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3232 :OR  spec_rm8,imm8      is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=1 ...; imm8     { logicalflags();   spec_rm8 =   spec_rm8 |  imm8; resultflags(  spec_rm8); }
0: Constructor line ia.sinc:3232(id0.343) printpiece=[OR,  ,  A, ,,  B]
Operands 0: spec_rm8 : 1999  1: imm8 : 2000  
Pattern id=343 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:80:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1650 :ADC spec_rm8,imm8		is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=2 ... ; imm8 { addCarryFlags( spec_rm8, imm8:1 ); resultflags( spec_rm8 ); }
0: Constructor line ia.sinc:1650(id0.27) printpiece=[ADC,  ,  A, ,,  B]
Operands 0: spec_rm8 : 1398  1: imm8 : 1399  
Pattern id=27 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:80:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d100:[handle:size]] = COPY register[200:1]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	5: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	6: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	7: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	8: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	10: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	13: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	14: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	15: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3580 :SBB  rm8,imm8     is vexMode=0 & (byte=0x80 | byte=0x82); rm8 & reg_opcode=3 ...; imm8								{ subCarryFlags( rm8, imm8 ); resultflags(rm8); }
0: Constructor line ia.sinc:3580(id0.508) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: rm8 : 2235  1: imm8 : 2236  
Pattern id=508 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:80:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d680:[handle:size]] = COPY register[200:1]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	6: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	7: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	8: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	10: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	13: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	14: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	15: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1710 :AND rm8,imm8      is vexMode=0 & (byte=0x80 | byte=0x82); rm8 & reg_opcode=4 ...; imm8     { logicalflags();   rm8 =   rm8 &  imm8; resultflags(  rm8); }
0: Constructor line ia.sinc:1710(id0.55) printpiece=[AND,  ,  A, ,,  B]
Operands 0: rm8 : 1464  1: imm8 : 1465  
Pattern id=55 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:80:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3789 :SUB  spec_rm8,imm8     is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=5 ...; imm8     { subflags(  spec_rm8,imm8 );   spec_rm8 =   spec_rm8 -  imm8; resultflags(  spec_rm8); }
0: Constructor line ia.sinc:3789(id0.571) printpiece=[SUB,  ,  A, ,,  B]
Operands 0: spec_rm8 : 2370  1: imm8 : 2371  
Pattern id=571 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:80:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3988 :XOR spec_rm8,imm8      is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=6 ...; imm8     { logicalflags();   spec_rm8 =   spec_rm8 ^  imm8; resultflags(  spec_rm8); }
0: Constructor line ia.sinc:3988(id0.639) printpiece=[XOR,  ,  A, ,,  B]
Operands 0: spec_rm8 : 2481  1: imm8 : 2482  
Pattern id=639 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:80:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2203 :CMP spec_rm8,imm8       is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=7 ...; imm8        { subflags(  spec_rm8,imm8 ); local tmp =   spec_rm8 -   imm8; resultflags(tmp); }
0: Constructor line ia.sinc:2203(id0.137) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: spec_rm8 : 1602  1: imm8 : 1603  
Pattern id=137 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:80:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[1e400:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[1e400:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[1e400:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[1e400:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1681 :ADD spec_rm16,imm16		is vexMode=0 & opsize=0 & byte=0x81; spec_rm16 & reg_opcode=0 ...; imm16	{ addflags( spec_rm16,imm16);  spec_rm16 =  spec_rm16 + imm16; resultflags( spec_rm16); }
0: Constructor line ia.sinc:1681(id0.42) printpiece=[ADD,  ,  A, ,,  B]
Operands 0: spec_rm16 : 1433  1: imm16 : 1434  
Pattern id=42 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:81:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1682 :ADD spec_rm32,imm32		is vexMode=0 & opsize=1 & byte=0x81; spec_rm32 & check_rm32_dest ... & reg_opcode=0 ...; imm32	{ addflags( spec_rm32,imm32);  spec_rm32 =  spec_rm32 + imm32; build check_rm32_dest; resultflags( spec_rm32); }
0: Constructor line ia.sinc:1682(id0.43) printpiece=[ADD,  ,  A, ,,  C]
Operands 0: spec_rm32 : 1435  1: check_rm32_dest : 1437  2: imm32 : 1436  
Pattern id=43 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:81:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3233 :OR  spec_rm16,imm16        is vexMode=0 & opsize=0 & byte=0x81; spec_rm16 & reg_opcode=1 ...; imm16  { logicalflags();  spec_rm16 =  spec_rm16 | imm16; resultflags( spec_rm16); }
0: Constructor line ia.sinc:3233(id0.344) printpiece=[OR,  ,  A, ,,  B]
Operands 0: spec_rm16 : 2001  1: imm16 : 2002  
Pattern id=344 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:81:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3234 :OR  spec_rm32,imm32        is vexMode=0 & opsize=1 & byte=0x81; spec_rm32 & check_rm32_dest ... & reg_opcode=1 ...; imm32  { logicalflags();  spec_rm32 =  spec_rm32 | imm32; build check_rm32_dest; resultflags( spec_rm32); }
0: Constructor line ia.sinc:3234(id0.345) printpiece=[OR,  ,  A, ,,  C]
Operands 0: spec_rm32 : 2003  1: check_rm32_dest : 2005  2: imm32 : 2004  
Pattern id=345 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:81:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1651 :ADC spec_rm16,imm16	is vexMode=0 & opsize=0 & byte=0x81; spec_rm16 & reg_opcode=2 ...; imm16 { addCarryFlags( spec_rm16, imm16:2 ); resultflags( spec_rm16 ); }
0: Constructor line ia.sinc:1651(id0.28) printpiece=[ADC,  ,  A, ,,  B]
Operands 0: spec_rm16 : 1400  1: imm16 : 1401  
Pattern id=28 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:81:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:2]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:2]
	4: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:2]
	5: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	6: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	7: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	8: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	10: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	13: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	14: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	15: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1652 :ADC spec_rm32,imm32	is vexMode=0 & opsize=1 & byte=0x81; spec_rm32 & check_rm32_dest ... & reg_opcode=2 ...; imm32 { addCarryFlags( spec_rm32, imm32:4 ); build check_rm32_dest; resultflags( spec_rm32 ); }
0: Constructor line ia.sinc:1652(id0.29) printpiece=[ADC,  ,  A, ,,  C]
Operands 0: spec_rm32 : 1402  1: check_rm32_dest : 1404  2: imm32 : 1403  
Pattern id=29 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:81:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:4]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:4]
	4: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:4]
	5: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	6: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	7: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	8: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	10: MULTIEQUAL const[1:4]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3581 :SBB  rm16,imm16       is vexMode=0 & opsize=0 & byte=0x81; rm16 & reg_opcode=3 ...; imm16							{ subCarryFlags( rm16, imm16 ); resultflags(rm16); }
0: Constructor line ia.sinc:3581(id0.509) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: rm16 : 2237  1: imm16 : 2238  
Pattern id=509 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:81:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d680:[handle:size]] = INT_ZEXT register[200:1]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	6: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	7: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	8: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	10: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	13: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	14: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	15: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3582 :SBB  rm32,imm32       is vexMode=0 & opsize=1 & byte=0x81; rm32 & check_rm32_dest ... & reg_opcode=3 ...; imm32	{ subCarryFlags( rm32, imm32 ); build check_rm32_dest; resultflags(rm32); }
0: Constructor line ia.sinc:3582(id0.510) printpiece=[SBB,  ,  A, ,,  C]
Operands 0: rm32 : 2239  1: check_rm32_dest : 2241  2: imm32 : 2240  
Pattern id=510 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:81:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d680:[handle:size]] = INT_ZEXT register[200:1]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	6: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	7: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	8: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	10: MULTIEQUAL const[1:4]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1711 :AND rm16,imm16    is vexMode=0 & opsize=0 & byte=0x81; rm16 & reg_opcode=4 ...; imm16  { logicalflags();  rm16 =  rm16 & imm16; resultflags( rm16); }
0: Constructor line ia.sinc:1711(id0.56) printpiece=[AND,  ,  A, ,,  B]
Operands 0: rm16 : 1466  1: imm16 : 1467  
Pattern id=56 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:81:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1712 :AND rm32,imm32    is vexMode=0 & opsize=1 & byte=0x81; rm32 & check_rm32_dest ... & reg_opcode=4 ...; imm32  { logicalflags();  rm32 =  rm32 & imm32; build check_rm32_dest; resultflags( rm32); }
0: Constructor line ia.sinc:1712(id0.57) printpiece=[AND,  ,  A, ,,  C]
Operands 0: rm32 : 1468  1: check_rm32_dest : 1470  2: imm32 : 1469  
Pattern id=57 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:81:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3790 :SUB  spec_rm16,imm16       is vexMode=0 & opsize=0 & byte=0x81; spec_rm16 & reg_opcode=5 ...; imm16  { subflags( spec_rm16,imm16);  spec_rm16 =  spec_rm16 - imm16; resultflags( spec_rm16); }
0: Constructor line ia.sinc:3790(id0.572) printpiece=[SUB,  ,  A, ,,  B]
Operands 0: spec_rm16 : 2372  1: imm16 : 2373  
Pattern id=572 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:81:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3791 :SUB  spec_rm32,imm32       is vexMode=0 & opsize=1 & byte=0x81; spec_rm32 & check_rm32_dest ... & reg_opcode=5 ...; imm32  { subflags( spec_rm32,imm32);  spec_rm32 =  spec_rm32 - imm32; build check_rm32_dest; resultflags( spec_rm32); }
0: Constructor line ia.sinc:3791(id0.573) printpiece=[SUB,  ,  A, ,,  C]
Operands 0: spec_rm32 : 2374  1: check_rm32_dest : 2376  2: imm32 : 2375  
Pattern id=573 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:81:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3989 :XOR spec_rm16,imm16    is vexMode=0 & opsize=0 & byte=0x81; spec_rm16 & reg_opcode=6 ...; imm16  { logicalflags();  spec_rm16 =  spec_rm16 ^ imm16; resultflags( spec_rm16); }
0: Constructor line ia.sinc:3989(id0.640) printpiece=[XOR,  ,  A, ,,  B]
Operands 0: spec_rm16 : 2483  1: imm16 : 2484  
Pattern id=640 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:81:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3990 :XOR spec_rm32,imm32    is vexMode=0 & opsize=1 & byte=0x81; spec_rm32 & check_rm32_dest ... & reg_opcode=6 ...; imm32  { logicalflags();  spec_rm32 =  spec_rm32 ^ imm32; build check_rm32_dest; resultflags( spec_rm32); }
0: Constructor line ia.sinc:3990(id0.641) printpiece=[XOR,  ,  A, ,,  C]
Operands 0: spec_rm32 : 2485  1: check_rm32_dest : 2487  2: imm32 : 2486  
Pattern id=641 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:81:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2204 :CMP spec_rm16,imm16     is vexMode=0 & opsize=0 & byte=0x81; spec_rm16 & reg_opcode=7 ...; imm16 { subflags( spec_rm16,imm16); local tmp =  spec_rm16 -  imm16; resultflags(tmp); }
0: Constructor line ia.sinc:2204(id0.138) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: spec_rm16 : 1604  1: imm16 : 1605  
Pattern id=138 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:81:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[1e500:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[1e500:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[1e500:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[1e500:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2205 :CMP spec_rm32,imm32     is vexMode=0 & opsize=1 & byte=0x81; spec_rm32 & reg_opcode=7 ...; imm32 { subflags( spec_rm32,imm32); local tmp =  spec_rm32 -  imm32; resultflags(tmp); }
0: Constructor line ia.sinc:2205(id0.139) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: spec_rm32 : 1606  1: imm32 : 1607  
Pattern id=139 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:81:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[1e600:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[1e600:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[1e600:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[1e600:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1680 :ADD spec_rm8,imm8		is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=0 ...; imm8		{ addflags(  spec_rm8,imm8 );   spec_rm8 =   spec_rm8 +  imm8; resultflags(  spec_rm8); }
0: Constructor line ia.sinc:1680(id0.41) printpiece=[ADD,  ,  A, ,,  B]
Operands 0: spec_rm8 : 1431  1: imm8 : 1432  
Pattern id=41 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:82:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3232 :OR  spec_rm8,imm8      is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=1 ...; imm8     { logicalflags();   spec_rm8 =   spec_rm8 |  imm8; resultflags(  spec_rm8); }
0: Constructor line ia.sinc:3232(id0.343) printpiece=[OR,  ,  A, ,,  B]
Operands 0: spec_rm8 : 1999  1: imm8 : 2000  
Pattern id=343 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:82:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1650 :ADC spec_rm8,imm8		is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=2 ... ; imm8 { addCarryFlags( spec_rm8, imm8:1 ); resultflags( spec_rm8 ); }
0: Constructor line ia.sinc:1650(id0.27) printpiece=[ADC,  ,  A, ,,  B]
Operands 0: spec_rm8 : 1398  1: imm8 : 1399  
Pattern id=27 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:82:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d100:[handle:size]] = COPY register[200:1]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	5: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	6: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	7: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	8: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	10: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	13: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	14: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	15: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3580 :SBB  rm8,imm8     is vexMode=0 & (byte=0x80 | byte=0x82); rm8 & reg_opcode=3 ...; imm8								{ subCarryFlags( rm8, imm8 ); resultflags(rm8); }
0: Constructor line ia.sinc:3580(id0.508) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: rm8 : 2235  1: imm8 : 2236  
Pattern id=508 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:82:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[d680:[handle:size]] = COPY register[200:1]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	6: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	7: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	8: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	10: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	13: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	14: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	15: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1710 :AND rm8,imm8      is vexMode=0 & (byte=0x80 | byte=0x82); rm8 & reg_opcode=4 ...; imm8     { logicalflags();   rm8 =   rm8 &  imm8; resultflags(  rm8); }
0: Constructor line ia.sinc:1710(id0.55) printpiece=[AND,  ,  A, ,,  B]
Operands 0: rm8 : 1464  1: imm8 : 1465  
Pattern id=55 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:82:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3789 :SUB  spec_rm8,imm8     is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=5 ...; imm8     { subflags(  spec_rm8,imm8 );   spec_rm8 =   spec_rm8 -  imm8; resultflags(  spec_rm8); }
0: Constructor line ia.sinc:3789(id0.571) printpiece=[SUB,  ,  A, ,,  B]
Operands 0: spec_rm8 : 2370  1: imm8 : 2371  
Pattern id=571 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:82:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3988 :XOR spec_rm8,imm8      is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=6 ...; imm8     { logicalflags();   spec_rm8 =   spec_rm8 ^  imm8; resultflags(  spec_rm8); }
0: Constructor line ia.sinc:3988(id0.639) printpiece=[XOR,  ,  A, ,,  B]
Operands 0: spec_rm8 : 2481  1: imm8 : 2482  
Pattern id=639 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:82:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2203 :CMP spec_rm8,imm8       is vexMode=0 & (byte=0x80 | byte=0x82); spec_rm8 & reg_opcode=7 ...; imm8        { subflags(  spec_rm8,imm8 ); local tmp =   spec_rm8 -   imm8; resultflags(tmp); }
0: Constructor line ia.sinc:2203(id0.137) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: spec_rm8 : 1602  1: imm8 : 1603  
Pattern id=137 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:82:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[1e400:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[1e400:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[1e400:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[1e400:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1686 :ADD spec_rm16,simm8_16		is vexMode=0 & opsize=0 & byte=0x83; spec_rm16 & reg_opcode=0 ...; simm8_16	{ addflags( spec_rm16,simm8_16);  spec_rm16 =  spec_rm16 + simm8_16; resultflags( spec_rm16); }
0: Constructor line ia.sinc:1686(id0.44) printpiece=[ADD,  ,  A, ,,  B]
Operands 0: spec_rm16 : 1438  1: simm8_16 : 1439  
Pattern id=44 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:83:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1687 :ADD spec_rm32,simm8_32		is vexMode=0 & opsize=1 & byte=0x83; spec_rm32 & check_rm32_dest ... & reg_opcode=0 ...; simm8_32	{ addflags( spec_rm32,simm8_32);  spec_rm32 =  spec_rm32 + simm8_32; build check_rm32_dest; resultflags( spec_rm32); }
0: Constructor line ia.sinc:1687(id0.45) printpiece=[ADD,  ,  A, ,,  C]
Operands 0: spec_rm32 : 1440  1: check_rm32_dest : 1442  2: simm8_32 : 1441  
Pattern id=45 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:83:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3238 :OR  spec_rm16,usimm8_16        is vexMode=0 & opsize=0 & byte=0x83; spec_rm16 & reg_opcode=1 ...; usimm8_16  { logicalflags();  spec_rm16 =  spec_rm16 | usimm8_16; resultflags( spec_rm16); }
0: Constructor line ia.sinc:3238(id0.346) printpiece=[OR,  ,  A, ,,  B]
Operands 0: spec_rm16 : 2006  1: usimm8_16 : 2007  
Pattern id=346 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:83:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3239 :OR  spec_rm32,usimm8_32        is vexMode=0 & opsize=1 & byte=0x83; spec_rm32 & check_rm32_dest ... & reg_opcode=1 ...; usimm8_32  { logicalflags();  spec_rm32 =  spec_rm32 | usimm8_32; build check_rm32_dest; resultflags( spec_rm32); }
0: Constructor line ia.sinc:3239(id0.347) printpiece=[OR,  ,  A, ,,  C]
Operands 0: spec_rm32 : 2008  1: check_rm32_dest : 2010  2: usimm8_32 : 2009  
Pattern id=347 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:83:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1656 :ADC spec_rm16,simm8_16	is vexMode=0 & opsize=0 & byte=0x83; spec_rm16 & reg_opcode=2 ...; simm8_16	{ addCarryFlags( spec_rm16, simm8_16 ); resultflags( spec_rm16 ); }
0: Constructor line ia.sinc:1656(id0.30) printpiece=[ADC,  ,  A, ,,  B]
Operands 0: spec_rm16 : 1405  1: simm8_16 : 1406  
Pattern id=30 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:83:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1657 :ADC spec_rm32,simm8_32	is vexMode=0 & opsize=1 & byte=0x83; spec_rm32 & check_rm32_dest ... & reg_opcode=2 ...; simm8_32 { addCarryFlags( spec_rm32, simm8_32 ); build check_rm32_dest; resultflags( spec_rm32 ); }
0: Constructor line ia.sinc:1657(id0.31) printpiece=[ADC,  ,  A, ,,  C]
Operands 0: spec_rm32 : 1407  1: check_rm32_dest : 1409  2: simm8_32 : 1408  
Pattern id=31 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:83:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d100:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_CARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d300:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d380:1] = INT_CARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d380:1]
	8: unique[d480:1] = INT_SCARRY unique[d300:[handle:size]], unique[d100:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[d480:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_ADD unique[d300:[handle:size]], unique[d100:[handle:size]]
	11: MULTIEQUAL const[1:4]
	12: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	15: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	16: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	17: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3587 :SBB  rm16,simm8_16       is vexMode=0 & opsize=0 & byte=0x83; rm16 & reg_opcode=3 ...; simm8_16						{ subCarryFlags( rm16, simm8_16 ); resultflags(rm16); }
0: Constructor line ia.sinc:3587(id0.511) printpiece=[SBB,  ,  A, ,,  B]
Operands 0: rm16 : 2242  1: simm8_16 : 2243  
Pattern id=511 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:83:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d680:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	12: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	14: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	15: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	16: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3588 :SBB  rm32,simm8_32       is vexMode=0 & opsize=1 & byte=0x83; rm32 & check_rm32_dest ... & reg_opcode=3 ...; simm8_32	{ subCarryFlags( rm32, simm8_32 ); build check_rm32_dest; resultflags(rm32); }
0: Constructor line ia.sinc:3588(id0.512) printpiece=[SBB,  ,  A, ,,  C]
Operands 0: rm32 : 2244  1: check_rm32_dest : 2246  2: simm8_32 : 2245  
Pattern id=512 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:83:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[d680:[handle:size]] = INT_ZEXT register[200:1]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[d880:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: unique[d900:1] = INT_LESS unique[d880:[handle:size]], unique[d680:[handle:size]]
	7: register[200:1] = BOOL_OR register[200:1], unique[d900:1]
	8: unique[da00:1] = INT_SBORROW unique[d880:[handle:size]], unique[d680:[handle:size]]
	9: register[20b:1] = BOOL_XOR register[20b:1], unique[da00:1]
	10: [handle:space][[handle:offset]:[handle:size]] = INT_SUB unique[d880:[handle:size]], unique[d680:[handle:size]]
	11: MULTIEQUAL const[1:4]
	12: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	13: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	15: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	16: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	17: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1716 :AND rm16,usimm8_16		is vexMode=0 & opsize=0 & byte=0x83; rm16 & reg_opcode=4 ...; usimm8_16	{ logicalflags();  rm16 =  rm16 & usimm8_16; resultflags( rm16); }
0: Constructor line ia.sinc:1716(id0.58) printpiece=[AND,  ,  A, ,,  B]
Operands 0: rm16 : 1471  1: usimm8_16 : 1472  
Pattern id=58 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:83:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:1717 :AND rm32,usimm8_32		is vexMode=0 & opsize=1 & byte=0x83; rm32 & check_rm32_dest ... & reg_opcode=4 ...; usimm8_32	{ logicalflags();  rm32 =  rm32 & usimm8_32; build check_rm32_dest; resultflags( rm32); }
0: Constructor line ia.sinc:1717(id0.59) printpiece=[AND,  ,  A, ,,  C]
Operands 0: rm32 : 1473  1: check_rm32_dest : 1475  2: usimm8_32 : 1474  
Pattern id=59 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:83:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3795 :SUB  spec_rm16,simm8_16       is vexMode=0 & opsize=0 & byte=0x83; spec_rm16 & reg_opcode=5 ...; simm8_16  { subflags( spec_rm16,simm8_16);  spec_rm16 =  spec_rm16 - simm8_16; resultflags( spec_rm16); }
0: Constructor line ia.sinc:3795(id0.574) printpiece=[SUB,  ,  A, ,,  B]
Operands 0: spec_rm16 : 2377  1: simm8_16 : 2378  
Pattern id=574 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:83:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3796 :SUB  spec_rm32,simm8_32       is vexMode=0 & opsize=1 & byte=0x83; spec_rm32 & check_rm32_dest ... & reg_opcode=5 ...; simm8_32  { subflags( spec_rm32,simm8_32);  spec_rm32 =  spec_rm32 - simm8_32; build check_rm32_dest; resultflags( spec_rm32); }
0: Constructor line ia.sinc:3796(id0.575) printpiece=[SUB,  ,  A, ,,  C]
Operands 0: spec_rm32 : 2379  1: check_rm32_dest : 2381  2: simm8_32 : 2380  
Pattern id=575 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:83:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3994 :XOR spec_rm16,usimm8_16    is vexMode=0 & opsize=0 & byte=0x83; spec_rm16 & reg_opcode=6 ...; usimm8_16  { logicalflags();  spec_rm16 =  spec_rm16 ^ usimm8_16; resultflags( spec_rm16); }
0: Constructor line ia.sinc:3994(id0.642) printpiece=[XOR,  ,  A, ,,  B]
Operands 0: spec_rm16 : 2488  1: usimm8_16 : 2489  
Pattern id=642 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:83:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3995 :XOR spec_rm32,usimm8_32    is vexMode=0 & opsize=1 & byte=0x83; spec_rm32 & check_rm32_dest ... & reg_opcode=6 ...; usimm8_32  { logicalflags();  spec_rm32 =  spec_rm32 ^ usimm8_32; build check_rm32_dest; resultflags( spec_rm32); }
0: Constructor line ia.sinc:3995(id0.643) printpiece=[XOR,  ,  A, ,,  C]
Operands 0: spec_rm32 : 2490  1: check_rm32_dest : 2492  2: usimm8_32 : 2491  
Pattern id=643 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:83:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_XOR [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2209 :CMP spec_rm16,simm8_16		is vexMode=0 & opsize=0 & byte=0x83; spec_rm16 & reg_opcode=7 ...; simm8_16	{ subflags( spec_rm16,simm8_16); local tmp =   spec_rm16 - simm8_16; resultflags(tmp); }
0: Constructor line ia.sinc:2209(id0.140) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: spec_rm16 : 1608  1: simm8_16 : 1609  
Pattern id=140 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:83:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1e700:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1e700:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[1e700:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[1e700:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2210 :CMP spec_rm32,simm8_32		is vexMode=0 & opsize=1 & byte=0x83; spec_rm32 & reg_opcode=7 ...; simm8_32	{ subflags( spec_rm32,simm8_32); local tmp =   spec_rm32 - simm8_32; resultflags(tmp); }
0: Constructor line ia.sinc:2210(id0.141) printpiece=[CMP,  ,  A, ,,  B]
Operands 0: spec_rm32 : 1610  1: simm8_32 : 1611  
Pattern id=141 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:83:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[1e800:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[1e800:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[1e800:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[1e800:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3846 :TEST  rm8,Reg8     is vexMode=0 & byte=0x84;  rm8 & Reg8  ...              { logicalflags(); local tmp =  rm8 & Reg8;  resultflags(tmp); }
0: Constructor line ia.sinc:3846(id0.594) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: rm8 : 2408  1: Reg8 : 2409  
Pattern id=594 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:84:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: unique[42b00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[42b00:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[42b00:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[42b00:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3847 :TEST rm16,Reg16    is vexMode=0 & opsize=0; byte=0x85; rm16 & Reg16 ...        { logicalflags(); local tmp = rm16 & Reg16; resultflags(tmp); }
0: Constructor line ia.sinc:3847(id0.595) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: rm16 : 2410  1: Reg16 : 2411  
Pattern id=595 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:85:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: unique[42c00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[42c00:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[42c00:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[42c00:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3848 :TEST rm32,Reg32    is vexMode=0 & opsize=1; byte=0x85; rm32 & Reg32 ...        { logicalflags(); local tmp = rm32 & Reg32; resultflags(tmp); }
0: Constructor line ia.sinc:3848(id0.596) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: rm32 : 2412  1: Reg32 : 2413  
Pattern id=596 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:85:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = COPY const[0:1]
	3: register[20b:1] = COPY const[0:1]
	4: unique[42d00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[42d00:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL unique[42d00:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND unique[42d00:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3969 :XCHG  rm8,Reg8        is vexMode=0 & byte=0x86; rm8 & Reg8  ...                { local tmp = rm8;   rm8 = Reg8;   Reg8 = tmp; }
0: Constructor line ia.sinc:3969(id0.631) printpiece=[XCHG,  ,  A, ,,  B]
Operands 0: rm8 : 2462  1: Reg8 : 2463  
Pattern id=631 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:86:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[43600:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = COPY unique[43600:[handle:size]]

Line ia.sinc:3970 :XCHG rm16,Reg16   is vexMode=0 & opsize=0 & byte=0x87; rm16 & Reg16 ...        { local tmp = rm16; rm16 = Reg16; Reg16 = tmp; }
0: Constructor line ia.sinc:3970(id0.632) printpiece=[XCHG,  ,  A, ,,  B]
Operands 0: rm16 : 2464  1: Reg16 : 2465  
Pattern id=632 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:87:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[43680:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = COPY unique[43680:[handle:size]]

Line ia.sinc:3971 :XCHG rm32,Reg32   is vexMode=0 & opsize=1 & byte=0x87; rm32 & check_rm32_dest ... & Reg32 ... & check_Reg32_dest ...        { local tmp = rm32; rm32 = Reg32; build check_rm32_dest; Reg32 = tmp; build check_Reg32_dest;}
0: Constructor line ia.sinc:3971(id0.633) printpiece=[XCHG,  ,  A, ,,  C]
Operands 0: rm32 : 2466  1: check_rm32_dest : 2468  2: Reg32 : 2467  3: check_Reg32_dest : 2469  
Pattern id=633 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:87:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[43700:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY unique[43700:[handle:size]]
	6: MULTIEQUAL const[3:4]

Line ia.sinc:3043 :MOV rm8,Reg8       is vexMode=0 & byte=0x88; rm8 & Reg8 ...                { rm8=Reg8; }
0: Constructor line ia.sinc:3043(id0.276) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: rm8 : 1865  1: Reg8 : 1866  
Pattern id=276 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:88:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3044 :MOV rm16,Reg16     is vexMode=0 & opsize=0 & byte=0x89; rm16 & Reg16 ...       { rm16=Reg16; }
0: Constructor line ia.sinc:3044(id0.277) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: rm16 : 1867  1: Reg16 : 1868  
Pattern id=277 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:89:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3046 :MOV rm32,Reg32     is vexMode=0 & opsize=1 & byte=0x89; rm32 & check_rm32_dest ... & Reg32 ...       { rm32=Reg32; build check_rm32_dest; }
0: Constructor line ia.sinc:3046(id0.278) printpiece=[MOV,  ,  A, ,,  C]
Operands 0: rm32 : 1869  1: check_rm32_dest : 1871  2: Reg32 : 1870  
Pattern id=278 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:89:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:3050 :MOV Reg8,rm8       is vexMode=0 & byte=0x8a; rm8 & Reg8 ...                { Reg8 = rm8; }
0: Constructor line ia.sinc:3050(id0.279) printpiece=[MOV,  ,  B, ,,  A]
Operands 0: rm8 : 1873  1: Reg8 : 1872  
Pattern id=279 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:8A:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3051 :MOV Reg16,rm16     is vexMode=0 & opsize=0 & byte=0x8b; rm16 & Reg16 ...       { Reg16 = rm16; }
0: Constructor line ia.sinc:3051(id0.280) printpiece=[MOV,  ,  B, ,,  A]
Operands 0: rm16 : 1875  1: Reg16 : 1874  
Pattern id=280 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:8B:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3053 :MOV Reg32,rm32     is vexMode=0 & opsize=1 & byte=0x8b; rm32 & Reg32 ... & check_Reg32_dest ...      { Reg32 = rm32; build check_Reg32_dest; }
0: Constructor line ia.sinc:3053(id0.281) printpiece=[MOV,  ,  B, ,,  A]
Operands 0: rm32 : 1877  1: Reg32 : 1876  2: check_Reg32_dest : 1878  
Pattern id=281 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:8B:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[2:4]

Line ia.sinc:3057 :MOV rm16,Sreg      is vexMode=0 & byte=0x8c; rm16 & Sreg ...               { rm16 = Sreg; }
0: Constructor line ia.sinc:3057(id0.282) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: rm16 : 1879  1: Sreg : 1880  
Pattern id=282 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:8C:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1088 :VPMASKMOVD XmmReg1, vexVVVV_XmmReg, m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x8C; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vpmaskmovd_avx2( vexVVVV_XmmReg, m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:1088(id0.2056) printpiece=[VPMASKMOVD,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6853  1: XmmReg1 : 6852  2: YmmReg1 : 6855  3: m128 : 6854  
Pattern id=2056 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:8C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c0600:10] = CALLOTHER const[26d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c0600:10]

Line avx2.sinc:1096 :VPMASKMOVD YmmReg1, vexVVVV_YmmReg, m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x8C; YmmReg1 ... & m256
{
	YmmReg1 = vpmaskmovd_avx2( vexVVVV_YmmReg, m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1096(id0.2057) printpiece=[VPMASKMOVD,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6857  1: YmmReg1 : 6856  2: m256 : 6858  
Pattern id=2057 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:8C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1104 :VPMASKMOVQ XmmReg1, vexVVVV_XmmReg, m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x8C; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vpmaskmovq_avx2( vexVVVV_XmmReg, m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx2.sinc:1104(id0.2058) printpiece=[VPMASKMOVQ,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 6861  1: XmmReg1 : 6860  2: YmmReg1 : 6863  3: m128 : 6862  
Pattern id=2058 pattern=cmb:(ctx:SS:X3:X[10xx]:[xx00][010x]:XX,ins:8C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c0800:10] = CALLOTHER const[26e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c0800:10]

Line avx2.sinc:1112 :VPMASKMOVQ YmmReg1, vexVVVV_YmmReg, m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x8C; YmmReg1 ... & m256
{
	YmmReg1 = vpmaskmovq_avx2( vexVVVV_YmmReg, m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:1112(id0.2059) printpiece=[VPMASKMOVQ,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6865  1: YmmReg1 : 6864  2: m256 : 6866  
Pattern id=2059 pattern=cmb:(ctx:SS:X3:X[11xx]:[xx00][010x]:XX,ins:8C:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2911 :LEA Reg16,addr16  is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & addrsize=0 & byte=0x8D; addr16 & Reg16 ...  { Reg16 = addr16; }
0: Constructor line ia.sinc:2911(id0.251) printpiece=[LEA,  ,  B, ,,  A]
Operands 0: addr16 : 1826  1: Reg16 : 1825  
Pattern id=251 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:8D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2912 :LEA Reg32,addr16  is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & addrsize=0 & byte=0x8D; addr16 & Reg32 ...  { Reg32 = zext(addr16); }
0: Constructor line ia.sinc:2912(id0.252) printpiece=[LEA,  ,  B, ,,  A]
Operands 0: addr16 : 1828  1: Reg32 : 1827  
Pattern id=252 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:8D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2914 :LEA Reg16,addr32  is vexMode=0 & opsize=0 & addrsize=1 & byte=0x8D; addr32 & Reg16 ...  { Reg16 = addr32(0); }
0: Constructor line ia.sinc:2914(id0.253) printpiece=[LEA,  ,  B, ,,  A]
Operands 0: addr32 : 1830  1: Reg16 : 1829  
Pattern id=253 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:8D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE [handle:space][[handle:offset]:[handle:size]], const[0:4]

Line ia.sinc:2915 :LEA Reg32,addr32  is vexMode=0 & opsize=1 & addrsize=1 & byte=0x8D; addr32 & Reg32 ...  & check_Reg32_dest ... {
    Reg32 = addr32;
	build check_Reg32_dest;
}
0: Constructor line ia.sinc:2915(id0.254) printpiece=[LEA,  ,  B, ,,  A]
Operands 0: addr32 : 1832  1: Reg32 : 1831  2: check_Reg32_dest : 1833  
Pattern id=254 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:8D:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[2:4]

Line ia.sinc:3058 :MOV Sreg,rm16      is vexMode=0 & byte=0x8e; rm16 & Sreg ...               { Sreg=rm16; }
0: Constructor line ia.sinc:3058(id0.283) printpiece=[MOV,  ,  B, ,,  A]
Operands 0: rm16 : 1882  1: Sreg : 1881  
Pattern id=283 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:8E:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1119 :VPMASKMOVD m128, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x8E; XmmReg1 ... & m128
{
	m128 = vpmaskmovd_avx2( vexVVVV_XmmReg, XmmReg1 );
}
0: Constructor line avx2.sinc:1119(id0.2060) printpiece=[VPMASKMOVD,  ,  C, ,,  ,  A, ,,  ,  B]
Operands 0: vexVVVV_XmmReg : 6868  1: XmmReg1 : 6869  2: m128 : 6867  
Pattern id=2060 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:8E:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1125 :VPMASKMOVD m256, vexVVVV_YmmReg, YmmReg1 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x8E; YmmReg1 ... & m256
{
	m256 = vpmaskmovd_avx2( vexVVVV_YmmReg, YmmReg1 );
}
0: Constructor line avx2.sinc:1125(id0.2061) printpiece=[VPMASKMOVD,  ,  C, ,,  ,  A, ,,  ,  B]
Operands 0: vexVVVV_YmmReg : 6871  1: YmmReg1 : 6872  2: m256 : 6870  
Pattern id=2061 pattern=cmb:(ctx:SS:X2:X[11xx]:[xx00][010x]:XX,ins:8E:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1131 :VPMASKMOVQ m128, vexVVVV_XmmReg, XmmReg1 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x8E; XmmReg1 ... & m128
{
	m128 = vpmaskmovq_avx2( vexVVVV_XmmReg, XmmReg1 );
}
0: Constructor line avx2.sinc:1131(id0.2062) printpiece=[VPMASKMOVQ,  ,  C, ,,  ,  A, ,,  ,  B]
Operands 0: vexVVVV_XmmReg : 6874  1: XmmReg1 : 6875  2: m128 : 6873  
Pattern id=2062 pattern=cmb:(ctx:SS:X3:X[10xx]:[xx00][010x]:XX,ins:8E:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:1137 :VPMASKMOVQ m256, vexVVVV_YmmReg, YmmReg1 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x8E; YmmReg1 ... & m256
{
	m256 = vpmaskmovq_avx2( vexVVVV_YmmReg, YmmReg1 );
}
0: Constructor line avx2.sinc:1137(id0.2063) printpiece=[VPMASKMOVQ,  ,  C, ,,  ,  A, ,,  ,  B]
Operands 0: vexVVVV_YmmReg : 6877  1: YmmReg1 : 6878  2: m256 : 6876  
Pattern id=2063 pattern=cmb:(ctx:SS:X3:X[11xx]:[xx00][010x]:XX,ins:8E:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[26e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3270 :POP rm16        is vexMode=0 & addrsize=0 & opsize=0 & byte=0x8f; rm16 & reg_opcode=0 ... { pop22(rm16); }
0: Constructor line ia.sinc:3270(id0.365) printpiece=[POP,  ,  A]
Operands 0: rm16 : 2049  
Pattern id=365 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:8F:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	2: [handle:space][[handle:offset]:[handle:size]] = LOAD const[ram:8], unique[9e80:4]
	3: register[10:2] = INT_ADD register[10:2], const[2:2]

Line ia.sinc:3272 :POP rm32        is vexMode=0 & addrsize=0 & opsize=1 & byte=0x8f; rm32 & reg_opcode=0 ... { pop24(rm32); }
0: Constructor line ia.sinc:3272(id0.367) printpiece=[POP,  ,  A]
Operands 0: rm32 : 2051  
Pattern id=367 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:8F:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	2: [handle:space][[handle:offset]:[handle:size]] = LOAD const[ram:8], unique[a080:4]
	3: register[10:2] = INT_ADD register[10:2], const[4:2]

Line ia.sinc:3271 :POP rm16        is vexMode=0 & addrsize=1 & opsize=0 & byte=0x8f; rm16 & reg_opcode=0 ... { pop42(rm16); }
0: Constructor line ia.sinc:3271(id0.366) printpiece=[POP,  ,  A]
Operands 0: rm16 : 2050  
Pattern id=366 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:8F:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = LOAD const[ram:8], register[10:4]
	2: register[10:4] = INT_ADD register[10:4], const[2:4]

Line ia.sinc:3273 :POP rm32        is vexMode=0 & addrsize=1 & opsize=1 & byte=0x8f; rm32 & reg_opcode=0 ... { pop44(rm32); }
0: Constructor line ia.sinc:3273(id0.368) printpiece=[POP,  ,  A]
Operands 0: rm32 : 2052  
Pattern id=368 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:8F:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = LOAD const[ram:8], register[10:4]
	2: register[10:4] = INT_ADD register[10:4], const[4:4]

Line ia.sinc:3210 :NOP            is vexMode=0 & opsize=0 & byte=0x90 & rexprefix=0   { }
0: Constructor line ia.sinc:3210(id0.329) printpiece=[NOP]
Operands 
Pattern id=329 pattern=cmb:(ctx:X[xx00]:XX:[xxx0][0xxx]:XX,ins:90:XX:XX:XX)
Template

Line ia.sinc:3267 :PAUSE          is vexMode=0 & opsize=0 & $(PRE_F3) & byte=0x90     {  }
1: Constructor line ia.sinc:3267(id0.363) printpiece=[PAUSE]
Operands 
Pattern id=363 pattern=cmb:(ctx:X[xx00]:X[x1xx]:X[0xxx]:XX,ins:90:XX:XX:XX)
Template

Line ia.sinc:3963 :XCHG   AX,Rmr16       is vexMode=0 & opsize=0 & row = 9 & page = 0 & AX & Rmr16        { local tmp = AX;     AX = Rmr16;     Rmr16 = tmp; }
2: Constructor line ia.sinc:3963(id0.629) printpiece=[XCHG,  ,  A, ,,  B]
Operands 0: AX : 2456  1: Rmr16 : 2457  
Pattern id=629 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:9[0xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[43500:2] = COPY register[0:2]
	2: register[0:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY unique[43500:2]

Line ia.sinc:3211 :NOP            is vexMode=0 & opsize=1 & byte=0x90 & rexprefix=0   { }
0: Constructor line ia.sinc:3211(id0.330) printpiece=[NOP]
Operands 
Pattern id=330 pattern=cmb:(ctx:X[xx01]:XX:[xxx0][0xxx]:XX,ins:90:XX:XX:XX)
Template

Line ia.sinc:3268 :PAUSE          is vexMode=0 & opsize=1 & $(PRE_F3) & byte=0x90     {  }
1: Constructor line ia.sinc:3268(id0.364) printpiece=[PAUSE]
Operands 
Pattern id=364 pattern=cmb:(ctx:X[xx01]:X[x1xx]:X[0xxx]:XX,ins:90:XX:XX:XX)
Template

Line ia.sinc:3964 :XCHG  EAX,Rmr32   is vexMode=0 & opsize=1 & row = 9 & page = 0 & EAX & check_EAX_dest & Rmr32 & check_Rmr32_dest      { local tmp = EAX;   EAX = Rmr32; build check_EAX_dest; Rmr32 = tmp; build check_Rmr32_dest; }
2: Constructor line ia.sinc:3964(id0.630) printpiece=[XCHG,  ,  A, ,,  C]
Operands 0: EAX : 2458  1: check_EAX_dest : 2460  2: Rmr32 : 2459  3: check_Rmr32_dest : 2461  
Pattern id=630 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:9[0xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[43580:4] = COPY register[0:4]
	2: register[0:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]
	4: [handle:space][[handle:offset]:[handle:size]] = COPY unique[43580:4]
	5: MULTIEQUAL const[3:4]

Line avx2_manual.sinc:124 :VPGATHERDD XmmReg1, d_vm32x, vexVVVV_XmmReg is $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x90; (XmmReg1 & YmmReg1) ... & d_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vpgatherdd(XmmReg1, d_vm32x, vexVVVV_XmmReg);
	local tmp:16 = vpgatherdd(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
0: Constructor line avx2_manual.sinc:124(id0.2080) printpiece=[VPGATHERDD,  ,  B, ,,  ,  D, ,,  ,  A]
Operands 0: vexVVVV_XmmReg : 6948  1: XmmReg1 : 6946  2: YmmReg1 : 6949  3: d_vm32x : 6947  
Pattern id=2080 pattern=cmb:(ctx:X[x1xx]:X2:X[10xx]:[xx00][010x],ins:90:X[x100]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c2180:10] = CALLOTHER const[277:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c2180:10]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]

Line avx2_manual.sinc:69 :VGATHERDPS XmmReg1, d_vm32x, vexVVVV_XmmReg is $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_XmmReg; byte=0x92; (XmmReg1 & YmmReg1) ... & d_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vgatherdps(XmmReg1, d_vm32x, vexVVVV_XmmReg);
	local tmp:16 = vgatherdps(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
0: Constructor line avx2_manual.sinc:69(id0.2077) printpiece=[VGATHERDPS,  ,  B, ,,  ,  D, ,,  ,  A]
Operands 0: vexVVVV_XmmReg : 6936  1: XmmReg1 : 6934  2: YmmReg1 : 6937  3: d_vm32x : 6935  
Pattern id=2077 pattern=cmb:(ctx:X[x1xx]:X2:X[10xx]:[xx00][010x],ins:92:X[x100]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c1980:10] = CALLOTHER const[276:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c1980:10]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]

Line avx2_manual.sinc:147 :VPGATHERDD YmmReg1, d_vm32y, vexVVVV_YmmReg is $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x90; YmmReg1 ... & d_vm32y {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vpgatherdd(YmmReg1, d_vm32y, vexVVVV_YmmReg);
	YmmReg1 = vpgatherdd(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}
0: Constructor line avx2_manual.sinc:147(id0.2081) printpiece=[VPGATHERDD,  ,  B, ,,  ,  C, ,,  ,  A]
Operands 0: vexVVVV_YmmReg : 6952  1: YmmReg1 : 6950  2: d_vm32y : 6951  
Pattern id=2081 pattern=cmb:(ctx:X[x1xx]:X2:X[11xx]:[xx00][010x],ins:90:X[x100]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[277:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]

Line avx2_manual.sinc:92 :VGATHERDPS YmmReg1, d_vm32y, vexVVVV_YmmReg is $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_YmmReg; byte=0x92; YmmReg1 ... & d_vm32y {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vgatherdps(YmmReg1, d_vm32y, vexVVVV_YmmReg);
	YmmReg1 = vgatherdps(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}
0: Constructor line avx2_manual.sinc:92(id0.2078) printpiece=[VGATHERDPS,  ,  B, ,,  ,  C, ,,  ,  A]
Operands 0: vexVVVV_YmmReg : 6940  1: YmmReg1 : 6938  2: d_vm32y : 6939  
Pattern id=2078 pattern=cmb:(ctx:X[x1xx]:X2:X[11xx]:[xx00][010x],ins:92:X[x100]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[276:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]

Line avx2_manual.sinc:170 :VPGATHERDQ XmmReg1, q_vm32x, vexVVVV_XmmReg is $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x90; (XmmReg1 & YmmReg1) ... & q_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vpgatherdq(XmmReg1, q_vm32x, vexVVVV_XmmReg);
	local tmp:16 = vpgatherdq(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
0: Constructor line avx2_manual.sinc:170(id0.2082) printpiece=[VPGATHERDQ,  ,  B, ,,  ,  D, ,,  ,  A]
Operands 0: vexVVVV_XmmReg : 6956  1: XmmReg1 : 6954  2: YmmReg1 : 6957  3: q_vm32x : 6955  
Pattern id=2082 pattern=cmb:(ctx:X[x1xx]:X3:X[10xx]:[xx00][010x],ins:90:X[x100]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c2380:10] = CALLOTHER const[278:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c2380:10]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]

Line avx2_manual.sinc:24 :VGATHERDPD XmmReg1, q_vm32x, vexVVVV_XmmReg is $(VEX_DDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_XmmReg; byte=0x92; (XmmReg1 & YmmReg1) ... & q_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	XmmReg1 = vgatherdpd(XmmReg1, q_vm32x, vexVVVV_XmmReg);
	local tmp:16 = vgatherdpd(XmmReg1, vexVVVV_XmmReg);
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
	vexVVVV_XmmReg = 0;
}
0: Constructor line avx2_manual.sinc:24(id0.2075) printpiece=[VGATHERDPD,  ,  B, ,,  ,  D, ,,  ,  A]
Operands 0: vexVVVV_XmmReg : 6928  1: XmmReg1 : 6926  2: YmmReg1 : 6929  3: q_vm32x : 6927  
Pattern id=2075 pattern=cmb:(ctx:X[x1xx]:X3:X[10xx]:[xx00][010x],ins:92:X[x100]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[c1780:10] = CALLOTHER const[275:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[c1780:10]
	5: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]

Line avx2_manual.sinc:193 :VPGATHERDQ YmmReg1, q_vm32x, vexVVVV_YmmReg is $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x90; YmmReg1 ... & q_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vpgatherdq(YmmReg1, q_vm32x, vexVVVV_YmmReg);
	YmmReg1 = vpgatherdq(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}
0: Constructor line avx2_manual.sinc:193(id0.2083) printpiece=[VPGATHERDQ,  ,  B, ,,  ,  C, ,,  ,  A]
Operands 0: vexVVVV_YmmReg : 6960  1: YmmReg1 : 6958  2: q_vm32x : 6959  
Pattern id=2083 pattern=cmb:(ctx:X[x1xx]:X3:X[11xx]:[xx00][010x],ins:90:X[x100]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[278:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]

Line avx2_manual.sinc:47 :VGATHERDPD YmmReg1, q_vm32x, vexVVVV_YmmReg is $(VEX_DDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W1) & vexVVVV_YmmReg; byte=0x92; YmmReg1 ... & q_vm32x {
# TODO full semantics necessary for VSIB memory data access, leave out of data flow for now
#	YmmReg1 = vgatherdpd(YmmReg1, q_vm32x, vexVVVV_YmmReg);
	YmmReg1 = vgatherdpd(YmmReg1, vexVVVV_YmmReg);
	# TODO ZmmReg1 = zext(YmmReg1)
	vexVVVV_YmmReg = 0;
}
0: Constructor line avx2_manual.sinc:47(id0.2076) printpiece=[VGATHERDPD,  ,  B, ,,  ,  C, ,,  ,  A]
Operands 0: vexVVVV_YmmReg : 6932  1: YmmReg1 : 6930  2: q_vm32x : 6931  
Pattern id=2076 pattern=cmb:(ctx:X[x1xx]:X3:X[11xx]:[xx00][010x],ins:92:X[x100]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[275:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY const[0:[handle:size]]

Line ia.sinc:2151 :CBW            is vexMode=0 & opsize=0 & byte=0x98                 { AX = sext(AL); }
0: Constructor line ia.sinc:2151(id0.118) printpiece=[CBW]
Operands 
Pattern id=118 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:98:XX:XX:XX)
Template
	0: register[0:2] = INT_SEXT register[0:1]

Line ia.sinc:2152 :CWDE           is vexMode=0 & opsize=1 & byte=0x98 & check_EAX_dest { EAX = sext(AX); build check_EAX_dest;}
0: Constructor line ia.sinc:2152(id0.119) printpiece=[CWDE]
Operands 0: check_EAX_dest : 1583  
Pattern id=119 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:98:XX:XX:XX)
Template
	0: register[0:4] = INT_SEXT register[0:2]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:2157 :CWD            is vexMode=0 & opsize=0 & byte=0x99                 { tmp:4 = sext(AX); DX = tmp(2); }
0: Constructor line ia.sinc:2157(id0.120) printpiece=[CWD]
Operands 
Pattern id=120 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:99:XX:XX:XX)
Template
	0: unique[1db80:4] = INT_SEXT register[0:2]
	1: register[8:2] = SUBPIECE unique[1db80:4], const[2:4]

Line ia.sinc:2158 :CDQ            is vexMode=0 & opsize=1 & byte=0x99 & check_EDX_dest { tmp:8 = sext(EAX); EDX = tmp(4); build check_EDX_dest;}
0: Constructor line ia.sinc:2158(id0.121) printpiece=[CDQ]
Operands 0: check_EDX_dest : 1584  
Pattern id=121 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:99:XX:XX:XX)
Template
	0: unique[1dd00:8] = INT_SEXT register[0:4]
	1: register[8:4] = SUBPIECE unique[1dd00:8], const[4:4]
	2: MULTIEQUAL const[0:4]

Line ia.sinc:2131 :CALLF ptr1616      is vexMode=0 & addrsize=0 & opsize=0 & byte=0x9a; ptr1616           { push22(CS); build ptr1616; push22(&:2 inst_next); call ptr1616; }
0: Constructor line ia.sinc:2131(id0.110) printpiece=[CALLF,  ,  A]
Operands 0: ptr1616 : 1575  
Pattern id=110 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:9A:XX:XX:XX)
Template
	0: unique[9400:2] = COPY register[102:2]
	1: register[10:2] = INT_SUB register[10:2], const[2:2]
	2: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	3: STORE const[ram:8], unique[9580:4], unique[9400:2]
	4: MULTIEQUAL const[0:4]
	5: unique[9400:2] = COPY const[[next]:2]
	6: register[10:2] = INT_SUB register[10:2], const[2:2]
	7: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	8: STORE const[ram:8], unique[9580:4], unique[9400:2]
	9: CALL [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2133 :CALLF ptr1632      is vexMode=0 & addrsize=0 & opsize=1 & byte=0x9a; ptr1632           { push22(CS); build ptr1632; push24(&:4 inst_next); call ptr1632; }
0: Constructor line ia.sinc:2133(id0.112) printpiece=[CALLF,  ,  A]
Operands 0: ptr1632 : 1577  
Pattern id=112 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:9A:XX:XX:XX)
Template
	0: unique[9400:2] = COPY register[102:2]
	1: register[10:2] = INT_SUB register[10:2], const[2:2]
	2: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	3: STORE const[ram:8], unique[9580:4], unique[9400:2]
	4: MULTIEQUAL const[0:4]
	5: unique[9600:4] = COPY const[[next]:4]
	6: register[10:2] = INT_SUB register[10:2], const[4:2]
	7: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	8: STORE const[ram:8], unique[9780:4], unique[9600:4]
	9: CALL [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2132 :CALLF ptr1616      is vexMode=0 & addrsize=1 & opsize=0 & byte=0x9a; ptr1616           { push42(CS); build ptr1616; push42(&:2 inst_next); call ptr1616; }
0: Constructor line ia.sinc:2132(id0.111) printpiece=[CALLF,  ,  A]
Operands 0: ptr1616 : 1576  
Pattern id=111 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:9A:XX:XX:XX)
Template
	0: unique[9a00:2] = COPY register[102:2]
	1: register[10:4] = INT_SUB register[10:4], const[2:4]
	2: STORE const[ram:8], register[10:4], unique[9a00:2]
	3: MULTIEQUAL const[0:4]
	4: unique[9a00:2] = COPY const[[next]:2]
	5: register[10:4] = INT_SUB register[10:4], const[2:4]
	6: STORE const[ram:8], register[10:4], unique[9a00:2]
	7: CALL [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2134 :CALLF ptr1632      is vexMode=0 & addrsize=1 & opsize=1 & byte=0x9a; ptr1632           { push42(CS); build ptr1632; push44(&:4 inst_next); call ptr1632; }
0: Constructor line ia.sinc:2134(id0.113) printpiece=[CALLF,  ,  A]
Operands 0: ptr1632 : 1578  
Pattern id=113 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:9A:XX:XX:XX)
Template
	0: register[10:4] = INT_SUB register[10:4], const[2:4]
	1: STORE const[ram:8], register[10:4], register[102:2]
	2: MULTIEQUAL const[0:4]
	3: register[10:4] = INT_SUB register[10:4], const[4:4]
	4: STORE const[ram:8], register[10:4], const[[next]:4]
	5: CALL [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4334 :FSTENV Mem     is vexMode=0 & byte=0x9B; byte=0xD9; (mod != 0b11 & reg_opcode=6) ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;
}
0: Constructor line ia.sinc:4334(id0.783) printpiece=[FSTENV,  ,  A]
Operands 0: Mem : 2638  
Pattern id=783 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:D9:3[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4b680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: STORE const[ram:8], unique[4b680:[handle:size]], register[10a2:2]
	4: unique[4b700:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: STORE const[ram:8], unique[4b700:[handle:size]], register[10a4:2]
	6: unique[4b780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: STORE const[ram:8], unique[4b780:[handle:size]], register[10a8:4]
	8: unique[4b800:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: STORE const[ram:8], unique[4b800:[handle:size]], register[10ac:4]
	10: unique[4b880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: STORE const[ram:8], unique[4b880:[handle:size]], register[10a6:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4331 :FSTCW m16      is vexMode=0 & byte=0x9B; byte=0xD9; (mod != 0b11 & reg_opcode=7) ... & m16     { m16 = FPUControlWord; }
0: Constructor line ia.sinc:4331(id0.781) printpiece=[FSTCW,  ,  A]
Operands 0: m16 : 2636  
Pattern id=781 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:D9:3[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[10a0:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4334 :FSTENV Mem     is vexMode=0 & byte=0x9B; byte=0xD9; (mod != 0b11 & reg_opcode=6) ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;
}
0: Constructor line ia.sinc:4334(id0.783) printpiece=[FSTENV,  ,  A]
Operands 0: Mem : 2638  
Pattern id=783 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:D9:7[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4b680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: STORE const[ram:8], unique[4b680:[handle:size]], register[10a2:2]
	4: unique[4b700:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: STORE const[ram:8], unique[4b700:[handle:size]], register[10a4:2]
	6: unique[4b780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: STORE const[ram:8], unique[4b780:[handle:size]], register[10a8:4]
	8: unique[4b800:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: STORE const[ram:8], unique[4b800:[handle:size]], register[10ac:4]
	10: unique[4b880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: STORE const[ram:8], unique[4b880:[handle:size]], register[10a6:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4331 :FSTCW m16      is vexMode=0 & byte=0x9B; byte=0xD9; (mod != 0b11 & reg_opcode=7) ... & m16     { m16 = FPUControlWord; }
0: Constructor line ia.sinc:4331(id0.781) printpiece=[FSTCW,  ,  A]
Operands 0: m16 : 2636  
Pattern id=781 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:D9:7[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[10a0:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4334 :FSTENV Mem     is vexMode=0 & byte=0x9B; byte=0xD9; (mod != 0b11 & reg_opcode=6) ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;
}
0: Constructor line ia.sinc:4334(id0.783) printpiece=[FSTENV,  ,  A]
Operands 0: Mem : 2638  
Pattern id=783 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:D9:B[0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4b680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: STORE const[ram:8], unique[4b680:[handle:size]], register[10a2:2]
	4: unique[4b700:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: STORE const[ram:8], unique[4b700:[handle:size]], register[10a4:2]
	6: unique[4b780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: STORE const[ram:8], unique[4b780:[handle:size]], register[10a8:4]
	8: unique[4b800:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: STORE const[ram:8], unique[4b800:[handle:size]], register[10ac:4]
	10: unique[4b880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: STORE const[ram:8], unique[4b880:[handle:size]], register[10a6:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4331 :FSTCW m16      is vexMode=0 & byte=0x9B; byte=0xD9; (mod != 0b11 & reg_opcode=7) ... & m16     { m16 = FPUControlWord; }
0: Constructor line ia.sinc:4331(id0.781) printpiece=[FSTCW,  ,  A]
Operands 0: m16 : 2636  
Pattern id=781 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:D9:B[1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[10a0:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
0: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4123 :FENI               is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE0 {}
0: Constructor line ia.sinc:4123(id0.702) printpiece=[FENI]
Operands 
Pattern id=702 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:DB:E0:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4121 :FDISI              is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE1 {}
0: Constructor line ia.sinc:4121(id0.700) printpiece=[FDISI]
Operands 
Pattern id=700 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:DB:E1:XX)
Template

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4088 :FCLEX          is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE2      { FPUStatusWord[0,8] = 0; FPUStatusWord[15,1] = 0; }
0: Constructor line ia.sinc:4088(id0.675) printpiece=[FCLEX]
Operands 
Pattern id=675 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:DB:E2:XX)
Template
	0: register[10a2:1] = COPY const[0:1]
	1: unique[45100:2] = INT_AND register[10a2:2], const[ffffffffffff7fff:2]
	2: unique[45180:2] = INT_ZEXT const[0:1]
	3: unique[45200:2] = INT_LEFT unique[45180:2], const[f:4]
	4: register[10a2:2] = INT_OR unique[45100:2], unique[45200:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4159 :FINIT              is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE3          {
										  FPUControlWord = 0x037f;        
                                          FPUStatusWord = 0x0000;         
                                          FPUTagWord = 0xffff;            
                                          FPUDataPointer = 0x00000000;        
                                          FPUInstructionPointer = 0x00000000;     
                                          FPULastInstructionOpcode = 0x0000;  
                                          C0 = 0;                 
                                          C1 = 0;                 
                                          C2 = 0;                 
                                          C3 = 0; }                           
0: Constructor line ia.sinc:4159(id0.730) printpiece=[FINIT]
Operands 
Pattern id=730 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:DB:E3:XX)
Template
	0: register[10a0:2] = COPY const[37f:2]
	1: register[10a2:2] = COPY const[0:2]
	2: register[10a4:2] = COPY const[ffff:2]
	3: register[10a8:4] = COPY const[0:4]
	4: register[10ac:4] = COPY const[0:4]
	5: register[10a6:2] = COPY const[0:2]
	6: register[1090:1] = COPY const[0:1]
	7: register[1091:1] = COPY const[0:1]
	8: register[1092:1] = COPY const[0:1]
	9: register[1093:1] = COPY const[0:1]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4263 :FSAVE Mem      is vexMode=0 & byte=0x9B; byte=0xDD; reg_opcode=6 ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;

  *:10 (Mem + 28) = ST0;
  *:10 (Mem + 38) = ST1;
  *:10 (Mem + 48) = ST2;
  *:10 (Mem + 58) = ST3;
  *:10 (Mem + 68) = ST4;
  *:10 (Mem + 78) = ST5;
  *:10 (Mem + 88) = ST6;
  *:10 (Mem + 98) = ST7;

  FPUControlWord = 0x037f;
  FPUStatusWord = 0x0000;
  FPUTagWord = 0xffff;
  FPUDataPointer = 0x00000000;
  FPUInstructionPointer = 0x00000000;
  FPULastInstructionOpcode = 0x0000;
}
0: Constructor line ia.sinc:4263(id0.768) printpiece=[FSAVE,  ,  A]
Operands 0: Mem : 2625  
Pattern id=768 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:DD:[xx11][0xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4a480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: STORE const[ram:8], unique[4a480:[handle:size]], register[10a2:2]
	4: unique[4a500:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: STORE const[ram:8], unique[4a500:[handle:size]], register[10a4:2]
	6: unique[4a580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: STORE const[ram:8], unique[4a580:[handle:size]], register[10a8:4]
	8: unique[4a600:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: STORE const[ram:8], unique[4a600:[handle:size]], register[10ac:4]
	10: unique[4a680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: STORE const[ram:8], unique[4a680:[handle:size]], register[10a6:2]
	12: unique[4a700:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[1c:[handle:size]]
	13: STORE const[ram:8], unique[4a700:[handle:size]], register[1106:a]
	14: unique[4a780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[26:[handle:size]]
	15: STORE const[ram:8], unique[4a780:[handle:size]], register[1116:a]
	16: unique[4a800:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[30:[handle:size]]
	17: STORE const[ram:8], unique[4a800:[handle:size]], register[1126:a]
	18: unique[4a880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[3a:[handle:size]]
	19: STORE const[ram:8], unique[4a880:[handle:size]], register[1136:a]
	20: unique[4a900:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[44:[handle:size]]
	21: STORE const[ram:8], unique[4a900:[handle:size]], register[1146:a]
	22: unique[4a980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4e:[handle:size]]
	23: STORE const[ram:8], unique[4a980:[handle:size]], register[1156:a]
	24: unique[4aa00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[58:[handle:size]]
	25: STORE const[ram:8], unique[4aa00:[handle:size]], register[1166:a]
	26: unique[4aa80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[62:[handle:size]]
	27: STORE const[ram:8], unique[4aa80:[handle:size]], register[1176:a]
	28: register[10a0:2] = COPY const[37f:2]
	29: register[10a2:2] = COPY const[0:2]
	30: register[10a4:2] = COPY const[ffff:2]
	31: register[10a8:4] = COPY const[0:4]
	32: register[10ac:4] = COPY const[0:4]
	33: register[10a6:2] = COPY const[0:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4354 :FSTSW m16      is vexMode=0 & byte=0x9B; byte=0xDD; reg_opcode=7 ... & m16     { m16 = FPUStatusWord; }
0: Constructor line ia.sinc:4354(id0.785) printpiece=[FSTSW,  ,  A]
Operands 0: m16 : 2640  
Pattern id=785 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:DD:[xx11][1xxx]:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[10a2:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:4355 :FSTSW AX       is vexMode=0 & byte=0x9B; byte=0xDF; byte=0xE0 & AX         { AX = FPUStatusWord; }
0: Constructor line ia.sinc:4355(id0.786) printpiece=[FSTSW,  ,  A]
Operands 0: AX : 2641  
Pattern id=786 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:DF:E0:XX)
Template
	0: register[0:2] = COPY register[10a2:2]

Line ia.sinc:3925 :WAIT           is vexMode=0 & byte=0x9b                        { }
1: Constructor line ia.sinc:3925(id0.618) printpiece=[WAIT]
Operands 
Pattern id=618 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9B:XX:XX:XX)
Template

Line ia.sinc:3396 :PUSHF          is vexMode=0 & addrsize=0 & opsize=0 & byte=0x9c            { packflags(flags); push22(flags); }
0: Constructor line ia.sinc:3396(id0.432) printpiece=[PUSHF]
Operands 
Pattern id=432 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:9C:XX:XX:XX)
Template
	0: unique[b400:1] = INT_AND register[20d:1], const[1:1]
	1: unique[b480:2] = INT_ZEXT unique[b400:1]
	2: unique[b500:2] = INT_MULT const[4000:2], unique[b480:2]
	3: unique[b580:1] = INT_AND register[20b:1], const[1:1]
	4: unique[b600:2] = INT_ZEXT unique[b580:1]
	5: unique[b680:2] = INT_MULT const[800:2], unique[b600:2]
	6: unique[b700:2] = INT_OR unique[b500:2], unique[b680:2]
	7: unique[b780:1] = INT_AND register[20a:1], const[1:1]
	8: unique[b800:2] = INT_ZEXT unique[b780:1]
	9: unique[b880:2] = INT_MULT const[400:2], unique[b800:2]
	10: unique[b900:2] = INT_OR unique[b700:2], unique[b880:2]
	11: unique[b980:1] = INT_AND register[209:1], const[1:1]
	12: unique[ba00:2] = INT_ZEXT unique[b980:1]
	13: unique[ba80:2] = INT_MULT const[200:2], unique[ba00:2]
	14: unique[bb00:2] = INT_OR unique[b900:2], unique[ba80:2]
	15: unique[bb80:1] = INT_AND register[208:1], const[1:1]
	16: unique[bc00:2] = INT_ZEXT unique[bb80:1]
	17: unique[bc80:2] = INT_MULT const[100:2], unique[bc00:2]
	18: unique[bd00:2] = INT_OR unique[bb00:2], unique[bc80:2]
	19: unique[bd80:1] = INT_AND register[207:1], const[1:1]
	20: unique[be00:2] = INT_ZEXT unique[bd80:1]
	21: unique[be80:2] = INT_MULT const[80:2], unique[be00:2]
	22: unique[bf00:2] = INT_OR unique[bd00:2], unique[be80:2]
	23: unique[bf80:1] = INT_AND register[206:1], const[1:1]
	24: unique[c000:2] = INT_ZEXT unique[bf80:1]
	25: unique[c080:2] = INT_MULT const[40:2], unique[c000:2]
	26: unique[c100:2] = INT_OR unique[bf00:2], unique[c080:2]
	27: unique[c180:1] = INT_AND register[204:1], const[1:1]
	28: unique[c200:2] = INT_ZEXT unique[c180:1]
	29: unique[c280:2] = INT_MULT const[10:2], unique[c200:2]
	30: unique[c300:2] = INT_OR unique[c100:2], unique[c280:2]
	31: unique[c380:1] = INT_AND register[202:1], const[1:1]
	32: unique[c400:2] = INT_ZEXT unique[c380:1]
	33: unique[c480:2] = INT_MULT const[4:2], unique[c400:2]
	34: unique[c500:2] = INT_OR unique[c300:2], unique[c480:2]
	35: unique[c580:1] = INT_AND register[200:1], const[1:1]
	36: unique[c600:2] = INT_ZEXT unique[c580:1]
	37: unique[c680:2] = INT_MULT const[1:2], unique[c600:2]
	38: register[280:2] = INT_OR unique[c500:2], unique[c680:2]
	39: unique[9400:2] = COPY register[280:2]
	40: register[10:2] = INT_SUB register[10:2], const[2:2]
	41: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	42: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3398 :PUSHFD         is vexMode=0 & addrsize=0 & opsize=1 & byte=0x9c            { packflags(eflags); packeflags(eflags); push24(eflags); }
0: Constructor line ia.sinc:3398(id0.434) printpiece=[PUSHFD]
Operands 
Pattern id=434 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:9C:XX:XX:XX)
Template
	0: unique[b400:1] = INT_AND register[20d:1], const[1:1]
	1: unique[b480:4] = INT_ZEXT unique[b400:1]
	2: unique[b500:4] = INT_MULT const[4000:4], unique[b480:4]
	3: unique[b580:1] = INT_AND register[20b:1], const[1:1]
	4: unique[b600:4] = INT_ZEXT unique[b580:1]
	5: unique[b680:4] = INT_MULT const[800:4], unique[b600:4]
	6: unique[b700:4] = INT_OR unique[b500:4], unique[b680:4]
	7: unique[b780:1] = INT_AND register[20a:1], const[1:1]
	8: unique[b800:4] = INT_ZEXT unique[b780:1]
	9: unique[b880:4] = INT_MULT const[400:4], unique[b800:4]
	10: unique[b900:4] = INT_OR unique[b700:4], unique[b880:4]
	11: unique[b980:1] = INT_AND register[209:1], const[1:1]
	12: unique[ba00:4] = INT_ZEXT unique[b980:1]
	13: unique[ba80:4] = INT_MULT const[200:4], unique[ba00:4]
	14: unique[bb00:4] = INT_OR unique[b900:4], unique[ba80:4]
	15: unique[bb80:1] = INT_AND register[208:1], const[1:1]
	16: unique[bc00:4] = INT_ZEXT unique[bb80:1]
	17: unique[bc80:4] = INT_MULT const[100:4], unique[bc00:4]
	18: unique[bd00:4] = INT_OR unique[bb00:4], unique[bc80:4]
	19: unique[bd80:1] = INT_AND register[207:1], const[1:1]
	20: unique[be00:4] = INT_ZEXT unique[bd80:1]
	21: unique[be80:4] = INT_MULT const[80:4], unique[be00:4]
	22: unique[bf00:4] = INT_OR unique[bd00:4], unique[be80:4]
	23: unique[bf80:1] = INT_AND register[206:1], const[1:1]
	24: unique[c000:4] = INT_ZEXT unique[bf80:1]
	25: unique[c080:4] = INT_MULT const[40:4], unique[c000:4]
	26: unique[c100:4] = INT_OR unique[bf00:4], unique[c080:4]
	27: unique[c180:1] = INT_AND register[204:1], const[1:1]
	28: unique[c200:4] = INT_ZEXT unique[c180:1]
	29: unique[c280:4] = INT_MULT const[10:4], unique[c200:4]
	30: unique[c300:4] = INT_OR unique[c100:4], unique[c280:4]
	31: unique[c380:1] = INT_AND register[202:1], const[1:1]
	32: unique[c400:4] = INT_ZEXT unique[c380:1]
	33: unique[c480:4] = INT_MULT const[4:4], unique[c400:4]
	34: unique[c500:4] = INT_OR unique[c300:4], unique[c480:4]
	35: unique[c580:1] = INT_AND register[200:1], const[1:1]
	36: unique[c600:4] = INT_ZEXT unique[c580:1]
	37: unique[c680:4] = INT_MULT const[1:4], unique[c600:4]
	38: register[280:4] = INT_OR unique[c500:4], unique[c680:4]
	39: unique[c780:1] = INT_AND register[214:1], const[1:1]
	40: unique[c800:4] = INT_ZEXT unique[c780:1]
	41: unique[c880:4] = INT_MULT const[200000:4], unique[c800:4]
	42: unique[c900:4] = INT_OR register[280:4], unique[c880:4]
	43: unique[c980:1] = INT_AND register[213:1], const[1:1]
	44: unique[ca00:4] = INT_ZEXT unique[c980:1]
	45: unique[ca80:4] = INT_MULT const[100000:4], unique[ca00:4]
	46: unique[cb00:4] = INT_OR unique[c900:4], unique[ca80:4]
	47: unique[cb80:1] = INT_AND register[212:1], const[1:1]
	48: unique[cc00:4] = INT_ZEXT unique[cb80:1]
	49: unique[cc80:4] = INT_MULT const[80000:4], unique[cc00:4]
	50: unique[cd00:4] = INT_OR unique[cb00:4], unique[cc80:4]
	51: unique[cd80:1] = INT_AND register[211:1], const[1:1]
	52: unique[ce00:4] = INT_ZEXT unique[cd80:1]
	53: unique[ce80:4] = INT_MULT const[40000:4], unique[ce00:4]
	54: register[280:4] = INT_OR unique[cd00:4], unique[ce80:4]
	55: unique[9600:4] = COPY register[280:4]
	56: register[10:2] = INT_SUB register[10:2], const[4:2]
	57: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	58: STORE const[ram:8], unique[9780:4], unique[9600:4]

Line ia.sinc:3397 :PUSHF          is vexMode=0 & addrsize=1 & opsize=0 & byte=0x9c            { packflags(flags); push42(flags); }
0: Constructor line ia.sinc:3397(id0.433) printpiece=[PUSHF]
Operands 
Pattern id=433 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:9C:XX:XX:XX)
Template
	0: unique[b400:1] = INT_AND register[20d:1], const[1:1]
	1: unique[b480:2] = INT_ZEXT unique[b400:1]
	2: unique[b500:2] = INT_MULT const[4000:2], unique[b480:2]
	3: unique[b580:1] = INT_AND register[20b:1], const[1:1]
	4: unique[b600:2] = INT_ZEXT unique[b580:1]
	5: unique[b680:2] = INT_MULT const[800:2], unique[b600:2]
	6: unique[b700:2] = INT_OR unique[b500:2], unique[b680:2]
	7: unique[b780:1] = INT_AND register[20a:1], const[1:1]
	8: unique[b800:2] = INT_ZEXT unique[b780:1]
	9: unique[b880:2] = INT_MULT const[400:2], unique[b800:2]
	10: unique[b900:2] = INT_OR unique[b700:2], unique[b880:2]
	11: unique[b980:1] = INT_AND register[209:1], const[1:1]
	12: unique[ba00:2] = INT_ZEXT unique[b980:1]
	13: unique[ba80:2] = INT_MULT const[200:2], unique[ba00:2]
	14: unique[bb00:2] = INT_OR unique[b900:2], unique[ba80:2]
	15: unique[bb80:1] = INT_AND register[208:1], const[1:1]
	16: unique[bc00:2] = INT_ZEXT unique[bb80:1]
	17: unique[bc80:2] = INT_MULT const[100:2], unique[bc00:2]
	18: unique[bd00:2] = INT_OR unique[bb00:2], unique[bc80:2]
	19: unique[bd80:1] = INT_AND register[207:1], const[1:1]
	20: unique[be00:2] = INT_ZEXT unique[bd80:1]
	21: unique[be80:2] = INT_MULT const[80:2], unique[be00:2]
	22: unique[bf00:2] = INT_OR unique[bd00:2], unique[be80:2]
	23: unique[bf80:1] = INT_AND register[206:1], const[1:1]
	24: unique[c000:2] = INT_ZEXT unique[bf80:1]
	25: unique[c080:2] = INT_MULT const[40:2], unique[c000:2]
	26: unique[c100:2] = INT_OR unique[bf00:2], unique[c080:2]
	27: unique[c180:1] = INT_AND register[204:1], const[1:1]
	28: unique[c200:2] = INT_ZEXT unique[c180:1]
	29: unique[c280:2] = INT_MULT const[10:2], unique[c200:2]
	30: unique[c300:2] = INT_OR unique[c100:2], unique[c280:2]
	31: unique[c380:1] = INT_AND register[202:1], const[1:1]
	32: unique[c400:2] = INT_ZEXT unique[c380:1]
	33: unique[c480:2] = INT_MULT const[4:2], unique[c400:2]
	34: unique[c500:2] = INT_OR unique[c300:2], unique[c480:2]
	35: unique[c580:1] = INT_AND register[200:1], const[1:1]
	36: unique[c600:2] = INT_ZEXT unique[c580:1]
	37: unique[c680:2] = INT_MULT const[1:2], unique[c600:2]
	38: register[280:2] = INT_OR unique[c500:2], unique[c680:2]
	39: register[10:4] = INT_SUB register[10:4], const[2:4]
	40: STORE const[ram:8], register[10:4], register[280:2]

Line ia.sinc:3399 :PUSHFD         is vexMode=0 & addrsize=1 & opsize=1 & byte=0x9c            { packflags(eflags); packeflags(eflags); push44(eflags); }
0: Constructor line ia.sinc:3399(id0.435) printpiece=[PUSHFD]
Operands 
Pattern id=435 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:9C:XX:XX:XX)
Template
	0: unique[b400:1] = INT_AND register[20d:1], const[1:1]
	1: unique[b480:4] = INT_ZEXT unique[b400:1]
	2: unique[b500:4] = INT_MULT const[4000:4], unique[b480:4]
	3: unique[b580:1] = INT_AND register[20b:1], const[1:1]
	4: unique[b600:4] = INT_ZEXT unique[b580:1]
	5: unique[b680:4] = INT_MULT const[800:4], unique[b600:4]
	6: unique[b700:4] = INT_OR unique[b500:4], unique[b680:4]
	7: unique[b780:1] = INT_AND register[20a:1], const[1:1]
	8: unique[b800:4] = INT_ZEXT unique[b780:1]
	9: unique[b880:4] = INT_MULT const[400:4], unique[b800:4]
	10: unique[b900:4] = INT_OR unique[b700:4], unique[b880:4]
	11: unique[b980:1] = INT_AND register[209:1], const[1:1]
	12: unique[ba00:4] = INT_ZEXT unique[b980:1]
	13: unique[ba80:4] = INT_MULT const[200:4], unique[ba00:4]
	14: unique[bb00:4] = INT_OR unique[b900:4], unique[ba80:4]
	15: unique[bb80:1] = INT_AND register[208:1], const[1:1]
	16: unique[bc00:4] = INT_ZEXT unique[bb80:1]
	17: unique[bc80:4] = INT_MULT const[100:4], unique[bc00:4]
	18: unique[bd00:4] = INT_OR unique[bb00:4], unique[bc80:4]
	19: unique[bd80:1] = INT_AND register[207:1], const[1:1]
	20: unique[be00:4] = INT_ZEXT unique[bd80:1]
	21: unique[be80:4] = INT_MULT const[80:4], unique[be00:4]
	22: unique[bf00:4] = INT_OR unique[bd00:4], unique[be80:4]
	23: unique[bf80:1] = INT_AND register[206:1], const[1:1]
	24: unique[c000:4] = INT_ZEXT unique[bf80:1]
	25: unique[c080:4] = INT_MULT const[40:4], unique[c000:4]
	26: unique[c100:4] = INT_OR unique[bf00:4], unique[c080:4]
	27: unique[c180:1] = INT_AND register[204:1], const[1:1]
	28: unique[c200:4] = INT_ZEXT unique[c180:1]
	29: unique[c280:4] = INT_MULT const[10:4], unique[c200:4]
	30: unique[c300:4] = INT_OR unique[c100:4], unique[c280:4]
	31: unique[c380:1] = INT_AND register[202:1], const[1:1]
	32: unique[c400:4] = INT_ZEXT unique[c380:1]
	33: unique[c480:4] = INT_MULT const[4:4], unique[c400:4]
	34: unique[c500:4] = INT_OR unique[c300:4], unique[c480:4]
	35: unique[c580:1] = INT_AND register[200:1], const[1:1]
	36: unique[c600:4] = INT_ZEXT unique[c580:1]
	37: unique[c680:4] = INT_MULT const[1:4], unique[c600:4]
	38: register[280:4] = INT_OR unique[c500:4], unique[c680:4]
	39: unique[c780:1] = INT_AND register[214:1], const[1:1]
	40: unique[c800:4] = INT_ZEXT unique[c780:1]
	41: unique[c880:4] = INT_MULT const[200000:4], unique[c800:4]
	42: unique[c900:4] = INT_OR register[280:4], unique[c880:4]
	43: unique[c980:1] = INT_AND register[213:1], const[1:1]
	44: unique[ca00:4] = INT_ZEXT unique[c980:1]
	45: unique[ca80:4] = INT_MULT const[100000:4], unique[ca00:4]
	46: unique[cb00:4] = INT_OR unique[c900:4], unique[ca80:4]
	47: unique[cb80:1] = INT_AND register[212:1], const[1:1]
	48: unique[cc00:4] = INT_ZEXT unique[cb80:1]
	49: unique[cc80:4] = INT_MULT const[80000:4], unique[cc00:4]
	50: unique[cd00:4] = INT_OR unique[cb00:4], unique[cc80:4]
	51: unique[cd80:1] = INT_AND register[211:1], const[1:1]
	52: unique[ce00:4] = INT_ZEXT unique[cd80:1]
	53: unique[ce80:4] = INT_MULT const[40000:4], unique[ce00:4]
	54: register[280:4] = INT_OR unique[cd00:4], unique[ce80:4]
	55: register[10:4] = INT_SUB register[10:4], const[4:4]
	56: STORE const[ram:8], register[10:4], register[280:4]

Line ia.sinc:3309 :POPF           is vexMode=0 & addrsize=0 & opsize=0 & byte=0x9d            { pop22(flags); unpackflags(flags); }
0: Constructor line ia.sinc:3309(id0.387) printpiece=[POPF]
Operands 
Pattern id=387 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:9D:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[280:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]
	3: unique[a800:2] = INT_AND register[280:2], const[4000:2]
	4: register[20d:1] = INT_NOTEQUAL unique[a800:2], const[0:2]
	5: unique[a900:2] = INT_AND register[280:2], const[800:2]
	6: register[20b:1] = INT_NOTEQUAL unique[a900:2], const[0:2]
	7: unique[aa00:2] = INT_AND register[280:2], const[400:2]
	8: register[20a:1] = INT_NOTEQUAL unique[aa00:2], const[0:2]
	9: unique[ab00:2] = INT_AND register[280:2], const[200:2]
	10: register[209:1] = INT_NOTEQUAL unique[ab00:2], const[0:2]
	11: unique[ac00:2] = INT_AND register[280:2], const[100:2]
	12: register[208:1] = INT_NOTEQUAL unique[ac00:2], const[0:2]
	13: unique[ad00:2] = INT_AND register[280:2], const[80:2]
	14: register[207:1] = INT_NOTEQUAL unique[ad00:2], const[0:2]
	15: unique[ae00:2] = INT_AND register[280:2], const[40:2]
	16: register[206:1] = INT_NOTEQUAL unique[ae00:2], const[0:2]
	17: unique[af00:2] = INT_AND register[280:2], const[10:2]
	18: register[204:1] = INT_NOTEQUAL unique[af00:2], const[0:2]
	19: unique[b000:2] = INT_AND register[280:2], const[4:2]
	20: register[202:1] = INT_NOTEQUAL unique[b000:2], const[0:2]
	21: unique[b100:2] = INT_AND register[280:2], const[1:2]
	22: register[200:1] = INT_NOTEQUAL unique[b100:2], const[0:2]

Line ia.sinc:3311 :POPFD          is vexMode=0 & addrsize=0 & opsize=1 & byte=0x9d            { pop24(eflags); unpackflags(eflags); unpackeflags(eflags); }
0: Constructor line ia.sinc:3311(id0.389) printpiece=[POPFD]
Operands 
Pattern id=389 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:9D:XX:XX:XX)
Template
	0: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[280:4] = LOAD const[ram:8], unique[a080:4]
	2: register[10:2] = INT_ADD register[10:2], const[4:2]
	3: unique[a800:4] = INT_AND register[280:4], const[4000:4]
	4: register[20d:1] = INT_NOTEQUAL unique[a800:4], const[0:4]
	5: unique[a900:4] = INT_AND register[280:4], const[800:4]
	6: register[20b:1] = INT_NOTEQUAL unique[a900:4], const[0:4]
	7: unique[aa00:4] = INT_AND register[280:4], const[400:4]
	8: register[20a:1] = INT_NOTEQUAL unique[aa00:4], const[0:4]
	9: unique[ab00:4] = INT_AND register[280:4], const[200:4]
	10: register[209:1] = INT_NOTEQUAL unique[ab00:4], const[0:4]
	11: unique[ac00:4] = INT_AND register[280:4], const[100:4]
	12: register[208:1] = INT_NOTEQUAL unique[ac00:4], const[0:4]
	13: unique[ad00:4] = INT_AND register[280:4], const[80:4]
	14: register[207:1] = INT_NOTEQUAL unique[ad00:4], const[0:4]
	15: unique[ae00:4] = INT_AND register[280:4], const[40:4]
	16: register[206:1] = INT_NOTEQUAL unique[ae00:4], const[0:4]
	17: unique[af00:4] = INT_AND register[280:4], const[10:4]
	18: register[204:1] = INT_NOTEQUAL unique[af00:4], const[0:4]
	19: unique[b000:4] = INT_AND register[280:4], const[4:4]
	20: register[202:1] = INT_NOTEQUAL unique[b000:4], const[0:4]
	21: unique[b100:4] = INT_AND register[280:4], const[1:4]
	22: register[200:1] = INT_NOTEQUAL unique[b100:4], const[0:4]
	23: unique[b200:4] = INT_AND register[280:4], const[200000:4]
	24: register[214:1] = INT_NOTEQUAL unique[b200:4], const[0:4]
	25: unique[b300:4] = INT_AND register[280:4], const[40000:4]
	26: register[211:1] = INT_NOTEQUAL unique[b300:4], const[0:4]
	27: register[213:1] = COPY const[0:1]
	28: register[212:1] = COPY const[0:1]

Line ia.sinc:3310 :POPF           is vexMode=0 & addrsize=1 & opsize=0 & byte=0x9d            { pop42(flags); unpackflags(flags); }
0: Constructor line ia.sinc:3310(id0.388) printpiece=[POPF]
Operands 
Pattern id=388 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:9D:XX:XX:XX)
Template
	0: register[280:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[2:4]
	2: unique[a800:2] = INT_AND register[280:2], const[4000:2]
	3: register[20d:1] = INT_NOTEQUAL unique[a800:2], const[0:2]
	4: unique[a900:2] = INT_AND register[280:2], const[800:2]
	5: register[20b:1] = INT_NOTEQUAL unique[a900:2], const[0:2]
	6: unique[aa00:2] = INT_AND register[280:2], const[400:2]
	7: register[20a:1] = INT_NOTEQUAL unique[aa00:2], const[0:2]
	8: unique[ab00:2] = INT_AND register[280:2], const[200:2]
	9: register[209:1] = INT_NOTEQUAL unique[ab00:2], const[0:2]
	10: unique[ac00:2] = INT_AND register[280:2], const[100:2]
	11: register[208:1] = INT_NOTEQUAL unique[ac00:2], const[0:2]
	12: unique[ad00:2] = INT_AND register[280:2], const[80:2]
	13: register[207:1] = INT_NOTEQUAL unique[ad00:2], const[0:2]
	14: unique[ae00:2] = INT_AND register[280:2], const[40:2]
	15: register[206:1] = INT_NOTEQUAL unique[ae00:2], const[0:2]
	16: unique[af00:2] = INT_AND register[280:2], const[10:2]
	17: register[204:1] = INT_NOTEQUAL unique[af00:2], const[0:2]
	18: unique[b000:2] = INT_AND register[280:2], const[4:2]
	19: register[202:1] = INT_NOTEQUAL unique[b000:2], const[0:2]
	20: unique[b100:2] = INT_AND register[280:2], const[1:2]
	21: register[200:1] = INT_NOTEQUAL unique[b100:2], const[0:2]

Line ia.sinc:3312 :POPFD          is vexMode=0 & addrsize=1 & opsize=1 & byte=0x9d            { pop44(eflags); unpackflags(eflags); unpackeflags(eflags); }
0: Constructor line ia.sinc:3312(id0.390) printpiece=[POPFD]
Operands 
Pattern id=390 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:9D:XX:XX:XX)
Template
	0: register[280:4] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]
	2: unique[a800:4] = INT_AND register[280:4], const[4000:4]
	3: register[20d:1] = INT_NOTEQUAL unique[a800:4], const[0:4]
	4: unique[a900:4] = INT_AND register[280:4], const[800:4]
	5: register[20b:1] = INT_NOTEQUAL unique[a900:4], const[0:4]
	6: unique[aa00:4] = INT_AND register[280:4], const[400:4]
	7: register[20a:1] = INT_NOTEQUAL unique[aa00:4], const[0:4]
	8: unique[ab00:4] = INT_AND register[280:4], const[200:4]
	9: register[209:1] = INT_NOTEQUAL unique[ab00:4], const[0:4]
	10: unique[ac00:4] = INT_AND register[280:4], const[100:4]
	11: register[208:1] = INT_NOTEQUAL unique[ac00:4], const[0:4]
	12: unique[ad00:4] = INT_AND register[280:4], const[80:4]
	13: register[207:1] = INT_NOTEQUAL unique[ad00:4], const[0:4]
	14: unique[ae00:4] = INT_AND register[280:4], const[40:4]
	15: register[206:1] = INT_NOTEQUAL unique[ae00:4], const[0:4]
	16: unique[af00:4] = INT_AND register[280:4], const[10:4]
	17: register[204:1] = INT_NOTEQUAL unique[af00:4], const[0:4]
	18: unique[b000:4] = INT_AND register[280:4], const[4:4]
	19: register[202:1] = INT_NOTEQUAL unique[b000:4], const[0:4]
	20: unique[b100:4] = INT_AND register[280:4], const[1:4]
	21: register[200:1] = INT_NOTEQUAL unique[b100:4], const[0:4]
	22: unique[b200:4] = INT_AND register[280:4], const[200000:4]
	23: register[214:1] = INT_NOTEQUAL unique[b200:4], const[0:4]
	24: unique[b300:4] = INT_AND register[280:4], const[40000:4]
	25: register[211:1] = INT_NOTEQUAL unique[b300:4], const[0:4]
	26: register[213:1] = COPY const[0:1]
	27: register[212:1] = COPY const[0:1]

Line ia.sinc:3543 :SAHF           is vexMode=0 & byte=0x9e { SF = (AH & 0x80) != 0;
                                          ZF = (AH & 0x40) != 0;
                                          AF = (AH & 0x10) != 0;
                                          PF = (AH & 0x04) != 0;
                                          CF = (AH & 0x01) != 0; }
0: Constructor line ia.sinc:3543(id0.494) printpiece=[SAHF]
Operands 
Pattern id=494 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9E:XX:XX:XX)
Template
	0: unique[3c300:1] = INT_AND register[1:1], const[80:1]
	1: register[207:1] = INT_NOTEQUAL unique[3c300:1], const[0:1]
	2: unique[3c400:1] = INT_AND register[1:1], const[40:1]
	3: register[206:1] = INT_NOTEQUAL unique[3c400:1], const[0:1]
	4: unique[3c500:1] = INT_AND register[1:1], const[10:1]
	5: register[204:1] = INT_NOTEQUAL unique[3c500:1], const[0:1]
	6: unique[3c600:1] = INT_AND register[1:1], const[4:1]
	7: register[202:1] = INT_NOTEQUAL unique[3c600:1], const[0:1]
	8: unique[3c700:1] = INT_AND register[1:1], const[1:1]
	9: register[200:1] = INT_NOTEQUAL unique[3c700:1], const[0:1]

Line ia.sinc:2875 :LAHF           is vexMode=0 & byte=0x9f { AH=(SF<<7)|(ZF<<6)|(AF<<4)|(PF<<2)|2|CF; }
0: Constructor line ia.sinc:2875(id0.237) printpiece=[LAHF]
Operands 
Pattern id=237 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:9F:XX:XX:XX)
Template
	0: unique[2af00:1] = INT_LEFT register[207:1], const[7:4]
	1: unique[2af80:1] = INT_LEFT register[206:1], const[6:4]
	2: unique[2b000:1] = INT_OR unique[2af00:1], unique[2af80:1]
	3: unique[2b080:1] = INT_LEFT register[204:1], const[4:4]
	4: unique[2b100:1] = INT_OR unique[2b000:1], unique[2b080:1]
	5: unique[2b180:1] = INT_LEFT register[202:1], const[2:4]
	6: unique[2b200:1] = INT_OR unique[2b100:1], unique[2b180:1]
	7: unique[2b280:1] = INT_OR unique[2b200:1], const[2:1]
	8: register[1:1] = INT_OR unique[2b280:1], register[200:1]

Line ia.sinc:3059 :MOV AL,moffs8      is vexMode=0 & byte=0xa0; AL & moffs8               { AL=moffs8; }
0: Constructor line ia.sinc:3059(id0.284) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: AL : 1883  1: moffs8 : 1884  
Pattern id=284 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:A0:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: register[0:1] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3060 :MOV AX,moffs16     is vexMode=0 & opsize=0 & byte=0xa1; AX & moffs16         { AX=moffs16; }
0: Constructor line ia.sinc:3060(id0.285) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: AX : 1885  1: moffs16 : 1886  
Pattern id=285 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:A1:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: register[0:2] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3061 :MOV EAX,moffs32    is vexMode=0 & opsize=1 & byte=0xa1; EAX & check_EAX_dest & moffs32            { EAX=moffs32; build check_EAX_dest; }
0: Constructor line ia.sinc:3061(id0.286) printpiece=[MOV,  ,  A, ,,  C]
Operands 0: EAX : 1887  1: check_EAX_dest : 1889  2: moffs32 : 1888  
Pattern id=286 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:A1:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: register[0:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: MULTIEQUAL const[1:4]

Line ia.sinc:3065 :MOV moffs8,AL      is vexMode=0 & byte=0xa2; AL & moffs8               { moffs8=AL; }
0: Constructor line ia.sinc:3065(id0.287) printpiece=[MOV,  ,  B, ,,  A]
Operands 0: AL : 1891  1: moffs8 : 1890  
Pattern id=287 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:A2:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[0:1]

Line ia.sinc:3066 :MOV moffs16,AX     is vexMode=0 & opsize=0 & byte=0xa3; AX & moffs16         { moffs16=AX; }
0: Constructor line ia.sinc:3066(id0.288) printpiece=[MOV,  ,  B, ,,  A]
Operands 0: AX : 1893  1: moffs16 : 1892  
Pattern id=288 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:A3:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[0:2]

Line ia.sinc:3067 :MOV moffs32,EAX    is vexMode=0 & opsize=1 & byte=0xa3; EAX & moffs32            { moffs32=EAX; }
0: Constructor line ia.sinc:3067(id0.289) printpiece=[MOV,  ,  B, ,,  A]
Operands 0: EAX : 1895  1: moffs32 : 1894  
Pattern id=289 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:A3:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[0:4]

Line ia.sinc:3158 :MOVSB^rep^reptail eseDI1,dseSI1    is vexMode=0 & rep & reptail & byte=0xa4 & eseDI1 & dseSI1          { build rep; build eseDI1; build dseSI1; eseDI1 = dseSI1; build reptail; }
0: Constructor line ia.sinc:3158(id0.309) printpiece=[MOVSB,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 1936  1: reptail : 1937  2: eseDI1 : 1938  3: dseSI1 : 1939  
Pattern id=309 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:A4:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[3:4]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]

Line ia.sinc:3159 :MOVSW^rep^reptail eseDI2,dseSI2    is vexMode=0 & rep & reptail & opsize=0 & byte=0xa5 & eseDI2 & dseSI2   { build rep; build eseDI2; build dseSI2; eseDI2 = dseSI2; build reptail; }
0: Constructor line ia.sinc:3159(id0.310) printpiece=[MOVSW,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 1940  1: reptail : 1941  2: eseDI2 : 1942  3: dseSI2 : 1943  
Pattern id=310 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:A5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[3:4]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]

Line ia.sinc:3160 :MOVSD^rep^reptail eseDI4,dseSI4    is vexMode=0 & rep & reptail & opsize=1 & byte=0xa5 & eseDI4 & dseSI4   { build rep; build eseDI4; build dseSI4; eseDI4 = dseSI4; build reptail; }
0: Constructor line ia.sinc:3160(id0.311) printpiece=[MOVSD,  A,  B,  ,  C, ,,  D]
Operands 0: rep : 1944  1: reptail : 1945  2: eseDI4 : 1946  3: dseSI4 : 1947  
Pattern id=311 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:A5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: MULTIEQUAL const[3:4]
	3: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]

Line ia.sinc:2228 :CMPSB^repe^repetail eseDI1,dseSI1  is vexMode=0 & repe & repetail & byte=0xa6 & dseSI1 & eseDI1        { build repe; build eseDI1; build dseSI1; subflags(dseSI1,eseDI1); local diff=dseSI1-eseDI1; resultflags(diff); build repetail; }
0: Constructor line ia.sinc:2228(id0.149) printpiece=[CMPSB,  A,  B,  ,  D, ,,  C]
Operands 0: repe : 1626  1: repetail : 1627  2: dseSI1 : 1629  3: eseDI1 : 1628  
Pattern id=149 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:A6:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[2:4]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[1f000:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: register[207:1] = INT_SLESS unique[1f000:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL unique[1f000:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND unique[1f000:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	12: MULTIEQUAL const[1:4]

Line ia.sinc:2229 :CMPSW^repe^repetail eseDI2,dseSI2  is vexMode=0 & repe & repetail & opsize=0 & byte=0xa7 & dseSI2 & eseDI2 { build repe; build eseDI2; build dseSI2; subflags(dseSI2,eseDI2); local diff=dseSI2-eseDI2; resultflags(diff); build repetail; }
0: Constructor line ia.sinc:2229(id0.150) printpiece=[CMPSW,  A,  B,  ,  D, ,,  C]
Operands 0: repe : 1630  1: repetail : 1631  2: dseSI2 : 1633  3: eseDI2 : 1632  
Pattern id=150 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:A7:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[2:4]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[1f100:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: register[207:1] = INT_SLESS unique[1f100:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL unique[1f100:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND unique[1f100:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	12: MULTIEQUAL const[1:4]

Line ia.sinc:2230 :CMPSD^repe^repetail eseDI4,dseSI4  is vexMode=0 & repe & repetail & opsize=1 & byte=0xa7 & dseSI4 & eseDI4 { build repe; build eseDI4; build dseSI4; subflags(dseSI4,eseDI4); local diff=dseSI4-eseDI4; resultflags(diff); build repetail; }
0: Constructor line ia.sinc:2230(id0.151) printpiece=[CMPSD,  A,  B,  ,  D, ,,  C]
Operands 0: repe : 1634  1: repetail : 1635  2: dseSI4 : 1637  3: eseDI4 : 1636  
Pattern id=151 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:A7:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[2:4]
	3: register[200:1] = INT_LESS [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[1f200:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: register[207:1] = INT_SLESS unique[1f200:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL unique[1f200:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND unique[1f200:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	12: MULTIEQUAL const[1:4]

Line ia.sinc:3834 :TEST   AL,imm8     is vexMode=0 & byte=0xA8; AL & imm8                 { logicalflags(); local tmp =   AL & imm8;  resultflags(tmp); }
0: Constructor line ia.sinc:3834(id0.588) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: AL : 2396  1: imm8 : 2397  
Pattern id=588 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:A8:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: unique[42500:1] = INT_AND register[0:1], [handle:space][[handle:offset]:1]
	3: register[207:1] = INT_SLESS unique[42500:1], const[0:1]
	4: register[206:1] = INT_EQUAL unique[42500:1], const[0:1]
	5: unique[dc80:1] = INT_AND unique[42500:1], const[ff:1]
	6: unique[dd00:1] = POPCOUNT unique[dc80:1]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3835 :TEST   AX,imm16    is vexMode=0 & opsize=0; byte=0xA9; AX & imm16          { logicalflags(); local tmp =   AX & imm16; resultflags(tmp); }
0: Constructor line ia.sinc:3835(id0.589) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: AX : 2398  1: imm16 : 2399  
Pattern id=589 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:A9:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: unique[42600:2] = INT_AND register[0:2], [handle:space][[handle:offset]:2]
	3: register[207:1] = INT_SLESS unique[42600:2], const[0:2]
	4: register[206:1] = INT_EQUAL unique[42600:2], const[0:2]
	5: unique[dc80:2] = INT_AND unique[42600:2], const[ff:2]
	6: unique[dd00:1] = POPCOUNT unique[dc80:2]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3836 :TEST   EAX,imm32   is vexMode=0 & opsize=1; byte=0xA9; EAX & imm32         { logicalflags(); local tmp =  EAX & imm32; resultflags(tmp); }
0: Constructor line ia.sinc:3836(id0.590) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: EAX : 2400  1: imm32 : 2401  
Pattern id=590 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:A9:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]
	1: register[20b:1] = COPY const[0:1]
	2: unique[42700:4] = INT_AND register[0:4], [handle:space][[handle:offset]:4]
	3: register[207:1] = INT_SLESS unique[42700:4], const[0:4]
	4: register[206:1] = INT_EQUAL unique[42700:4], const[0:4]
	5: unique[dc80:4] = INT_AND unique[42700:4], const[ff:4]
	6: unique[dd00:1] = POPCOUNT unique[dc80:4]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3774 :STOSB^rep^reptail eseDI1   is vexMode=0 & rep & reptail & byte=0xaa & eseDI1           { build rep; build eseDI1; eseDI1=AL; build reptail; }
0: Constructor line ia.sinc:3774(id0.564) printpiece=[STOSB,  A,  B,  ,  C]
Operands 0: rep : 2353  1: reptail : 2354  2: eseDI1 : 2355  
Pattern id=564 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:AA:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY register[0:1]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:3775 :STOSW^rep^reptail eseDI2   is vexMode=0 & rep & reptail & opsize=0 & byte=0xab & eseDI2    { build rep; build eseDI2; eseDI2=AX; build reptail; }
0: Constructor line ia.sinc:3775(id0.565) printpiece=[STOSW,  A,  B,  ,  C]
Operands 0: rep : 2356  1: reptail : 2357  2: eseDI2 : 2358  
Pattern id=565 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:AB:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY register[0:2]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:3776 :STOSD^rep^reptail eseDI4   is vexMode=0 & rep & reptail & opsize=1 & byte=0xab & eseDI4    { build rep; build eseDI4; eseDI4=EAX; build reptail; }
0: Constructor line ia.sinc:3776(id0.566) printpiece=[STOSD,  A,  B,  ,  C]
Operands 0: rep : 2359  1: reptail : 2360  2: eseDI4 : 2361  
Pattern id=566 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:AB:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY register[0:4]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:2991 :LODSB^rep^reptail dseSI1   is vexMode=0 & rep & reptail & byte=0xAC & dseSI1           { build rep; build dseSI1; AL=dseSI1; build reptail; }
0: Constructor line ia.sinc:2991(id0.264) printpiece=[LODSB,  A,  B,  ,  C]
Operands 0: rep : 1843  1: reptail : 1844  2: dseSI1 : 1845  
Pattern id=264 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:AC:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: register[0:1] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:2992 :LODSW^rep^reptail dseSI2   is vexMode=0 & rep & reptail & opsize=0 & byte=0xAD & dseSI2    { build rep; build dseSI2; AX=dseSI2; build reptail; }
0: Constructor line ia.sinc:2992(id0.265) printpiece=[LODSW,  A,  B,  ,  C]
Operands 0: rep : 1846  1: reptail : 1847  2: dseSI2 : 1848  
Pattern id=265 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:AD:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: register[0:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:2993 :LODSD^rep^reptail dseSI4   is vexMode=0 & rep & reptail & opsize=1 & byte=0xAD & dseSI4    { build rep; build dseSI4; EAX=dseSI4; build reptail; }
0: Constructor line ia.sinc:2993(id0.266) printpiece=[LODSD,  A,  B,  ,  C]
Operands 0: rep : 1849  1: reptail : 1850  2: dseSI4 : 1851  
Pattern id=266 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:AD:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: register[0:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]

Line ia.sinc:3607 :SCASB^repe^repetail eseDI1 is vexMode=0 & repe & repetail &            byte=0xae & eseDI1  { build repe; build eseDI1; subflags(AL,eseDI1); local diff=AL-eseDI1; resultflags(diff); build repetail; }
0: Constructor line ia.sinc:3607(id0.519) printpiece=[SCASB,  A,  B,  ,  C]
Operands 0: repe : 2261  1: repetail : 2262  2: eseDI1 : 2263  
Pattern id=519 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:AE:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: register[200:1] = INT_LESS register[0:1], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW register[0:1], [handle:space][[handle:offset]:[handle:size]]
	4: unique[3d900:1] = INT_SUB register[0:1], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[3d900:1], const[0:1]
	6: register[206:1] = INT_EQUAL unique[3d900:1], const[0:1]
	7: unique[dc80:1] = INT_AND unique[3d900:1], const[ff:1]
	8: unique[dd00:1] = POPCOUNT unique[dc80:1]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	11: MULTIEQUAL const[1:4]

Line avx.sinc:1003 :VLDMXCSR m32 is $(VEX_NONE) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0xAE; reg_opcode=2 ... & m32
{
	vldmxcsr_avx( m32 );
	# TODO missing destination or side effects
}
0: Constructor line avx.sinc:1003(id0.1632) printpiece=[VLDMXCSR,  ,  B]
Operands 0: rexWprefix : 4828  1: m32 : 4827  
Pattern id=1632 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:AE:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: CALLOTHER const[12f:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2936 :VSTMXCSR m32 is $(VEX_NONE) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG); byte=0xAE; reg_opcode=3 ... & m32
{
	m32 = vstmxcsr_avx(  );
}
0: Constructor line avx.sinc:2936(id0.1856) printpiece=[VSTMXCSR,  ,  B]
Operands 0: rexWprefix : 5975  1: m32 : 5974  
Pattern id=1856 pattern=cmb:(ctx:SS:X[000x]:X8:0[001x]:XX,ins:AE:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1da:4]

Line ia.sinc:3608 :SCASW^repe^repetail eseDI2 is vexMode=0 & repe & repetail & opsize=0 & byte=0xaf & eseDI2  { build repe; build eseDI2; subflags(AX,eseDI2); local diff=AX-eseDI2; resultflags(diff); build repetail; }
0: Constructor line ia.sinc:3608(id0.520) printpiece=[SCASW,  A,  B,  ,  C]
Operands 0: repe : 2264  1: repetail : 2265  2: eseDI2 : 2266  
Pattern id=520 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:AF:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: register[200:1] = INT_LESS register[0:2], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW register[0:2], [handle:space][[handle:offset]:[handle:size]]
	4: unique[3da00:2] = INT_SUB register[0:2], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[3da00:2], const[0:2]
	6: register[206:1] = INT_EQUAL unique[3da00:2], const[0:2]
	7: unique[dc80:2] = INT_AND unique[3da00:2], const[ff:2]
	8: unique[dd00:1] = POPCOUNT unique[dc80:2]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	11: MULTIEQUAL const[1:4]

Line ia.sinc:3609 :SCASD^repe^repetail eseDI4 is vexMode=0 & repe & repetail & opsize=1 & byte=0xaf & eseDI4  { build repe; build eseDI4; subflags(EAX,eseDI4); local diff=EAX-eseDI4; resultflags(diff); build repetail; }
0: Constructor line ia.sinc:3609(id0.521) printpiece=[SCASD,  A,  B,  ,  C]
Operands 0: repe : 2267  1: repetail : 2268  2: eseDI4 : 2269  
Pattern id=521 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:AF:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: register[200:1] = INT_LESS register[0:4], [handle:space][[handle:offset]:[handle:size]]
	3: register[20b:1] = INT_SBORROW register[0:4], [handle:space][[handle:offset]:[handle:size]]
	4: unique[3db00:4] = INT_SUB register[0:4], [handle:space][[handle:offset]:[handle:size]]
	5: register[207:1] = INT_SLESS unique[3db00:4], const[0:4]
	6: register[206:1] = INT_EQUAL unique[3db00:4], const[0:4]
	7: unique[dc80:4] = INT_AND unique[3db00:4], const[ff:4]
	8: unique[dd00:1] = POPCOUNT unique[dc80:4]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	11: MULTIEQUAL const[1:4]

Line ia.sinc:3071 :MOV CRmr8,imm8     is vexMode=0 & row=11 & page=0 & CRmr8; imm8                        { CRmr8 = imm8; }
0: Constructor line ia.sinc:3071(id0.290) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: CRmr8 : 1896  1: imm8 : 1897  
Pattern id=290 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:B[0xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3072 :MOV CRmr16,imm16   is vexMode=0 & opsize=0 & row=11 & page=1 & CRmr16; imm16       { CRmr16 = imm16; }
0: Constructor line ia.sinc:3072(id0.291) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: CRmr16 : 1898  1: imm16 : 1899  
Pattern id=291 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:B[1xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3073 :MOV CRmr32,imm32   is vexMode=0 & opsize=1 & row=11 & page=1 & CRmr32; imm32       { CRmr32 = imm32; }
0: Constructor line ia.sinc:3073(id0.292) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: CRmr32 : 1900  1: imm32 : 1901  
Pattern id=292 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:B[1xxx]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3511 :ROL  rm8,imm8      is vexMode=0 & byte=0xC0; rm8 & reg_opcode=0 ... ; imm8     { local cnt = imm8 & 0x7; rm8 = (rm8 << cnt) | (rm8 >> (8 - cnt)); rolflags(rm8,imm8 & 0x1f:1);}
0: Constructor line ia.sinc:3511(id0.477) printpiece=[ROL,  ,  A, ,,  B]
Operands 0: rm8 : 2168  1: imm8 : 2169  
Pattern id=477 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C0:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[38880:4] = INT_AND [handle:space][[handle:offset]:4], const[7:4]
	2: unique[38900:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[38880:4]
	3: unique[38980:4] = INT_SUB const[8:4], unique[38880:4]
	4: unique[38a00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[38980:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[38900:[handle:size]], unique[38a00:[handle:size]]
	6: unique[38b00:1] = INT_AND [handle:space][[handle:offset]:1], const[1f:1]
	7: unique[ee00:1] = INT_NOTEQUAL unique[38b00:1], const[0:1]
	8: unique[ee80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	9: unique[ef80:1] = INT_NOTEQUAL unique[ee80:[handle:size]], const[0:[handle:size]]
	10: unique[f000:1] = BOOL_NEGATE unique[ee00:1]
	11: unique[f080:1] = INT_AND unique[f000:1], register[200:1]
	12: unique[f100:1] = INT_AND unique[ee00:1], unique[ef80:1]
	13: register[200:1] = INT_OR unique[f080:1], unique[f100:1]
	14: unique[f280:1] = INT_EQUAL unique[38b00:1], const[1:1]
	15: unique[f300:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	16: unique[f400:1] = INT_XOR register[200:1], unique[f300:1]
	17: unique[f480:1] = BOOL_NEGATE unique[f280:1]
	18: unique[f500:1] = INT_AND unique[f480:1], register[20b:1]
	19: unique[f580:1] = INT_AND unique[f280:1], unique[f400:1]
	20: register[20b:1] = INT_OR unique[f500:1], unique[f580:1]

Line ia.sinc:3526 :ROR  rm8,imm8      is vexMode=0 & byte=0xC0; rm8 & reg_opcode=1 ... ; imm8     { local cnt = imm8 & 0x7; rm8 = (rm8 >> cnt) | (rm8 << (8 - cnt)); rorflags(rm8,imm8 & 0x1f:1);}
0: Constructor line ia.sinc:3526(id0.486) printpiece=[ROR,  ,  A, ,,  B]
Operands 0: rm8 : 2189  1: imm8 : 2190  
Pattern id=486 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C0:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3a780:4] = INT_AND [handle:space][[handle:offset]:4], const[7:4]
	2: unique[3a800:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3a780:4]
	3: unique[3a880:4] = INT_SUB const[8:4], unique[3a780:4]
	4: unique[3a900:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3a880:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3a800:[handle:size]], unique[3a900:[handle:size]]
	6: unique[3aa00:1] = INT_AND [handle:space][[handle:offset]:1], const[1f:1]
	7: unique[f700:1] = INT_NOTEQUAL unique[3aa00:1], const[0:1]
	8: unique[f800:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	9: unique[f880:1] = BOOL_NEGATE unique[f700:1]
	10: unique[f900:1] = INT_AND unique[f880:1], register[200:1]
	11: unique[f980:1] = INT_AND unique[f700:1], unique[f800:1]
	12: register[200:1] = INT_OR unique[f900:1], unique[f980:1]
	13: unique[fb00:1] = INT_EQUAL unique[3aa00:1], const[1:1]
	14: unique[fb80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[fc00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	16: unique[fc80:1] = INT_SLESS unique[fc00:[handle:size]], const[0:[handle:size]]
	17: unique[fd80:1] = INT_XOR unique[fb80:1], unique[fc80:1]
	18: unique[fe00:1] = BOOL_NEGATE unique[fb00:1]
	19: unique[fe80:1] = INT_AND unique[fe00:1], register[20b:1]
	20: unique[ff00:1] = INT_AND unique[fb00:1], unique[fd80:1]
	21: register[20b:1] = INT_OR unique[fe80:1], unique[ff00:1]

Line ia.sinc:3407 :RCL  rm8,imm8      is vexMode=0 & byte=0xC0; rm8 & reg_opcode=2 ... ; imm8     { local cnt=(imm8&0x1f)%9; tmp:2=(zext(CF)<<8)|zext(rm8); tmp=(tmp<<cnt)|(tmp>>(9-cnt)); rm8=tmp(0); CF=(tmp&0x100)!=0; }
0: Constructor line ia.sinc:3407(id0.438) printpiece=[RCL,  ,  A, ,,  B]
Operands 0: rm8 : 2110  1: imm8 : 2111  
Pattern id=438 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C0:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[30880:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[30980:4] = INT_REM unique[30880:4], const[9:4]
	3: unique[30a00:2] = INT_ZEXT register[200:1]
	4: unique[30a80:2] = INT_LEFT unique[30a00:2], const[8:4]
	5: unique[30b00:2] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	6: unique[30c00:2] = INT_OR unique[30a80:2], unique[30b00:2]
	7: unique[30c80:2] = INT_LEFT unique[30c00:2], unique[30980:4]
	8: unique[30d00:4] = INT_SUB const[9:4], unique[30980:4]
	9: unique[30d80:2] = INT_RIGHT unique[30c00:2], unique[30d00:4]
	10: unique[30c00:2] = INT_OR unique[30c80:2], unique[30d80:2]
	11: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[30c00:2], const[0:4]
	12: unique[30f00:2] = INT_AND unique[30c00:2], const[100:2]
	13: register[200:1] = INT_NOTEQUAL unique[30f00:2], const[0:2]

Line ia.sinc:3422 :RCR rm8,imm8       is vexMode=0 & byte=0xC0; rm8 & reg_opcode=3 ... ; imm8     { local cnt=(imm8&0x1f)%9; tmp:2=(zext(CF)<<8)|zext(rm8); tmp=(tmp>>cnt)|(tmp<<(9-cnt)); rm8=tmp(0); CF=(tmp&0x100)!=0; }
0: Constructor line ia.sinc:3422(id0.447) printpiece=[RCR,  ,  A, ,,  B]
Operands 0: rm8 : 2131  1: imm8 : 2132  
Pattern id=447 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C0:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[34000:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[34100:4] = INT_REM unique[34000:4], const[9:4]
	3: unique[34180:2] = INT_ZEXT register[200:1]
	4: unique[34200:2] = INT_LEFT unique[34180:2], const[8:4]
	5: unique[34280:2] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	6: unique[34380:2] = INT_OR unique[34200:2], unique[34280:2]
	7: unique[34400:2] = INT_RIGHT unique[34380:2], unique[34100:4]
	8: unique[34480:4] = INT_SUB const[9:4], unique[34100:4]
	9: unique[34500:2] = INT_LEFT unique[34380:2], unique[34480:4]
	10: unique[34380:2] = INT_OR unique[34400:2], unique[34500:2]
	11: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[34380:2], const[0:4]
	12: unique[34680:2] = INT_AND unique[34380:2], const[100:2]
	13: register[200:1] = INT_NOTEQUAL unique[34680:2], const[0:2]

Line ia.sinc:3638 :SHL  rm8,imm8  is vexMode=0 & byte=0xC0;  rm8 & (reg_opcode=4|reg_opcode=6) ... ; imm8            { local count = imm8 & 0x1f; local tmp = rm8; rm8 = rm8 << count;
                                          shlflags(tmp, rm8,count); shiftresultflags(rm8,count); }
0: Constructor line ia.sinc:3638(id0.527) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm8 : 2278  1: imm8 : 2279  
Pattern id=527 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C0:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3e100:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3e180:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3e100:4]
	4: unique[10080:1] = INT_NOTEQUAL unique[3e100:4], const[0:4]
	5: unique[10100:4] = INT_SUB unique[3e100:4], const[1:4]
	6: unique[10180:[handle:size]] = INT_LEFT unique[3e180:[handle:size]], unique[10100:4]
	7: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	8: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	9: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	10: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	11: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	12: unique[10580:1] = INT_EQUAL unique[3e100:4], const[1:4]
	13: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	15: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	16: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	17: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	18: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[3e100:4], const[0:4]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3703 :SHR  rm8,imm8  is vexMode=0 & byte=0xC0;  rm8 & reg_opcode=5 ... ; imm8            { local count = imm8 & 0x1f; local tmp = rm8; rm8 = rm8 >> count;
                                          shrflags(tmp, rm8,count); shiftresultflags(rm8,count); }
0: Constructor line ia.sinc:3703(id0.544) printpiece=[SHR,  ,  A, ,,  B]
Operands 0: rm8 : 2327  1: imm8 : 2328  
Pattern id=544 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C0:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[40e00:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[40e80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[40e00:4]
	4: unique[11180:1] = INT_NOTEQUAL unique[40e00:4], const[0:4]
	5: unique[11200:4] = INT_SUB unique[40e00:4], const[1:4]
	6: unique[11280:[handle:size]] = INT_RIGHT unique[40e80:[handle:size]], unique[11200:4]
	7: unique[11300:[handle:size]] = INT_AND unique[11280:[handle:size]], const[1:[handle:size]]
	8: unique[11400:1] = INT_NOTEQUAL unique[11300:[handle:size]], const[0:[handle:size]]
	9: unique[11480:1] = BOOL_NEGATE unique[11180:1]
	10: unique[11500:1] = INT_AND unique[11480:1], register[200:1]
	11: unique[11580:1] = INT_AND unique[11180:1], unique[11400:1]
	12: register[200:1] = INT_OR unique[11500:1], unique[11580:1]
	13: unique[11700:1] = INT_EQUAL unique[40e00:4], const[1:4]
	14: unique[11800:1] = INT_SLESS unique[40e80:[handle:size]], const[0:[handle:size]]
	15: unique[11880:1] = BOOL_NEGATE unique[11700:1]
	16: unique[11900:1] = INT_AND unique[11880:1], register[20b:1]
	17: unique[11980:1] = INT_AND unique[11700:1], unique[11800:1]
	18: register[20b:1] = INT_OR unique[11900:1], unique[11980:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[40e00:4], const[0:4]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3638 :SHL  rm8,imm8  is vexMode=0 & byte=0xC0;  rm8 & (reg_opcode=4|reg_opcode=6) ... ; imm8            { local count = imm8 & 0x1f; local tmp = rm8; rm8 = rm8 << count;
                                          shlflags(tmp, rm8,count); shiftresultflags(rm8,count); }
0: Constructor line ia.sinc:3638(id0.527) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm8 : 2278  1: imm8 : 2279  
Pattern id=527 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C0:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3e100:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3e180:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3e100:4]
	4: unique[10080:1] = INT_NOTEQUAL unique[3e100:4], const[0:4]
	5: unique[10100:4] = INT_SUB unique[3e100:4], const[1:4]
	6: unique[10180:[handle:size]] = INT_LEFT unique[3e180:[handle:size]], unique[10100:4]
	7: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	8: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	9: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	10: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	11: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	12: unique[10580:1] = INT_EQUAL unique[3e100:4], const[1:4]
	13: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	15: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	16: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	17: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	18: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[3e100:4], const[0:4]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3554 :SAR  rm8,imm8  is vexMode=0 & byte=0xC0;  rm8 & reg_opcode=7 ... ; imm8            { local count = imm8 & 0x1f; local tmp = rm8; rm8 = rm8 s>> count;
                                          sarflags(tmp, rm8,count); shiftresultflags(rm8,count); }
0: Constructor line ia.sinc:3554(id0.498) printpiece=[SAR,  ,  A, ,,  B]
Operands 0: rm8 : 2211  1: imm8 : 2212  
Pattern id=498 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C0:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3cc00:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3cc80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], unique[3cc00:4]
	4: unique[10a00:1] = INT_NOTEQUAL unique[3cc00:4], const[0:4]
	5: unique[10a80:4] = INT_SUB unique[3cc00:4], const[1:4]
	6: unique[10b00:[handle:size]] = INT_SRIGHT unique[3cc80:[handle:size]], unique[10a80:4]
	7: unique[10b80:[handle:size]] = INT_AND unique[10b00:[handle:size]], const[1:[handle:size]]
	8: unique[10c80:1] = INT_NOTEQUAL unique[10b80:[handle:size]], const[0:[handle:size]]
	9: unique[10d00:1] = BOOL_NEGATE unique[10a00:1]
	10: unique[10d80:1] = INT_AND unique[10d00:1], register[200:1]
	11: unique[10e00:1] = INT_AND unique[10a00:1], unique[10c80:1]
	12: register[200:1] = INT_OR unique[10d80:1], unique[10e00:1]
	13: unique[10f80:1] = INT_EQUAL unique[3cc00:4], const[1:4]
	14: unique[11000:1] = BOOL_NEGATE unique[10f80:1]
	15: register[20b:1] = INT_AND unique[11000:1], register[20b:1]
	16: unique[df00:1] = INT_NOTEQUAL unique[3cc00:4], const[0:4]
	17: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	18: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	19: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	20: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	21: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	22: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	23: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	24: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	25: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	26: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	27: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	28: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	29: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	30: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	31: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	32: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	33: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	34: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3514 :ROL rm16,imm8      is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=0 ... ; imm8 { local cnt = imm8 & 0xf; rm16 = (rm16 << cnt) | (rm16 >> (16 - cnt)); rolflags(rm16,imm8 & 0x1f:1);}
0: Constructor line ia.sinc:3514(id0.480) printpiece=[ROL,  ,  A, ,,  B]
Operands 0: rm16 : 2174  1: imm8 : 2175  
Pattern id=480 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C1:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[39300:4] = INT_AND [handle:space][[handle:offset]:4], const[f:4]
	2: unique[39380:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[39300:4]
	3: unique[39400:4] = INT_SUB const[10:4], unique[39300:4]
	4: unique[39480:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[39400:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[39380:[handle:size]], unique[39480:[handle:size]]
	6: unique[39580:1] = INT_AND [handle:space][[handle:offset]:1], const[1f:1]
	7: unique[ee00:1] = INT_NOTEQUAL unique[39580:1], const[0:1]
	8: unique[ee80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	9: unique[ef80:1] = INT_NOTEQUAL unique[ee80:[handle:size]], const[0:[handle:size]]
	10: unique[f000:1] = BOOL_NEGATE unique[ee00:1]
	11: unique[f080:1] = INT_AND unique[f000:1], register[200:1]
	12: unique[f100:1] = INT_AND unique[ee00:1], unique[ef80:1]
	13: register[200:1] = INT_OR unique[f080:1], unique[f100:1]
	14: unique[f280:1] = INT_EQUAL unique[39580:1], const[1:1]
	15: unique[f300:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	16: unique[f400:1] = INT_XOR register[200:1], unique[f300:1]
	17: unique[f480:1] = BOOL_NEGATE unique[f280:1]
	18: unique[f500:1] = INT_AND unique[f480:1], register[20b:1]
	19: unique[f580:1] = INT_AND unique[f280:1], unique[f400:1]
	20: register[20b:1] = INT_OR unique[f500:1], unique[f580:1]

Line ia.sinc:3517 :ROL rm32,imm8      is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=0 ... ; imm8 { local cnt = imm8 & 0x1f; rm32 = (rm32 << cnt) | (rm32 >> (32 - cnt)); rolflags(rm32,cnt); build check_rm32_dest; }
0: Constructor line ia.sinc:3517(id0.483) printpiece=[ROL,  ,  A, ,,  C]
Operands 0: rm32 : 2182  1: check_rm32_dest : 2184  2: imm8 : 2183  
Pattern id=483 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C1:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[39c80:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[39d00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[39c80:4]
	3: unique[39d80:4] = INT_SUB const[20:4], unique[39c80:4]
	4: unique[39e00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[39d80:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[39d00:[handle:size]], unique[39e00:[handle:size]]
	6: unique[ee00:1] = INT_NOTEQUAL unique[39c80:4], const[0:4]
	7: unique[ee80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	8: unique[ef80:1] = INT_NOTEQUAL unique[ee80:[handle:size]], const[0:[handle:size]]
	9: unique[f000:1] = BOOL_NEGATE unique[ee00:1]
	10: unique[f080:1] = INT_AND unique[f000:1], register[200:1]
	11: unique[f100:1] = INT_AND unique[ee00:1], unique[ef80:1]
	12: register[200:1] = INT_OR unique[f080:1], unique[f100:1]
	13: unique[f280:1] = INT_EQUAL unique[39c80:4], const[1:4]
	14: unique[f300:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[f400:1] = INT_XOR register[200:1], unique[f300:1]
	16: unique[f480:1] = BOOL_NEGATE unique[f280:1]
	17: unique[f500:1] = INT_AND unique[f480:1], register[20b:1]
	18: unique[f580:1] = INT_AND unique[f280:1], unique[f400:1]
	19: register[20b:1] = INT_OR unique[f500:1], unique[f580:1]
	20: MULTIEQUAL const[1:4]

Line ia.sinc:3529 :ROR rm16,imm8      is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=1 ... ; imm8 { local cnt = imm8 & 0xf; rm16 = (rm16 >> cnt) | (rm16 << (16 - cnt)); rorflags(rm16,imm8 & 0x1f:1);}
0: Constructor line ia.sinc:3529(id0.489) printpiece=[ROR,  ,  A, ,,  B]
Operands 0: rm16 : 2195  1: imm8 : 2196  
Pattern id=489 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C1:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3b400:4] = INT_AND [handle:space][[handle:offset]:4], const[f:4]
	2: unique[3b480:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3b400:4]
	3: unique[3b500:4] = INT_SUB const[10:4], unique[3b400:4]
	4: unique[3b580:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3b500:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3b480:[handle:size]], unique[3b580:[handle:size]]
	6: unique[3b680:1] = INT_AND [handle:space][[handle:offset]:1], const[1f:1]
	7: unique[f700:1] = INT_NOTEQUAL unique[3b680:1], const[0:1]
	8: unique[f800:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	9: unique[f880:1] = BOOL_NEGATE unique[f700:1]
	10: unique[f900:1] = INT_AND unique[f880:1], register[200:1]
	11: unique[f980:1] = INT_AND unique[f700:1], unique[f800:1]
	12: register[200:1] = INT_OR unique[f900:1], unique[f980:1]
	13: unique[fb00:1] = INT_EQUAL unique[3b680:1], const[1:1]
	14: unique[fb80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[fc00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	16: unique[fc80:1] = INT_SLESS unique[fc00:[handle:size]], const[0:[handle:size]]
	17: unique[fd80:1] = INT_XOR unique[fb80:1], unique[fc80:1]
	18: unique[fe00:1] = BOOL_NEGATE unique[fb00:1]
	19: unique[fe80:1] = INT_AND unique[fe00:1], register[20b:1]
	20: unique[ff00:1] = INT_AND unique[fb00:1], unique[fd80:1]
	21: register[20b:1] = INT_OR unique[fe80:1], unique[ff00:1]

Line ia.sinc:3532 :ROR rm32,imm8      is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=1 ... ; imm8 { local cnt = imm8 & 0x1f; rm32 = (rm32 >> cnt) | (rm32 << (32 - cnt)); rorflags(rm32,cnt); build check_rm32_dest; }
0: Constructor line ia.sinc:3532(id0.492) printpiece=[ROR,  ,  A, ,,  C]
Operands 0: rm32 : 2203  1: check_rm32_dest : 2205  2: imm8 : 2204  
Pattern id=492 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C1:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3bf80:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3c000:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3bf80:4]
	3: unique[3c080:4] = INT_SUB const[20:4], unique[3bf80:4]
	4: unique[3c100:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3c080:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3c000:[handle:size]], unique[3c100:[handle:size]]
	6: unique[f700:1] = INT_NOTEQUAL unique[3bf80:4], const[0:4]
	7: unique[f800:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[f880:1] = BOOL_NEGATE unique[f700:1]
	9: unique[f900:1] = INT_AND unique[f880:1], register[200:1]
	10: unique[f980:1] = INT_AND unique[f700:1], unique[f800:1]
	11: register[200:1] = INT_OR unique[f900:1], unique[f980:1]
	12: unique[fb00:1] = INT_EQUAL unique[3bf80:4], const[1:4]
	13: unique[fb80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[fc00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	15: unique[fc80:1] = INT_SLESS unique[fc00:[handle:size]], const[0:[handle:size]]
	16: unique[fd80:1] = INT_XOR unique[fb80:1], unique[fc80:1]
	17: unique[fe00:1] = BOOL_NEGATE unique[fb00:1]
	18: unique[fe80:1] = INT_AND unique[fe00:1], register[20b:1]
	19: unique[ff00:1] = INT_AND unique[fb00:1], unique[fd80:1]
	20: register[20b:1] = INT_OR unique[fe80:1], unique[ff00:1]
	21: MULTIEQUAL const[1:4]

Line ia.sinc:3410 :RCL rm16,imm8      is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=2 ... ; imm8 { local cnt=(imm8&0x1f)%17; tmp:4=(zext(CF)<<16)|zext(rm16); tmp=(tmp<<cnt)|(tmp>>(17-cnt)); rm16=tmp(0); CF=(tmp&0x10000)!=0; }
0: Constructor line ia.sinc:3410(id0.441) printpiece=[RCL,  ,  A, ,,  B]
Operands 0: rm16 : 2116  1: imm8 : 2117  
Pattern id=441 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C1:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[31b00:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[31c00:4] = INT_REM unique[31b00:4], const[11:4]
	3: unique[31c80:4] = INT_ZEXT register[200:1]
	4: unique[31d00:4] = INT_LEFT unique[31c80:4], const[10:4]
	5: unique[31d80:4] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	6: unique[31e80:4] = INT_OR unique[31d00:4], unique[31d80:4]
	7: unique[31f00:4] = INT_LEFT unique[31e80:4], unique[31c00:4]
	8: unique[31f80:4] = INT_SUB const[11:4], unique[31c00:4]
	9: unique[32000:4] = INT_RIGHT unique[31e80:4], unique[31f80:4]
	10: unique[31e80:4] = INT_OR unique[31f00:4], unique[32000:4]
	11: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[31e80:4], const[0:4]
	12: unique[32180:4] = INT_AND unique[31e80:4], const[10000:4]
	13: register[200:1] = INT_NOTEQUAL unique[32180:4], const[0:4]

Line ia.sinc:3413 :RCL rm32,imm8      is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=2 ... ; imm8 { local cnt=imm8&0x1f; tmp:8=(zext(CF)<<32)|zext(rm32); tmp=(tmp<<cnt)|(tmp>>(33-cnt)); rm32=tmp(0); CF=(tmp&0x100000000)!=0; build check_rm32_dest; }
0: Constructor line ia.sinc:3413(id0.444) printpiece=[RCL,  ,  A, ,,  C]
Operands 0: rm32 : 2124  1: check_rm32_dest : 2126  2: imm8 : 2125  
Pattern id=444 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C1:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[32d80:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[32e00:8] = INT_ZEXT register[200:1]
	3: unique[32e80:8] = INT_LEFT unique[32e00:8], const[20:4]
	4: unique[32f00:8] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[33000:8] = INT_OR unique[32e80:8], unique[32f00:8]
	6: unique[33080:8] = INT_LEFT unique[33000:8], unique[32d80:4]
	7: unique[33100:4] = INT_SUB const[21:4], unique[32d80:4]
	8: unique[33180:8] = INT_RIGHT unique[33000:8], unique[33100:4]
	9: unique[33000:8] = INT_OR unique[33080:8], unique[33180:8]
	10: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[33000:8], const[0:4]
	11: unique[33300:8] = INT_AND unique[33000:8], const[100000000:8]
	12: register[200:1] = INT_NOTEQUAL unique[33300:8], const[0:8]
	13: MULTIEQUAL const[1:4]

Line ia.sinc:3425 :RCR rm16,imm8      is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=3 ... ; imm8 { local cnt=(imm8&0x1f)%17; tmp:4=(zext(CF)<<16)|zext(rm16); tmp=(tmp>>cnt)|(tmp<<(17-cnt)); rm16=tmp(0); CF=(tmp&0x10000)!=0; }
0: Constructor line ia.sinc:3425(id0.450) printpiece=[RCR,  ,  A, ,,  B]
Operands 0: rm16 : 2137  1: imm8 : 2138  
Pattern id=450 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C1:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[35400:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[35500:4] = INT_REM unique[35400:4], const[11:4]
	3: unique[35580:4] = INT_ZEXT register[200:1]
	4: unique[35600:4] = INT_LEFT unique[35580:4], const[10:4]
	5: unique[35680:4] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	6: unique[35780:4] = INT_OR unique[35600:4], unique[35680:4]
	7: unique[35800:4] = INT_RIGHT unique[35780:4], unique[35500:4]
	8: unique[35880:4] = INT_SUB const[11:4], unique[35500:4]
	9: unique[35900:4] = INT_LEFT unique[35780:4], unique[35880:4]
	10: unique[35780:4] = INT_OR unique[35800:4], unique[35900:4]
	11: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[35780:4], const[0:4]
	12: unique[35a80:4] = INT_AND unique[35780:4], const[10000:4]
	13: register[200:1] = INT_NOTEQUAL unique[35a80:4], const[0:4]

Line ia.sinc:3428 :RCR rm32,imm8      is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=3 ... ; imm8 { local cnt=imm8&0x1f; tmp:8=(zext(CF)<<32)|zext(rm32); tmp=(tmp>>cnt)|(tmp<<(33-cnt)); rm32=tmp(0); CF=(tmp&0x100000000)!=0; build check_rm32_dest; }
0: Constructor line ia.sinc:3428(id0.453) printpiece=[RCR,  ,  A, ,,  C]
Operands 0: rm32 : 2145  1: check_rm32_dest : 2147  2: imm8 : 2146  
Pattern id=453 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C1:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[36800:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[36880:8] = INT_ZEXT register[200:1]
	3: unique[36900:8] = INT_LEFT unique[36880:8], const[20:4]
	4: unique[36980:8] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[36a80:8] = INT_OR unique[36900:8], unique[36980:8]
	6: unique[36b00:8] = INT_RIGHT unique[36a80:8], unique[36800:4]
	7: unique[36b80:4] = INT_SUB const[21:4], unique[36800:4]
	8: unique[36c00:8] = INT_LEFT unique[36a80:8], unique[36b80:4]
	9: unique[36a80:8] = INT_OR unique[36b00:8], unique[36c00:8]
	10: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[36a80:8], const[0:4]
	11: unique[36d80:8] = INT_AND unique[36a80:8], const[100000000:8]
	12: register[200:1] = INT_NOTEQUAL unique[36d80:8], const[0:8]
	13: MULTIEQUAL const[1:4]

Line ia.sinc:3643 :SHL rm16,imm8  is vexMode=0 & opsize=0 & byte=0xC1; rm16 & (reg_opcode=4|reg_opcode=6) ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm16; rm16 = rm16 << count;
                                          shlflags(tmp, rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3643(id0.530) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm16 : 2284  1: imm8 : 2285  
Pattern id=530 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C1:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3e700:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3e780:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3e700:4]
	4: unique[10080:1] = INT_NOTEQUAL unique[3e700:4], const[0:4]
	5: unique[10100:4] = INT_SUB unique[3e700:4], const[1:4]
	6: unique[10180:[handle:size]] = INT_LEFT unique[3e780:[handle:size]], unique[10100:4]
	7: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	8: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	9: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	10: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	11: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	12: unique[10580:1] = INT_EQUAL unique[3e700:4], const[1:4]
	13: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	15: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	16: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	17: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	18: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[3e700:4], const[0:4]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3648 :SHL rm32,imm8  is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & (reg_opcode=4|reg_opcode=6) ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm32; rm32 = rm32 << count; build check_rm32_dest;
                                          shlflags(tmp, rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3648(id0.533) printpiece=[SHL,  ,  A, ,,  C]
Operands 0: rm32 : 2292  1: check_rm32_dest : 2294  2: imm8 : 2293  
Pattern id=533 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C1:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3ed00:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3ed80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3ed00:4]
	4: MULTIEQUAL const[1:4]
	5: unique[10080:1] = INT_NOTEQUAL unique[3ed00:4], const[0:4]
	6: unique[10100:4] = INT_SUB unique[3ed00:4], const[1:4]
	7: unique[10180:[handle:size]] = INT_LEFT unique[3ed80:[handle:size]], unique[10100:4]
	8: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	9: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	10: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	11: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	12: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	13: unique[10580:1] = INT_EQUAL unique[3ed00:4], const[1:4]
	14: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	16: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	17: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	18: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	19: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	20: unique[df00:1] = INT_NOTEQUAL unique[3ed00:4], const[0:4]
	21: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	22: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	23: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	24: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	25: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	26: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	27: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	28: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	29: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	30: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	31: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	32: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	33: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	34: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	35: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	36: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	37: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	38: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3708 :SHR rm16,imm8  is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=5 ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm16; rm16 = rm16 >> count;
                                          shrflags(tmp, rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3708(id0.547) printpiece=[SHR,  ,  A, ,,  B]
Operands 0: rm16 : 2333  1: imm8 : 2334  
Pattern id=547 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C1:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[41380:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[41400:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[41380:4]
	4: unique[11180:1] = INT_NOTEQUAL unique[41380:4], const[0:4]
	5: unique[11200:4] = INT_SUB unique[41380:4], const[1:4]
	6: unique[11280:[handle:size]] = INT_RIGHT unique[41400:[handle:size]], unique[11200:4]
	7: unique[11300:[handle:size]] = INT_AND unique[11280:[handle:size]], const[1:[handle:size]]
	8: unique[11400:1] = INT_NOTEQUAL unique[11300:[handle:size]], const[0:[handle:size]]
	9: unique[11480:1] = BOOL_NEGATE unique[11180:1]
	10: unique[11500:1] = INT_AND unique[11480:1], register[200:1]
	11: unique[11580:1] = INT_AND unique[11180:1], unique[11400:1]
	12: register[200:1] = INT_OR unique[11500:1], unique[11580:1]
	13: unique[11700:1] = INT_EQUAL unique[41380:4], const[1:4]
	14: unique[11800:1] = INT_SLESS unique[41400:[handle:size]], const[0:[handle:size]]
	15: unique[11880:1] = BOOL_NEGATE unique[11700:1]
	16: unique[11900:1] = INT_AND unique[11880:1], register[20b:1]
	17: unique[11980:1] = INT_AND unique[11700:1], unique[11800:1]
	18: register[20b:1] = INT_OR unique[11900:1], unique[11980:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[41380:4], const[0:4]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3713 :SHR rm32,imm8  is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=5 ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm32; rm32 = rm32 >> count; build check_rm32_dest;
                                          shrflags(tmp, rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3713(id0.550) printpiece=[SHR,  ,  A, ,,  C]
Operands 0: rm32 : 2341  1: check_rm32_dest : 2343  2: imm8 : 2342  
Pattern id=550 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C1:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[41900:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[41980:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[41900:4]
	4: MULTIEQUAL const[1:4]
	5: unique[11180:1] = INT_NOTEQUAL unique[41900:4], const[0:4]
	6: unique[11200:4] = INT_SUB unique[41900:4], const[1:4]
	7: unique[11280:[handle:size]] = INT_RIGHT unique[41980:[handle:size]], unique[11200:4]
	8: unique[11300:[handle:size]] = INT_AND unique[11280:[handle:size]], const[1:[handle:size]]
	9: unique[11400:1] = INT_NOTEQUAL unique[11300:[handle:size]], const[0:[handle:size]]
	10: unique[11480:1] = BOOL_NEGATE unique[11180:1]
	11: unique[11500:1] = INT_AND unique[11480:1], register[200:1]
	12: unique[11580:1] = INT_AND unique[11180:1], unique[11400:1]
	13: register[200:1] = INT_OR unique[11500:1], unique[11580:1]
	14: unique[11700:1] = INT_EQUAL unique[41900:4], const[1:4]
	15: unique[11800:1] = INT_SLESS unique[41980:[handle:size]], const[0:[handle:size]]
	16: unique[11880:1] = BOOL_NEGATE unique[11700:1]
	17: unique[11900:1] = INT_AND unique[11880:1], register[20b:1]
	18: unique[11980:1] = INT_AND unique[11700:1], unique[11800:1]
	19: register[20b:1] = INT_OR unique[11900:1], unique[11980:1]
	20: unique[df00:1] = INT_NOTEQUAL unique[41900:4], const[0:4]
	21: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	22: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	23: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	24: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	25: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	26: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	27: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	28: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	29: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	30: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	31: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	32: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	33: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	34: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	35: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	36: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	37: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	38: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3643 :SHL rm16,imm8  is vexMode=0 & opsize=0 & byte=0xC1; rm16 & (reg_opcode=4|reg_opcode=6) ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm16; rm16 = rm16 << count;
                                          shlflags(tmp, rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3643(id0.530) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm16 : 2284  1: imm8 : 2285  
Pattern id=530 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C1:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3e700:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3e780:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3e700:4]
	4: unique[10080:1] = INT_NOTEQUAL unique[3e700:4], const[0:4]
	5: unique[10100:4] = INT_SUB unique[3e700:4], const[1:4]
	6: unique[10180:[handle:size]] = INT_LEFT unique[3e780:[handle:size]], unique[10100:4]
	7: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	8: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	9: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	10: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	11: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	12: unique[10580:1] = INT_EQUAL unique[3e700:4], const[1:4]
	13: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	15: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	16: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	17: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	18: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[3e700:4], const[0:4]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3648 :SHL rm32,imm8  is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & (reg_opcode=4|reg_opcode=6) ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm32; rm32 = rm32 << count; build check_rm32_dest;
                                          shlflags(tmp, rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3648(id0.533) printpiece=[SHL,  ,  A, ,,  C]
Operands 0: rm32 : 2292  1: check_rm32_dest : 2294  2: imm8 : 2293  
Pattern id=533 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C1:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3ed00:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3ed80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3ed00:4]
	4: MULTIEQUAL const[1:4]
	5: unique[10080:1] = INT_NOTEQUAL unique[3ed00:4], const[0:4]
	6: unique[10100:4] = INT_SUB unique[3ed00:4], const[1:4]
	7: unique[10180:[handle:size]] = INT_LEFT unique[3ed80:[handle:size]], unique[10100:4]
	8: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	9: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	10: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	11: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	12: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	13: unique[10580:1] = INT_EQUAL unique[3ed00:4], const[1:4]
	14: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	16: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	17: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	18: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	19: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	20: unique[df00:1] = INT_NOTEQUAL unique[3ed00:4], const[0:4]
	21: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	22: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	23: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	24: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	25: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	26: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	27: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	28: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	29: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	30: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	31: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	32: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	33: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	34: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	35: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	36: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	37: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	38: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3559 :SAR rm16,imm8  is vexMode=0 & opsize=0 & byte=0xC1; rm16 & reg_opcode=7 ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm16; rm16 = rm16 s>> count;
                                          sarflags(tmp, rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3559(id0.501) printpiece=[SAR,  ,  A, ,,  B]
Operands 0: rm16 : 2217  1: imm8 : 2218  
Pattern id=501 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C1:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3d180:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3d200:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], unique[3d180:4]
	4: unique[10a00:1] = INT_NOTEQUAL unique[3d180:4], const[0:4]
	5: unique[10a80:4] = INT_SUB unique[3d180:4], const[1:4]
	6: unique[10b00:[handle:size]] = INT_SRIGHT unique[3d200:[handle:size]], unique[10a80:4]
	7: unique[10b80:[handle:size]] = INT_AND unique[10b00:[handle:size]], const[1:[handle:size]]
	8: unique[10c80:1] = INT_NOTEQUAL unique[10b80:[handle:size]], const[0:[handle:size]]
	9: unique[10d00:1] = BOOL_NEGATE unique[10a00:1]
	10: unique[10d80:1] = INT_AND unique[10d00:1], register[200:1]
	11: unique[10e00:1] = INT_AND unique[10a00:1], unique[10c80:1]
	12: register[200:1] = INT_OR unique[10d80:1], unique[10e00:1]
	13: unique[10f80:1] = INT_EQUAL unique[3d180:4], const[1:4]
	14: unique[11000:1] = BOOL_NEGATE unique[10f80:1]
	15: register[20b:1] = INT_AND unique[11000:1], register[20b:1]
	16: unique[df00:1] = INT_NOTEQUAL unique[3d180:4], const[0:4]
	17: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	18: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	19: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	20: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	21: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	22: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	23: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	24: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	25: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	26: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	27: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	28: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	29: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	30: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	31: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	32: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	33: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	34: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3564 :SAR rm32,imm8  is vexMode=0 & opsize=1 & byte=0xC1; rm32 & check_rm32_dest ... & reg_opcode=7 ... ; imm8     { local count = imm8 & 0x1f; local tmp = rm32; rm32 = rm32 s>> count; build check_rm32_dest;
                                          sarflags(tmp, rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3564(id0.504) printpiece=[SAR,  ,  A, ,,  C]
Operands 0: rm32 : 2225  1: check_rm32_dest : 2227  2: imm8 : 2226  
Pattern id=504 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C1:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3d700:4] = INT_AND [handle:space][[handle:offset]:4], const[1f:4]
	2: unique[3d780:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], unique[3d700:4]
	4: MULTIEQUAL const[1:4]
	5: unique[10a00:1] = INT_NOTEQUAL unique[3d700:4], const[0:4]
	6: unique[10a80:4] = INT_SUB unique[3d700:4], const[1:4]
	7: unique[10b00:[handle:size]] = INT_SRIGHT unique[3d780:[handle:size]], unique[10a80:4]
	8: unique[10b80:[handle:size]] = INT_AND unique[10b00:[handle:size]], const[1:[handle:size]]
	9: unique[10c80:1] = INT_NOTEQUAL unique[10b80:[handle:size]], const[0:[handle:size]]
	10: unique[10d00:1] = BOOL_NEGATE unique[10a00:1]
	11: unique[10d80:1] = INT_AND unique[10d00:1], register[200:1]
	12: unique[10e00:1] = INT_AND unique[10a00:1], unique[10c80:1]
	13: register[200:1] = INT_OR unique[10d80:1], unique[10e00:1]
	14: unique[10f80:1] = INT_EQUAL unique[3d700:4], const[1:4]
	15: unique[11000:1] = BOOL_NEGATE unique[10f80:1]
	16: register[20b:1] = INT_AND unique[11000:1], register[20b:1]
	17: unique[df00:1] = INT_NOTEQUAL unique[3d700:4], const[0:4]
	18: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	19: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	20: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	21: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	22: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	23: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	24: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	25: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	26: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	27: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	28: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	29: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	30: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	31: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	32: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	33: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	34: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	35: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3488 :RET imm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xc2; imm16     { pop22(IP); EIP=zext(IP); SP=SP+imm16; return [EIP]; }      
0: Constructor line ia.sinc:3488(id0.467) printpiece=[RET,  ,  A]
Operands 0: imm16 : 2156  
Pattern id=467 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:C2:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]
	3: register[284:4] = INT_ZEXT register[284:2]
	4: register[10:2] = INT_ADD register[10:2], [handle:space][[handle:offset]:2]
	5: RETURN register[284:4]

Line ia.sinc:3490 :RET imm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xc2; imm16     { pop24(EIP); SP=SP+imm16; return [EIP]; }
0: Constructor line ia.sinc:3490(id0.469) printpiece=[RET,  ,  A]
Operands 0: imm16 : 2158  
Pattern id=469 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:C2:XX:XX:XX)
Template
	0: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:4] = LOAD const[ram:8], unique[a080:4]
	2: register[10:2] = INT_ADD register[10:2], const[4:2]
	3: register[10:2] = INT_ADD register[10:2], [handle:space][[handle:offset]:2]
	4: RETURN register[284:4]

Line ia.sinc:3489 :RET imm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xc2; imm16     { pop42(IP); EIP=zext(IP); ESP=ESP+imm16; return [EIP]; }        
0: Constructor line ia.sinc:3489(id0.468) printpiece=[RET,  ,  A]
Operands 0: imm16 : 2157  
Pattern id=468 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:C2:XX:XX:XX)
Template
	0: register[284:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[2:4]
	2: register[284:4] = INT_ZEXT register[284:2]
	3: register[10:4] = INT_ADD register[10:4], [handle:space][[handle:offset]:4]
	4: RETURN register[284:4]

Line ia.sinc:3491 :RET imm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xc2; imm16     { pop44(EIP); ESP=ESP+imm16; return [EIP]; }
0: Constructor line ia.sinc:3491(id0.470) printpiece=[RET,  ,  A]
Operands 0: imm16 : 2159  
Pattern id=470 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:C2:XX:XX:XX)
Template
	0: register[284:4] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]
	2: register[10:4] = INT_ADD register[10:4], [handle:space][[handle:offset]:4]
	3: RETURN register[284:4]

Line avx.sinc:365 :^VCMPPS_mon XmmReg1, vexVVVV_XmmReg, XmmReg2_m128^VCMPPS_op is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; VCMPPS_mon & VCMPPS_op
{
	local tmp:16 = vcmpps_avx( vexVVVV_XmmReg, XmmReg2_m128, VCMPPS_op );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:365(id0.1577) printpiece=[ F,  ,  C, ,,  ,  B, ,,  ,  E,  G]
Operands 0: rexWprefix : 4559  1: vexVVVV_XmmReg : 4556  2: XmmReg1 : 4555  3: YmmReg1 : 4560  4: XmmReg2_m128 : 4557  5: VCMPPS_mon : 4554  6: VCMPPS_op : 4558  
Pattern id=1577 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:C2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[6:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[2:4]
	4: MULTIEQUAL const[5:4]
	5: unique[a1b80:10] = CALLOTHER const[10b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a1b80:10]

Line avx.sinc:373 :^VCMPPS_mon YmmReg1, vexVVVV_YmmReg, YmmReg2_m256^VCMPPS_op is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xC2; YmmReg1 ... & YmmReg2_m256; VCMPPS_mon & VCMPPS_op
{
	YmmReg1 = vcmpps_avx( vexVVVV_YmmReg, YmmReg2_m256, VCMPPS_op );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:373(id0.1578) printpiece=[ E,  ,  C, ,,  ,  B, ,,  ,  D,  F]
Operands 0: rexWprefix : 4566  1: vexVVVV_YmmReg : 4563  2: YmmReg1 : 4562  3: YmmReg2_m256 : 4564  4: VCMPPS_mon : 4561  5: VCMPPS_op : 4565  
Pattern id=1578 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:C2:XX:XX:XX)
Template
	0: MULTIEQUAL const[5:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[2:4]
	3: MULTIEQUAL const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[10b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:283 :^VCMPPD_mon XmmReg1, vexVVVV_XmmReg, XmmReg2_m128^VCMPPD_op is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; VCMPPD_mon & VCMPPD_op
{
	local tmp:16 = vcmppd_avx( vexVVVV_XmmReg, XmmReg2_m128, VCMPPD_op );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:283(id0.1575) printpiece=[ F,  ,  C, ,,  ,  B, ,,  ,  E,  G]
Operands 0: rexWprefix : 4541  1: vexVVVV_XmmReg : 4538  2: XmmReg1 : 4537  3: YmmReg1 : 4542  4: XmmReg2_m128 : 4539  5: VCMPPD_mon : 4536  6: VCMPPD_op : 4540  
Pattern id=1575 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:C2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[6:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[2:4]
	4: MULTIEQUAL const[5:4]
	5: unique[a1900:10] = CALLOTHER const[10a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a1900:10]

Line avx.sinc:291 :^VCMPPD_mon YmmReg1, vexVVVV_YmmReg, YmmReg2_m256^VCMPPD_op is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xC2; YmmReg1 ... & YmmReg2_m256; VCMPPD_mon & VCMPPD_op
{
	YmmReg1 = vcmppd_avx( vexVVVV_YmmReg, YmmReg2_m256, VCMPPD_op );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:291(id0.1576) printpiece=[ E,  ,  C, ,,  ,  B, ,,  ,  D,  F]
Operands 0: rexWprefix : 4548  1: vexVVVV_YmmReg : 4545  2: YmmReg1 : 4544  3: YmmReg2_m256 : 4546  4: VCMPPD_mon : 4543  5: VCMPPD_op : 4547  
Pattern id=1576 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:C2:XX:XX:XX)
Template
	0: MULTIEQUAL const[5:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[2:4]
	3: MULTIEQUAL const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[10a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:522 :^VCMPSS_mon XmmReg1, vexVVVV_XmmReg, XmmReg2_m32^VCMPSS_op is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC2; (XmmReg1 & YmmReg1) ... & XmmReg2_m32; VCMPSS_mon & VCMPSS_op
{
	local tmp:16 = vcmpss_avx( vexVVVV_XmmReg, XmmReg2_m32, VCMPSS_op );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:522(id0.1580) printpiece=[ F,  ,  C, ,,  ,  B, ,,  ,  E,  G]
Operands 0: rexWprefix : 4589  1: vexVVVV_XmmReg : 4586  2: XmmReg1 : 4585  3: YmmReg1 : 4590  4: XmmReg2_m32 : 4587  5: VCMPSS_mon : 4584  6: VCMPSS_op : 4588  
Pattern id=1580 pattern=cmb:(ctx:SS:X[010x]:X[10xx]:[xx00][001x]:XX,ins:C2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[6:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[2:4]
	4: MULTIEQUAL const[5:4]
	5: unique[a2000:10] = CALLOTHER const[10d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2000:10]

Line avx.sinc:447 :^VCMPSD_mon XmmReg1, vexVVVV_XmmReg, XmmReg2_m64^VCMPSD_op is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC2; (XmmReg1 & YmmReg1) ... & XmmReg2_m64; VCMPSD_mon & VCMPSD_op
{
	local tmp:16 = vcmpsd_avx( vexVVVV_XmmReg, XmmReg2_m64, VCMPSD_op );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:447(id0.1579) printpiece=[ F,  ,  C, ,,  ,  B, ,,  ,  E,  G]
Operands 0: rexWprefix : 4577  1: vexVVVV_XmmReg : 4574  2: XmmReg1 : 4573  3: YmmReg1 : 4578  4: XmmReg2_m64 : 4575  5: VCMPSD_mon : 4572  6: VCMPSD_op : 4576  
Pattern id=1579 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:C2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[6:4]
	2: MULTIEQUAL const[4:4]
	3: MULTIEQUAL const[2:4]
	4: MULTIEQUAL const[5:4]
	5: unique[a1e00:10] = CALLOTHER const[10c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a1e00:10]

Line ia.sinc:3467 :RET            is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xc3            { pop22(IP); EIP=segment(CS,IP); return [EIP]; }
0: Constructor line ia.sinc:3467(id0.459) printpiece=[RET]
Operands 
Pattern id=459 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:C3:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]
	3: register[284:4] = CALLOTHER const[0:4], register[102:2], register[284:2]
	4: RETURN register[284:4]

Line ia.sinc:3469 :RET            is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xc3            { pop24(EIP); return [EIP]; }
0: Constructor line ia.sinc:3469(id0.461) printpiece=[RET]
Operands 
Pattern id=461 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:C3:XX:XX:XX)
Template
	0: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:4] = LOAD const[ram:8], unique[a080:4]
	2: register[10:2] = INT_ADD register[10:2], const[4:2]
	3: RETURN register[284:4]

Line ia.sinc:3468 :RET            is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xc3            { pop42(IP); EIP=zext(IP); return [EIP]; }
0: Constructor line ia.sinc:3468(id0.460) printpiece=[RET]
Operands 
Pattern id=460 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:C3:XX:XX:XX)
Template
	0: register[284:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[2:4]
	2: register[284:4] = INT_ZEXT register[284:2]
	3: RETURN register[284:4]

Line ia.sinc:3470 :RET            is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xc3            { pop44(EIP); return [EIP]; }
0: Constructor line ia.sinc:3470(id0.462) printpiece=[RET]
Operands 
Pattern id=462 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:C3:XX:XX:XX)
Template
	0: register[284:4] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]
	2: RETURN register[284:4]

Line ia.sinc:1602 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; ] {}
0: Constructor line ia.sinc:1602(id0.10) printpiece=[ F]
Operands 0: vex_b : 1346  1: vex_mmmmm : 1347  2: vex_w : 1348  3: vex_vvvv : 1349  4: vex_l : 1350  5: instruction : 1345  
Pattern id=10 pattern=cmb:(ctx:X[xx00]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx00]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:2896 :LES Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC4; Mem & Reg16 ...        { tmp:4 = *Mem; ES = tmp(2); Reg16 = tmp(0); }
1: Constructor line ia.sinc:2896(id0.245) printpiece=[LES,  ,  B, ,,  A]
Operands 0: Mem : 1811  1: Reg16 : 1810  
Pattern id=245 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C4:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2bd00:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[100:2] = SUBPIECE unique[2bd00:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2bd00:4], const[0:4]

Line ia.sinc:1604 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_66=1; ] {}
0: Constructor line ia.sinc:1604(id0.11) printpiece=[ F]
Operands 0: vex_b : 1352  1: vex_mmmmm : 1353  2: vex_w : 1354  3: vex_vvvv : 1355  4: vex_l : 1356  5: instruction : 1351  
Pattern id=11 pattern=cmb:(ctx:X[xx00]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx01]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:2896 :LES Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC4; Mem & Reg16 ...        { tmp:4 = *Mem; ES = tmp(2); Reg16 = tmp(0); }
1: Constructor line ia.sinc:2896(id0.245) printpiece=[LES,  ,  B, ,,  A]
Operands 0: Mem : 1811  1: Reg16 : 1810  
Pattern id=245 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C4:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2bd00:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[100:2] = SUBPIECE unique[2bd00:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2bd00:4], const[0:4]

Line ia.sinc:1606 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f3=1; ] {}
0: Constructor line ia.sinc:1606(id0.12) printpiece=[ F]
Operands 0: vex_b : 1358  1: vex_mmmmm : 1359  2: vex_w : 1360  3: vex_vvvv : 1361  4: vex_l : 1362  5: instruction : 1357  
Pattern id=12 pattern=cmb:(ctx:X[xx00]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx10]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:2896 :LES Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC4; Mem & Reg16 ...        { tmp:4 = *Mem; ES = tmp(2); Reg16 = tmp(0); }
1: Constructor line ia.sinc:2896(id0.245) printpiece=[LES,  ,  B, ,,  A]
Operands 0: Mem : 1811  1: Reg16 : 1810  
Pattern id=245 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C4:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2bd00:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[100:2] = SUBPIECE unique[2bd00:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2bd00:4], const[0:4]

Line ia.sinc:1608 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f2=1; ] {}
0: Constructor line ia.sinc:1608(id0.13) printpiece=[ F]
Operands 0: vex_b : 1364  1: vex_mmmmm : 1365  2: vex_w : 1366  3: vex_vvvv : 1367  4: vex_l : 1368  5: instruction : 1363  
Pattern id=13 pattern=cmb:(ctx:X[xx00]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx11]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:2896 :LES Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC4; Mem & Reg16 ...        { tmp:4 = *Mem; ES = tmp(2); Reg16 = tmp(0); }
1: Constructor line ia.sinc:2896(id0.245) printpiece=[LES,  ,  B, ,,  A]
Operands 0: Mem : 1811  1: Reg16 : 1810  
Pattern id=245 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C4:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2bd00:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[100:2] = SUBPIECE unique[2bd00:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2bd00:4], const[0:4]

Line ia.sinc:1602 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; ] {}
0: Constructor line ia.sinc:1602(id0.10) printpiece=[ F]
Operands 0: vex_b : 1346  1: vex_mmmmm : 1347  2: vex_w : 1348  3: vex_vvvv : 1349  4: vex_l : 1350  5: instruction : 1345  
Pattern id=10 pattern=cmb:(ctx:X[xx01]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx00]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:2897 :LES Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC4 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; ES = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
1: Constructor line ia.sinc:2897(id0.246) printpiece=[LES,  ,  B, ,,  A]
Operands 0: Mem : 1813  1: Reg32 : 1812  2: check_Reg32_dest : 1814  
Pattern id=246 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:C4:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2bf00:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[100:2] = SUBPIECE unique[2bf00:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2bf00:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:1604 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_66=1; ] {}
0: Constructor line ia.sinc:1604(id0.11) printpiece=[ F]
Operands 0: vex_b : 1352  1: vex_mmmmm : 1353  2: vex_w : 1354  3: vex_vvvv : 1355  4: vex_l : 1356  5: instruction : 1351  
Pattern id=11 pattern=cmb:(ctx:X[xx01]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx01]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:2897 :LES Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC4 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; ES = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
1: Constructor line ia.sinc:2897(id0.246) printpiece=[LES,  ,  B, ,,  A]
Operands 0: Mem : 1813  1: Reg32 : 1812  2: check_Reg32_dest : 1814  
Pattern id=246 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:C4:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2bf00:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[100:2] = SUBPIECE unique[2bf00:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2bf00:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:1606 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f3=1; ] {}
0: Constructor line ia.sinc:1606(id0.12) printpiece=[ F]
Operands 0: vex_b : 1358  1: vex_mmmmm : 1359  2: vex_w : 1360  3: vex_vvvv : 1361  4: vex_l : 1362  5: instruction : 1357  
Pattern id=12 pattern=cmb:(ctx:X[xx01]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx10]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:2897 :LES Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC4 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; ES = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
1: Constructor line ia.sinc:2897(id0.246) printpiece=[LES,  ,  B, ,,  A]
Operands 0: Mem : 1813  1: Reg32 : 1812  2: check_Reg32_dest : 1814  
Pattern id=246 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:C4:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2bf00:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[100:2] = SUBPIECE unique[2bf00:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2bf00:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:1608 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f2=1; ] {}
0: Constructor line ia.sinc:1608(id0.13) printpiece=[ F]
Operands 0: vex_b : 1364  1: vex_mmmmm : 1365  2: vex_w : 1366  3: vex_vvvv : 1367  4: vex_l : 1368  5: instruction : 1363  
Pattern id=13 pattern=cmb:(ctx:X[xx01]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx11]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:2897 :LES Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC4 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; ES = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
1: Constructor line ia.sinc:2897(id0.246) printpiece=[LES,  ,  B, ,,  A]
Operands 0: Mem : 1813  1: Reg32 : 1812  2: check_Reg32_dest : 1814  
Pattern id=246 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:C4:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2bf00:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[100:2] = SUBPIECE unique[2bf00:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2bf00:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:1602 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; ] {}
0: Constructor line ia.sinc:1602(id0.10) printpiece=[ F]
Operands 0: vex_b : 1346  1: vex_mmmmm : 1347  2: vex_w : 1348  3: vex_vvvv : 1349  4: vex_l : 1350  5: instruction : 1345  
Pattern id=10 pattern=cmb:(ctx:X[xx10]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx00]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:1604 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_66=1; ] {}
0: Constructor line ia.sinc:1604(id0.11) printpiece=[ F]
Operands 0: vex_b : 1352  1: vex_mmmmm : 1353  2: vex_w : 1354  3: vex_vvvv : 1355  4: vex_l : 1356  5: instruction : 1351  
Pattern id=11 pattern=cmb:(ctx:X[xx10]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx01]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:1606 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f3=1; ] {}
0: Constructor line ia.sinc:1606(id0.12) printpiece=[ F]
Operands 0: vex_b : 1358  1: vex_mmmmm : 1359  2: vex_w : 1360  3: vex_vvvv : 1361  4: vex_l : 1362  5: instruction : 1357  
Pattern id=12 pattern=cmb:(ctx:X[xx10]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx10]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:1608 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f2=1; ] {}
0: Constructor line ia.sinc:1608(id0.13) printpiece=[ F]
Operands 0: vex_b : 1364  1: vex_mmmmm : 1365  2: vex_w : 1366  3: vex_vvvv : 1367  4: vex_l : 1368  5: instruction : 1363  
Pattern id=13 pattern=cmb:(ctx:X[xx10]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx11]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:1602 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; ] {}
0: Constructor line ia.sinc:1602(id0.10) printpiece=[ F]
Operands 0: vex_b : 1346  1: vex_mmmmm : 1347  2: vex_w : 1348  3: vex_vvvv : 1349  4: vex_l : 1350  5: instruction : 1345  
Pattern id=10 pattern=cmb:(ctx:X[xx11]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx00]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:1604 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_66=1; ] {}
0: Constructor line ia.sinc:1604(id0.11) printpiece=[ F]
Operands 0: vex_b : 1352  1: vex_mmmmm : 1353  2: vex_w : 1354  3: vex_vvvv : 1355  4: vex_l : 1356  5: instruction : 1351  
Pattern id=11 pattern=cmb:(ctx:X[xx11]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx01]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:1606 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f3=1; ] {}
0: Constructor line ia.sinc:1606(id0.12) printpiece=[ F]
Operands 0: vex_b : 1358  1: vex_mmmmm : 1359  2: vex_w : 1360  3: vex_vvvv : 1361  4: vex_l : 1362  5: instruction : 1357  
Pattern id=12 pattern=cmb:(ctx:X[xx11]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx10]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line ia.sinc:1608 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC4; vex_r=1 & vex_x=1 & vex_b & vex_mmmmm; vex_w & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; rexBprefix=~vex_b; vexMMMMM=vex_mmmmm; rexWprefix=vex_w;  vexVVVV=~vex_vvvv; vexL=vex_l; prefix_f2=1; ] {}
0: Constructor line ia.sinc:1608(id0.13) printpiece=[ F]
Operands 0: vex_b : 1364  1: vex_mmmmm : 1365  2: vex_w : 1366  3: vex_vvvv : 1367  4: vex_l : 1368  5: instruction : 1363  
Pattern id=13 pattern=cmb:(ctx:X[xx11]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C4:[11xx]X:X[xx11]:XX)
Template
	0: MULTIEQUAL const[5:4]

Line avx.sinc:2065 :VPINSRW XmmReg1, vexVVVV_XmmReg, Reg32_m16, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W0) & vexVVVV_XmmReg; byte=0xC4; (XmmReg1 & YmmReg1) ... & Reg32_m16; imm8
{
	local tmp:16 = vpinsrw_avx( vexVVVV_XmmReg, Reg32_m16, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2065(id0.1754) printpiece=[VPINSRW,  ,  B, ,,  ,  A, ,,  ,  D, ,,  ,  E]
Operands 0: vexVVVV_XmmReg : 5418  1: XmmReg1 : 5417  2: YmmReg1 : 5421  3: Reg32_m16 : 5419  4: imm8 : 5420  
Pattern id=1754 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][001x]:XX,ins:C4:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[adb00:10] = CALLOTHER const[185:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[adb00:10]

Line ia.sinc:1612 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; ] {}
0: Constructor line ia.sinc:1612(id0.14) printpiece=[ C]
Operands 0: vex_vvvv : 1370  1: vex_l : 1371  2: instruction : 1369  
Pattern id=14 pattern=cmb:(ctx:X[xx00]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx00]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:2886 :LDS Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC5; Mem & Reg16 ...        { tmp:4 = *Mem; DS = tmp(2); Reg16 = tmp(0); }
1: Constructor line ia.sinc:2886(id0.241) printpiece=[LDS,  ,  B, ,,  A]
Operands 0: Mem : 1801  1: Reg16 : 1800  
Pattern id=241 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2b500:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[106:2] = SUBPIECE unique[2b500:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2b500:4], const[0:4]

Line ia.sinc:1614 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_66=1; ] {}
0: Constructor line ia.sinc:1614(id0.15) printpiece=[ C]
Operands 0: vex_vvvv : 1373  1: vex_l : 1374  2: instruction : 1372  
Pattern id=15 pattern=cmb:(ctx:X[xx00]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx01]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:2886 :LDS Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC5; Mem & Reg16 ...        { tmp:4 = *Mem; DS = tmp(2); Reg16 = tmp(0); }
1: Constructor line ia.sinc:2886(id0.241) printpiece=[LDS,  ,  B, ,,  A]
Operands 0: Mem : 1801  1: Reg16 : 1800  
Pattern id=241 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2b500:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[106:2] = SUBPIECE unique[2b500:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2b500:4], const[0:4]

Line ia.sinc:1616 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f3=1; ] {}
0: Constructor line ia.sinc:1616(id0.16) printpiece=[ C]
Operands 0: vex_vvvv : 1376  1: vex_l : 1377  2: instruction : 1375  
Pattern id=16 pattern=cmb:(ctx:X[xx00]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx10]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:2886 :LDS Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC5; Mem & Reg16 ...        { tmp:4 = *Mem; DS = tmp(2); Reg16 = tmp(0); }
1: Constructor line ia.sinc:2886(id0.241) printpiece=[LDS,  ,  B, ,,  A]
Operands 0: Mem : 1801  1: Reg16 : 1800  
Pattern id=241 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2b500:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[106:2] = SUBPIECE unique[2b500:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2b500:4], const[0:4]

Line ia.sinc:1618 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f2=1; ] {}
0: Constructor line ia.sinc:1618(id0.17) printpiece=[ C]
Operands 0: vex_vvvv : 1379  1: vex_l : 1380  2: instruction : 1378  
Pattern id=17 pattern=cmb:(ctx:X[xx00]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx11]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:2886 :LDS Reg16,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=0 & byte=0xC5; Mem & Reg16 ...        { tmp:4 = *Mem; DS = tmp(2); Reg16 = tmp(0); }
1: Constructor line ia.sinc:2886(id0.241) printpiece=[LDS,  ,  B, ,,  A]
Operands 0: Mem : 1801  1: Reg16 : 1800  
Pattern id=241 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2b500:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[106:2] = SUBPIECE unique[2b500:4], const[2:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2b500:4], const[0:4]

Line ia.sinc:1612 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; ] {}
0: Constructor line ia.sinc:1612(id0.14) printpiece=[ C]
Operands 0: vex_vvvv : 1370  1: vex_l : 1371  2: instruction : 1369  
Pattern id=14 pattern=cmb:(ctx:X[xx01]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx00]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:2887 :LDS Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC5 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; DS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
1: Constructor line ia.sinc:2887(id0.242) printpiece=[LDS,  ,  B, ,,  A]
Operands 0: Mem : 1803  1: Reg32 : 1802  2: check_Reg32_dest : 1804  
Pattern id=242 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:C5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2b700:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[106:2] = SUBPIECE unique[2b700:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2b700:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:1614 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_66=1; ] {}
0: Constructor line ia.sinc:1614(id0.15) printpiece=[ C]
Operands 0: vex_vvvv : 1373  1: vex_l : 1374  2: instruction : 1372  
Pattern id=15 pattern=cmb:(ctx:X[xx01]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx01]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:2887 :LDS Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC5 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; DS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
1: Constructor line ia.sinc:2887(id0.242) printpiece=[LDS,  ,  B, ,,  A]
Operands 0: Mem : 1803  1: Reg32 : 1802  2: check_Reg32_dest : 1804  
Pattern id=242 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:C5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2b700:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[106:2] = SUBPIECE unique[2b700:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2b700:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:1616 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f3=1; ] {}
0: Constructor line ia.sinc:1616(id0.16) printpiece=[ C]
Operands 0: vex_vvvv : 1376  1: vex_l : 1377  2: instruction : 1375  
Pattern id=16 pattern=cmb:(ctx:X[xx01]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx10]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:2887 :LDS Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC5 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; DS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
1: Constructor line ia.sinc:2887(id0.242) printpiece=[LDS,  ,  B, ,,  A]
Operands 0: Mem : 1803  1: Reg32 : 1802  2: check_Reg32_dest : 1804  
Pattern id=242 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:C5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2b700:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[106:2] = SUBPIECE unique[2b700:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2b700:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:1618 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f2=1; ] {}
0: Constructor line ia.sinc:1618(id0.17) printpiece=[ C]
Operands 0: vex_vvvv : 1379  1: vex_l : 1380  2: instruction : 1378  
Pattern id=17 pattern=cmb:(ctx:X[xx01]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx11]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:2887 :LDS Reg32,Mem      is $(LONGMODE_OFF) & vexMode=0 & opsize=1 & byte=0xC5 & bit64=0; Mem & Reg32 ... & check_Reg32_dest ...     { tmp:6 = *Mem; DS = tmp(4); Reg32 = tmp(0); build check_Reg32_dest; }
1: Constructor line ia.sinc:2887(id0.242) printpiece=[LDS,  ,  B, ,,  A]
Operands 0: Mem : 1803  1: Reg32 : 1802  2: check_Reg32_dest : 1804  
Pattern id=242 pattern=cmb:(ctx:X[0x01]:XX:X[0xxx]:XX,ins:C5:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2b700:6] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	3: register[106:2] = SUBPIECE unique[2b700:6], const[4:4]
	4: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[2b700:6], const[0:4]
	5: MULTIEQUAL const[2:4]

Line ia.sinc:1612 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; ] {}
0: Constructor line ia.sinc:1612(id0.14) printpiece=[ C]
Operands 0: vex_vvvv : 1370  1: vex_l : 1371  2: instruction : 1369  
Pattern id=14 pattern=cmb:(ctx:X[xx10]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx00]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:1614 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_66=1; ] {}
0: Constructor line ia.sinc:1614(id0.15) printpiece=[ C]
Operands 0: vex_vvvv : 1373  1: vex_l : 1374  2: instruction : 1372  
Pattern id=15 pattern=cmb:(ctx:X[xx10]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx01]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:1616 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f3=1; ] {}
0: Constructor line ia.sinc:1616(id0.16) printpiece=[ C]
Operands 0: vex_vvvv : 1376  1: vex_l : 1377  2: instruction : 1375  
Pattern id=16 pattern=cmb:(ctx:X[xx10]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx10]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:1618 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f2=1; ] {}
0: Constructor line ia.sinc:1618(id0.17) printpiece=[ C]
Operands 0: vex_vvvv : 1379  1: vex_l : 1380  2: instruction : 1378  
Pattern id=17 pattern=cmb:(ctx:X[xx10]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx11]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:1612 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=0; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; ] {}
0: Constructor line ia.sinc:1612(id0.14) printpiece=[ C]
Operands 0: vex_vvvv : 1370  1: vex_l : 1371  2: instruction : 1369  
Pattern id=14 pattern=cmb:(ctx:X[xx11]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx00]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:1614 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=1; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_66=1; ] {}
0: Constructor line ia.sinc:1614(id0.15) printpiece=[ C]
Operands 0: vex_vvvv : 1373  1: vex_l : 1374  2: instruction : 1372  
Pattern id=15 pattern=cmb:(ctx:X[xx11]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx01]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:1616 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=2; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f3=1; ] {}
0: Constructor line ia.sinc:1616(id0.16) printpiece=[ C]
Operands 0: vex_vvvv : 1376  1: vex_l : 1377  2: instruction : 1375  
Pattern id=16 pattern=cmb:(ctx:X[xx11]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx10]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line ia.sinc:1618 :^instruction is $(LONGMODE_OFF) & instrPhase=0 & vexMode=0 & rexprefix=0 & mandover=0 & byte=0xC5; vex_r=1 & vex_vvvv & vex_l & vex_pp=3; instruction
                       [ instrPhase=1; vexMode=1; vexVVVV=~vex_vvvv; vexL=vex_l; vexMMMMM=0x1; prefix_f2=1; ] {}
0: Constructor line ia.sinc:1618(id0.17) printpiece=[ C]
Operands 0: vex_vvvv : 1379  1: vex_l : 1380  2: instruction : 1378  
Pattern id=17 pattern=cmb:(ctx:X[xx11]:X[000x]:[xxx0][0xxx]:X[xxx0],ins:C5:[1xxx][xx11]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]

Line avx.sinc:1958 :VPEXTRW Reg32, XmmReg2, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_W0); byte=0xC5; Reg32 & (mod=0x3 & XmmReg2); imm8
{
	Reg32 = vpextrw_avx( XmmReg2, imm8:1 );
	# TODO Reg64 = zext(Reg32)
}
0: Constructor line avx.sinc:1958(id0.1743) printpiece=[VPEXTRW,  ,  A, ,,  ,  B, ,,  ,  C]
Operands 0: Reg32 : 5356  1: XmmReg2 : 5357  2: imm8 : 5358  
Pattern id=1743 pattern=cmb:(ctx:SS:X2:X8:0[001x]:XX,ins:C5:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[17a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3078 :MOV CRmr8,imm8     is vexMode=0 & byte=0xc6; (CRmr8 & mod=3 & reg_opcode=0); imm8      { CRmr8 = imm8; }
0: Constructor line ia.sinc:3078(id0.294) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: CRmr8 : 1904  1: imm8 : 1905  
Pattern id=294 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C6:C[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3077 :MOV spec_rm8,imm8       is vexMode=0 & byte=0xc6; (spec_rm8 & reg_opcode=0 ...); imm8        { spec_rm8 = imm8; }
1: Constructor line ia.sinc:3077(id0.293) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: spec_rm8 : 1902  1: imm8 : 1903  
Pattern id=293 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C6:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3953 :XABORT imm8     is vexMode=0 & byte=0xc6; byte=0xf8; imm8                         { tmp:1 = imm8; xabort(tmp); }
0: Constructor line ia.sinc:3953(id0.625) printpiece=[XABORT,  ,  A]
Operands 0: imm8 : 2451  
Pattern id=625 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:C6:F8:XX:XX)
Template
	0: CALLOTHER const[4e:4], [handle:space][[handle:offset]:1]

Line avx.sinc:2870 :VSHUFPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vshufps_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2870(id0.1848) printpiece=[VSHUFPS,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5938  1: vexVVVV_XmmReg : 5935  2: XmmReg1 : 5934  3: YmmReg1 : 5939  4: XmmReg2_m128 : 5936  5: imm8 : 5937  
Pattern id=1848 pattern=cmb:(ctx:SS:X[000x]:X[10xx]:[xx00][001x]:XX,ins:C6:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b5600:10] = CALLOTHER const[1d5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b5600:10]

Line avx.sinc:2878 :VSHUFPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_NONE) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xC6; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vshufps_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2878(id0.1849) printpiece=[VSHUFPS,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 5944  1: vexVVVV_YmmReg : 5941  2: YmmReg1 : 5940  3: YmmReg2_m256 : 5942  4: imm8 : 5943  
Pattern id=1849 pattern=cmb:(ctx:SS:X[000x]:X[11xx]:[xx00][001x]:XX,ins:C6:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1d5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line avx.sinc:2854 :VSHUFPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128, imm8 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xC6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8
{
	local tmp:16 = vshufpd_avx( vexVVVV_XmmReg, XmmReg2_m128, imm8:1 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2854(id0.1846) printpiece=[VSHUFPD,  ,  C, ,,  ,  B, ,,  ,  E, ,,  ,  F]
Operands 0: rexWprefix : 5926  1: vexVVVV_XmmReg : 5923  2: XmmReg1 : 5922  3: YmmReg1 : 5927  4: XmmReg2_m128 : 5924  5: imm8 : 5925  
Pattern id=1846 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:C6:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b5400:10] = CALLOTHER const[1d4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b5400:10]

Line avx.sinc:2862 :VSHUFPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256, imm8 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xC6; YmmReg1 ... & YmmReg2_m256; imm8
{
	YmmReg1 = vshufpd_avx( vexVVVV_YmmReg, YmmReg2_m256, imm8:1 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:2862(id0.1847) printpiece=[VSHUFPD,  ,  C, ,,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 5932  1: vexVVVV_YmmReg : 5929  2: YmmReg1 : 5928  3: YmmReg2_m256 : 5930  4: imm8 : 5931  
Pattern id=1847 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:C6:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[1d4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]

Line ia.sinc:3080 :MOV CRmr16,imm16   is vexMode=0 & opsize=0 & byte=0xc7; (CRmr16 & mod=3 & reg_opcode=0); imm16 { CRmr16 = imm16; }
0: Constructor line ia.sinc:3080(id0.296) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: CRmr16 : 1908  1: imm16 : 1909  
Pattern id=296 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C7:C[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3079 :MOV spec_rm16,imm16     is vexMode=0 & opsize=0 & byte=0xc7; (spec_rm16 & reg_opcode=0 ...); imm16 { spec_rm16 = imm16; }
1: Constructor line ia.sinc:3079(id0.295) printpiece=[MOV,  ,  A, ,,  B]
Operands 0: spec_rm16 : 1906  1: imm16 : 1907  
Pattern id=295 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C7:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3958 :XBEGIN rel16     is vexMode=0 & opsize=0 & byte=0xc7; byte=0xf8; rel16                      { xbegin(&:$(SIZE) rel16); }
0: Constructor line ia.sinc:3958(id0.626) printpiece=[XBEGIN,  ,  A]
Operands 0: rel16 : 2454  
Pattern id=626 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:C7:F8:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[4f:4], const[[handle:offset]:4]

Line ia.sinc:3081 :MOV spec_rm32,imm32     is vexMode=0 & opsize=1 & byte=0xc7; (spec_rm32 & check_rm32_dest ... & reg_opcode=0 ...); imm32 { spec_rm32 = imm32; build check_rm32_dest; }
0: Constructor line ia.sinc:3081(id0.297) printpiece=[MOV,  ,  A, ,,  C]
Operands 0: spec_rm32 : 1910  1: check_rm32_dest : 1912  2: imm32 : 1911  
Pattern id=297 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C7:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: MULTIEQUAL const[1:4]

Line ia.sinc:3959 :XBEGIN rel32     is vexMode=0 & (opsize=1 | opsize=2) & byte=0xc7; byte=0xf8; rel32         { xbegin(&:$(SIZE) rel32); }
0: Constructor line ia.sinc:3959(id0.627) printpiece=[XBEGIN,  ,  A]
Operands 0: rel32 : 2455  
Pattern id=627 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:C7:F8:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[4f:4], const[[handle:offset]:4]

Line ia.sinc:3959 :XBEGIN rel32     is vexMode=0 & (opsize=1 | opsize=2) & byte=0xc7; byte=0xf8; rel32         { xbegin(&:$(SIZE) rel32); }
0: Constructor line ia.sinc:3959(id0.627) printpiece=[XBEGIN,  ,  A]
Operands 0: rel32 : 2455  
Pattern id=627 pattern=cmb:(ctx:X[xx10]:XX:X[0xxx]:XX,ins:C7:F8:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: CALLOTHER const[4f:4], const[[handle:offset]:4]

Line ia.sinc:2622 :ENTER imm16,enterFrames is vexMode=0 & addrsize=0 & byte=0xc8; imm16; enterFrames & low5=0x00 {
        push22(BP);
        BP = SP;
        SP = SP - imm16;
}
0: Constructor line ia.sinc:2622(id0.174) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1693  1: enterFrames : 1694  
Pattern id=174 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:C8:XX:XX:[xxx0]0)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9400:2] = COPY register[14:2]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]
	5: register[14:2] = COPY register[10:2]
	6: register[10:2] = INT_SUB register[10:2], [handle:space][[handle:offset]:2]

Line ia.sinc:2663 :ENTER imm16,enterFrames is vexMode=0 & seg16 & addrsize=0 & opsize=0 & byte=0xc8; imm16; enterFrames {
        push22(BP);
        frameTemp:2 = SP;

        SPt:2 = SP;
        BPt:2 = BP;
        ii:1 = enterFrames - 1;
<loop>
        BPt = BPt - 2;
        tmp2:$(SIZE) = segment(seg16,BPt);
        SPt = SPt - 2;
        tmp:$(SIZE) = segment(SS,SPt);
        *:2 tmp = *:2 tmp2;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:2 = 2 * zext(enterFrames - 1);
        SP = SP - tmp_offset;
        BP = BP - tmp_offset;

        push22(frameTemp);
        BP = frameTemp;
        SP = SP - imm16;
}
1: Constructor line ia.sinc:2663(id0.177) printpiece=[ENTER,  ,  B, ,,  C]
Operands 0: seg16 : 1702  1: imm16 : 1700  2: enterFrames : 1701  
Pattern id=177 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:C8:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: unique[9400:2] = COPY register[14:2]
	3: register[10:2] = INT_SUB register[10:2], const[2:2]
	4: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: STORE const[ram:8], unique[9580:4], unique[9400:2]
	6: unique[25d00:2] = COPY register[10:2]
	7: unique[25d80:2] = COPY register[10:2]
	8: unique[25e00:2] = COPY register[14:2]
	9: unique[25f00:1] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:1]
	10: PTRADD const[0:4]
	11: unique[25e00:2] = INT_SUB unique[25e00:2], const[2:2]
	12: unique[26080:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], unique[25e00:2]
	13: unique[25d80:2] = INT_SUB unique[25d80:2], const[2:2]
	14: unique[26200:4] = CALLOTHER const[0:4], register[104:2], unique[25d80:2]
	15: unique[26280:2] = LOAD const[ram:8], unique[26080:4]
	16: STORE const[ram:8], unique[26200:4], unique[26280:2]
	17: unique[25f00:1] = INT_SUB unique[25f00:1], const[1:1]
	18: unique[26380:1] = INT_SLESS const[0:1], unique[25f00:1]
	19: CBRANCH const[[rel:0]:4], unique[26380:1]
	20: unique[26400:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	21: unique[26480:2] = INT_ZEXT unique[26400:[handle:size]]
	22: unique[26580:2] = INT_MULT const[2:2], unique[26480:2]
	23: register[10:2] = INT_SUB register[10:2], unique[26580:2]
	24: register[14:2] = INT_SUB register[14:2], unique[26580:2]
	25: unique[9400:2] = COPY unique[25d00:2]
	26: register[10:2] = INT_SUB register[10:2], const[2:2]
	27: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	28: STORE const[ram:8], unique[9580:4], unique[9400:2]
	29: register[14:2] = COPY unique[25d00:2]
	30: register[10:2] = INT_SUB register[10:2], [handle:space][[handle:offset]:2]

Line ia.sinc:2628 :ENTER imm16,enterFrames is vexMode=0 & addrsize=0 & byte=0xc8; imm16; enterFrames & low5=0x01 {
        push22(BP);
        frameTemp:2 = SP;

        push22(frameTemp);
        BP = frameTemp;
        SP = SP - imm16;
}
0: Constructor line ia.sinc:2628(id0.175) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1695  1: enterFrames : 1696  
Pattern id=175 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:C8:XX:XX:[xxx0]1)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9400:2] = COPY register[14:2]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]
	5: unique[25080:2] = COPY register[10:2]
	6: unique[9400:2] = COPY unique[25080:2]
	7: register[10:2] = INT_SUB register[10:2], const[2:2]
	8: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	9: STORE const[ram:8], unique[9580:4], unique[9400:2]
	10: register[14:2] = COPY unique[25080:2]
	11: register[10:2] = INT_SUB register[10:2], [handle:space][[handle:offset]:2]

Line ia.sinc:2663 :ENTER imm16,enterFrames is vexMode=0 & seg16 & addrsize=0 & opsize=0 & byte=0xc8; imm16; enterFrames {
        push22(BP);
        frameTemp:2 = SP;

        SPt:2 = SP;
        BPt:2 = BP;
        ii:1 = enterFrames - 1;
<loop>
        BPt = BPt - 2;
        tmp2:$(SIZE) = segment(seg16,BPt);
        SPt = SPt - 2;
        tmp:$(SIZE) = segment(SS,SPt);
        *:2 tmp = *:2 tmp2;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:2 = 2 * zext(enterFrames - 1);
        SP = SP - tmp_offset;
        BP = BP - tmp_offset;

        push22(frameTemp);
        BP = frameTemp;
        SP = SP - imm16;
}
1: Constructor line ia.sinc:2663(id0.177) printpiece=[ENTER,  ,  B, ,,  C]
Operands 0: seg16 : 1702  1: imm16 : 1700  2: enterFrames : 1701  
Pattern id=177 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:C8:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: unique[9400:2] = COPY register[14:2]
	3: register[10:2] = INT_SUB register[10:2], const[2:2]
	4: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: STORE const[ram:8], unique[9580:4], unique[9400:2]
	6: unique[25d00:2] = COPY register[10:2]
	7: unique[25d80:2] = COPY register[10:2]
	8: unique[25e00:2] = COPY register[14:2]
	9: unique[25f00:1] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:1]
	10: PTRADD const[0:4]
	11: unique[25e00:2] = INT_SUB unique[25e00:2], const[2:2]
	12: unique[26080:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], unique[25e00:2]
	13: unique[25d80:2] = INT_SUB unique[25d80:2], const[2:2]
	14: unique[26200:4] = CALLOTHER const[0:4], register[104:2], unique[25d80:2]
	15: unique[26280:2] = LOAD const[ram:8], unique[26080:4]
	16: STORE const[ram:8], unique[26200:4], unique[26280:2]
	17: unique[25f00:1] = INT_SUB unique[25f00:1], const[1:1]
	18: unique[26380:1] = INT_SLESS const[0:1], unique[25f00:1]
	19: CBRANCH const[[rel:0]:4], unique[26380:1]
	20: unique[26400:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	21: unique[26480:2] = INT_ZEXT unique[26400:[handle:size]]
	22: unique[26580:2] = INT_MULT const[2:2], unique[26480:2]
	23: register[10:2] = INT_SUB register[10:2], unique[26580:2]
	24: register[14:2] = INT_SUB register[14:2], unique[26580:2]
	25: unique[9400:2] = COPY unique[25d00:2]
	26: register[10:2] = INT_SUB register[10:2], const[2:2]
	27: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	28: STORE const[ram:8], unique[9580:4], unique[9400:2]
	29: register[14:2] = COPY unique[25d00:2]
	30: register[10:2] = INT_SUB register[10:2], [handle:space][[handle:offset]:2]

Line ia.sinc:2622 :ENTER imm16,enterFrames is vexMode=0 & addrsize=0 & byte=0xc8; imm16; enterFrames & low5=0x00 {
        push22(BP);
        BP = SP;
        SP = SP - imm16;
}
0: Constructor line ia.sinc:2622(id0.174) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1693  1: enterFrames : 1694  
Pattern id=174 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:C8:XX:XX:[xxx0]0)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9400:2] = COPY register[14:2]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]
	5: register[14:2] = COPY register[10:2]
	6: register[10:2] = INT_SUB register[10:2], [handle:space][[handle:offset]:2]

Line ia.sinc:2637 :ENTER imm16,enterFrames is vexMode=0 & seg16 & addrsize=0 & opsize=1 & byte=0xc8; imm16; enterFrames {
        push24(zext(BP));
        frameTemp:2 = SP;

        SPt:2 = SP;
        BPt:2 = BP;
        ii:1 = enterFrames - 1;
<loop>

        BPt = BPt - 4;
        tmp2:$(SIZE) = segment(seg16,BPt);
        SPt = SPt - 4;
        tmp:$(SIZE) = segment(SS,SPt);
        *:4 tmp = *:4 tmp2;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:2 = 4 * zext(enterFrames - 1);
        SP = SP - tmp_offset;
        BP = BP - tmp_offset;

        push24(zext(frameTemp));
        BP = frameTemp;
        SP = SP - imm16;
}
1: Constructor line ia.sinc:2637(id0.176) printpiece=[ENTER,  ,  B, ,,  C]
Operands 0: seg16 : 1699  1: imm16 : 1697  2: enterFrames : 1698  
Pattern id=176 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:C8:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: unique[9600:4] = INT_ZEXT register[14:2]
	3: register[10:2] = INT_SUB register[10:2], const[4:2]
	4: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: STORE const[ram:8], unique[9780:4], unique[9600:4]
	6: unique[25200:2] = COPY register[10:2]
	7: unique[25280:2] = COPY register[10:2]
	8: unique[25300:2] = COPY register[14:2]
	9: unique[25400:1] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:1]
	10: PTRADD const[0:4]
	11: unique[25300:2] = INT_SUB unique[25300:2], const[4:2]
	12: unique[25580:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], unique[25300:2]
	13: unique[25280:2] = INT_SUB unique[25280:2], const[4:2]
	14: unique[25700:4] = CALLOTHER const[0:4], register[104:2], unique[25280:2]
	15: unique[25780:4] = LOAD const[ram:8], unique[25580:4]
	16: STORE const[ram:8], unique[25700:4], unique[25780:4]
	17: unique[25400:1] = INT_SUB unique[25400:1], const[1:1]
	18: unique[25880:1] = INT_SLESS const[0:1], unique[25400:1]
	19: CBRANCH const[[rel:0]:4], unique[25880:1]
	20: unique[25900:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	21: unique[25980:2] = INT_ZEXT unique[25900:[handle:size]]
	22: unique[25a80:2] = INT_MULT const[4:2], unique[25980:2]
	23: register[10:2] = INT_SUB register[10:2], unique[25a80:2]
	24: register[14:2] = INT_SUB register[14:2], unique[25a80:2]
	25: unique[9600:4] = INT_ZEXT unique[25200:2]
	26: register[10:2] = INT_SUB register[10:2], const[4:2]
	27: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	28: STORE const[ram:8], unique[9780:4], unique[9600:4]
	29: register[14:2] = COPY unique[25200:2]
	30: register[10:2] = INT_SUB register[10:2], [handle:space][[handle:offset]:2]

Line ia.sinc:2628 :ENTER imm16,enterFrames is vexMode=0 & addrsize=0 & byte=0xc8; imm16; enterFrames & low5=0x01 {
        push22(BP);
        frameTemp:2 = SP;

        push22(frameTemp);
        BP = frameTemp;
        SP = SP - imm16;
}
0: Constructor line ia.sinc:2628(id0.175) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1695  1: enterFrames : 1696  
Pattern id=175 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:C8:XX:XX:[xxx0]1)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9400:2] = COPY register[14:2]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]
	5: unique[25080:2] = COPY register[10:2]
	6: unique[9400:2] = COPY unique[25080:2]
	7: register[10:2] = INT_SUB register[10:2], const[2:2]
	8: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	9: STORE const[ram:8], unique[9580:4], unique[9400:2]
	10: register[14:2] = COPY unique[25080:2]
	11: register[10:2] = INT_SUB register[10:2], [handle:space][[handle:offset]:2]

Line ia.sinc:2637 :ENTER imm16,enterFrames is vexMode=0 & seg16 & addrsize=0 & opsize=1 & byte=0xc8; imm16; enterFrames {
        push24(zext(BP));
        frameTemp:2 = SP;

        SPt:2 = SP;
        BPt:2 = BP;
        ii:1 = enterFrames - 1;
<loop>

        BPt = BPt - 4;
        tmp2:$(SIZE) = segment(seg16,BPt);
        SPt = SPt - 4;
        tmp:$(SIZE) = segment(SS,SPt);
        *:4 tmp = *:4 tmp2;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:2 = 4 * zext(enterFrames - 1);
        SP = SP - tmp_offset;
        BP = BP - tmp_offset;

        push24(zext(frameTemp));
        BP = frameTemp;
        SP = SP - imm16;
}
1: Constructor line ia.sinc:2637(id0.176) printpiece=[ENTER,  ,  B, ,,  C]
Operands 0: seg16 : 1699  1: imm16 : 1697  2: enterFrames : 1698  
Pattern id=176 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:C8:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[2:4]
	2: unique[9600:4] = INT_ZEXT register[14:2]
	3: register[10:2] = INT_SUB register[10:2], const[4:2]
	4: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: STORE const[ram:8], unique[9780:4], unique[9600:4]
	6: unique[25200:2] = COPY register[10:2]
	7: unique[25280:2] = COPY register[10:2]
	8: unique[25300:2] = COPY register[14:2]
	9: unique[25400:1] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:1]
	10: PTRADD const[0:4]
	11: unique[25300:2] = INT_SUB unique[25300:2], const[4:2]
	12: unique[25580:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], unique[25300:2]
	13: unique[25280:2] = INT_SUB unique[25280:2], const[4:2]
	14: unique[25700:4] = CALLOTHER const[0:4], register[104:2], unique[25280:2]
	15: unique[25780:4] = LOAD const[ram:8], unique[25580:4]
	16: STORE const[ram:8], unique[25700:4], unique[25780:4]
	17: unique[25400:1] = INT_SUB unique[25400:1], const[1:1]
	18: unique[25880:1] = INT_SLESS const[0:1], unique[25400:1]
	19: CBRANCH const[[rel:0]:4], unique[25880:1]
	20: unique[25900:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	21: unique[25980:2] = INT_ZEXT unique[25900:[handle:size]]
	22: unique[25a80:2] = INT_MULT const[4:2], unique[25980:2]
	23: register[10:2] = INT_SUB register[10:2], unique[25a80:2]
	24: register[14:2] = INT_SUB register[14:2], unique[25a80:2]
	25: unique[9600:4] = INT_ZEXT unique[25200:2]
	26: register[10:2] = INT_SUB register[10:2], const[4:2]
	27: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	28: STORE const[ram:8], unique[9780:4], unique[9600:4]
	29: register[14:2] = COPY unique[25200:2]
	30: register[10:2] = INT_SUB register[10:2], [handle:space][[handle:offset]:2]

Line ia.sinc:2551 :ENTER imm16,enterFrames is vexMode=0 & addrsize=1 & byte=0xc8; imm16; enterFrames & low5=0x00 {
        push44(EBP);
        EBP = ESP;
        ESP = ESP - imm16;
}
0: Constructor line ia.sinc:2551(id0.170) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1685  1: enterFrames : 1686  
Pattern id=170 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:C8:XX:XX:[xxx0]0)
Template
	0: MULTIEQUAL const[1:4]
	1: register[10:4] = INT_SUB register[10:4], const[4:4]
	2: STORE const[ram:8], register[10:4], register[14:4]
	3: register[14:4] = COPY register[10:4]
	4: register[10:4] = INT_SUB register[10:4], [handle:space][[handle:offset]:4]

Line ia.sinc:2594 :ENTER imm16,enterFrames is vexMode=0 & addrsize=1 & opsize=0 & byte=0xc8; imm16; enterFrames {
        push44(EBP);
        frameTemp:4 = ESP;

@ifdef IA64
        ESPt:$(SIZE) = zext(ESP);
        EBPt:$(SIZE) = zext(EBP);
@else
        ESPt:$(SIZE) = ESP;
        EBPt:$(SIZE) = EBP;
@endif
        ii:1 = enterFrames - 1;
<loop>
        EBPt = EBPt - 2;
        ESPt = ESPt - 2;
        *:2 ESPt = *:2 EBPt;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:4 = 2 * zext(enterFrames - 1);
        ESP = ESP - tmp_offset;
        EBP = EBP - tmp_offset;

        push44(frameTemp);
        EBP = frameTemp;
        ESP = ESP - imm16;
}
1: Constructor line ia.sinc:2594(id0.173) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1691  1: enterFrames : 1692  
Pattern id=173 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:C8:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9b00:4] = COPY register[14:4]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[9b00:4]
	4: unique[24780:4] = COPY register[10:4]
	5: unique[24800:4] = COPY register[10:4]
	6: unique[24880:4] = COPY register[14:4]
	7: unique[24980:1] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:1]
	8: PTRADD const[0:4]
	9: unique[24880:4] = INT_SUB unique[24880:4], const[2:4]
	10: unique[24800:4] = INT_SUB unique[24800:4], const[2:4]
	11: unique[24b00:2] = LOAD const[ram:8], unique[24880:4]
	12: STORE const[ram:8], unique[24800:4], unique[24b00:2]
	13: unique[24980:1] = INT_SUB unique[24980:1], const[1:1]
	14: unique[24c00:1] = INT_SLESS const[0:1], unique[24980:1]
	15: CBRANCH const[[rel:0]:4], unique[24c00:1]
	16: unique[24c80:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	17: unique[24d00:4] = INT_ZEXT unique[24c80:[handle:size]]
	18: unique[24e00:4] = INT_MULT const[2:4], unique[24d00:4]
	19: register[10:4] = INT_SUB register[10:4], unique[24e00:4]
	20: register[14:4] = INT_SUB register[14:4], unique[24e00:4]
	21: unique[9b00:4] = COPY unique[24780:4]
	22: register[10:4] = INT_SUB register[10:4], const[4:4]
	23: STORE const[ram:8], register[10:4], unique[9b00:4]
	24: register[14:4] = COPY unique[24780:4]
	25: register[10:4] = INT_SUB register[10:4], [handle:space][[handle:offset]:4]

Line ia.sinc:2557 :ENTER imm16,enterFrames is vexMode=0 & addrsize=1 & byte=0xc8; imm16; enterFrames & low5=0x01 {
        push44(EBP);
        frameTemp:4 = ESP;

        push44(frameTemp);
        EBP = frameTemp;
        ESP = ESP - imm16;
}
0: Constructor line ia.sinc:2557(id0.171) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1687  1: enterFrames : 1688  
Pattern id=171 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:C8:XX:XX:[xxx0]1)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9b00:4] = COPY register[14:4]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[9b00:4]
	4: unique[23e00:4] = COPY register[10:4]
	5: unique[9b00:4] = COPY unique[23e00:4]
	6: register[10:4] = INT_SUB register[10:4], const[4:4]
	7: STORE const[ram:8], register[10:4], unique[9b00:4]
	8: register[14:4] = COPY unique[23e00:4]
	9: register[10:4] = INT_SUB register[10:4], [handle:space][[handle:offset]:4]

Line ia.sinc:2594 :ENTER imm16,enterFrames is vexMode=0 & addrsize=1 & opsize=0 & byte=0xc8; imm16; enterFrames {
        push44(EBP);
        frameTemp:4 = ESP;

@ifdef IA64
        ESPt:$(SIZE) = zext(ESP);
        EBPt:$(SIZE) = zext(EBP);
@else
        ESPt:$(SIZE) = ESP;
        EBPt:$(SIZE) = EBP;
@endif
        ii:1 = enterFrames - 1;
<loop>
        EBPt = EBPt - 2;
        ESPt = ESPt - 2;
        *:2 ESPt = *:2 EBPt;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:4 = 2 * zext(enterFrames - 1);
        ESP = ESP - tmp_offset;
        EBP = EBP - tmp_offset;

        push44(frameTemp);
        EBP = frameTemp;
        ESP = ESP - imm16;
}
1: Constructor line ia.sinc:2594(id0.173) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1691  1: enterFrames : 1692  
Pattern id=173 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:C8:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9b00:4] = COPY register[14:4]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[9b00:4]
	4: unique[24780:4] = COPY register[10:4]
	5: unique[24800:4] = COPY register[10:4]
	6: unique[24880:4] = COPY register[14:4]
	7: unique[24980:1] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:1]
	8: PTRADD const[0:4]
	9: unique[24880:4] = INT_SUB unique[24880:4], const[2:4]
	10: unique[24800:4] = INT_SUB unique[24800:4], const[2:4]
	11: unique[24b00:2] = LOAD const[ram:8], unique[24880:4]
	12: STORE const[ram:8], unique[24800:4], unique[24b00:2]
	13: unique[24980:1] = INT_SUB unique[24980:1], const[1:1]
	14: unique[24c00:1] = INT_SLESS const[0:1], unique[24980:1]
	15: CBRANCH const[[rel:0]:4], unique[24c00:1]
	16: unique[24c80:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	17: unique[24d00:4] = INT_ZEXT unique[24c80:[handle:size]]
	18: unique[24e00:4] = INT_MULT const[2:4], unique[24d00:4]
	19: register[10:4] = INT_SUB register[10:4], unique[24e00:4]
	20: register[14:4] = INT_SUB register[14:4], unique[24e00:4]
	21: unique[9b00:4] = COPY unique[24780:4]
	22: register[10:4] = INT_SUB register[10:4], const[4:4]
	23: STORE const[ram:8], register[10:4], unique[9b00:4]
	24: register[14:4] = COPY unique[24780:4]
	25: register[10:4] = INT_SUB register[10:4], [handle:space][[handle:offset]:4]

Line ia.sinc:2551 :ENTER imm16,enterFrames is vexMode=0 & addrsize=1 & byte=0xc8; imm16; enterFrames & low5=0x00 {
        push44(EBP);
        EBP = ESP;
        ESP = ESP - imm16;
}
0: Constructor line ia.sinc:2551(id0.170) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1685  1: enterFrames : 1686  
Pattern id=170 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:C8:XX:XX:[xxx0]0)
Template
	0: MULTIEQUAL const[1:4]
	1: register[10:4] = INT_SUB register[10:4], const[4:4]
	2: STORE const[ram:8], register[10:4], register[14:4]
	3: register[14:4] = COPY register[10:4]
	4: register[10:4] = INT_SUB register[10:4], [handle:space][[handle:offset]:4]

Line ia.sinc:2566 :ENTER imm16,enterFrames is vexMode=0 & addrsize=1 & opsize=1 & byte=0xc8; imm16; enterFrames {
        push44(EBP);
        frameTemp:4 = ESP;

@ifdef IA64
        ESPt:$(SIZE) = zext(ESP);
        EBPt:$(SIZE) = zext(EBP);
@else
        ESPt:$(SIZE) = ESP;
        EBPt:$(SIZE) = EBP;
@endif
        ii:1 = enterFrames - 1;
<loop>
        EBPt = EBPt - 4;
        ESPt = ESPt - 4;
        *:4 ESPt = *:4 EBPt;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:4 = 4 * zext(enterFrames - 1);
        ESP = ESP - tmp_offset;
        EBP = EBP - tmp_offset;

        push44(frameTemp);
        EBP = frameTemp;
        ESP = ESP - imm16;
}
1: Constructor line ia.sinc:2566(id0.172) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1689  1: enterFrames : 1690  
Pattern id=172 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:C8:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9b00:4] = COPY register[14:4]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[9b00:4]
	4: unique[23f00:4] = COPY register[10:4]
	5: unique[23f80:4] = COPY register[10:4]
	6: unique[24000:4] = COPY register[14:4]
	7: unique[24100:1] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:1]
	8: PTRADD const[0:4]
	9: unique[24000:4] = INT_SUB unique[24000:4], const[4:4]
	10: unique[23f80:4] = INT_SUB unique[23f80:4], const[4:4]
	11: unique[24280:4] = LOAD const[ram:8], unique[24000:4]
	12: STORE const[ram:8], unique[23f80:4], unique[24280:4]
	13: unique[24100:1] = INT_SUB unique[24100:1], const[1:1]
	14: unique[24380:1] = INT_SLESS const[0:1], unique[24100:1]
	15: CBRANCH const[[rel:0]:4], unique[24380:1]
	16: unique[24400:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	17: unique[24480:4] = INT_ZEXT unique[24400:[handle:size]]
	18: unique[24580:4] = INT_MULT const[4:4], unique[24480:4]
	19: register[10:4] = INT_SUB register[10:4], unique[24580:4]
	20: register[14:4] = INT_SUB register[14:4], unique[24580:4]
	21: unique[9b00:4] = COPY unique[23f00:4]
	22: register[10:4] = INT_SUB register[10:4], const[4:4]
	23: STORE const[ram:8], register[10:4], unique[9b00:4]
	24: register[14:4] = COPY unique[23f00:4]
	25: register[10:4] = INT_SUB register[10:4], [handle:space][[handle:offset]:4]

Line ia.sinc:2557 :ENTER imm16,enterFrames is vexMode=0 & addrsize=1 & byte=0xc8; imm16; enterFrames & low5=0x01 {
        push44(EBP);
        frameTemp:4 = ESP;

        push44(frameTemp);
        EBP = frameTemp;
        ESP = ESP - imm16;
}
0: Constructor line ia.sinc:2557(id0.171) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1687  1: enterFrames : 1688  
Pattern id=171 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:C8:XX:XX:[xxx0]1)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9b00:4] = COPY register[14:4]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[9b00:4]
	4: unique[23e00:4] = COPY register[10:4]
	5: unique[9b00:4] = COPY unique[23e00:4]
	6: register[10:4] = INT_SUB register[10:4], const[4:4]
	7: STORE const[ram:8], register[10:4], unique[9b00:4]
	8: register[14:4] = COPY unique[23e00:4]
	9: register[10:4] = INT_SUB register[10:4], [handle:space][[handle:offset]:4]

Line ia.sinc:2566 :ENTER imm16,enterFrames is vexMode=0 & addrsize=1 & opsize=1 & byte=0xc8; imm16; enterFrames {
        push44(EBP);
        frameTemp:4 = ESP;

@ifdef IA64
        ESPt:$(SIZE) = zext(ESP);
        EBPt:$(SIZE) = zext(EBP);
@else
        ESPt:$(SIZE) = ESP;
        EBPt:$(SIZE) = EBP;
@endif
        ii:1 = enterFrames - 1;
<loop>
        EBPt = EBPt - 4;
        ESPt = ESPt - 4;
        *:4 ESPt = *:4 EBPt;
        ii = ii - 1;
        if (ii s> 0) goto <loop>;

        tmp_offset:4 = 4 * zext(enterFrames - 1);
        ESP = ESP - tmp_offset;
        EBP = EBP - tmp_offset;

        push44(frameTemp);
        EBP = frameTemp;
        ESP = ESP - imm16;
}
1: Constructor line ia.sinc:2566(id0.172) printpiece=[ENTER,  ,  A, ,,  B]
Operands 0: imm16 : 1689  1: enterFrames : 1690  
Pattern id=172 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:C8:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[9b00:4] = COPY register[14:4]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[9b00:4]
	4: unique[23f00:4] = COPY register[10:4]
	5: unique[23f80:4] = COPY register[10:4]
	6: unique[24000:4] = COPY register[14:4]
	7: unique[24100:1] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:1]
	8: PTRADD const[0:4]
	9: unique[24000:4] = INT_SUB unique[24000:4], const[4:4]
	10: unique[23f80:4] = INT_SUB unique[23f80:4], const[4:4]
	11: unique[24280:4] = LOAD const[ram:8], unique[24000:4]
	12: STORE const[ram:8], unique[23f80:4], unique[24280:4]
	13: unique[24100:1] = INT_SUB unique[24100:1], const[1:1]
	14: unique[24380:1] = INT_SLESS const[0:1], unique[24100:1]
	15: CBRANCH const[[rel:0]:4], unique[24380:1]
	16: unique[24400:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	17: unique[24480:4] = INT_ZEXT unique[24400:[handle:size]]
	18: unique[24580:4] = INT_MULT const[4:4], unique[24480:4]
	19: register[10:4] = INT_SUB register[10:4], unique[24580:4]
	20: register[14:4] = INT_SUB register[14:4], unique[24580:4]
	21: unique[9b00:4] = COPY unique[23f00:4]
	22: register[10:4] = INT_SUB register[10:4], const[4:4]
	23: STORE const[ram:8], register[10:4], unique[9b00:4]
	24: register[14:4] = COPY unique[23f00:4]
	25: register[10:4] = INT_SUB register[10:4], [handle:space][[handle:offset]:4]

Line ia.sinc:2930 :LEAVE          is vexMode=0 & addrsize=0 & byte=0xc9               { SP = BP; tmp:$(SIZE) = segment(SS,SP); BP = *tmp; SP = SP + 2; }
0: Constructor line ia.sinc:2930(id0.255) printpiece=[LEAVE]
Operands 
Pattern id=255 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:C9:XX:XX:XX)
Template
	0: register[10:2] = COPY register[14:2]
	1: unique[2ca00:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	2: register[14:2] = LOAD const[ram:8], unique[2ca00:4]
	3: register[10:2] = INT_ADD register[10:2], const[2:2]

Line ia.sinc:2931 :LEAVE          is vexMode=0 & addrsize=1 & byte=0xc9               { ESP = EBP; EBP = *$(STACKPTR); ESP=ESP+4; }
0: Constructor line ia.sinc:2931(id0.256) printpiece=[LEAVE]
Operands 
Pattern id=256 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:C9:XX:XX:XX)
Template
	0: register[10:4] = COPY register[14:4]
	1: register[14:4] = LOAD const[ram:8], register[10:4]
	2: register[10:4] = INT_ADD register[10:4], const[4:4]

Line ia.sinc:3496 :RETF imm16     is vexMode=0 & addrsize=0 & opsize=0 & byte=0xca; imm16     { pop22(IP); EIP=zext(IP); pop22(CS); SP=SP+imm16; return [EIP]; }       
0: Constructor line ia.sinc:3496(id0.471) printpiece=[RETF,  ,  A]
Operands 0: imm16 : 2160  
Pattern id=471 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:CA:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]
	3: register[284:4] = INT_ZEXT register[284:2]
	4: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: register[102:2] = LOAD const[ram:8], unique[9e80:4]
	6: register[10:2] = INT_ADD register[10:2], const[2:2]
	7: register[10:2] = INT_ADD register[10:2], [handle:space][[handle:offset]:2]
	8: RETURN register[284:4]

Line ia.sinc:3502 :RETF imm16     is vexMode=0 & addrsize=0 & opsize=1 & byte=0xca; imm16     { pop24(EIP); tmp:4=0; pop24(tmp); CS=tmp(0); SP=SP+imm16; return [EIP]; }
0: Constructor line ia.sinc:3502(id0.473) printpiece=[RETF,  ,  A]
Operands 0: imm16 : 2162  
Pattern id=473 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:CA:XX:XX:XX)
Template
	0: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:4] = LOAD const[ram:8], unique[a080:4]
	2: register[10:2] = INT_ADD register[10:2], const[4:2]
	3: unique[37e80:4] = COPY const[0:4]
	4: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: unique[37e80:4] = LOAD const[ram:8], unique[a080:4]
	6: register[10:2] = INT_ADD register[10:2], const[4:2]
	7: register[102:2] = SUBPIECE unique[37e80:4], const[0:4]
	8: register[10:2] = INT_ADD register[10:2], [handle:space][[handle:offset]:2]
	9: RETURN register[284:4]

Line ia.sinc:3497 :RETF imm16     is vexMode=0 & addrsize=1 & opsize=0 & byte=0xca; imm16     { pop42(IP); EIP=zext(IP); pop42(CS); ESP=ESP+imm16; return [EIP]; }         
0: Constructor line ia.sinc:3497(id0.472) printpiece=[RETF,  ,  A]
Operands 0: imm16 : 2161  
Pattern id=472 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:CA:XX:XX:XX)
Template
	0: register[284:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[2:4]
	2: register[284:4] = INT_ZEXT register[284:2]
	3: register[102:2] = LOAD const[ram:8], register[10:4]
	4: register[10:4] = INT_ADD register[10:4], const[2:4]
	5: register[10:4] = INT_ADD register[10:4], [handle:space][[handle:offset]:4]
	6: RETURN register[284:4]

Line ia.sinc:3503 :RETF imm16     is vexMode=0 & addrsize=1 & opsize=1 & byte=0xca; imm16     { pop44(EIP); tmp:4=0; pop44(tmp); CS=tmp(0); ESP=ESP+imm16; return [EIP]; }
0: Constructor line ia.sinc:3503(id0.474) printpiece=[RETF,  ,  A]
Operands 0: imm16 : 2163  
Pattern id=474 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:CA:XX:XX:XX)
Template
	0: register[284:4] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]
	2: unique[38000:4] = COPY const[0:4]
	3: unique[38000:4] = LOAD const[ram:8], register[10:4]
	4: register[10:4] = INT_ADD register[10:4], const[4:4]
	5: register[102:2] = SUBPIECE unique[38000:4], const[0:4]
	6: register[10:4] = INT_ADD register[10:4], [handle:space][[handle:offset]:4]
	7: RETURN register[284:4]

Line ia.sinc:3475 :RETF           is vexMode=0 & addrsize=0 & opsize=0 & byte=0xcb            { pop22(IP); pop22(CS); EIP = segment(CS,IP); return [EIP]; }
0: Constructor line ia.sinc:3475(id0.463) printpiece=[RETF]
Operands 
Pattern id=463 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:CB:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]
	3: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: register[102:2] = LOAD const[ram:8], unique[9e80:4]
	5: register[10:2] = INT_ADD register[10:2], const[2:2]
	6: register[284:4] = CALLOTHER const[0:4], register[102:2], register[284:2]
	7: RETURN register[284:4]

Line ia.sinc:3481 :RETF           is vexMode=0 & addrsize=0 & opsize=1 & byte=0xcb            { pop24(EIP); tmp:4=0; pop24(tmp); CS=tmp(0); return [EIP]; }
0: Constructor line ia.sinc:3481(id0.465) printpiece=[RETF]
Operands 
Pattern id=465 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:CB:XX:XX:XX)
Template
	0: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:4] = LOAD const[ram:8], unique[a080:4]
	2: register[10:2] = INT_ADD register[10:2], const[4:2]
	3: unique[37780:4] = COPY const[0:4]
	4: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: unique[37780:4] = LOAD const[ram:8], unique[a080:4]
	6: register[10:2] = INT_ADD register[10:2], const[4:2]
	7: register[102:2] = SUBPIECE unique[37780:4], const[0:4]
	8: RETURN register[284:4]

Line ia.sinc:3476 :RETF           is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xcb            { pop42(IP); EIP=zext(IP); pop42(CS); return [EIP]; }        
0: Constructor line ia.sinc:3476(id0.464) printpiece=[RETF]
Operands 
Pattern id=464 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:CB:XX:XX:XX)
Template
	0: register[284:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[2:4]
	2: register[284:4] = INT_ZEXT register[284:2]
	3: register[102:2] = LOAD const[ram:8], register[10:4]
	4: register[10:4] = INT_ADD register[10:4], const[2:4]
	5: RETURN register[284:4]

Line ia.sinc:3482 :RETF           is vexMode=0 & addrsize=1 & opsize=1 & byte=0xcb            { pop44(EIP); tmp:4=0; pop44(tmp); CS=tmp(0); return [EIP]; }
0: Constructor line ia.sinc:3482(id0.466) printpiece=[RETF]
Operands 
Pattern id=466 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:CB:XX:XX:XX)
Template
	0: register[284:4] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]
	2: unique[37880:4] = COPY const[0:4]
	3: unique[37880:4] = LOAD const[ram:8], register[10:4]
	4: register[10:4] = INT_ADD register[10:4], const[4:4]
	5: register[102:2] = SUBPIECE unique[37880:4], const[0:4]
	6: RETURN register[284:4]

Line ia.sinc:2795 :INT3           is vexMode=0 & byte=0xcc                            { tmp:1 = 0x3; intloc:$(SIZE) = swi(tmp); call [intloc]; return [0:1]; }
0: Constructor line ia.sinc:2795(id0.208) printpiece=[INT3]
Operands 
Pattern id=208 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:CC:XX:XX:XX)
Template
	0: unique[2a300:4] = CALLOTHER const[10:4], const[3:1]
	1: CALLIND unique[2a300:4]
	2: RETURN const[0:1]

Line ia.sinc:2796 :INT imm8       is vexMode=0 & byte=0xcd; imm8                      { tmp:1 = imm8; intloc:$(SIZE) = swi(tmp); call [intloc]; }
0: Constructor line ia.sinc:2796(id0.209) printpiece=[INT,  ,  A]
Operands 0: imm8 : 1768  
Pattern id=209 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:CD:XX:XX:XX)
Template
	0: unique[2a480:4] = CALLOTHER const[10:4], [handle:space][[handle:offset]:1]
	1: CALLIND unique[2a480:4]

Line ia.sinc:2797 :INTO           is vexMode=0 & byte=0xce & bit64=0
{
  tmp:1 = 0x4;
  intloc:$(SIZE) = swi(tmp);

  if (OF != 1) goto <no_overflow>;
    call [intloc];
  <no_overflow>
}
0: Constructor line ia.sinc:2797(id0.210) printpiece=[INTO]
Operands 
Pattern id=210 pattern=cmb:(ctx:X[0xxx]:XX:X[0xxx]:XX,ins:CE:XX:XX:XX)
Template
	0: unique[2a600:4] = CALLOTHER const[10:4], const[4:1]
	1: unique[2a680:1] = INT_NOTEQUAL register[20b:1], const[1:1]
	2: CBRANCH const[[rel:0]:4], unique[2a680:1]
	3: CALLIND unique[2a600:4]
	4: PTRADD const[0:4]

Line ia.sinc:2821 :IRET           is vexMode=0 & addrsize=0 & opsize=0 & byte=0xcf            { pop22(IP); EIP=zext(IP); pop22(CS); pop22(flags); return [EIP]; }    
0: Constructor line ia.sinc:2821(id0.216) printpiece=[IRET]
Operands 
Pattern id=216 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:CF:XX:XX:XX)
Template
	0: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:2] = LOAD const[ram:8], unique[9e80:4]
	2: register[10:2] = INT_ADD register[10:2], const[2:2]
	3: register[284:4] = INT_ZEXT register[284:2]
	4: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: register[102:2] = LOAD const[ram:8], unique[9e80:4]
	6: register[10:2] = INT_ADD register[10:2], const[2:2]
	7: unique[9e80:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	8: register[280:2] = LOAD const[ram:8], unique[9e80:4]
	9: register[10:2] = INT_ADD register[10:2], const[2:2]
	10: RETURN register[284:4]

Line ia.sinc:2826 :IRETD          is vexMode=0 & addrsize=0 & opsize=1 & byte=0xcf            { pop24(EIP); tmp:4=0; pop24(tmp); CS=tmp(0); pop24(tmp); flags=tmp(0); return [EIP]; }
0: Constructor line ia.sinc:2826(id0.218) printpiece=[IRETD]
Operands 
Pattern id=218 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:CF:XX:XX:XX)
Template
	0: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	1: register[284:4] = LOAD const[ram:8], unique[a080:4]
	2: register[10:2] = INT_ADD register[10:2], const[4:2]
	3: unique[2a800:4] = COPY const[0:4]
	4: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: unique[2a800:4] = LOAD const[ram:8], unique[a080:4]
	6: register[10:2] = INT_ADD register[10:2], const[4:2]
	7: register[102:2] = SUBPIECE unique[2a800:4], const[0:4]
	8: unique[a080:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	9: unique[2a800:4] = LOAD const[ram:8], unique[a080:4]
	10: register[10:2] = INT_ADD register[10:2], const[4:2]
	11: register[280:2] = SUBPIECE unique[2a800:4], const[0:4]
	12: RETURN register[284:4]

Line ia.sinc:2822 :IRET           is vexMode=0 & addrsize=1 & opsize=0 & byte=0xcf            { pop42(IP); EIP=zext(IP); pop42(CS); pop42(flags); return [EIP]; }    
0: Constructor line ia.sinc:2822(id0.217) printpiece=[IRET]
Operands 
Pattern id=217 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:CF:XX:XX:XX)
Template
	0: register[284:2] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[2:4]
	2: register[284:4] = INT_ZEXT register[284:2]
	3: register[102:2] = LOAD const[ram:8], register[10:4]
	4: register[10:4] = INT_ADD register[10:4], const[2:4]
	5: register[280:2] = LOAD const[ram:8], register[10:4]
	6: register[10:4] = INT_ADD register[10:4], const[2:4]
	7: RETURN register[284:4]

Line ia.sinc:2827 :IRETD          is vexMode=0 & addrsize=1 & opsize=1 & byte=0xcf            { pop44(EIP); tmp:4=0; pop44(tmp); CS=tmp(0); pop44(eflags); return [EIP]; }
0: Constructor line ia.sinc:2827(id0.219) printpiece=[IRETD]
Operands 
Pattern id=219 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:CF:XX:XX:XX)
Template
	0: register[284:4] = LOAD const[ram:8], register[10:4]
	1: register[10:4] = INT_ADD register[10:4], const[4:4]
	2: unique[2a980:4] = COPY const[0:4]
	3: unique[2a980:4] = LOAD const[ram:8], register[10:4]
	4: register[10:4] = INT_ADD register[10:4], const[4:4]
	5: register[102:2] = SUBPIECE unique[2a980:4], const[0:4]
	6: register[280:4] = LOAD const[ram:8], register[10:4]
	7: register[10:4] = INT_ADD register[10:4], const[4:4]
	8: RETURN register[284:4]

Line ia.sinc:3509 :ROL  rm8,n1        is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=0 ...           { CF = rm8 s< 0; rm8 = (rm8 << 1) | CF; OF = CF ^ (rm8 s< 0); }
0: Constructor line ia.sinc:3509(id0.475) printpiece=[ROL,  ,  A, ,,  B]
Operands 0: rm8 : 2164  1: n1 : 2165  
Pattern id=475 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D0:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	3: unique[38200:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[38200:[handle:size]], register[200:1]
	5: unique[38300:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[20b:1] = INT_XOR register[200:1], unique[38300:1]

Line ia.sinc:3524 :ROR  rm8,n1        is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=1 ...           { CF = rm8 & 1; rm8 = (rm8 >> 1) | (CF << 7); OF = ((rm8 & 0x40) != 0) ^ (rm8 s< 0); }
0: Constructor line ia.sinc:3524(id0.484) printpiece=[ROR,  ,  A, ,,  B]
Operands 0: rm8 : 2185  1: n1 : 2186  
Pattern id=484 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D0:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:1]
	3: unique[39f80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: unique[3a000:1] = INT_LEFT register[200:1], const[7:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[39f80:[handle:size]], unique[3a000:1]
	6: unique[3a100:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[40:[handle:size]]
	7: unique[3a180:1] = INT_NOTEQUAL unique[3a100:[handle:size]], const[0:[handle:size]]
	8: unique[3a200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	9: register[20b:1] = INT_XOR unique[3a180:1], unique[3a200:1]

Line ia.sinc:3405 :RCL  rm8,n1        is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=2 ...           { local tmpCF = CF; CF = rm8 s< 0; rm8 = (rm8 << 1) | tmpCF; OF = CF ^ (rm8 s< 0); }
0: Constructor line ia.sinc:3405(id0.436) printpiece=[RCL,  ,  A, ,,  B]
Operands 0: rm8 : 2106  1: n1 : 2107  
Pattern id=436 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D0:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[2fe00:1] = COPY register[200:1]
	3: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[2ff00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[2ff00:[handle:size]], unique[2fe00:1]
	6: unique[30000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[20b:1] = INT_XOR register[200:1], unique[30000:1]

Line ia.sinc:3420 :RCR  rm8,n1        is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=3 ...           { local tmpCF=CF; OF=rm8 s< 0; CF=(rm8&1)!=0; rm8=(rm8>>1)|(tmpCF<<7); OF=OF^(rm8 s< 0); }
0: Constructor line ia.sinc:3420(id0.445) printpiece=[RCR,  ,  A, ,,  B]
Operands 0: rm8 : 2127  1: n1 : 2128  
Pattern id=445 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D0:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[33400:1] = COPY register[200:1]
	3: register[20b:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[33500:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	5: register[200:1] = INT_NOTEQUAL unique[33500:[handle:size]], const[0:[handle:size]]
	6: unique[33600:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	7: unique[33680:1] = INT_LEFT unique[33400:1], const[7:4]
	8: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[33600:[handle:size]], unique[33680:1]
	9: unique[33780:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	10: register[20b:1] = INT_XOR register[20b:1], unique[33780:1]

Line ia.sinc:3635 :SHL  rm8,n1    is vexMode=0 & byte=0xD0;  rm8 & n1 &(reg_opcode=4|reg_opcode=6) ...               { CF = rm8 s< 0; rm8 = rm8 << 1; OF = CF ^ (rm8 s< 0); resultflags(rm8); }
0: Constructor line ia.sinc:3635(id0.525) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm8 : 2274  1: n1 : 2275  
Pattern id=525 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D0:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: unique[3dd80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[20b:1] = INT_XOR register[200:1], unique[3dd80:1]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3700 :SHR  rm8,n1    is vexMode=0 & byte=0xD0;  rm8 & n1 & reg_opcode=5 ...              { CF = rm8 & 1; OF = 0; rm8 = rm8 >> 1; resultflags(rm8); }
0: Constructor line ia.sinc:3700(id0.542) printpiece=[SHR,  ,  A, ,,  B]
Operands 0: rm8 : 2323  1: n1 : 2324  
Pattern id=542 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D0:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3635 :SHL  rm8,n1    is vexMode=0 & byte=0xD0;  rm8 & n1 &(reg_opcode=4|reg_opcode=6) ...               { CF = rm8 s< 0; rm8 = rm8 << 1; OF = CF ^ (rm8 s< 0); resultflags(rm8); }
0: Constructor line ia.sinc:3635(id0.525) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm8 : 2274  1: n1 : 2275  
Pattern id=525 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D0:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: unique[3dd80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[20b:1] = INT_XOR register[200:1], unique[3dd80:1]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3551 :SAR  rm8,n1    is vexMode=0 & byte=0xD0; rm8 & n1 & reg_opcode=7 ...               { CF = rm8 & 1; OF = 0; rm8 = rm8 s>> 1; resultflags(rm8); }
0: Constructor line ia.sinc:3551(id0.496) printpiece=[SAR,  ,  A, ,,  B]
Operands 0: rm8 : 2207  1: n1 : 2208  
Pattern id=496 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D0:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:1]
	3: register[20b:1] = COPY const[0:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	8: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	9: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	10: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:57 :VADDSUBPD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD0; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vaddsubpd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:57(id0.1555) printpiece=[VADDSUBPD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4439  1: vexVVVV_XmmReg : 4437  2: XmmReg1 : 4436  3: YmmReg1 : 4440  4: XmmReg2_m128 : 4438  
Pattern id=1555 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:D0:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a0480:10] = CALLOTHER const[100:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a0480:10]

Line avx.sinc:65 :VADDSUBPD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD0; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vaddsubpd_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:65(id0.1556) printpiece=[VADDSUBPD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4444  1: vexVVVV_YmmReg : 4442  2: YmmReg1 : 4441  3: YmmReg2_m256 : 4443  
Pattern id=1556 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:D0:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[100:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:73 :VADDSUBPS XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD0; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vaddsubps_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:73(id0.1557) printpiece=[VADDSUBPS,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4449  1: vexVVVV_XmmReg : 4447  2: XmmReg1 : 4446  3: YmmReg1 : 4450  4: XmmReg2_m128 : 4448  
Pattern id=1557 pattern=cmb:(ctx:SS:X[100x]:X[10xx]:[xx00][001x]:XX,ins:D0:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[a0680:10] = CALLOTHER const[101:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a0680:10]

Line avx.sinc:81 :VADDSUBPS YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD0; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vaddsubps_avx( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:81(id0.1558) printpiece=[VADDSUBPS,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4454  1: vexVVVV_YmmReg : 4452  2: YmmReg1 : 4451  3: YmmReg2_m256 : 4453  
Pattern id=1558 pattern=cmb:(ctx:SS:X[100x]:X[11xx]:[xx00][001x]:XX,ins:D0:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[101:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3512 :ROL rm16,n1       is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=0 ...   { CF = rm16 s< 0; rm16 = (rm16 << 1) | zext(CF); OF = CF ^ (rm16 s< 0); }
0: Constructor line ia.sinc:3512(id0.478) printpiece=[ROL,  ,  A, ,,  B]
Operands 0: rm16 : 2170  1: n1 : 2171  
Pattern id=478 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D1:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	3: unique[38c00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: unique[38c80:[handle:size]] = INT_ZEXT register[200:1]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[38c00:[handle:size]], unique[38c80:[handle:size]]
	6: unique[38d80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[20b:1] = INT_XOR register[200:1], unique[38d80:1]

Line ia.sinc:3515 :ROL rm32,n1        is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=0 ...   { CF = rm32 s< 0; rm32 = (rm32 << 1) | zext(CF); OF = CF ^ (rm32 s< 0); build check_rm32_dest; }
0: Constructor line ia.sinc:3515(id0.481) printpiece=[ROL,  ,  A, ,,  B]
Operands 0: rm32 : 2176  1: n1 : 2177  2: check_rm32_dest : 2178  
Pattern id=481 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D1:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	3: unique[39680:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: unique[39700:[handle:size]] = INT_ZEXT register[200:1]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[39680:[handle:size]], unique[39700:[handle:size]]
	6: unique[39800:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[20b:1] = INT_XOR register[200:1], unique[39800:1]
	8: MULTIEQUAL const[2:4]

Line ia.sinc:3527 :ROR rm16,n1        is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=1 ...   { CF=(rm16 & 1)!=0; rm16=(rm16>>1)|(zext(CF)<<15); OF=((rm16 & 0x4000) != 0) ^ (rm16 s< 0); }
0: Constructor line ia.sinc:3527(id0.487) printpiece=[ROR,  ,  A, ,,  B]
Operands 0: rm16 : 2191  1: n1 : 2192  
Pattern id=487 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D1:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3aa80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[200:1] = INT_NOTEQUAL unique[3aa80:[handle:size]], const[0:[handle:size]]
	4: unique[3ab80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	5: unique[3ac00:[handle:size]] = INT_ZEXT register[200:1]
	6: unique[3ac80:[handle:size]] = INT_LEFT unique[3ac00:[handle:size]], const[f:4]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3ab80:[handle:size]], unique[3ac80:[handle:size]]
	8: unique[3ad80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[4000:[handle:size]]
	9: unique[3ae00:1] = INT_NOTEQUAL unique[3ad80:[handle:size]], const[0:[handle:size]]
	10: unique[3ae80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[20b:1] = INT_XOR unique[3ae00:1], unique[3ae80:1]

Line ia.sinc:3530 :ROR rm32,n1        is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=1 ...   { CF=(rm32&1)!=0; rm32=(rm32>>1)|(zext(CF)<<31); OF=((rm32&0x40000000)!=0) ^ (rm32 s< 0); build check_rm32_dest; }
0: Constructor line ia.sinc:3530(id0.490) printpiece=[ROR,  ,  A, ,,  B]
Operands 0: rm32 : 2197  1: n1 : 2198  2: check_rm32_dest : 2199  
Pattern id=490 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D1:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3b700:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[200:1] = INT_NOTEQUAL unique[3b700:[handle:size]], const[0:[handle:size]]
	4: unique[3b800:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	5: unique[3b880:[handle:size]] = INT_ZEXT register[200:1]
	6: unique[3b900:[handle:size]] = INT_LEFT unique[3b880:[handle:size]], const[1f:4]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3b800:[handle:size]], unique[3b900:[handle:size]]
	8: unique[3ba00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[40000000:[handle:size]]
	9: unique[3ba80:1] = INT_NOTEQUAL unique[3ba00:[handle:size]], const[0:[handle:size]]
	10: unique[3bb00:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[20b:1] = INT_XOR unique[3ba80:1], unique[3bb00:1]
	12: MULTIEQUAL const[2:4]

Line ia.sinc:3408 :RCL rm16,n1        is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=2 ...   { local tmpCF = CF; CF = rm16 s< 0; rm16 = (rm16 << 1) | zext(tmpCF); OF = CF ^ (rm16 s< 0);}
0: Constructor line ia.sinc:3408(id0.439) printpiece=[RCL,  ,  A, ,,  B]
Operands 0: rm16 : 2112  1: n1 : 2113  
Pattern id=439 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D1:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[31000:1] = COPY register[200:1]
	3: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[31100:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	5: unique[31180:[handle:size]] = INT_ZEXT unique[31000:1]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[31100:[handle:size]], unique[31180:[handle:size]]
	7: unique[31280:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: register[20b:1] = INT_XOR register[200:1], unique[31280:1]

Line ia.sinc:3411 :RCL rm32,n1        is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=2 ...   { local tmpCF=CF; CF=rm32 s< 0; rm32=(rm32<<1)|zext(tmpCF); OF=CF^(rm32 s< 0); build check_rm32_dest; }
0: Constructor line ia.sinc:3411(id0.442) printpiece=[RCL,  ,  A, ,,  B]
Operands 0: rm32 : 2118  1: n1 : 2119  2: check_rm32_dest : 2120  
Pattern id=442 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D1:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[32280:1] = COPY register[200:1]
	3: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[32380:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	5: unique[32400:[handle:size]] = INT_ZEXT unique[32280:1]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[32380:[handle:size]], unique[32400:[handle:size]]
	7: unique[32500:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: register[20b:1] = INT_XOR register[200:1], unique[32500:1]
	9: MULTIEQUAL const[2:4]

Line ia.sinc:3423 :RCR rm16,n1        is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=3 ...   { local tmpCF=CF; OF=rm16 s< 0; CF=(rm16&1)!=0; rm16=(rm16>>1)|(zext(tmpCF)<<15); OF=OF^(rm16 s< 0); }
0: Constructor line ia.sinc:3423(id0.448) printpiece=[RCR,  ,  A, ,,  B]
Operands 0: rm16 : 2133  1: n1 : 2134  
Pattern id=448 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D1:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[34780:1] = COPY register[200:1]
	3: register[20b:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[34880:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	5: register[200:1] = INT_NOTEQUAL unique[34880:[handle:size]], const[0:[handle:size]]
	6: unique[34980:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	7: unique[34a00:[handle:size]] = INT_ZEXT unique[34780:1]
	8: unique[34a80:[handle:size]] = INT_LEFT unique[34a00:[handle:size]], const[f:4]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[34980:[handle:size]], unique[34a80:[handle:size]]
	10: unique[34b80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[20b:1] = INT_XOR register[20b:1], unique[34b80:1]

Line ia.sinc:3426 :RCR rm32,n1        is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=3 ...   { local tmpCF=CF; OF=rm32 s< 0; CF=(rm32&1)!=0; rm32=(rm32>>1)|(zext(tmpCF)<<31); OF=OF^(rm32 s< 0); build check_rm32_dest; }
0: Constructor line ia.sinc:3426(id0.451) printpiece=[RCR,  ,  A, ,,  B]
Operands 0: rm32 : 2139  1: n1 : 2140  2: check_rm32_dest : 2141  
Pattern id=451 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D1:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[35b80:1] = COPY register[200:1]
	3: register[20b:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: unique[35c80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	5: register[200:1] = INT_NOTEQUAL unique[35c80:[handle:size]], const[0:[handle:size]]
	6: unique[35d80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	7: unique[35e00:[handle:size]] = INT_ZEXT unique[35b80:1]
	8: unique[35e80:[handle:size]] = INT_LEFT unique[35e00:[handle:size]], const[1f:4]
	9: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[35d80:[handle:size]], unique[35e80:[handle:size]]
	10: unique[35f80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[20b:1] = INT_XOR register[20b:1], unique[35f80:1]
	12: MULTIEQUAL const[2:4]

Line ia.sinc:3640 :SHL rm16,n1    is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & (reg_opcode=4|reg_opcode=6) ...       { CF = rm16 s< 0; rm16 = rm16 << 1; OF = CF ^ (rm16 s< 0); resultflags(rm16); }
0: Constructor line ia.sinc:3640(id0.528) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm16 : 2280  1: n1 : 2281  
Pattern id=528 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D1:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: unique[3e380:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[20b:1] = INT_XOR register[200:1], unique[3e380:1]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3645 :SHL rm32,n1    is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & (reg_opcode=4|reg_opcode=6) ...       { CF = rm32 s< 0; rm32 = rm32 << 1; OF = CF ^ (rm32 s< 0); build check_rm32_dest; resultflags(rm32); }
0: Constructor line ia.sinc:3645(id0.531) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm32 : 2286  1: n1 : 2287  2: check_rm32_dest : 2288  
Pattern id=531 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D1:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: unique[3e980:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[20b:1] = INT_XOR register[200:1], unique[3e980:1]
	6: MULTIEQUAL const[2:4]
	7: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	9: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	10: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	11: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	12: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3705 :SHR rm16,n1    is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=5 ...       { CF = (rm16 & 1) != 0; OF = 0; rm16 = rm16 >> 1; resultflags(rm16); }
0: Constructor line ia.sinc:3705(id0.545) printpiece=[SHR,  ,  A, ,,  B]
Operands 0: rm16 : 2329  1: n1 : 2330  
Pattern id=545 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D1:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[40f80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[200:1] = INT_NOTEQUAL unique[40f80:[handle:size]], const[0:[handle:size]]
	4: register[20b:1] = COPY const[0:1]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3710 :SHR rm32,n1    is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=5 ...        { CF = (rm32 & 1) != 0; OF = 0; rm32 = rm32 >> 1; build check_rm32_dest; resultflags(rm32); }
0: Constructor line ia.sinc:3710(id0.548) printpiece=[SHR,  ,  A, ,,  B]
Operands 0: rm32 : 2335  1: n1 : 2336  2: check_rm32_dest : 2337  
Pattern id=548 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D1:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[41500:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[200:1] = INT_NOTEQUAL unique[41500:[handle:size]], const[0:[handle:size]]
	4: register[20b:1] = COPY const[0:1]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	6: MULTIEQUAL const[2:4]
	7: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	9: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	10: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	11: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	12: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3640 :SHL rm16,n1    is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & (reg_opcode=4|reg_opcode=6) ...       { CF = rm16 s< 0; rm16 = rm16 << 1; OF = CF ^ (rm16 s< 0); resultflags(rm16); }
0: Constructor line ia.sinc:3640(id0.528) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm16 : 2280  1: n1 : 2281  
Pattern id=528 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D1:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: unique[3e380:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[20b:1] = INT_XOR register[200:1], unique[3e380:1]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3645 :SHL rm32,n1    is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & (reg_opcode=4|reg_opcode=6) ...       { CF = rm32 s< 0; rm32 = rm32 << 1; OF = CF ^ (rm32 s< 0); build check_rm32_dest; resultflags(rm32); }
0: Constructor line ia.sinc:3645(id0.531) printpiece=[SHL,  ,  A, ,,  B]
Operands 0: rm32 : 2286  1: n1 : 2287  2: check_rm32_dest : 2288  
Pattern id=531 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D1:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: register[200:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	4: unique[3e980:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[20b:1] = INT_XOR register[200:1], unique[3e980:1]
	6: MULTIEQUAL const[2:4]
	7: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	9: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	10: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	11: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	12: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3556 :SAR rm16,n1    is vexMode=0 & opsize=0 & byte=0xD1; rm16 & n1 & reg_opcode=7 ...       { CF = (rm16 & 1) != 0; OF = 0; rm16 = rm16 s>> 1; resultflags(rm16); }
0: Constructor line ia.sinc:3556(id0.499) printpiece=[SAR,  ,  A, ,,  B]
Operands 0: rm16 : 2213  1: n1 : 2214  
Pattern id=499 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D1:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3cd80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[200:1] = INT_NOTEQUAL unique[3cd80:[handle:size]], const[0:[handle:size]]
	4: register[20b:1] = COPY const[0:1]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	9: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	10: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	11: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3561 :SAR rm32,n1    is vexMode=0 & opsize=1 & byte=0xD1; rm32 & n1 & check_rm32_dest ... & reg_opcode=7 ...       { CF = (rm32 & 1) != 0; OF = 0; rm32 = rm32 s>> 1; build check_rm32_dest; resultflags(rm32); }
0: Constructor line ia.sinc:3561(id0.502) printpiece=[SAR,  ,  A, ,,  B]
Operands 0: rm32 : 2219  1: n1 : 2220  2: check_rm32_dest : 2221  
Pattern id=502 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D1:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3d300:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[200:1] = INT_NOTEQUAL unique[3d300:[handle:size]], const[0:[handle:size]]
	4: register[20b:1] = COPY const[0:1]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	6: MULTIEQUAL const[2:4]
	7: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	9: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	10: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	11: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	12: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2541 :VPSRLW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD1; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrlw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2541(id0.1809) printpiece=[VPSRLW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5720  1: vexVVVV_XmmReg : 5718  2: XmmReg1 : 5717  3: YmmReg1 : 5721  4: XmmReg2_m128 : 5719  
Pattern id=1809 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:D1:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b2680:10] = CALLOTHER const[1b7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b2680:10]

Line avx2.sinc:723 :VPSRLW YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD1; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsrlw_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:723(id0.2016) printpiece=[VPSRLW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6681  1: vexVVVV_YmmReg : 6679  2: YmmReg1 : 6678  3: XmmReg2_m128 : 6680  
Pattern id=2016 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:D1:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3510 :ROL  rm8,CL        is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=0 ...       { local cnt = CL & 0x7; local count_and_mask = CL & 0x1f;rm8 = (rm8 << cnt) | (rm8 >> (8 - cnt)); rolflags(rm8, count_and_mask);}
0: Constructor line ia.sinc:3510(id0.476) printpiece=[ROL,  ,  B, ,,  A]
Operands 0: CL : 2167  1: rm8 : 2166  
Pattern id=476 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D2:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[38480:1] = INT_AND register[4:1], const[7:1]
	2: unique[38580:1] = INT_AND register[4:1], const[1f:1]
	3: unique[38600:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[38480:1]
	4: unique[38680:1] = INT_SUB const[8:1], unique[38480:1]
	5: unique[38700:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[38680:1]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[38600:[handle:size]], unique[38700:[handle:size]]
	7: unique[ee00:1] = INT_NOTEQUAL unique[38580:1], const[0:1]
	8: unique[ee80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	9: unique[ef80:1] = INT_NOTEQUAL unique[ee80:[handle:size]], const[0:[handle:size]]
	10: unique[f000:1] = BOOL_NEGATE unique[ee00:1]
	11: unique[f080:1] = INT_AND unique[f000:1], register[200:1]
	12: unique[f100:1] = INT_AND unique[ee00:1], unique[ef80:1]
	13: register[200:1] = INT_OR unique[f080:1], unique[f100:1]
	14: unique[f280:1] = INT_EQUAL unique[38580:1], const[1:1]
	15: unique[f300:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	16: unique[f400:1] = INT_XOR register[200:1], unique[f300:1]
	17: unique[f480:1] = BOOL_NEGATE unique[f280:1]
	18: unique[f500:1] = INT_AND unique[f480:1], register[20b:1]
	19: unique[f580:1] = INT_AND unique[f280:1], unique[f400:1]
	20: register[20b:1] = INT_OR unique[f500:1], unique[f580:1]

Line ia.sinc:3525 :ROR  rm8,CL        is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=1 ...       { local cnt = CL & 0x7; local count_and_mask = CL & 0x1f;rm8 = (rm8 >> cnt) | (rm8 << (8 - cnt)); rorflags(rm8,count_and_mask);}
0: Constructor line ia.sinc:3525(id0.485) printpiece=[ROR,  ,  B, ,,  A]
Operands 0: CL : 2188  1: rm8 : 2187  
Pattern id=485 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D2:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3a380:1] = INT_AND register[4:1], const[7:1]
	2: unique[3a480:1] = INT_AND register[4:1], const[1f:1]
	3: unique[3a500:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3a380:1]
	4: unique[3a580:1] = INT_SUB const[8:1], unique[3a380:1]
	5: unique[3a600:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3a580:1]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3a500:[handle:size]], unique[3a600:[handle:size]]
	7: unique[f700:1] = INT_NOTEQUAL unique[3a480:1], const[0:1]
	8: unique[f800:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	9: unique[f880:1] = BOOL_NEGATE unique[f700:1]
	10: unique[f900:1] = INT_AND unique[f880:1], register[200:1]
	11: unique[f980:1] = INT_AND unique[f700:1], unique[f800:1]
	12: register[200:1] = INT_OR unique[f900:1], unique[f980:1]
	13: unique[fb00:1] = INT_EQUAL unique[3a480:1], const[1:1]
	14: unique[fb80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[fc00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	16: unique[fc80:1] = INT_SLESS unique[fc00:[handle:size]], const[0:[handle:size]]
	17: unique[fd80:1] = INT_XOR unique[fb80:1], unique[fc80:1]
	18: unique[fe00:1] = BOOL_NEGATE unique[fb00:1]
	19: unique[fe80:1] = INT_AND unique[fe00:1], register[20b:1]
	20: unique[ff00:1] = INT_AND unique[fb00:1], unique[fd80:1]
	21: register[20b:1] = INT_OR unique[fe80:1], unique[ff00:1]

Line ia.sinc:3406 :RCL  rm8,CL        is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=2 ...       { local cnt=(CL&0x1f)%9; tmp:2=(zext(CF)<<8)|zext(rm8); tmp=(tmp<<cnt)|(tmp>>(9-cnt));rm8=tmp(0); CF=(tmp&0x100)!=0; }
0: Constructor line ia.sinc:3406(id0.437) printpiece=[RCL,  ,  B, ,,  A]
Operands 0: CL : 2109  1: rm8 : 2108  
Pattern id=437 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D2:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[30100:1] = INT_AND register[4:1], const[1f:1]
	2: unique[30200:1] = INT_REM unique[30100:1], const[9:1]
	3: unique[30280:2] = INT_ZEXT register[200:1]
	4: unique[30300:2] = INT_LEFT unique[30280:2], const[8:4]
	5: unique[30380:2] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	6: unique[30480:2] = INT_OR unique[30300:2], unique[30380:2]
	7: unique[30500:2] = INT_LEFT unique[30480:2], unique[30200:1]
	8: unique[30580:1] = INT_SUB const[9:1], unique[30200:1]
	9: unique[30600:2] = INT_RIGHT unique[30480:2], unique[30580:1]
	10: unique[30480:2] = INT_OR unique[30500:2], unique[30600:2]
	11: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[30480:2], const[0:4]
	12: unique[30780:2] = INT_AND unique[30480:2], const[100:2]
	13: register[200:1] = INT_NOTEQUAL unique[30780:2], const[0:2]

Line ia.sinc:3421 :RCR  rm8,CL        is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=3 ...       { local cnt=(CL&0x1f)%9; tmp:2=(zext(CF)<<8)|zext(rm8); tmp=(tmp>>cnt)|(tmp<<(9-cnt)); rm8=tmp(0); CF=(tmp&0x100)!=0; }
0: Constructor line ia.sinc:3421(id0.446) printpiece=[RCR,  ,  B, ,,  A]
Operands 0: CL : 2130  1: rm8 : 2129  
Pattern id=446 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D2:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[33880:1] = INT_AND register[4:1], const[1f:1]
	2: unique[33980:1] = INT_REM unique[33880:1], const[9:1]
	3: unique[33a00:2] = INT_ZEXT register[200:1]
	4: unique[33a80:2] = INT_LEFT unique[33a00:2], const[8:4]
	5: unique[33b00:2] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	6: unique[33c00:2] = INT_OR unique[33a80:2], unique[33b00:2]
	7: unique[33c80:2] = INT_RIGHT unique[33c00:2], unique[33980:1]
	8: unique[33d00:1] = INT_SUB const[9:1], unique[33980:1]
	9: unique[33d80:2] = INT_LEFT unique[33c00:2], unique[33d00:1]
	10: unique[33c00:2] = INT_OR unique[33c80:2], unique[33d80:2]
	11: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[33c00:2], const[0:4]
	12: unique[33f00:2] = INT_AND unique[33c00:2], const[100:2]
	13: register[200:1] = INT_NOTEQUAL unique[33f00:2], const[0:2]

Line ia.sinc:3636 :SHL  rm8,CL    is vexMode=0 & byte=0xD2;  CL & rm8 & (reg_opcode=4|reg_opcode=6) ...          { local count =   CL & 0x1f; local tmp = rm8; rm8 = rm8 << count;
                                          shlflags(tmp, rm8,count); shiftresultflags(rm8,count); }
0: Constructor line ia.sinc:3636(id0.526) printpiece=[SHL,  ,  B, ,,  A]
Operands 0: CL : 2277  1: rm8 : 2276  
Pattern id=526 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D2:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3df00:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3df80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3df00:1]
	4: unique[10080:1] = INT_NOTEQUAL unique[3df00:1], const[0:1]
	5: unique[10100:1] = INT_SUB unique[3df00:1], const[1:1]
	6: unique[10180:[handle:size]] = INT_LEFT unique[3df80:[handle:size]], unique[10100:1]
	7: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	8: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	9: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	10: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	11: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	12: unique[10580:1] = INT_EQUAL unique[3df00:1], const[1:1]
	13: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	15: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	16: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	17: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	18: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[3df00:1], const[0:1]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3701 :SHR  rm8,CL    is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=5 ...           { local count =   CL & 0x1f; local tmp = rm8; rm8 = rm8 >> count;
                                          shrflags(tmp, rm8,count); shiftresultflags(rm8,count); }
0: Constructor line ia.sinc:3701(id0.543) printpiece=[SHR,  ,  B, ,,  A]
Operands 0: CL : 2326  1: rm8 : 2325  
Pattern id=543 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D2:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[40c00:1] = INT_AND register[4:1], const[1f:1]
	2: unique[40c80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[40c00:1]
	4: unique[11180:1] = INT_NOTEQUAL unique[40c00:1], const[0:1]
	5: unique[11200:1] = INT_SUB unique[40c00:1], const[1:1]
	6: unique[11280:[handle:size]] = INT_RIGHT unique[40c80:[handle:size]], unique[11200:1]
	7: unique[11300:[handle:size]] = INT_AND unique[11280:[handle:size]], const[1:[handle:size]]
	8: unique[11400:1] = INT_NOTEQUAL unique[11300:[handle:size]], const[0:[handle:size]]
	9: unique[11480:1] = BOOL_NEGATE unique[11180:1]
	10: unique[11500:1] = INT_AND unique[11480:1], register[200:1]
	11: unique[11580:1] = INT_AND unique[11180:1], unique[11400:1]
	12: register[200:1] = INT_OR unique[11500:1], unique[11580:1]
	13: unique[11700:1] = INT_EQUAL unique[40c00:1], const[1:1]
	14: unique[11800:1] = INT_SLESS unique[40c80:[handle:size]], const[0:[handle:size]]
	15: unique[11880:1] = BOOL_NEGATE unique[11700:1]
	16: unique[11900:1] = INT_AND unique[11880:1], register[20b:1]
	17: unique[11980:1] = INT_AND unique[11700:1], unique[11800:1]
	18: register[20b:1] = INT_OR unique[11900:1], unique[11980:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[40c00:1], const[0:1]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3636 :SHL  rm8,CL    is vexMode=0 & byte=0xD2;  CL & rm8 & (reg_opcode=4|reg_opcode=6) ...          { local count =   CL & 0x1f; local tmp = rm8; rm8 = rm8 << count;
                                          shlflags(tmp, rm8,count); shiftresultflags(rm8,count); }
0: Constructor line ia.sinc:3636(id0.526) printpiece=[SHL,  ,  B, ,,  A]
Operands 0: CL : 2277  1: rm8 : 2276  
Pattern id=526 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D2:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3df00:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3df80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3df00:1]
	4: unique[10080:1] = INT_NOTEQUAL unique[3df00:1], const[0:1]
	5: unique[10100:1] = INT_SUB unique[3df00:1], const[1:1]
	6: unique[10180:[handle:size]] = INT_LEFT unique[3df80:[handle:size]], unique[10100:1]
	7: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	8: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	9: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	10: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	11: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	12: unique[10580:1] = INT_EQUAL unique[3df00:1], const[1:1]
	13: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	15: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	16: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	17: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	18: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[3df00:1], const[0:1]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3552 :SAR  rm8,CL    is vexMode=0 & byte=0xD2; CL & rm8 & reg_opcode=7 ...           { local count =   CL & 0x1f; local tmp = rm8; rm8 = rm8 s>> count;
                                          sarflags(tmp, rm8,count); shiftresultflags(rm8,count); }
0: Constructor line ia.sinc:3552(id0.497) printpiece=[SAR,  ,  B, ,,  A]
Operands 0: CL : 2210  1: rm8 : 2209  
Pattern id=497 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D2:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3ca00:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3ca80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], unique[3ca00:1]
	4: unique[10a00:1] = INT_NOTEQUAL unique[3ca00:1], const[0:1]
	5: unique[10a80:1] = INT_SUB unique[3ca00:1], const[1:1]
	6: unique[10b00:[handle:size]] = INT_SRIGHT unique[3ca80:[handle:size]], unique[10a80:1]
	7: unique[10b80:[handle:size]] = INT_AND unique[10b00:[handle:size]], const[1:[handle:size]]
	8: unique[10c80:1] = INT_NOTEQUAL unique[10b80:[handle:size]], const[0:[handle:size]]
	9: unique[10d00:1] = BOOL_NEGATE unique[10a00:1]
	10: unique[10d80:1] = INT_AND unique[10d00:1], register[200:1]
	11: unique[10e00:1] = INT_AND unique[10a00:1], unique[10c80:1]
	12: register[200:1] = INT_OR unique[10d80:1], unique[10e00:1]
	13: unique[10f80:1] = INT_EQUAL unique[3ca00:1], const[1:1]
	14: unique[11000:1] = BOOL_NEGATE unique[10f80:1]
	15: register[20b:1] = INT_AND unique[11000:1], register[20b:1]
	16: unique[df00:1] = INT_NOTEQUAL unique[3ca00:1], const[0:1]
	17: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	18: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	19: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	20: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	21: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	22: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	23: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	24: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	25: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	26: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	27: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	28: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	29: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	30: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	31: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	32: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	33: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	34: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line avx.sinc:2556 :VPSRLD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrld_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2556(id0.1811) printpiece=[VPSRLD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5730  1: vexVVVV_XmmReg : 5728  2: XmmReg1 : 5727  3: YmmReg1 : 5731  4: XmmReg2_m128 : 5729  
Pattern id=1811 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:D2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b2880:10] = CALLOTHER const[1b8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b2880:10]

Line avx2.sinc:737 :VPSRLD YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD2; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsrld_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:737(id0.2018) printpiece=[VPSRLD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6690  1: vexVVVV_YmmReg : 6688  2: YmmReg1 : 6687  3: XmmReg2_m128 : 6689  
Pattern id=2018 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:D2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3513 :ROL rm16,CL        is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=0 ...   { local cnt =   CL & 0xf; local count_and_mask = CL & 0x1f;rm16 = (rm16 << cnt) | (rm16 >> (16 - cnt)); rolflags(rm16,count_and_mask);}
0: Constructor line ia.sinc:3513(id0.479) printpiece=[ROL,  ,  B, ,,  A]
Operands 0: CL : 2173  1: rm16 : 2172  
Pattern id=479 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D3:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[38f00:1] = INT_AND register[4:1], const[f:1]
	2: unique[39000:1] = INT_AND register[4:1], const[1f:1]
	3: unique[39080:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[38f00:1]
	4: unique[39100:1] = INT_SUB const[10:1], unique[38f00:1]
	5: unique[39180:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[39100:1]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[39080:[handle:size]], unique[39180:[handle:size]]
	7: unique[ee00:1] = INT_NOTEQUAL unique[39000:1], const[0:1]
	8: unique[ee80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	9: unique[ef80:1] = INT_NOTEQUAL unique[ee80:[handle:size]], const[0:[handle:size]]
	10: unique[f000:1] = BOOL_NEGATE unique[ee00:1]
	11: unique[f080:1] = INT_AND unique[f000:1], register[200:1]
	12: unique[f100:1] = INT_AND unique[ee00:1], unique[ef80:1]
	13: register[200:1] = INT_OR unique[f080:1], unique[f100:1]
	14: unique[f280:1] = INT_EQUAL unique[39000:1], const[1:1]
	15: unique[f300:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	16: unique[f400:1] = INT_XOR register[200:1], unique[f300:1]
	17: unique[f480:1] = BOOL_NEGATE unique[f280:1]
	18: unique[f500:1] = INT_AND unique[f480:1], register[20b:1]
	19: unique[f580:1] = INT_AND unique[f280:1], unique[f400:1]
	20: register[20b:1] = INT_OR unique[f500:1], unique[f580:1]

Line ia.sinc:3516 :ROL rm32,CL        is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=0 ...   { local cnt =   CL & 0x1f; rm32 = (rm32 << cnt) | (rm32 >> (32 - cnt)); rolflags(rm32,cnt); build check_rm32_dest; }
0: Constructor line ia.sinc:3516(id0.482) printpiece=[ROL,  ,  B, ,,  A]
Operands 0: CL : 2180  1: rm32 : 2179  2: check_rm32_dest : 2181  
Pattern id=482 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D3:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[39980:1] = INT_AND register[4:1], const[1f:1]
	2: unique[39a00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[39980:1]
	3: unique[39a80:1] = INT_SUB const[20:1], unique[39980:1]
	4: unique[39b00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[39a80:1]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[39a00:[handle:size]], unique[39b00:[handle:size]]
	6: unique[ee00:1] = INT_NOTEQUAL unique[39980:1], const[0:1]
	7: unique[ee80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	8: unique[ef80:1] = INT_NOTEQUAL unique[ee80:[handle:size]], const[0:[handle:size]]
	9: unique[f000:1] = BOOL_NEGATE unique[ee00:1]
	10: unique[f080:1] = INT_AND unique[f000:1], register[200:1]
	11: unique[f100:1] = INT_AND unique[ee00:1], unique[ef80:1]
	12: register[200:1] = INT_OR unique[f080:1], unique[f100:1]
	13: unique[f280:1] = INT_EQUAL unique[39980:1], const[1:1]
	14: unique[f300:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[f400:1] = INT_XOR register[200:1], unique[f300:1]
	16: unique[f480:1] = BOOL_NEGATE unique[f280:1]
	17: unique[f500:1] = INT_AND unique[f480:1], register[20b:1]
	18: unique[f580:1] = INT_AND unique[f280:1], unique[f400:1]
	19: register[20b:1] = INT_OR unique[f500:1], unique[f580:1]
	20: MULTIEQUAL const[2:4]

Line ia.sinc:3528 :ROR rm16,CL        is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=1 ...   { local cnt = CL & 0xf; local count_and_mask = CL & 0x1f; rm16 = (rm16 >> cnt) | (rm16 << (16 - cnt)); rorflags(rm16,count_and_mask);}
0: Constructor line ia.sinc:3528(id0.488) printpiece=[ROR,  ,  B, ,,  A]
Operands 0: CL : 2194  1: rm16 : 2193  
Pattern id=488 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D3:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3b000:1] = INT_AND register[4:1], const[f:1]
	2: unique[3b100:1] = INT_AND register[4:1], const[1f:1]
	3: unique[3b180:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3b000:1]
	4: unique[3b200:1] = INT_SUB const[10:1], unique[3b000:1]
	5: unique[3b280:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3b200:1]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3b180:[handle:size]], unique[3b280:[handle:size]]
	7: unique[f700:1] = INT_NOTEQUAL unique[3b100:1], const[0:1]
	8: unique[f800:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	9: unique[f880:1] = BOOL_NEGATE unique[f700:1]
	10: unique[f900:1] = INT_AND unique[f880:1], register[200:1]
	11: unique[f980:1] = INT_AND unique[f700:1], unique[f800:1]
	12: register[200:1] = INT_OR unique[f900:1], unique[f980:1]
	13: unique[fb00:1] = INT_EQUAL unique[3b100:1], const[1:1]
	14: unique[fb80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[fc00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	16: unique[fc80:1] = INT_SLESS unique[fc00:[handle:size]], const[0:[handle:size]]
	17: unique[fd80:1] = INT_XOR unique[fb80:1], unique[fc80:1]
	18: unique[fe00:1] = BOOL_NEGATE unique[fb00:1]
	19: unique[fe80:1] = INT_AND unique[fe00:1], register[20b:1]
	20: unique[ff00:1] = INT_AND unique[fb00:1], unique[fd80:1]
	21: register[20b:1] = INT_OR unique[fe80:1], unique[ff00:1]

Line ia.sinc:3531 :ROR rm32,CL        is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=1 ...   { local cnt =   CL & 0x1f; rm32 = (rm32 >> cnt) | (rm32 << (32 - cnt)); rorflags(rm32,cnt); build check_rm32_dest; }
0: Constructor line ia.sinc:3531(id0.491) printpiece=[ROR,  ,  B, ,,  A]
Operands 0: CL : 2201  1: rm32 : 2200  2: check_rm32_dest : 2202  
Pattern id=491 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D3:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3bc80:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3bd00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[3bc80:1]
	3: unique[3bd80:1] = INT_SUB const[20:1], unique[3bc80:1]
	4: unique[3be00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3bd80:1]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[3bd00:[handle:size]], unique[3be00:[handle:size]]
	6: unique[f700:1] = INT_NOTEQUAL unique[3bc80:1], const[0:1]
	7: unique[f800:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: unique[f880:1] = BOOL_NEGATE unique[f700:1]
	9: unique[f900:1] = INT_AND unique[f880:1], register[200:1]
	10: unique[f980:1] = INT_AND unique[f700:1], unique[f800:1]
	11: register[200:1] = INT_OR unique[f900:1], unique[f980:1]
	12: unique[fb00:1] = INT_EQUAL unique[3bc80:1], const[1:1]
	13: unique[fb80:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[fc00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], const[1:4]
	15: unique[fc80:1] = INT_SLESS unique[fc00:[handle:size]], const[0:[handle:size]]
	16: unique[fd80:1] = INT_XOR unique[fb80:1], unique[fc80:1]
	17: unique[fe00:1] = BOOL_NEGATE unique[fb00:1]
	18: unique[fe80:1] = INT_AND unique[fe00:1], register[20b:1]
	19: unique[ff00:1] = INT_AND unique[fb00:1], unique[fd80:1]
	20: register[20b:1] = INT_OR unique[fe80:1], unique[ff00:1]
	21: MULTIEQUAL const[2:4]

Line ia.sinc:3409 :RCL rm16,CL        is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=2 ...   {local cnt=(CL&0x1f)%17; tmp:4=(zext(CF)<<16)|zext(rm16); tmp=(tmp<<cnt)|(tmp>>(17-cnt)); rm16=tmp(0); CF=(tmp&0x10000)!=0; }
0: Constructor line ia.sinc:3409(id0.440) printpiece=[RCL,  ,  B, ,,  A]
Operands 0: CL : 2115  1: rm16 : 2114  
Pattern id=440 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D3:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[31380:1] = INT_AND register[4:1], const[1f:1]
	2: unique[31480:1] = INT_REM unique[31380:1], const[11:1]
	3: unique[31500:4] = INT_ZEXT register[200:1]
	4: unique[31580:4] = INT_LEFT unique[31500:4], const[10:4]
	5: unique[31600:4] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	6: unique[31700:4] = INT_OR unique[31580:4], unique[31600:4]
	7: unique[31780:4] = INT_LEFT unique[31700:4], unique[31480:1]
	8: unique[31800:1] = INT_SUB const[11:1], unique[31480:1]
	9: unique[31880:4] = INT_RIGHT unique[31700:4], unique[31800:1]
	10: unique[31700:4] = INT_OR unique[31780:4], unique[31880:4]
	11: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[31700:4], const[0:4]
	12: unique[31a00:4] = INT_AND unique[31700:4], const[10000:4]
	13: register[200:1] = INT_NOTEQUAL unique[31a00:4], const[0:4]

Line ia.sinc:3412 :RCL rm32,CL        is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=2 ...   { local cnt=CL&0x1f; tmp:8=(zext(CF)<<32)|zext(rm32); tmp=(tmp<<cnt)|(tmp>>(33-cnt)); rm32=tmp(0); CF=(tmp&0x100000000)!=0; build check_rm32_dest; }
0: Constructor line ia.sinc:3412(id0.443) printpiece=[RCL,  ,  B, ,,  A]
Operands 0: CL : 2122  1: rm32 : 2121  2: check_rm32_dest : 2123  
Pattern id=443 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D3:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[32680:1] = INT_AND register[4:1], const[1f:1]
	2: unique[32700:8] = INT_ZEXT register[200:1]
	3: unique[32780:8] = INT_LEFT unique[32700:8], const[20:4]
	4: unique[32800:8] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[32900:8] = INT_OR unique[32780:8], unique[32800:8]
	6: unique[32980:8] = INT_LEFT unique[32900:8], unique[32680:1]
	7: unique[32a00:1] = INT_SUB const[21:1], unique[32680:1]
	8: unique[32a80:8] = INT_RIGHT unique[32900:8], unique[32a00:1]
	9: unique[32900:8] = INT_OR unique[32980:8], unique[32a80:8]
	10: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[32900:8], const[0:4]
	11: unique[32c00:8] = INT_AND unique[32900:8], const[100000000:8]
	12: register[200:1] = INT_NOTEQUAL unique[32c00:8], const[0:8]
	13: MULTIEQUAL const[2:4]

Line ia.sinc:3424 :RCR rm16,CL        is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=3 ...   { local cnt=(CL&0x1f)%17; tmp:4=(zext(CF)<<16)|zext(rm16); tmp=(tmp>>cnt)|(tmp<<(17-cnt)); rm16=tmp(0); CF=(tmp&0x10000)!=0; }
0: Constructor line ia.sinc:3424(id0.449) printpiece=[RCR,  ,  B, ,,  A]
Operands 0: CL : 2136  1: rm16 : 2135  
Pattern id=449 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D3:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[34c80:1] = INT_AND register[4:1], const[1f:1]
	2: unique[34d80:1] = INT_REM unique[34c80:1], const[11:1]
	3: unique[34e00:4] = INT_ZEXT register[200:1]
	4: unique[34e80:4] = INT_LEFT unique[34e00:4], const[10:4]
	5: unique[34f00:4] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	6: unique[35000:4] = INT_OR unique[34e80:4], unique[34f00:4]
	7: unique[35080:4] = INT_RIGHT unique[35000:4], unique[34d80:1]
	8: unique[35100:1] = INT_SUB const[11:1], unique[34d80:1]
	9: unique[35180:4] = INT_LEFT unique[35000:4], unique[35100:1]
	10: unique[35000:4] = INT_OR unique[35080:4], unique[35180:4]
	11: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[35000:4], const[0:4]
	12: unique[35300:4] = INT_AND unique[35000:4], const[10000:4]
	13: register[200:1] = INT_NOTEQUAL unique[35300:4], const[0:4]

Line ia.sinc:3427 :RCR rm32,CL        is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=3 ...   { local cnt=CL&0x1f; tmp:8=(zext(CF)<<32)|zext(rm32); tmp=(tmp>>cnt)|(tmp<<(33-cnt)); rm32=tmp(0); CF=(tmp&0x100000000)!=0; build check_rm32_dest; }
0: Constructor line ia.sinc:3427(id0.452) printpiece=[RCR,  ,  B, ,,  A]
Operands 0: CL : 2143  1: rm32 : 2142  2: check_rm32_dest : 2144  
Pattern id=452 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D3:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[36100:1] = INT_AND register[4:1], const[1f:1]
	2: unique[36180:8] = INT_ZEXT register[200:1]
	3: unique[36200:8] = INT_LEFT unique[36180:8], const[20:4]
	4: unique[36280:8] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	5: unique[36380:8] = INT_OR unique[36200:8], unique[36280:8]
	6: unique[36400:8] = INT_RIGHT unique[36380:8], unique[36100:1]
	7: unique[36480:1] = INT_SUB const[21:1], unique[36100:1]
	8: unique[36500:8] = INT_LEFT unique[36380:8], unique[36480:1]
	9: unique[36380:8] = INT_OR unique[36400:8], unique[36500:8]
	10: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[36380:8], const[0:4]
	11: unique[36680:8] = INT_AND unique[36380:8], const[100000000:8]
	12: register[200:1] = INT_NOTEQUAL unique[36680:8], const[0:8]
	13: MULTIEQUAL const[2:4]

Line ia.sinc:3641 :SHL rm16,CL    is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & (reg_opcode=4|reg_opcode=6) ...       { local count =   CL & 0x1f; local tmp = rm16; rm16 = rm16 << count;
                                          shlflags(tmp, rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3641(id0.529) printpiece=[SHL,  ,  B, ,,  A]
Operands 0: CL : 2283  1: rm16 : 2282  
Pattern id=529 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D3:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3e500:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3e580:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3e500:1]
	4: unique[10080:1] = INT_NOTEQUAL unique[3e500:1], const[0:1]
	5: unique[10100:1] = INT_SUB unique[3e500:1], const[1:1]
	6: unique[10180:[handle:size]] = INT_LEFT unique[3e580:[handle:size]], unique[10100:1]
	7: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	8: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	9: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	10: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	11: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	12: unique[10580:1] = INT_EQUAL unique[3e500:1], const[1:1]
	13: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	15: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	16: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	17: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	18: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[3e500:1], const[0:1]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3646 :SHL rm32,CL    is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & (reg_opcode=4|reg_opcode=6) ...       { local count =   CL & 0x1f; local tmp = rm32; rm32 = rm32 << count; build check_rm32_dest;
                                          shlflags(tmp, rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3646(id0.532) printpiece=[SHL,  ,  B, ,,  A]
Operands 0: CL : 2290  1: rm32 : 2289  2: check_rm32_dest : 2291  
Pattern id=532 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D3:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3eb00:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3eb80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3eb00:1]
	4: MULTIEQUAL const[2:4]
	5: unique[10080:1] = INT_NOTEQUAL unique[3eb00:1], const[0:1]
	6: unique[10100:1] = INT_SUB unique[3eb00:1], const[1:1]
	7: unique[10180:[handle:size]] = INT_LEFT unique[3eb80:[handle:size]], unique[10100:1]
	8: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	9: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	10: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	11: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	12: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	13: unique[10580:1] = INT_EQUAL unique[3eb00:1], const[1:1]
	14: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	16: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	17: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	18: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	19: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	20: unique[df00:1] = INT_NOTEQUAL unique[3eb00:1], const[0:1]
	21: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	22: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	23: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	24: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	25: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	26: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	27: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	28: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	29: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	30: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	31: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	32: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	33: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	34: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	35: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	36: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	37: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	38: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3706 :SHR rm16,CL    is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=5 ...       { local count =   CL & 0x1f; local tmp = rm16; rm16 = rm16 >> count;
                                          shrflags(tmp, rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3706(id0.546) printpiece=[SHR,  ,  B, ,,  A]
Operands 0: CL : 2332  1: rm16 : 2331  
Pattern id=546 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D3:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[41180:1] = INT_AND register[4:1], const[1f:1]
	2: unique[41200:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[41180:1]
	4: unique[11180:1] = INT_NOTEQUAL unique[41180:1], const[0:1]
	5: unique[11200:1] = INT_SUB unique[41180:1], const[1:1]
	6: unique[11280:[handle:size]] = INT_RIGHT unique[41200:[handle:size]], unique[11200:1]
	7: unique[11300:[handle:size]] = INT_AND unique[11280:[handle:size]], const[1:[handle:size]]
	8: unique[11400:1] = INT_NOTEQUAL unique[11300:[handle:size]], const[0:[handle:size]]
	9: unique[11480:1] = BOOL_NEGATE unique[11180:1]
	10: unique[11500:1] = INT_AND unique[11480:1], register[200:1]
	11: unique[11580:1] = INT_AND unique[11180:1], unique[11400:1]
	12: register[200:1] = INT_OR unique[11500:1], unique[11580:1]
	13: unique[11700:1] = INT_EQUAL unique[41180:1], const[1:1]
	14: unique[11800:1] = INT_SLESS unique[41200:[handle:size]], const[0:[handle:size]]
	15: unique[11880:1] = BOOL_NEGATE unique[11700:1]
	16: unique[11900:1] = INT_AND unique[11880:1], register[20b:1]
	17: unique[11980:1] = INT_AND unique[11700:1], unique[11800:1]
	18: register[20b:1] = INT_OR unique[11900:1], unique[11980:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[41180:1], const[0:1]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3711 :SHR rm32,CL    is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=5 ...       { local count =   CL & 0x1f; local tmp = rm32; rm32 = rm32 >> count; build check_rm32_dest;
                                          shrflags(tmp, rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3711(id0.549) printpiece=[SHR,  ,  B, ,,  A]
Operands 0: CL : 2339  1: rm32 : 2338  2: check_rm32_dest : 2340  
Pattern id=549 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D3:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[41700:1] = INT_AND register[4:1], const[1f:1]
	2: unique[41780:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[41700:1]
	4: MULTIEQUAL const[2:4]
	5: unique[11180:1] = INT_NOTEQUAL unique[41700:1], const[0:1]
	6: unique[11200:1] = INT_SUB unique[41700:1], const[1:1]
	7: unique[11280:[handle:size]] = INT_RIGHT unique[41780:[handle:size]], unique[11200:1]
	8: unique[11300:[handle:size]] = INT_AND unique[11280:[handle:size]], const[1:[handle:size]]
	9: unique[11400:1] = INT_NOTEQUAL unique[11300:[handle:size]], const[0:[handle:size]]
	10: unique[11480:1] = BOOL_NEGATE unique[11180:1]
	11: unique[11500:1] = INT_AND unique[11480:1], register[200:1]
	12: unique[11580:1] = INT_AND unique[11180:1], unique[11400:1]
	13: register[200:1] = INT_OR unique[11500:1], unique[11580:1]
	14: unique[11700:1] = INT_EQUAL unique[41700:1], const[1:1]
	15: unique[11800:1] = INT_SLESS unique[41780:[handle:size]], const[0:[handle:size]]
	16: unique[11880:1] = BOOL_NEGATE unique[11700:1]
	17: unique[11900:1] = INT_AND unique[11880:1], register[20b:1]
	18: unique[11980:1] = INT_AND unique[11700:1], unique[11800:1]
	19: register[20b:1] = INT_OR unique[11900:1], unique[11980:1]
	20: unique[df00:1] = INT_NOTEQUAL unique[41700:1], const[0:1]
	21: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	22: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	23: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	24: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	25: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	26: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	27: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	28: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	29: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	30: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	31: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	32: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	33: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	34: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	35: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	36: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	37: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	38: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3641 :SHL rm16,CL    is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & (reg_opcode=4|reg_opcode=6) ...       { local count =   CL & 0x1f; local tmp = rm16; rm16 = rm16 << count;
                                          shlflags(tmp, rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3641(id0.529) printpiece=[SHL,  ,  B, ,,  A]
Operands 0: CL : 2283  1: rm16 : 2282  
Pattern id=529 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D3:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3e500:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3e580:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3e500:1]
	4: unique[10080:1] = INT_NOTEQUAL unique[3e500:1], const[0:1]
	5: unique[10100:1] = INT_SUB unique[3e500:1], const[1:1]
	6: unique[10180:[handle:size]] = INT_LEFT unique[3e580:[handle:size]], unique[10100:1]
	7: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	8: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	9: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	10: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	11: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	12: unique[10580:1] = INT_EQUAL unique[3e500:1], const[1:1]
	13: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	14: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	15: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	16: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	17: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	18: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	19: unique[df00:1] = INT_NOTEQUAL unique[3e500:1], const[0:1]
	20: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	21: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	22: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	23: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	24: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	25: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	26: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	27: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	28: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	29: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	30: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	31: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	32: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	33: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	34: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	35: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	36: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	37: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3646 :SHL rm32,CL    is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & (reg_opcode=4|reg_opcode=6) ...       { local count =   CL & 0x1f; local tmp = rm32; rm32 = rm32 << count; build check_rm32_dest;
                                          shlflags(tmp, rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3646(id0.532) printpiece=[SHL,  ,  B, ,,  A]
Operands 0: CL : 2290  1: rm32 : 2289  2: check_rm32_dest : 2291  
Pattern id=532 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D3:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3eb00:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3eb80:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[3eb00:1]
	4: MULTIEQUAL const[2:4]
	5: unique[10080:1] = INT_NOTEQUAL unique[3eb00:1], const[0:1]
	6: unique[10100:1] = INT_SUB unique[3eb00:1], const[1:1]
	7: unique[10180:[handle:size]] = INT_LEFT unique[3eb80:[handle:size]], unique[10100:1]
	8: unique[10280:1] = INT_SLESS unique[10180:[handle:size]], const[0:[handle:size]]
	9: unique[10300:1] = BOOL_NEGATE unique[10080:1]
	10: unique[10380:1] = INT_AND unique[10300:1], register[200:1]
	11: unique[10400:1] = INT_AND unique[10080:1], unique[10280:1]
	12: register[200:1] = INT_OR unique[10380:1], unique[10400:1]
	13: unique[10580:1] = INT_EQUAL unique[3eb00:1], const[1:1]
	14: unique[10600:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	15: unique[10700:1] = INT_XOR register[200:1], unique[10600:1]
	16: unique[10780:1] = BOOL_NEGATE unique[10580:1]
	17: unique[10800:1] = INT_AND unique[10780:1], register[20b:1]
	18: unique[10880:1] = INT_AND unique[10580:1], unique[10700:1]
	19: register[20b:1] = INT_OR unique[10800:1], unique[10880:1]
	20: unique[df00:1] = INT_NOTEQUAL unique[3eb00:1], const[0:1]
	21: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	22: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	23: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	24: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	25: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	26: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	27: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	28: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	29: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	30: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	31: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	32: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	33: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	34: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	35: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	36: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	37: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	38: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3557 :SAR rm16,CL    is vexMode=0 & opsize=0 & byte=0xD3; CL & rm16 & reg_opcode=7 ...       { local count =   CL & 0x1f; local tmp = rm16; rm16 = rm16 s>> count;
                                          sarflags(tmp, rm16,count); shiftresultflags(rm16,count); }
0: Constructor line ia.sinc:3557(id0.500) printpiece=[SAR,  ,  B, ,,  A]
Operands 0: CL : 2216  1: rm16 : 2215  
Pattern id=500 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:D3:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3cf80:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3d000:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], unique[3cf80:1]
	4: unique[10a00:1] = INT_NOTEQUAL unique[3cf80:1], const[0:1]
	5: unique[10a80:1] = INT_SUB unique[3cf80:1], const[1:1]
	6: unique[10b00:[handle:size]] = INT_SRIGHT unique[3d000:[handle:size]], unique[10a80:1]
	7: unique[10b80:[handle:size]] = INT_AND unique[10b00:[handle:size]], const[1:[handle:size]]
	8: unique[10c80:1] = INT_NOTEQUAL unique[10b80:[handle:size]], const[0:[handle:size]]
	9: unique[10d00:1] = BOOL_NEGATE unique[10a00:1]
	10: unique[10d80:1] = INT_AND unique[10d00:1], register[200:1]
	11: unique[10e00:1] = INT_AND unique[10a00:1], unique[10c80:1]
	12: register[200:1] = INT_OR unique[10d80:1], unique[10e00:1]
	13: unique[10f80:1] = INT_EQUAL unique[3cf80:1], const[1:1]
	14: unique[11000:1] = BOOL_NEGATE unique[10f80:1]
	15: register[20b:1] = INT_AND unique[11000:1], register[20b:1]
	16: unique[df00:1] = INT_NOTEQUAL unique[3cf80:1], const[0:1]
	17: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	18: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	19: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	20: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	21: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	22: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	23: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	24: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	25: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	26: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	27: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	28: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	29: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	30: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	31: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	32: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	33: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	34: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line ia.sinc:3562 :SAR rm32,CL    is vexMode=0 & opsize=1 & byte=0xD3; CL & rm32 & check_rm32_dest ... & reg_opcode=7 ...       { local count =   CL & 0x1f; local tmp = rm32; rm32 = rm32 s>> count; build check_rm32_dest;
                                          sarflags(tmp, rm32,count); shiftresultflags(rm32,count); }
0: Constructor line ia.sinc:3562(id0.503) printpiece=[SAR,  ,  B, ,,  A]
Operands 0: CL : 2223  1: rm32 : 2222  2: check_rm32_dest : 2224  
Pattern id=503 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:D3:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: unique[3d500:1] = INT_AND register[4:1], const[1f:1]
	2: unique[3d580:[handle:size]] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], unique[3d500:1]
	4: MULTIEQUAL const[2:4]
	5: unique[10a00:1] = INT_NOTEQUAL unique[3d500:1], const[0:1]
	6: unique[10a80:1] = INT_SUB unique[3d500:1], const[1:1]
	7: unique[10b00:[handle:size]] = INT_SRIGHT unique[3d580:[handle:size]], unique[10a80:1]
	8: unique[10b80:[handle:size]] = INT_AND unique[10b00:[handle:size]], const[1:[handle:size]]
	9: unique[10c80:1] = INT_NOTEQUAL unique[10b80:[handle:size]], const[0:[handle:size]]
	10: unique[10d00:1] = BOOL_NEGATE unique[10a00:1]
	11: unique[10d80:1] = INT_AND unique[10d00:1], register[200:1]
	12: unique[10e00:1] = INT_AND unique[10a00:1], unique[10c80:1]
	13: register[200:1] = INT_OR unique[10d80:1], unique[10e00:1]
	14: unique[10f80:1] = INT_EQUAL unique[3d500:1], const[1:1]
	15: unique[11000:1] = BOOL_NEGATE unique[10f80:1]
	16: register[20b:1] = INT_AND unique[11000:1], register[20b:1]
	17: unique[df00:1] = INT_NOTEQUAL unique[3d500:1], const[0:1]
	18: unique[e000:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	19: unique[e080:1] = BOOL_NEGATE unique[df00:1]
	20: unique[e100:1] = INT_AND unique[e080:1], register[207:1]
	21: unique[e180:1] = INT_AND unique[df00:1], unique[e000:1]
	22: register[207:1] = INT_OR unique[e100:1], unique[e180:1]
	23: unique[e300:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	24: unique[e380:1] = BOOL_NEGATE unique[df00:1]
	25: unique[e400:1] = INT_AND unique[e380:1], register[206:1]
	26: unique[e480:1] = INT_AND unique[df00:1], unique[e300:1]
	27: register[206:1] = INT_OR unique[e400:1], unique[e480:1]
	28: unique[e580:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	29: unique[e600:1] = POPCOUNT unique[e580:[handle:size]]
	30: unique[e680:1] = INT_AND unique[e600:1], const[1:1]
	31: unique[e780:1] = INT_EQUAL unique[e680:1], const[0:1]
	32: unique[e800:1] = BOOL_NEGATE unique[df00:1]
	33: unique[e880:1] = INT_AND unique[e800:1], register[202:1]
	34: unique[e900:1] = INT_AND unique[df00:1], unique[e780:1]
	35: register[202:1] = INT_OR unique[e880:1], unique[e900:1]

Line avx.sinc:2571 :VPSRLQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD3; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrlq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2571(id0.1813) printpiece=[VPSRLQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5740  1: vexVVVV_XmmReg : 5738  2: XmmReg1 : 5737  3: YmmReg1 : 5741  4: XmmReg2_m128 : 5739  
Pattern id=1813 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:D3:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b2a80:10] = CALLOTHER const[1b9:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b2a80:10]

Line avx2.sinc:751 :VPSRLQ YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD3; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsrlq_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:751(id0.2020) printpiece=[VPSRLQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6699  1: vexVVVV_YmmReg : 6697  2: YmmReg1 : 6696  3: XmmReg2_m128 : 6698  
Pattern id=2020 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:D3:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1641 :AAM imm8		is vexMode=0 & bit64=0 & byte=0xd4; imm8	{ AH = AL/imm8; AL = AL % imm8; resultflags(AX); }
0: Constructor line ia.sinc:1641(id0.22) printpiece=[AAM,  ,  A]
Operands 0: imm8 : 1390  
Pattern id=22 pattern=cmb:(ctx:X[0xxx]:XX:X[0xxx]:XX,ins:D4:XX:XX:XX)
Template
	0: register[1:1] = INT_DIV register[0:1], [handle:space][[handle:offset]:1]
	1: register[0:1] = INT_REM register[0:1], [handle:space][[handle:offset]:1]
	2: register[207:1] = INT_SLESS register[0:2], const[0:2]
	3: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	4: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	5: unique[dd00:1] = POPCOUNT unique[dc80:2]
	6: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	7: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1728 :VPADDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD4; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1728(id0.1718) printpiece=[VPADDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5216  1: vexVVVV_XmmReg : 5214  2: XmmReg1 : 5213  3: YmmReg1 : 5217  4: XmmReg2_m128 : 5215  
Pattern id=1718 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:D4:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[aaf00:10] = CALLOTHER const[160:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aaf00:10]

Line avx2.sinc:103 :VPADDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD4; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:103(id0.1937) printpiece=[VPADDQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6307  1: vexVVVV_YmmReg : 6305  2: YmmReg1 : 6304  3: YmmReg2_m256 : 6306  
Pattern id=1937 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:D4:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[203:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1640 :AAD imm8		is vexMode=0 & bit64=0 & byte=0xd5; imm8	{ AL = AL + imm8*AH; AH=0; resultflags(AX); }
0: Constructor line ia.sinc:1640(id0.21) printpiece=[AAD,  ,  A]
Operands 0: imm8 : 1389  
Pattern id=21 pattern=cmb:(ctx:X[0xxx]:XX:X[0xxx]:XX,ins:D5:XX:XX:XX)
Template
	0: unique[13a80:1] = INT_MULT [handle:space][[handle:offset]:1], register[1:1]
	1: register[0:1] = INT_ADD register[0:1], unique[13a80:1]
	2: register[1:1] = COPY const[0:1]
	3: register[207:1] = INT_SLESS register[0:2], const[0:2]
	4: register[206:1] = INT_EQUAL register[0:2], const[0:2]
	5: unique[dc80:2] = INT_AND register[0:2], const[ff:2]
	6: unique[dd00:1] = POPCOUNT unique[dc80:2]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:2353 :VPMULLW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD5; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmullw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2353(id0.1786) printpiece=[VPMULLW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5594  1: vexVVVV_XmmReg : 5592  2: XmmReg1 : 5591  3: YmmReg1 : 5595  4: XmmReg2_m128 : 5593  
Pattern id=1786 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:D5:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b0b00:10] = CALLOTHER const[1a5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0b00:10]

Line avx2.sinc:551 :VPMULLW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD5; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmullw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:551(id0.1993) printpiece=[VPMULLW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6571  1: vexVVVV_YmmReg : 6569  2: YmmReg1 : 6568  3: YmmReg2_m256 : 6570  
Pattern id=1993 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:D5:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[23b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3549 :SALC         is vexMode=0 & bit64=0 & byte=0xd6 { AL = CF * 0xff; }
0: Constructor line ia.sinc:3549(id0.495) printpiece=[SALC]
Operands 
Pattern id=495 pattern=cmb:(ctx:X[0xxx]:XX:X[0xxx]:XX,ins:D6:XX:XX:XX)
Template
	0: register[0:1] = INT_MULT register[200:1], const[ff:1]

Line avx.sinc:1422 :VMOVQ XmmReg2_m64, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xD6; XmmReg1 ... & XmmReg2_m64
{
	XmmReg2_m64 = vmovq_avx( XmmReg1 );
	# TODO ZmmReg2 = zext(XmmReg2)
}
0: Constructor line avx.sinc:1422(id0.1684) printpiece=[VMOVQ,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5048  1: XmmReg1 : 5047  2: XmmReg2_m64 : 5046  
Pattern id=1684 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:D6:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[13c:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3976 :XLAT seg16^BX      is vexMode=0 & addrsize=0 & seg16 & byte=0xd7; BX           { tmp:$(SIZE)= 0; ptr2(tmp,BX+zext(AL)); AL = *tmp; }
0: Constructor line ia.sinc:3976(id0.634) printpiece=[XLAT,  ,  A,  B]
Operands 0: seg16 : 2470  1: BX : 2471  
Pattern id=634 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:D7:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[43780:4] = COPY const[0:4]
	2: unique[43800:2] = INT_ZEXT register[0:1]
	3: unique[43880:2] = INT_ADD register[c:2], unique[43800:2]
	4: unique[43780:4] = INT_ZEXT unique[43880:2]
	5: register[0:1] = LOAD const[ram:8], unique[43780:4]

Line ia.sinc:3977 :XLAT segWide^EBX     is vexMode=0 & addrsize=1 & segWide & byte=0xd7; EBX          { tmp:$(SIZE)= 0; ptr4(tmp,EBX+zext(AL)); AL = *tmp; }
0: Constructor line ia.sinc:3977(id0.635) printpiece=[XLAT,  ,  A,  B]
Operands 0: segWide : 2472  1: EBX : 2473  
Pattern id=635 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:D7:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[43980:4] = COPY const[0:4]
	2: unique[43a00:4] = INT_ZEXT register[0:1]
	3: unique[43980:4] = INT_ADD register[c:4], unique[43a00:4]
	4: register[0:1] = LOAD const[ram:8], unique[43980:4]

Line avx_manual.sinc:121 :VPMOVMSKB Reg32, XmmReg2 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xD7; Reg32 & (mod=0x3 & XmmReg2) & check_Reg32_dest
{
	local byte_mask:2 = 0:2;
	byte_mask[0,1] = XmmReg2[7,1];
	byte_mask[1,1] = XmmReg2[15,1];
	byte_mask[2,1] = XmmReg2[23,1];
	byte_mask[3,1] = XmmReg2[31,1];
	byte_mask[4,1] = XmmReg2[39,1];
	byte_mask[5,1] = XmmReg2[47,1];
	byte_mask[6,1] = XmmReg2[55,1];
	byte_mask[7,1] = XmmReg2[63,1];
	byte_mask[8,1] = XmmReg2[71,1];
	byte_mask[9,1] = XmmReg2[79,1];
	byte_mask[10,1] = XmmReg2[87,1];
	byte_mask[11,1] = XmmReg2[95,1];
	byte_mask[12,1] = XmmReg2[103,1];
	byte_mask[13,1] = XmmReg2[111,1];
	byte_mask[14,1] = XmmReg2[119,1];
	byte_mask[15,1] = XmmReg2[127,1];
	Reg32 = zext(byte_mask);
	build check_Reg32_dest;
}
0: Constructor line avx_manual.sinc:121(id0.1924) printpiece=[VPMOVMSKB,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6245  1: Reg32 : 6243  2: XmmReg2 : 6244  3: check_Reg32_dest : 6246  
Pattern id=1924 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:D7:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: unique[b8e80:2] = COPY const[0:2]
	3: unique[b9080:2] = INT_AND unique[b8e80:2], const[fffffffffffffffe:2]
	4: unique[b8f00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[7:4]
	5: unique[b8f80:1] = SUBPIECE unique[b8f00:[handle:size]], const[0:4]
	6: unique[b9000:1] = INT_AND unique[b8f80:1], const[1:1]
	7: unique[b9100:2] = INT_ZEXT unique[b9000:1]
	8: unique[b8e80:2] = INT_OR unique[b9080:2], unique[b9100:2]
	9: unique[b9300:2] = INT_AND unique[b8e80:2], const[fffffffffffffffd:2]
	10: unique[b9180:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[f:4]
	11: unique[b9200:1] = SUBPIECE unique[b9180:[handle:size]], const[0:4]
	12: unique[b9280:1] = INT_AND unique[b9200:1], const[1:1]
	13: unique[b9380:2] = INT_ZEXT unique[b9280:1]
	14: unique[b9400:2] = INT_LEFT unique[b9380:2], const[1:4]
	15: unique[b8e80:2] = INT_OR unique[b9300:2], unique[b9400:2]
	16: unique[b9600:2] = INT_AND unique[b8e80:2], const[fffffffffffffffb:2]
	17: unique[b9480:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[17:4]
	18: unique[b9500:1] = SUBPIECE unique[b9480:[handle:size]], const[0:4]
	19: unique[b9580:1] = INT_AND unique[b9500:1], const[1:1]
	20: unique[b9680:2] = INT_ZEXT unique[b9580:1]
	21: unique[b9700:2] = INT_LEFT unique[b9680:2], const[2:4]
	22: unique[b8e80:2] = INT_OR unique[b9600:2], unique[b9700:2]
	23: unique[b9900:2] = INT_AND unique[b8e80:2], const[fffffffffffffff7:2]
	24: unique[b9780:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1f:4]
	25: unique[b9800:1] = SUBPIECE unique[b9780:[handle:size]], const[0:4]
	26: unique[b9880:1] = INT_AND unique[b9800:1], const[1:1]
	27: unique[b9980:2] = INT_ZEXT unique[b9880:1]
	28: unique[b9a00:2] = INT_LEFT unique[b9980:2], const[3:4]
	29: unique[b8e80:2] = INT_OR unique[b9900:2], unique[b9a00:2]
	30: unique[b9c00:2] = INT_AND unique[b8e80:2], const[ffffffffffffffef:2]
	31: unique[b9a80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[27:4]
	32: unique[b9b00:1] = SUBPIECE unique[b9a80:[handle:size]], const[0:4]
	33: unique[b9b80:1] = INT_AND unique[b9b00:1], const[1:1]
	34: unique[b9c80:2] = INT_ZEXT unique[b9b80:1]
	35: unique[b9d00:2] = INT_LEFT unique[b9c80:2], const[4:4]
	36: unique[b8e80:2] = INT_OR unique[b9c00:2], unique[b9d00:2]
	37: unique[b9f00:2] = INT_AND unique[b8e80:2], const[ffffffffffffffdf:2]
	38: unique[b9d80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[2f:4]
	39: unique[b9e00:1] = SUBPIECE unique[b9d80:[handle:size]], const[0:4]
	40: unique[b9e80:1] = INT_AND unique[b9e00:1], const[1:1]
	41: unique[b9f80:2] = INT_ZEXT unique[b9e80:1]
	42: unique[ba000:2] = INT_LEFT unique[b9f80:2], const[5:4]
	43: unique[b8e80:2] = INT_OR unique[b9f00:2], unique[ba000:2]
	44: unique[ba200:2] = INT_AND unique[b8e80:2], const[ffffffffffffffbf:2]
	45: unique[ba080:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[37:4]
	46: unique[ba100:1] = SUBPIECE unique[ba080:[handle:size]], const[0:4]
	47: unique[ba180:1] = INT_AND unique[ba100:1], const[1:1]
	48: unique[ba280:2] = INT_ZEXT unique[ba180:1]
	49: unique[ba300:2] = INT_LEFT unique[ba280:2], const[6:4]
	50: unique[b8e80:2] = INT_OR unique[ba200:2], unique[ba300:2]
	51: unique[ba500:2] = INT_AND unique[b8e80:2], const[ffffffffffffff7f:2]
	52: unique[ba380:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[3f:4]
	53: unique[ba400:1] = SUBPIECE unique[ba380:[handle:size]], const[0:4]
	54: unique[ba480:1] = INT_AND unique[ba400:1], const[1:1]
	55: unique[ba580:2] = INT_ZEXT unique[ba480:1]
	56: unique[ba600:2] = INT_LEFT unique[ba580:2], const[7:4]
	57: unique[b8e80:2] = INT_OR unique[ba500:2], unique[ba600:2]
	58: unique[ba800:2] = INT_AND unique[b8e80:2], const[fffffffffffffeff:2]
	59: unique[ba680:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[47:4]
	60: unique[ba700:1] = SUBPIECE unique[ba680:[handle:size]], const[0:4]
	61: unique[ba780:1] = INT_AND unique[ba700:1], const[1:1]
	62: unique[ba880:2] = INT_ZEXT unique[ba780:1]
	63: unique[ba900:2] = INT_LEFT unique[ba880:2], const[8:4]
	64: unique[b8e80:2] = INT_OR unique[ba800:2], unique[ba900:2]
	65: unique[bab00:2] = INT_AND unique[b8e80:2], const[fffffffffffffdff:2]
	66: unique[ba980:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[4f:4]
	67: unique[baa00:1] = SUBPIECE unique[ba980:[handle:size]], const[0:4]
	68: unique[baa80:1] = INT_AND unique[baa00:1], const[1:1]
	69: unique[bab80:2] = INT_ZEXT unique[baa80:1]
	70: unique[bac00:2] = INT_LEFT unique[bab80:2], const[9:4]
	71: unique[b8e80:2] = INT_OR unique[bab00:2], unique[bac00:2]
	72: unique[bae00:2] = INT_AND unique[b8e80:2], const[fffffffffffffbff:2]
	73: unique[bac80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[57:4]
	74: unique[bad00:1] = SUBPIECE unique[bac80:[handle:size]], const[0:4]
	75: unique[bad80:1] = INT_AND unique[bad00:1], const[1:1]
	76: unique[bae80:2] = INT_ZEXT unique[bad80:1]
	77: unique[baf00:2] = INT_LEFT unique[bae80:2], const[a:4]
	78: unique[b8e80:2] = INT_OR unique[bae00:2], unique[baf00:2]
	79: unique[bb100:2] = INT_AND unique[b8e80:2], const[fffffffffffff7ff:2]
	80: unique[baf80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[5f:4]
	81: unique[bb000:1] = SUBPIECE unique[baf80:[handle:size]], const[0:4]
	82: unique[bb080:1] = INT_AND unique[bb000:1], const[1:1]
	83: unique[bb180:2] = INT_ZEXT unique[bb080:1]
	84: unique[bb200:2] = INT_LEFT unique[bb180:2], const[b:4]
	85: unique[b8e80:2] = INT_OR unique[bb100:2], unique[bb200:2]
	86: unique[bb400:2] = INT_AND unique[b8e80:2], const[ffffffffffffefff:2]
	87: unique[bb280:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[67:4]
	88: unique[bb300:1] = SUBPIECE unique[bb280:[handle:size]], const[0:4]
	89: unique[bb380:1] = INT_AND unique[bb300:1], const[1:1]
	90: unique[bb480:2] = INT_ZEXT unique[bb380:1]
	91: unique[bb500:2] = INT_LEFT unique[bb480:2], const[c:4]
	92: unique[b8e80:2] = INT_OR unique[bb400:2], unique[bb500:2]
	93: unique[bb700:2] = INT_AND unique[b8e80:2], const[ffffffffffffdfff:2]
	94: unique[bb580:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[6f:4]
	95: unique[bb600:1] = SUBPIECE unique[bb580:[handle:size]], const[0:4]
	96: unique[bb680:1] = INT_AND unique[bb600:1], const[1:1]
	97: unique[bb780:2] = INT_ZEXT unique[bb680:1]
	98: unique[bb800:2] = INT_LEFT unique[bb780:2], const[d:4]
	99: unique[b8e80:2] = INT_OR unique[bb700:2], unique[bb800:2]
	100: unique[bba00:2] = INT_AND unique[b8e80:2], const[ffffffffffffbfff:2]
	101: unique[bb880:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[77:4]
	102: unique[bb900:1] = SUBPIECE unique[bb880:[handle:size]], const[0:4]
	103: unique[bb980:1] = INT_AND unique[bb900:1], const[1:1]
	104: unique[bba80:2] = INT_ZEXT unique[bb980:1]
	105: unique[bbb00:2] = INT_LEFT unique[bba80:2], const[e:4]
	106: unique[b8e80:2] = INT_OR unique[bba00:2], unique[bbb00:2]
	107: unique[bbd00:2] = INT_AND unique[b8e80:2], const[ffffffffffff7fff:2]
	108: unique[bbb80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[7f:4]
	109: unique[bbc00:1] = SUBPIECE unique[bbb80:[handle:size]], const[0:4]
	110: unique[bbc80:1] = INT_AND unique[bbc00:1], const[1:1]
	111: unique[bbd80:2] = INT_ZEXT unique[bbc80:1]
	112: unique[bbe00:2] = INT_LEFT unique[bbd80:2], const[f:4]
	113: unique[b8e80:2] = INT_OR unique[bbd00:2], unique[bbe00:2]
	114: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b8e80:2]
	115: MULTIEQUAL const[3:4]

Line avx2_manual.sinc:214 :VPMOVMSKB Reg32, YmmReg2 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xD7; Reg32 & (mod=0x3 & YmmReg2) & check_Reg32_dest
{
	local byte_mask:4 = 0:4;
	byte_mask[0,1] = YmmReg2[7,1];
	byte_mask[1,1] = YmmReg2[15,1];
	byte_mask[2,1] = YmmReg2[23,1];
	byte_mask[3,1] = YmmReg2[31,1];
	byte_mask[4,1] = YmmReg2[39,1];
	byte_mask[5,1] = YmmReg2[47,1];
	byte_mask[6,1] = YmmReg2[55,1];
	byte_mask[7,1] = YmmReg2[63,1];
	byte_mask[8,1] = YmmReg2[71,1];
	byte_mask[9,1] = YmmReg2[79,1];
	byte_mask[10,1] = YmmReg2[87,1];
	byte_mask[11,1] = YmmReg2[95,1];
	byte_mask[12,1] = YmmReg2[103,1];
	byte_mask[13,1] = YmmReg2[111,1];
	byte_mask[14,1] = YmmReg2[119,1];
	byte_mask[15,1] = YmmReg2[127,1];
	byte_mask[16,1] = YmmReg2[135,1];
	byte_mask[17,1] = YmmReg2[143,1];
	byte_mask[18,1] = YmmReg2[151,1];
	byte_mask[19,1] = YmmReg2[159,1];
	byte_mask[20,1] = YmmReg2[167,1];
	byte_mask[21,1] = YmmReg2[175,1];
	byte_mask[22,1] = YmmReg2[183,1];
	byte_mask[23,1] = YmmReg2[191,1];
	byte_mask[24,1] = YmmReg2[199,1];
	byte_mask[25,1] = YmmReg2[207,1];
	byte_mask[26,1] = YmmReg2[215,1];
	byte_mask[27,1] = YmmReg2[223,1];
	byte_mask[28,1] = YmmReg2[231,1];
	byte_mask[29,1] = YmmReg2[239,1];
	byte_mask[30,1] = YmmReg2[247,1];
	byte_mask[31,1] = YmmReg2[255,1];
	Reg32 = zext(byte_mask);
	build check_Reg32_dest;
}
0: Constructor line avx2_manual.sinc:214(id0.2084) printpiece=[VPMOVMSKB,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 6963  1: Reg32 : 6961  2: YmmReg2 : 6962  3: check_Reg32_dest : 6964  
Pattern id=2084 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:D7:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: unique[c2500:4] = COPY const[0:4]
	3: unique[c2700:4] = INT_AND unique[c2500:4], const[fffffffffffffffe:4]
	4: unique[c2580:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[7:4]
	5: unique[c2600:1] = SUBPIECE unique[c2580:[handle:size]], const[0:4]
	6: unique[c2680:1] = INT_AND unique[c2600:1], const[1:1]
	7: unique[c2780:4] = INT_ZEXT unique[c2680:1]
	8: unique[c2500:4] = INT_OR unique[c2700:4], unique[c2780:4]
	9: unique[c2980:4] = INT_AND unique[c2500:4], const[fffffffffffffffd:4]
	10: unique[c2800:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[f:4]
	11: unique[c2880:1] = SUBPIECE unique[c2800:[handle:size]], const[0:4]
	12: unique[c2900:1] = INT_AND unique[c2880:1], const[1:1]
	13: unique[c2a00:4] = INT_ZEXT unique[c2900:1]
	14: unique[c2a80:4] = INT_LEFT unique[c2a00:4], const[1:4]
	15: unique[c2500:4] = INT_OR unique[c2980:4], unique[c2a80:4]
	16: unique[c2c80:4] = INT_AND unique[c2500:4], const[fffffffffffffffb:4]
	17: unique[c2b00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[17:4]
	18: unique[c2b80:1] = SUBPIECE unique[c2b00:[handle:size]], const[0:4]
	19: unique[c2c00:1] = INT_AND unique[c2b80:1], const[1:1]
	20: unique[c2d00:4] = INT_ZEXT unique[c2c00:1]
	21: unique[c2d80:4] = INT_LEFT unique[c2d00:4], const[2:4]
	22: unique[c2500:4] = INT_OR unique[c2c80:4], unique[c2d80:4]
	23: unique[c2f80:4] = INT_AND unique[c2500:4], const[fffffffffffffff7:4]
	24: unique[c2e00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[1f:4]
	25: unique[c2e80:1] = SUBPIECE unique[c2e00:[handle:size]], const[0:4]
	26: unique[c2f00:1] = INT_AND unique[c2e80:1], const[1:1]
	27: unique[c3000:4] = INT_ZEXT unique[c2f00:1]
	28: unique[c3080:4] = INT_LEFT unique[c3000:4], const[3:4]
	29: unique[c2500:4] = INT_OR unique[c2f80:4], unique[c3080:4]
	30: unique[c3280:4] = INT_AND unique[c2500:4], const[ffffffffffffffef:4]
	31: unique[c3100:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[27:4]
	32: unique[c3180:1] = SUBPIECE unique[c3100:[handle:size]], const[0:4]
	33: unique[c3200:1] = INT_AND unique[c3180:1], const[1:1]
	34: unique[c3300:4] = INT_ZEXT unique[c3200:1]
	35: unique[c3380:4] = INT_LEFT unique[c3300:4], const[4:4]
	36: unique[c2500:4] = INT_OR unique[c3280:4], unique[c3380:4]
	37: unique[c3580:4] = INT_AND unique[c2500:4], const[ffffffffffffffdf:4]
	38: unique[c3400:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[2f:4]
	39: unique[c3480:1] = SUBPIECE unique[c3400:[handle:size]], const[0:4]
	40: unique[c3500:1] = INT_AND unique[c3480:1], const[1:1]
	41: unique[c3600:4] = INT_ZEXT unique[c3500:1]
	42: unique[c3680:4] = INT_LEFT unique[c3600:4], const[5:4]
	43: unique[c2500:4] = INT_OR unique[c3580:4], unique[c3680:4]
	44: unique[c3880:4] = INT_AND unique[c2500:4], const[ffffffffffffffbf:4]
	45: unique[c3700:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[37:4]
	46: unique[c3780:1] = SUBPIECE unique[c3700:[handle:size]], const[0:4]
	47: unique[c3800:1] = INT_AND unique[c3780:1], const[1:1]
	48: unique[c3900:4] = INT_ZEXT unique[c3800:1]
	49: unique[c3980:4] = INT_LEFT unique[c3900:4], const[6:4]
	50: unique[c2500:4] = INT_OR unique[c3880:4], unique[c3980:4]
	51: unique[c3b80:4] = INT_AND unique[c2500:4], const[ffffffffffffff7f:4]
	52: unique[c3a00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[3f:4]
	53: unique[c3a80:1] = SUBPIECE unique[c3a00:[handle:size]], const[0:4]
	54: unique[c3b00:1] = INT_AND unique[c3a80:1], const[1:1]
	55: unique[c3c00:4] = INT_ZEXT unique[c3b00:1]
	56: unique[c3c80:4] = INT_LEFT unique[c3c00:4], const[7:4]
	57: unique[c2500:4] = INT_OR unique[c3b80:4], unique[c3c80:4]
	58: unique[c3e80:4] = INT_AND unique[c2500:4], const[fffffffffffffeff:4]
	59: unique[c3d00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[47:4]
	60: unique[c3d80:1] = SUBPIECE unique[c3d00:[handle:size]], const[0:4]
	61: unique[c3e00:1] = INT_AND unique[c3d80:1], const[1:1]
	62: unique[c3f00:4] = INT_ZEXT unique[c3e00:1]
	63: unique[c3f80:4] = INT_LEFT unique[c3f00:4], const[8:4]
	64: unique[c2500:4] = INT_OR unique[c3e80:4], unique[c3f80:4]
	65: unique[c4180:4] = INT_AND unique[c2500:4], const[fffffffffffffdff:4]
	66: unique[c4000:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[4f:4]
	67: unique[c4080:1] = SUBPIECE unique[c4000:[handle:size]], const[0:4]
	68: unique[c4100:1] = INT_AND unique[c4080:1], const[1:1]
	69: unique[c4200:4] = INT_ZEXT unique[c4100:1]
	70: unique[c4280:4] = INT_LEFT unique[c4200:4], const[9:4]
	71: unique[c2500:4] = INT_OR unique[c4180:4], unique[c4280:4]
	72: unique[c4480:4] = INT_AND unique[c2500:4], const[fffffffffffffbff:4]
	73: unique[c4300:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[57:4]
	74: unique[c4380:1] = SUBPIECE unique[c4300:[handle:size]], const[0:4]
	75: unique[c4400:1] = INT_AND unique[c4380:1], const[1:1]
	76: unique[c4500:4] = INT_ZEXT unique[c4400:1]
	77: unique[c4580:4] = INT_LEFT unique[c4500:4], const[a:4]
	78: unique[c2500:4] = INT_OR unique[c4480:4], unique[c4580:4]
	79: unique[c4780:4] = INT_AND unique[c2500:4], const[fffffffffffff7ff:4]
	80: unique[c4600:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[5f:4]
	81: unique[c4680:1] = SUBPIECE unique[c4600:[handle:size]], const[0:4]
	82: unique[c4700:1] = INT_AND unique[c4680:1], const[1:1]
	83: unique[c4800:4] = INT_ZEXT unique[c4700:1]
	84: unique[c4880:4] = INT_LEFT unique[c4800:4], const[b:4]
	85: unique[c2500:4] = INT_OR unique[c4780:4], unique[c4880:4]
	86: unique[c4a80:4] = INT_AND unique[c2500:4], const[ffffffffffffefff:4]
	87: unique[c4900:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[67:4]
	88: unique[c4980:1] = SUBPIECE unique[c4900:[handle:size]], const[0:4]
	89: unique[c4a00:1] = INT_AND unique[c4980:1], const[1:1]
	90: unique[c4b00:4] = INT_ZEXT unique[c4a00:1]
	91: unique[c4b80:4] = INT_LEFT unique[c4b00:4], const[c:4]
	92: unique[c2500:4] = INT_OR unique[c4a80:4], unique[c4b80:4]
	93: unique[c4d80:4] = INT_AND unique[c2500:4], const[ffffffffffffdfff:4]
	94: unique[c4c00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[6f:4]
	95: unique[c4c80:1] = SUBPIECE unique[c4c00:[handle:size]], const[0:4]
	96: unique[c4d00:1] = INT_AND unique[c4c80:1], const[1:1]
	97: unique[c4e00:4] = INT_ZEXT unique[c4d00:1]
	98: unique[c4e80:4] = INT_LEFT unique[c4e00:4], const[d:4]
	99: unique[c2500:4] = INT_OR unique[c4d80:4], unique[c4e80:4]
	100: unique[c5080:4] = INT_AND unique[c2500:4], const[ffffffffffffbfff:4]
	101: unique[c4f00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[77:4]
	102: unique[c4f80:1] = SUBPIECE unique[c4f00:[handle:size]], const[0:4]
	103: unique[c5000:1] = INT_AND unique[c4f80:1], const[1:1]
	104: unique[c5100:4] = INT_ZEXT unique[c5000:1]
	105: unique[c5180:4] = INT_LEFT unique[c5100:4], const[e:4]
	106: unique[c2500:4] = INT_OR unique[c5080:4], unique[c5180:4]
	107: unique[c5380:4] = INT_AND unique[c2500:4], const[ffffffffffff7fff:4]
	108: unique[c5200:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[7f:4]
	109: unique[c5280:1] = SUBPIECE unique[c5200:[handle:size]], const[0:4]
	110: unique[c5300:1] = INT_AND unique[c5280:1], const[1:1]
	111: unique[c5400:4] = INT_ZEXT unique[c5300:1]
	112: unique[c5480:4] = INT_LEFT unique[c5400:4], const[f:4]
	113: unique[c2500:4] = INT_OR unique[c5380:4], unique[c5480:4]
	114: unique[c5680:4] = INT_AND unique[c2500:4], const[fffffffffffeffff:4]
	115: unique[c5500:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[87:4]
	116: unique[c5580:1] = SUBPIECE unique[c5500:[handle:size]], const[0:4]
	117: unique[c5600:1] = INT_AND unique[c5580:1], const[1:1]
	118: unique[c5700:4] = INT_ZEXT unique[c5600:1]
	119: unique[c5780:4] = INT_LEFT unique[c5700:4], const[10:4]
	120: unique[c2500:4] = INT_OR unique[c5680:4], unique[c5780:4]
	121: unique[c5980:4] = INT_AND unique[c2500:4], const[fffffffffffdffff:4]
	122: unique[c5800:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[8f:4]
	123: unique[c5880:1] = SUBPIECE unique[c5800:[handle:size]], const[0:4]
	124: unique[c5900:1] = INT_AND unique[c5880:1], const[1:1]
	125: unique[c5a00:4] = INT_ZEXT unique[c5900:1]
	126: unique[c5a80:4] = INT_LEFT unique[c5a00:4], const[11:4]
	127: unique[c2500:4] = INT_OR unique[c5980:4], unique[c5a80:4]
	128: unique[c5c80:4] = INT_AND unique[c2500:4], const[fffffffffffbffff:4]
	129: unique[c5b00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[97:4]
	130: unique[c5b80:1] = SUBPIECE unique[c5b00:[handle:size]], const[0:4]
	131: unique[c5c00:1] = INT_AND unique[c5b80:1], const[1:1]
	132: unique[c5d00:4] = INT_ZEXT unique[c5c00:1]
	133: unique[c5d80:4] = INT_LEFT unique[c5d00:4], const[12:4]
	134: unique[c2500:4] = INT_OR unique[c5c80:4], unique[c5d80:4]
	135: unique[c5f80:4] = INT_AND unique[c2500:4], const[fffffffffff7ffff:4]
	136: unique[c5e00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[9f:4]
	137: unique[c5e80:1] = SUBPIECE unique[c5e00:[handle:size]], const[0:4]
	138: unique[c5f00:1] = INT_AND unique[c5e80:1], const[1:1]
	139: unique[c6000:4] = INT_ZEXT unique[c5f00:1]
	140: unique[c6080:4] = INT_LEFT unique[c6000:4], const[13:4]
	141: unique[c2500:4] = INT_OR unique[c5f80:4], unique[c6080:4]
	142: unique[c6280:4] = INT_AND unique[c2500:4], const[ffffffffffefffff:4]
	143: unique[c6100:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[a7:4]
	144: unique[c6180:1] = SUBPIECE unique[c6100:[handle:size]], const[0:4]
	145: unique[c6200:1] = INT_AND unique[c6180:1], const[1:1]
	146: unique[c6300:4] = INT_ZEXT unique[c6200:1]
	147: unique[c6380:4] = INT_LEFT unique[c6300:4], const[14:4]
	148: unique[c2500:4] = INT_OR unique[c6280:4], unique[c6380:4]
	149: unique[c6580:4] = INT_AND unique[c2500:4], const[ffffffffffdfffff:4]
	150: unique[c6400:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[af:4]
	151: unique[c6480:1] = SUBPIECE unique[c6400:[handle:size]], const[0:4]
	152: unique[c6500:1] = INT_AND unique[c6480:1], const[1:1]
	153: unique[c6600:4] = INT_ZEXT unique[c6500:1]
	154: unique[c6680:4] = INT_LEFT unique[c6600:4], const[15:4]
	155: unique[c2500:4] = INT_OR unique[c6580:4], unique[c6680:4]
	156: unique[c6880:4] = INT_AND unique[c2500:4], const[ffffffffffbfffff:4]
	157: unique[c6700:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[b7:4]
	158: unique[c6780:1] = SUBPIECE unique[c6700:[handle:size]], const[0:4]
	159: unique[c6800:1] = INT_AND unique[c6780:1], const[1:1]
	160: unique[c6900:4] = INT_ZEXT unique[c6800:1]
	161: unique[c6980:4] = INT_LEFT unique[c6900:4], const[16:4]
	162: unique[c2500:4] = INT_OR unique[c6880:4], unique[c6980:4]
	163: unique[c6b80:4] = INT_AND unique[c2500:4], const[ffffffffff7fffff:4]
	164: unique[c6a00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[bf:4]
	165: unique[c6a80:1] = SUBPIECE unique[c6a00:[handle:size]], const[0:4]
	166: unique[c6b00:1] = INT_AND unique[c6a80:1], const[1:1]
	167: unique[c6c00:4] = INT_ZEXT unique[c6b00:1]
	168: unique[c6c80:4] = INT_LEFT unique[c6c00:4], const[17:4]
	169: unique[c2500:4] = INT_OR unique[c6b80:4], unique[c6c80:4]
	170: unique[c6e80:4] = INT_AND unique[c2500:4], const[fffffffffeffffff:4]
	171: unique[c6d00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[c7:4]
	172: unique[c6d80:1] = SUBPIECE unique[c6d00:[handle:size]], const[0:4]
	173: unique[c6e00:1] = INT_AND unique[c6d80:1], const[1:1]
	174: unique[c6f00:4] = INT_ZEXT unique[c6e00:1]
	175: unique[c6f80:4] = INT_LEFT unique[c6f00:4], const[18:4]
	176: unique[c2500:4] = INT_OR unique[c6e80:4], unique[c6f80:4]
	177: unique[c7180:4] = INT_AND unique[c2500:4], const[fffffffffdffffff:4]
	178: unique[c7000:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[cf:4]
	179: unique[c7080:1] = SUBPIECE unique[c7000:[handle:size]], const[0:4]
	180: unique[c7100:1] = INT_AND unique[c7080:1], const[1:1]
	181: unique[c7200:4] = INT_ZEXT unique[c7100:1]
	182: unique[c7280:4] = INT_LEFT unique[c7200:4], const[19:4]
	183: unique[c2500:4] = INT_OR unique[c7180:4], unique[c7280:4]
	184: unique[c7480:4] = INT_AND unique[c2500:4], const[fffffffffbffffff:4]
	185: unique[c7300:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[d7:4]
	186: unique[c7380:1] = SUBPIECE unique[c7300:[handle:size]], const[0:4]
	187: unique[c7400:1] = INT_AND unique[c7380:1], const[1:1]
	188: unique[c7500:4] = INT_ZEXT unique[c7400:1]
	189: unique[c7580:4] = INT_LEFT unique[c7500:4], const[1a:4]
	190: unique[c2500:4] = INT_OR unique[c7480:4], unique[c7580:4]
	191: unique[c7780:4] = INT_AND unique[c2500:4], const[fffffffff7ffffff:4]
	192: unique[c7600:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[df:4]
	193: unique[c7680:1] = SUBPIECE unique[c7600:[handle:size]], const[0:4]
	194: unique[c7700:1] = INT_AND unique[c7680:1], const[1:1]
	195: unique[c7800:4] = INT_ZEXT unique[c7700:1]
	196: unique[c7880:4] = INT_LEFT unique[c7800:4], const[1b:4]
	197: unique[c2500:4] = INT_OR unique[c7780:4], unique[c7880:4]
	198: unique[c7a80:4] = INT_AND unique[c2500:4], const[ffffffffefffffff:4]
	199: unique[c7900:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[e7:4]
	200: unique[c7980:1] = SUBPIECE unique[c7900:[handle:size]], const[0:4]
	201: unique[c7a00:1] = INT_AND unique[c7980:1], const[1:1]
	202: unique[c7b00:4] = INT_ZEXT unique[c7a00:1]
	203: unique[c7b80:4] = INT_LEFT unique[c7b00:4], const[1c:4]
	204: unique[c2500:4] = INT_OR unique[c7a80:4], unique[c7b80:4]
	205: unique[c7d80:4] = INT_AND unique[c2500:4], const[ffffffffdfffffff:4]
	206: unique[c7c00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[ef:4]
	207: unique[c7c80:1] = SUBPIECE unique[c7c00:[handle:size]], const[0:4]
	208: unique[c7d00:1] = INT_AND unique[c7c80:1], const[1:1]
	209: unique[c7e00:4] = INT_ZEXT unique[c7d00:1]
	210: unique[c7e80:4] = INT_LEFT unique[c7e00:4], const[1d:4]
	211: unique[c2500:4] = INT_OR unique[c7d80:4], unique[c7e80:4]
	212: unique[c8080:4] = INT_AND unique[c2500:4], const[ffffffffbfffffff:4]
	213: unique[c7f00:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[f7:4]
	214: unique[c7f80:1] = SUBPIECE unique[c7f00:[handle:size]], const[0:4]
	215: unique[c8000:1] = INT_AND unique[c7f80:1], const[1:1]
	216: unique[c8100:4] = INT_ZEXT unique[c8000:1]
	217: unique[c8180:4] = INT_LEFT unique[c8100:4], const[1e:4]
	218: unique[c2500:4] = INT_OR unique[c8080:4], unique[c8180:4]
	219: unique[c8380:4] = INT_AND unique[c2500:4], const[ffffffff7fffffff:4]
	220: unique[c8200:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], const[ff:4]
	221: unique[c8280:1] = SUBPIECE unique[c8200:[handle:size]], const[0:4]
	222: unique[c8300:1] = INT_AND unique[c8280:1], const[1:1]
	223: unique[c8400:4] = INT_ZEXT unique[c8300:1]
	224: unique[c8480:4] = INT_LEFT unique[c8400:4], const[1f:4]
	225: unique[c2500:4] = INT_OR unique[c8380:4], unique[c8480:4]
	226: [handle:space][[handle:offset]:[handle:size]] = COPY unique[c2500:4]
	227: MULTIEQUAL const[3:4]

Line ia.sinc:4075 :FADD ST0, freg     is vexMode=0 & byte=0xD8; frow=12 & fpage=0 & freg & ST0        { ST0 = ST0 f+ freg; }         
0: Constructor line ia.sinc:4075(id0.666) printpiece=[FADD,  ,  B, ,,  ,  A]
Operands 0: freg : 2530  1: ST0 : 2529  
Pattern id=666 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:C[0xxx]:XX:XX)
Template
	0: register[1106:a] = FLOAT_ADD register[1106:a], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4073 :FADD spec_m32      is vexMode=0 & byte=0xD8; reg_opcode=0 ... & spec_m32                    { ST0 = ST0 f+ float2float(spec_m32); } 
1: Constructor line ia.sinc:4073(id0.664) printpiece=[FADD,  ,  A]
Operands 0: spec_m32 : 2527  
Pattern id=664 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[44a80:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_ADD register[1106:a], unique[44a80:a]

Line ia.sinc:4223 :FMUL freg      is vexMode=0 & byte=0xD8; frow=12 & fpage=1 & freg          { ST0 = ST0 f* freg; }          
0: Constructor line ia.sinc:4223(id0.755) printpiece=[FMUL,  ,  A]
Operands 0: freg : 2617  
Pattern id=755 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:C[1xxx]:XX:XX)
Template
	0: register[1106:a] = FLOAT_MULT register[1106:a], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4221 :FMUL spec_m32       is vexMode=0 & byte=0xD8; reg_opcode=1 ... & spec_m32            { ST0 = ST0 f* float2float(spec_m32); }  
1: Constructor line ia.sinc:4221(id0.753) printpiece=[FMUL,  ,  A]
Operands 0: spec_m32 : 2615  
Pattern id=753 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[48980:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_MULT register[1106:a], unique[48980:a]

Line ia.sinc:4103 :FCOM           is vexMode=0 & byte=0xD8; byte=0xD1                 { fcom(ST1); }                   
0: Constructor line ia.sinc:4103(id0.688) printpiece=[FCOM]
Operands 
Pattern id=688 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:D1:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN register[1116:a]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], register[1116:a]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], register[1116:a]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]

Line ia.sinc:4102 :FCOM freg      is vexMode=0 & byte=0xD8; frow=13 & fpage=0 & freg          { fcom(freg); }                  
1: Constructor line ia.sinc:4102(id0.687) printpiece=[FCOM,  ,  A]
Operands 0: freg : 2557  
Pattern id=687 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:D[0xxx]:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]

Line ia.sinc:4100 :FCOM spec_m32       is vexMode=0 & byte=0xD8; reg_opcode=2 ... & spec_m32            { local tmp=float2float(spec_m32); fcom(tmp); }         
2: Constructor line ia.sinc:4100(id0.685) printpiece=[FCOM,  ,  A]
Operands 0: spec_m32 : 2555  
Pattern id=685 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[45800:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[45800:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[45800:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[45800:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]

Line ia.sinc:4107 :FCOMP          is vexMode=0 & byte=0xD8; byte=0xD9                 { fcom(ST1); fpop(); }               
0: Constructor line ia.sinc:4107(id0.692) printpiece=[FCOMP]
Operands 
Pattern id=692 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:D9:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN register[1116:a]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], register[1116:a]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], register[1116:a]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	19: register[1106:a] = COPY register[1116:a]
	20: register[1116:a] = COPY register[1126:a]
	21: register[1126:a] = COPY register[1136:a]
	22: register[1136:a] = COPY register[1146:a]
	23: register[1146:a] = COPY register[1156:a]
	24: register[1156:a] = COPY register[1166:a]
	25: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4106 :FCOMP freg     is vexMode=0 & byte=0xD8; frow=13 & fpage=1 & freg          { fcom(freg); fpop(); }              
1: Constructor line ia.sinc:4106(id0.691) printpiece=[FCOMP,  ,  A]
Operands 0: freg : 2560  
Pattern id=691 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:D[1xxx]:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	19: register[1106:a] = COPY register[1116:a]
	20: register[1116:a] = COPY register[1126:a]
	21: register[1126:a] = COPY register[1136:a]
	22: register[1136:a] = COPY register[1146:a]
	23: register[1146:a] = COPY register[1156:a]
	24: register[1156:a] = COPY register[1166:a]
	25: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4104 :FCOMP spec_m32      is vexMode=0 & byte=0xD8; reg_opcode=3 ... & spec_m32            { local tmp=float2float(spec_m32); fcom(tmp); fpop(); }     
2: Constructor line ia.sinc:4104(id0.689) printpiece=[FCOMP,  ,  A]
Operands 0: spec_m32 : 2558  
Pattern id=689 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[45a00:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[45a00:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[45a00:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[45a00:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	21: register[1106:a] = COPY register[1116:a]
	22: register[1116:a] = COPY register[1126:a]
	23: register[1126:a] = COPY register[1136:a]
	24: register[1136:a] = COPY register[1146:a]
	25: register[1146:a] = COPY register[1156:a]
	26: register[1156:a] = COPY register[1166:a]
	27: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4361 :FSUB ST0,freg  is vexMode=0 & byte=0xD8; frow=14 & fpage=0 & freg & ST0        { ST0 = ST0 f- freg; }                  
0: Constructor line ia.sinc:4361(id0.791) printpiece=[FSUB,  ,  B, ,,  A]
Operands 0: freg : 2647  1: ST0 : 2646  
Pattern id=791 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:E[0xxx]:XX:XX)
Template
	0: register[1106:a] = FLOAT_SUB register[1106:a], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4359 :FSUB spec_m32  is vexMode=0 & byte=0xD8; reg_opcode=4 ... & spec_m32            { ST0 = ST0 f- float2float(spec_m32); }          
1: Constructor line ia.sinc:4359(id0.789) printpiece=[FSUB,  ,  A]
Operands 0: spec_m32 : 2644  
Pattern id=789 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4bb80:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB register[1106:a], unique[4bb80:a]

Line ia.sinc:4370 :FSUBR ST0,freg  is vexMode=0 & byte=0xD8; frow=14 & fpage=1 & freg & ST0       { ST0 = freg f- ST0; }                  
0: Constructor line ia.sinc:4370(id0.799) printpiece=[FSUBR,  ,  B, ,,  A]
Operands 0: freg : 2657  1: ST0 : 2656  
Pattern id=799 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:E[1xxx]:XX:XX)
Template
	0: register[1106:a] = FLOAT_SUB [handle:space][[handle:offset]:[handle:size]], register[1106:a]

Line ia.sinc:4368 :FSUBR spec_m32  is vexMode=0 & byte=0xD8; reg_opcode=5 ... & spec_m32           { ST0 = float2float(spec_m32) f- ST0; }          
1: Constructor line ia.sinc:4368(id0.797) printpiece=[FSUBR,  ,  A]
Operands 0: spec_m32 : 2654  
Pattern id=797 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4c180:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB unique[4c180:a], register[1106:a]

Line ia.sinc:4128 :FDIV ST0,freg      is vexMode=0 & byte=0xD8; frow=15 & fpage=0 & freg & ST0        { ST0 = ST0 f/ freg; }            
0: Constructor line ia.sinc:4128(id0.706) printpiece=[FDIV,  ,  B, ,,  A]
Operands 0: freg : 2573  1: ST0 : 2572  
Pattern id=706 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:F[0xxx]:XX:XX)
Template
	0: register[1106:a] = FLOAT_DIV register[1106:a], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4126 :FDIV spec_m32      is vexMode=0 & byte=0xD8; reg_opcode=6 ... & spec_m32            { ST0 = ST0 f/ float2float(spec_m32); }    
1: Constructor line ia.sinc:4126(id0.704) printpiece=[FDIV,  ,  A]
Operands 0: spec_m32 : 2570  
Pattern id=704 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[45c80:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_DIV register[1106:a], unique[45c80:a]

Line ia.sinc:4137 :FDIVR ST0,freg     is vexMode=0 & byte=0xD8; frow=15 & fpage=1 & freg & ST0        { ST0 = freg f/ ST0; }            
0: Constructor line ia.sinc:4137(id0.714) printpiece=[FDIVR,  ,  B, ,,  A]
Operands 0: freg : 2583  1: ST0 : 2582  
Pattern id=714 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:F[1xxx]:XX:XX)
Template
	0: register[1106:a] = FLOAT_DIV [handle:space][[handle:offset]:[handle:size]], register[1106:a]

Line ia.sinc:4135 :FDIVR spec_m32     is vexMode=0 & byte=0xD8; reg_opcode=7 ... & spec_m32            { ST0 = float2float(spec_m32) f/ ST0; }    
1: Constructor line ia.sinc:4135(id0.712) printpiece=[FDIVR,  ,  A]
Operands 0: spec_m32 : 2580  
Pattern id=712 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D8:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46280:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_DIV unique[46280:a], register[1106:a]

Line avx.sinc:2640 :VPSUBUSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubusb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2640(id0.1821) printpiece=[VPSUBUSB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5786  1: vexVVVV_XmmReg : 5784  2: XmmReg1 : 5783  3: YmmReg1 : 5787  4: XmmReg2_m128 : 5785  
Pattern id=1821 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:D8:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3580:10] = CALLOTHER const[1c0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3580:10]

Line avx2.sinc:813 :VPSUBUSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubusb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:813(id0.2028) printpiece=[VPSUBUSB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6738  1: vexVVVV_YmmReg : 6736  2: YmmReg1 : 6735  3: YmmReg2_m256 : 6737  
Pattern id=2028 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:D8:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[256:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4193 :FLD spec_m32        is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=0) ... & spec_m32            { fdec(); ST0 = float2float(spec_m32); }           
0: Constructor line ia.sinc:4193(id0.740) printpiece=[FLD,  ,  A]
Operands 0: spec_m32 : 2608  
Pattern id=740 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:0[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[12500:a] = COPY register[1176:a]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[12500:a]
	10: register[1106:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4323 :FST spec_m32   is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=2) ... & spec_m32            { spec_m32 = float2float(ST0); }     
0: Constructor line ia.sinc:4323(id0.774) printpiece=[FST,  ,  A]
Operands 0: spec_m32 : 2629  
Pattern id=774 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:1[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = FLOAT2FLOAT register[1106:a]

Line ia.sinc:4326 :FSTP spec_m32  is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=3) ... & spec_m32            { spec_m32 = float2float(ST0); fpop(); } 
0: Constructor line ia.sinc:4326(id0.777) printpiece=[FSTP,  ,  A]
Operands 0: spec_m32 : 2632  
Pattern id=777 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = FLOAT2FLOAT register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4211 :FLDENV Mem     is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=4) ... & Mem
{
  FPUControlWord           = *:2 (Mem);
  FPUStatusWord            = *:2 (Mem +  4);
  FPUTagWord               = *:2 (Mem +  8);
  FPUDataPointer           = *:4 (Mem + 20);
  FPUInstructionPointer    = *:4 (Mem + 12);
  FPULastInstructionOpcode = *:2 (Mem + 18);
}
0: Constructor line ia.sinc:4211(id0.752) printpiece=[FLDENV,  ,  A]
Operands 0: Mem : 2614  
Pattern id=752 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:2[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[48480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: register[10a2:2] = LOAD const[ram:8], unique[48480:[handle:size]]
	4: unique[48580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: register[10a4:2] = LOAD const[ram:8], unique[48580:[handle:size]]
	6: unique[48680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: register[10a8:4] = LOAD const[ram:8], unique[48680:[handle:size]]
	8: unique[48780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: register[10ac:4] = LOAD const[ram:8], unique[48780:[handle:size]]
	10: unique[48880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: register[10a6:2] = LOAD const[ram:8], unique[48880:[handle:size]]

Line ia.sinc:4208 :FLDCW m16      is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=5) ... & m16            { FPUControlWord = m16; }
0: Constructor line ia.sinc:4208(id0.751) printpiece=[FLDCW,  ,  A]
Operands 0: m16 : 2612  
Pattern id=751 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:2[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4344 :FNSTENV Mem    is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=6) ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;
}
0: Constructor line ia.sinc:4344(id0.784) printpiece=[FNSTENV,  ,  A]
Operands 0: Mem : 2639  
Pattern id=784 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:3[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4b900:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: STORE const[ram:8], unique[4b900:[handle:size]], register[10a2:2]
	4: unique[4b980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: STORE const[ram:8], unique[4b980:[handle:size]], register[10a4:2]
	6: unique[4ba00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: STORE const[ram:8], unique[4ba00:[handle:size]], register[10a8:4]
	8: unique[4ba80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: STORE const[ram:8], unique[4ba80:[handle:size]], register[10ac:4]
	10: unique[4bb00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: STORE const[ram:8], unique[4bb00:[handle:size]], register[10a6:2]

Line ia.sinc:4332 :FNSTCW m16     is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=7) ... & m16            { m16 = FPUControlWord; }
0: Constructor line ia.sinc:4332(id0.782) printpiece=[FNSTCW,  ,  A]
Operands 0: m16 : 2637  
Pattern id=782 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:3[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[10a0:2]

Line ia.sinc:4193 :FLD spec_m32        is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=0) ... & spec_m32            { fdec(); ST0 = float2float(spec_m32); }           
0: Constructor line ia.sinc:4193(id0.740) printpiece=[FLD,  ,  A]
Operands 0: spec_m32 : 2608  
Pattern id=740 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:4[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[12500:a] = COPY register[1176:a]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[12500:a]
	10: register[1106:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4323 :FST spec_m32   is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=2) ... & spec_m32            { spec_m32 = float2float(ST0); }     
0: Constructor line ia.sinc:4323(id0.774) printpiece=[FST,  ,  A]
Operands 0: spec_m32 : 2629  
Pattern id=774 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:5[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = FLOAT2FLOAT register[1106:a]

Line ia.sinc:4326 :FSTP spec_m32  is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=3) ... & spec_m32            { spec_m32 = float2float(ST0); fpop(); } 
0: Constructor line ia.sinc:4326(id0.777) printpiece=[FSTP,  ,  A]
Operands 0: spec_m32 : 2632  
Pattern id=777 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:5[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = FLOAT2FLOAT register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4211 :FLDENV Mem     is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=4) ... & Mem
{
  FPUControlWord           = *:2 (Mem);
  FPUStatusWord            = *:2 (Mem +  4);
  FPUTagWord               = *:2 (Mem +  8);
  FPUDataPointer           = *:4 (Mem + 20);
  FPUInstructionPointer    = *:4 (Mem + 12);
  FPULastInstructionOpcode = *:2 (Mem + 18);
}
0: Constructor line ia.sinc:4211(id0.752) printpiece=[FLDENV,  ,  A]
Operands 0: Mem : 2614  
Pattern id=752 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:6[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[48480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: register[10a2:2] = LOAD const[ram:8], unique[48480:[handle:size]]
	4: unique[48580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: register[10a4:2] = LOAD const[ram:8], unique[48580:[handle:size]]
	6: unique[48680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: register[10a8:4] = LOAD const[ram:8], unique[48680:[handle:size]]
	8: unique[48780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: register[10ac:4] = LOAD const[ram:8], unique[48780:[handle:size]]
	10: unique[48880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: register[10a6:2] = LOAD const[ram:8], unique[48880:[handle:size]]

Line ia.sinc:4208 :FLDCW m16      is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=5) ... & m16            { FPUControlWord = m16; }
0: Constructor line ia.sinc:4208(id0.751) printpiece=[FLDCW,  ,  A]
Operands 0: m16 : 2612  
Pattern id=751 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:6[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4344 :FNSTENV Mem    is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=6) ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;
}
0: Constructor line ia.sinc:4344(id0.784) printpiece=[FNSTENV,  ,  A]
Operands 0: Mem : 2639  
Pattern id=784 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:7[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4b900:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: STORE const[ram:8], unique[4b900:[handle:size]], register[10a2:2]
	4: unique[4b980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: STORE const[ram:8], unique[4b980:[handle:size]], register[10a4:2]
	6: unique[4ba00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: STORE const[ram:8], unique[4ba00:[handle:size]], register[10a8:4]
	8: unique[4ba80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: STORE const[ram:8], unique[4ba80:[handle:size]], register[10ac:4]
	10: unique[4bb00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: STORE const[ram:8], unique[4bb00:[handle:size]], register[10a6:2]

Line ia.sinc:4332 :FNSTCW m16     is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=7) ... & m16            { m16 = FPUControlWord; }
0: Constructor line ia.sinc:4332(id0.782) printpiece=[FNSTCW,  ,  A]
Operands 0: m16 : 2637  
Pattern id=782 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:7[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[10a0:2]

Line ia.sinc:4193 :FLD spec_m32        is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=0) ... & spec_m32            { fdec(); ST0 = float2float(spec_m32); }           
0: Constructor line ia.sinc:4193(id0.740) printpiece=[FLD,  ,  A]
Operands 0: spec_m32 : 2608  
Pattern id=740 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:8[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[12500:a] = COPY register[1176:a]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[12500:a]
	10: register[1106:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4323 :FST spec_m32   is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=2) ... & spec_m32            { spec_m32 = float2float(ST0); }     
0: Constructor line ia.sinc:4323(id0.774) printpiece=[FST,  ,  A]
Operands 0: spec_m32 : 2629  
Pattern id=774 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:9[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = FLOAT2FLOAT register[1106:a]

Line ia.sinc:4326 :FSTP spec_m32  is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=3) ... & spec_m32            { spec_m32 = float2float(ST0); fpop(); } 
0: Constructor line ia.sinc:4326(id0.777) printpiece=[FSTP,  ,  A]
Operands 0: spec_m32 : 2632  
Pattern id=777 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:9[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = FLOAT2FLOAT register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4211 :FLDENV Mem     is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=4) ... & Mem
{
  FPUControlWord           = *:2 (Mem);
  FPUStatusWord            = *:2 (Mem +  4);
  FPUTagWord               = *:2 (Mem +  8);
  FPUDataPointer           = *:4 (Mem + 20);
  FPUInstructionPointer    = *:4 (Mem + 12);
  FPULastInstructionOpcode = *:2 (Mem + 18);
}
0: Constructor line ia.sinc:4211(id0.752) printpiece=[FLDENV,  ,  A]
Operands 0: Mem : 2614  
Pattern id=752 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:A[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[48480:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: register[10a2:2] = LOAD const[ram:8], unique[48480:[handle:size]]
	4: unique[48580:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: register[10a4:2] = LOAD const[ram:8], unique[48580:[handle:size]]
	6: unique[48680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: register[10a8:4] = LOAD const[ram:8], unique[48680:[handle:size]]
	8: unique[48780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: register[10ac:4] = LOAD const[ram:8], unique[48780:[handle:size]]
	10: unique[48880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: register[10a6:2] = LOAD const[ram:8], unique[48880:[handle:size]]

Line ia.sinc:4208 :FLDCW m16      is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=5) ... & m16            { FPUControlWord = m16; }
0: Constructor line ia.sinc:4208(id0.751) printpiece=[FLDCW,  ,  A]
Operands 0: m16 : 2612  
Pattern id=751 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:A[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4344 :FNSTENV Mem    is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=6) ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;
}
0: Constructor line ia.sinc:4344(id0.784) printpiece=[FNSTENV,  ,  A]
Operands 0: Mem : 2639  
Pattern id=784 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:B[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4b900:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: STORE const[ram:8], unique[4b900:[handle:size]], register[10a2:2]
	4: unique[4b980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: STORE const[ram:8], unique[4b980:[handle:size]], register[10a4:2]
	6: unique[4ba00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: STORE const[ram:8], unique[4ba00:[handle:size]], register[10a8:4]
	8: unique[4ba80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: STORE const[ram:8], unique[4ba80:[handle:size]], register[10ac:4]
	10: unique[4bb00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: STORE const[ram:8], unique[4bb00:[handle:size]], register[10a6:2]

Line ia.sinc:4332 :FNSTCW m16     is vexMode=0 & byte=0xD9; (mod != 0b11 & reg_opcode=7) ... & m16            { m16 = FPUControlWord; }
0: Constructor line ia.sinc:4332(id0.782) printpiece=[FNSTCW,  ,  A]
Operands 0: m16 : 2637  
Pattern id=782 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:B[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[10a0:2]

Line ia.sinc:4198 :FLD freg       is vexMode=0 & byte=0xD9; frow=12 & fpage=0 & freg          { tmp:10 = freg; fpushv(tmp); }                     
0: Constructor line ia.sinc:4198(id0.743) printpiece=[FLD,  ,  A]
Operands 0: freg : 2611  
Pattern id=743 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:C[0xxx]:XX:XX)
Template
	0: unique[47900:a] = COPY [handle:space][[handle:offset]:[handle:size]]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY unique[47900:a]

Line ia.sinc:4407 :FXCH           is vexMode=0 & byte=0xD9; byte=0xC9                 { local tmp = ST0; ST0 = ST1; ST1 = tmp; }                    
0: Constructor line ia.sinc:4407(id0.813) printpiece=[FXCH]
Operands 
Pattern id=813 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:C9:XX:XX)
Template
	0: unique[4d280:a] = COPY register[1106:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY unique[4d280:a]

Line ia.sinc:4406 :FXCH freg      is vexMode=0 & byte=0xD9; frow=12 & fpage=1 & freg          { local tmp = ST0; ST0 = freg; freg = tmp; }          
1: Constructor line ia.sinc:4406(id0.812) printpiece=[FXCH,  ,  A]
Operands 0: freg : 2666  
Pattern id=812 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:C[1xxx]:XX:XX)
Template
	0: unique[4d200:a] = COPY register[1106:a]
	1: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = COPY unique[4d200:a]

Line ia.sinc:4230 :FNOP           is vexMode=0 & byte=0xD9; byte=0xD0                 { }
0: Constructor line ia.sinc:4230(id0.761) printpiece=[FNOP]
Operands 
Pattern id=761 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:D0:XX:XX)
Template

Line ia.sinc:4086 :FCHS           is vexMode=0 & byte=0xD9; byte=0xE0                 { ST0 = f- ST0; }
0: Constructor line ia.sinc:4086(id0.674) printpiece=[FCHS]
Operands 
Pattern id=674 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:E0:XX:XX)
Template
	0: register[1106:a] = FLOAT_NEG register[1106:a]

Line ia.sinc:4071 :FABS           is vexMode=0 & byte=0xD9; byte=0xE1                 { ST0 = abs(ST0); }
0: Constructor line ia.sinc:4071(id0.663) printpiece=[FABS]
Operands 
Pattern id=663 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:E1:XX:XX)
Template
	0: register[1106:a] = FLOAT_ABS register[1106:a]

Line ia.sinc:4377 :FTST           is vexMode=0 & byte=0xD9; byte=0xE4                 { zero:4 = 0; tmp:10 = int2float(zero); fcom(tmp); }    
0: Constructor line ia.sinc:4377(id0.805) printpiece=[FTST]
Operands 
Pattern id=805 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:E4:XX:XX)
Template
	0: unique[4c880:a] = INT2FLOAT const[0:4]
	1: register[1091:1] = COPY const[0:1]
	2: unique[12600:1] = FLOAT_NAN register[1106:a]
	3: unique[12680:1] = FLOAT_NAN unique[4c880:a]
	4: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	5: unique[12780:1] = FLOAT_LESS register[1106:a], unique[4c880:a]
	6: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	7: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[4c880:a]
	8: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	9: unique[12980:2] = INT_ZEXT register[1090:1]
	10: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	11: unique[12a80:2] = INT_ZEXT register[1091:1]
	12: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	13: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	14: unique[12c00:2] = INT_ZEXT register[1092:1]
	15: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	16: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	17: unique[12d80:2] = INT_ZEXT register[1093:1]
	18: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	19: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]

Line ia.sinc:4385 :FXAM           is vexMode=0 & byte=0xD9; byte=0xE5
{
  # this is not an exact implementation, but gets the sign and zero tests right
  izero:4 = 0;
  fzero:10 = int2float(izero);
  
  # did not know how test for infinity or empty
  C0 = nan(ST0);
  
  # sign of ST0
  C1 = ( ST0 f< fzero );

  # assume normal if not zero 
  C2 = ( ST0 f!= fzero );

  # equal to zero  
  C3 = ( ST0 f== fzero );
  
  FPUStatusWord = (zext(C0)<<8) | (zext(C1)<<9) | (zext(C2)<<10) | (zext(C3)<<14);
}
0: Constructor line ia.sinc:4385(id0.811) printpiece=[FXAM]
Operands 
Pattern id=811 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:E5:XX:XX)
Template
	0: unique[4ca00:a] = INT2FLOAT const[0:4]
	1: register[1090:1] = FLOAT_NAN register[1106:a]
	2: register[1091:1] = FLOAT_LESS register[1106:a], unique[4ca00:a]
	3: register[1092:1] = FLOAT_NOTEQUAL register[1106:a], unique[4ca00:a]
	4: register[1093:1] = FLOAT_EQUAL register[1106:a], unique[4ca00:a]
	5: unique[4cc80:2] = INT_ZEXT register[1090:1]
	6: unique[4cd00:2] = INT_LEFT unique[4cc80:2], const[8:4]
	7: unique[4cd80:2] = INT_ZEXT register[1091:1]
	8: unique[4ce00:2] = INT_LEFT unique[4cd80:2], const[9:4]
	9: unique[4ce80:2] = INT_OR unique[4cd00:2], unique[4ce00:2]
	10: unique[4cf00:2] = INT_ZEXT register[1092:1]
	11: unique[4cf80:2] = INT_LEFT unique[4cf00:2], const[a:4]
	12: unique[4d000:2] = INT_OR unique[4ce80:2], unique[4cf80:2]
	13: unique[4d080:2] = INT_ZEXT register[1093:1]
	14: unique[4d100:2] = INT_LEFT unique[4d080:2], const[e:4]
	15: register[10a2:2] = INT_OR unique[4d000:2], unique[4d100:2]

Line ia.sinc:4200 :FLD1           is vexMode=0 & byte=0xD9; byte=0xE8                 { one:4 = 1; tmp:10 = int2float(one); fpushv(tmp); }  
0: Constructor line ia.sinc:4200(id0.744) printpiece=[FLD1]
Operands 
Pattern id=744 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:E8:XX:XX)
Template
	0: unique[47a80:a] = INT2FLOAT const[1:4]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY unique[47a80:a]

Line ia.sinc:4201 :FLDL2T		is vexMode=0 & byte=0xD9; byte=0xE9			{ src:8 = 0x400a934f0979a371; tmp:10 = float2float(src); fpushv(tmp); }
0: Constructor line ia.sinc:4201(id0.745) printpiece=[FLDL2T]
Operands 
Pattern id=745 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:E9:XX:XX)
Template
	0: unique[47c00:a] = FLOAT2FLOAT const[400a934f0979a371:8]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY unique[47c00:a]

Line ia.sinc:4202 :FLDL2E		is vexMode=0 & byte=0xD9; byte=0xEA			{ src:8 = 0x3ff71547652b82fe; tmp:10 = float2float(src); fpushv(tmp); }
0: Constructor line ia.sinc:4202(id0.746) printpiece=[FLDL2E]
Operands 
Pattern id=746 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:EA:XX:XX)
Template
	0: unique[47d80:a] = FLOAT2FLOAT const[3ff71547652b82fe:8]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY unique[47d80:a]

Line ia.sinc:4203 :FLDPI		is vexMode=0 & byte=0xD9; byte=0xEB			{ src:8 = 0x400921fb54442d18; tmp:10 = float2float(src); fpushv(tmp); }
0: Constructor line ia.sinc:4203(id0.747) printpiece=[FLDPI]
Operands 
Pattern id=747 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:EB:XX:XX)
Template
	0: unique[47f00:a] = FLOAT2FLOAT const[400921fb54442d18:8]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY unique[47f00:a]

Line ia.sinc:4204 :FLDLG2		is vexMode=0 & byte=0xD9; byte=0xEC			{ src:8 = 0x3fd34413509f79ff; tmp:10 = float2float(src); fpushv(tmp); }
0: Constructor line ia.sinc:4204(id0.748) printpiece=[FLDLG2]
Operands 
Pattern id=748 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:EC:XX:XX)
Template
	0: unique[48080:a] = FLOAT2FLOAT const[3fd34413509f79ff:8]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY unique[48080:a]

Line ia.sinc:4205 :FLDLN2		is vexMode=0 & byte=0xD9; byte=0xED			{ src:8 = 0x3fe62e42fefa39ef; tmp:10 = float2float(src); fpushv(tmp); }
0: Constructor line ia.sinc:4205(id0.749) printpiece=[FLDLN2]
Operands 
Pattern id=749 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:ED:XX:XX)
Template
	0: unique[48200:a] = FLOAT2FLOAT const[3fe62e42fefa39ef:8]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY unique[48200:a]

Line ia.sinc:4206 :FLDZ		is vexMode=0 & byte=0xD9; byte=0xEE			{ zero:4 = 0; tmp:10 = int2float(zero); fpushv(tmp); }
0: Constructor line ia.sinc:4206(id0.750) printpiece=[FLDZ]
Operands 
Pattern id=750 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:EE:XX:XX)
Template
	0: unique[48380:a] = INT2FLOAT const[0:4]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY unique[48380:a]

Line ia.sinc:4069 :F2XM1          is vexMode=0 & byte=0xD9; byte=0xF0                 { ST0 = f2xm1(ST0); } # compute 2^x-1

:FABS           is vexMode=0 & byte=0xD9; byte=0xE1                 { ST0 = abs(ST0); }
0: Constructor line ia.sinc:4069(id0.662) printpiece=[F2XM1]
Operands 
Pattern id=662 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F0:XX:XX)
Template
	0: register[1106:a] = CALLOTHER const[5e:4], register[1106:a]

Line ia.sinc:4650 :FYL2X          is vexMode=0 & byte=0xD9; byte=0xF1                 { local log2st0 = ST0; ST1 = ST1 f* log2st0; fpop(); }
0: Constructor line ia.sinc:4650(id0.817) printpiece=[FYL2X]
Operands 
Pattern id=817 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F1:XX:XX)
Template
	0: register[1116:a] = FLOAT_MULT register[1116:a], register[1106:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4240 :FPTAN		is vexMode=0 & byte=0xD9; byte=0xF2			{ ST0 = fptan(ST0); one:4 = 1; tmp:10 = int2float(one); fpushv(tmp); }
0: Constructor line ia.sinc:4240(id0.765) printpiece=[FPTAN]
Operands 
Pattern id=765 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F2:XX:XX)
Template
	0: register[1106:a] = CALLOTHER const[63:4], register[1106:a]
	1: unique[49580:a] = INT2FLOAT const[1:4]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[49580:a]

Line ia.sinc:4233 :FPATAN		is vexMode=0 & byte=0xD9; byte=0xF3			{ ST1 = fpatan(ST1, ST0); fpop(); }
0: Constructor line ia.sinc:4233(id0.762) printpiece=[FPATAN]
Operands 
Pattern id=762 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F3:XX:XX)
Template
	0: register[1116:a] = CALLOTHER const[62:4], register[1116:a], register[1106:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4648 :FXTRACT        is vexMode=0 & byte=0xD9; byte=0xF4                 { significand:10 = ST0; exponent:10 = ST0; ST0 = exponent; fpushv(significand); }
0: Constructor line ia.sinc:4648(id0.816) printpiece=[FXTRACT]
Operands 
Pattern id=816 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F4:XX:XX)
Template
	0: unique[4f780:a] = COPY register[1106:a]
	1: register[1106:a] = COPY register[1106:a]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[4f780:a]

Line ia.sinc:4237 :FPREM1         is vexMode=0 & byte=0xD9; byte=0xF5                 { local tmp = ST0 f/ ST1; tmp = tmp f* ST1; ST0 = ST0 f- tmp; }
0: Constructor line ia.sinc:4237(id0.764) printpiece=[FPREM1]
Operands 
Pattern id=764 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F5:XX:XX)
Template
	0: unique[49280:a] = FLOAT_DIV register[1106:a], register[1116:a]
	1: unique[49280:a] = FLOAT_MULT unique[49280:a], register[1116:a]
	2: register[1106:a] = FLOAT_SUB register[1106:a], unique[49280:a]

Line ia.sinc:4118 :FDECSTP		    is vexMode=0 & byte=0xD9; byte=0xF6					{ fdec(); FPUStatusWord = FPUStatusWord & 0xfeff; C0 = 0; }  #Clear C0

# Legacy 8087 instructions. Still valid but treated as NOP instructions.
:FDISI              is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE1 {}
0: Constructor line ia.sinc:4118(id0.699) printpiece=[FDECSTP]
Operands 
Pattern id=699 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F6:XX:XX)
Template
	0: unique[12500:a] = COPY register[1176:a]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY unique[12500:a]
	9: register[10a2:2] = INT_AND register[10a2:2], const[feff:2]
	10: register[1090:1] = COPY const[0:1]

Line ia.sinc:4157 :FINCSTP            is vexMode=0 & byte=0xD9; byte=0xF7                 { finc(); }                                   
0: Constructor line ia.sinc:4157(id0.729) printpiece=[FINCSTP]
Operands 
Pattern id=729 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F7:XX:XX)
Template
	0: unique[12580:a] = COPY register[1106:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]
	8: register[1176:a] = COPY unique[12580:a]

Line ia.sinc:4235 :FPREM          is vexMode=0 & byte=0xD9; byte=0xF8                 { local tmp = ST0 f/ ST1; tmp = tmp f* ST1; ST0 = ST0 f- tmp; }
0: Constructor line ia.sinc:4235(id0.763) printpiece=[FPREM]
Operands 
Pattern id=763 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F8:XX:XX)
Template
	0: unique[49080:a] = FLOAT_DIV register[1106:a], register[1116:a]
	1: unique[49080:a] = FLOAT_MULT unique[49080:a], register[1116:a]
	2: register[1106:a] = FLOAT_SUB register[1106:a], unique[49080:a]

Line ia.sinc:4651 :FYL2XP1        is vexMode=0 & byte=0xD9; byte=0xF9                 { one:4 = 1; tmp:10 = int2float(one); log2st0:10 = ST0 f+ tmp; ST1 = ST1 f* log2st0; fpop(); }
0: Constructor line ia.sinc:4651(id0.818) printpiece=[FYL2XP1]
Operands 
Pattern id=818 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:F9:XX:XX)
Template
	0: unique[4fa80:a] = INT2FLOAT const[1:4]
	1: unique[4fb80:a] = FLOAT_ADD register[1106:a], unique[4fa80:a]
	2: register[1116:a] = FLOAT_MULT register[1116:a], unique[4fb80:a]
	3: register[1106:a] = COPY register[1116:a]
	4: register[1116:a] = COPY register[1126:a]
	5: register[1126:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1146:a]
	7: register[1146:a] = COPY register[1156:a]
	8: register[1156:a] = COPY register[1166:a]
	9: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4321 :FSQRT          is vexMode=0 & byte=0xD9; byte=0xFA                 { ST0 = sqrt(ST0); }
0: Constructor line ia.sinc:4321(id0.773) printpiece=[FSQRT]
Operands 
Pattern id=773 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:FA:XX:XX)
Template
	0: register[1106:a] = FLOAT_SQRT register[1106:a]

Line ia.sinc:4320 :FSINCOS	    is vexMode=0 & byte=0xD9; byte=0xFB			{ tmp:10 = fcos(ST0); ST0 = fsin(ST0); fpushv(tmp); }
0: Constructor line ia.sinc:4320(id0.772) printpiece=[FSINCOS]
Operands 
Pattern id=772 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:FB:XX:XX)
Template
	0: unique[4b300:a] = CALLOTHER const[5f:4], register[1106:a]
	1: register[1106:a] = CALLOTHER const[65:4], register[1106:a]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[4b300:a]

Line ia.sinc:4242 :FRNDINT        is vexMode=0 & byte=0xD9; byte=0xFC                 { local tmp = round(ST0); ST0 = tmp; }
0: Constructor line ia.sinc:4242(id0.766) printpiece=[FRNDINT]
Operands 
Pattern id=766 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:FC:XX:XX)
Template
	0: register[1106:a] = ROUND register[1106:a]

Line ia.sinc:4316 :FSCALE		    is vexMode=0 & byte=0xD9; byte=0xFD			{ ST0 = fscale(ST0, ST1); }
0: Constructor line ia.sinc:4316(id0.770) printpiece=[FSCALE]
Operands 
Pattern id=770 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:FD:XX:XX)
Template
	0: register[1106:a] = CALLOTHER const[64:4], register[1106:a], register[1116:a]

Line ia.sinc:4319 :FSIN		    is vexMode=0 & byte=0xD9; byte=0xFE			{ ST0 = fsin(ST0); }
0: Constructor line ia.sinc:4319(id0.771) printpiece=[FSIN]
Operands 
Pattern id=771 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:FE:XX:XX)
Template
	0: register[1106:a] = CALLOTHER const[65:4], register[1106:a]

Line ia.sinc:4116 :FCOS			    is vexMode=0 & byte=0xD9; byte=0xFF					{ ST0 = fcos(ST0); }
0: Constructor line ia.sinc:4116(id0.698) printpiece=[FCOS]
Operands 
Pattern id=698 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:D9:FF:XX:XX)
Template
	0: register[1106:a] = CALLOTHER const[5f:4], register[1106:a]

Line avx.sinc:2649 :VPSUBUSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xD9; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubusw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2649(id0.1822) printpiece=[VPSUBUSW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5792  1: vexVVVV_XmmReg : 5790  2: XmmReg1 : 5789  3: YmmReg1 : 5793  4: XmmReg2_m128 : 5791  
Pattern id=1822 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:D9:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3700:10] = CALLOTHER const[1c1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3700:10]

Line avx2.sinc:821 :VPSUBUSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xD9; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubusw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:821(id0.2029) printpiece=[VPSUBUSW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6743  1: vexVVVV_YmmReg : 6741  2: YmmReg1 : 6740  3: YmmReg2_m256 : 6742  
Pattern id=2029 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:D9:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[257:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4091 :FCMOVB ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=0 & freg & ST0        { if ( !CF ) goto inst_next; ST0 = freg; }   
0: Constructor line ia.sinc:4091(id0.677) printpiece=[FCMOVB,  ,  B, ,,  ,  A]
Operands 0: freg : 2540  1: ST0 : 2539  
Pattern id=677 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:C[0xxx]:XX:XX)
Template
	0: unique[45400:1] = BOOL_NEGATE register[200:1]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[45400:1]
	2: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4079 :FIADD spec_m32     is vexMode=0 & byte=0xDA; reg_opcode=0 ... & spec_m32            { ST0 = ST0 f+ int2float(spec_m32); }   
1: Constructor line ia.sinc:4079(id0.670) printpiece=[FIADD,  ,  A]
Operands 0: spec_m32 : 2535  
Pattern id=670 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[44e80:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_ADD register[1106:a], unique[44e80:a]

Line ia.sinc:4092 :FCMOVE ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=1 & freg & ST0        { if ( !ZF ) goto inst_next; ST0 = freg; }   
0: Constructor line ia.sinc:4092(id0.678) printpiece=[FCMOVE,  ,  B, ,,  ,  A]
Operands 0: freg : 2542  1: ST0 : 2541  
Pattern id=678 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:C[1xxx]:XX:XX)
Template
	0: unique[45480:1] = BOOL_NEGATE register[206:1]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[45480:1]
	2: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4227 :FIMUL spec_m32      is vexMode=0 & byte=0xDA; reg_opcode=1 ... & spec_m32            { ST0 = ST0 f* int2float(spec_m32); }    
1: Constructor line ia.sinc:4227(id0.759) printpiece=[FIMUL,  ,  A]
Operands 0: spec_m32 : 2620  
Pattern id=759 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[48d80:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_MULT register[1106:a], unique[48d80:a]

Line ia.sinc:4093 :FCMOVBE ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=0 & freg & ST0        { if ( !CF & !ZF ) goto inst_next; ST0 = freg; } 
0: Constructor line ia.sinc:4093(id0.679) printpiece=[FCMOVBE,  ,  B, ,,  ,  A]
Operands 0: freg : 2544  1: ST0 : 2543  
Pattern id=679 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:D[0xxx]:XX:XX)
Template
	0: unique[45500:1] = BOOL_NEGATE register[200:1]
	1: unique[45580:1] = BOOL_NEGATE register[206:1]
	2: unique[45600:1] = INT_AND unique[45500:1], unique[45580:1]
	3: CBRANCH [curspace][[next]:[curspace_size]], unique[45600:1]
	4: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4149 :FICOM spec_m32     is vexMode=0 & byte=0xDA; reg_opcode=2 ... & spec_m32            { local tmp = int2float(spec_m32); fcom(tmp); }          
1: Constructor line ia.sinc:4149(id0.723) printpiece=[FICOM,  ,  A]
Operands 0: spec_m32 : 2594  
Pattern id=723 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46b00:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[46b00:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[46b00:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[46b00:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]

Line ia.sinc:4094 :FCMOVU  ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=1 & freg & ST0        { if ( !PF ) goto inst_next; ST0 = freg; }   
0: Constructor line ia.sinc:4094(id0.680) printpiece=[FCMOVU,  ,  B, ,,  ,  A]
Operands 0: freg : 2546  1: ST0 : 2545  
Pattern id=680 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:D[1xxx]:XX:XX)
Template
	0: unique[45680:1] = BOOL_NEGATE register[202:1]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[45680:1]
	2: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4151 :FICOMP spec_m32    is vexMode=0 & byte=0xDA; reg_opcode=3 ... & spec_m32            { local tmp = int2float(spec_m32); fcom(tmp); fpop(); }  
1: Constructor line ia.sinc:4151(id0.725) printpiece=[FICOMP,  ,  A]
Operands 0: spec_m32 : 2596  
Pattern id=725 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46d00:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[46d00:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[46d00:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[46d00:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	21: register[1106:a] = COPY register[1116:a]
	22: register[1116:a] = COPY register[1126:a]
	23: register[1126:a] = COPY register[1136:a]
	24: register[1136:a] = COPY register[1146:a]
	25: register[1146:a] = COPY register[1156:a]
	26: register[1156:a] = COPY register[1166:a]
	27: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4365 :FISUB spec_m32 is vexMode=0 & byte=0xDA; (mod != 0b11 & reg_opcode=4) ... & spec_m32            { ST0 = ST0 f- int2float(spec_m32); }            
0: Constructor line ia.sinc:4365(id0.795) printpiece=[FISUB,  ,  A]
Operands 0: spec_m32 : 2652  
Pattern id=795 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:2[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4bf80:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB register[1106:a], unique[4bf80:a]

Line ia.sinc:4365 :FISUB spec_m32 is vexMode=0 & byte=0xDA; (mod != 0b11 & reg_opcode=4) ... & spec_m32            { ST0 = ST0 f- int2float(spec_m32); }            
0: Constructor line ia.sinc:4365(id0.795) printpiece=[FISUB,  ,  A]
Operands 0: spec_m32 : 2652  
Pattern id=795 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:6[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4bf80:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB register[1106:a], unique[4bf80:a]

Line ia.sinc:4365 :FISUB spec_m32 is vexMode=0 & byte=0xDA; (mod != 0b11 & reg_opcode=4) ... & spec_m32            { ST0 = ST0 f- int2float(spec_m32); }            
0: Constructor line ia.sinc:4365(id0.795) printpiece=[FISUB,  ,  A]
Operands 0: spec_m32 : 2652  
Pattern id=795 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:A[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4bf80:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB register[1106:a], unique[4bf80:a]

Line ia.sinc:4383 :FUCOMPP        is vexMode=0 & byte=0xDA; byte=0xE9                 { fcom(ST1); fpop(); fpop(); }                  
0: Constructor line ia.sinc:4383(id0.810) printpiece=[FUCOMPP]
Operands 
Pattern id=810 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:E9:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN register[1116:a]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], register[1116:a]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], register[1116:a]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	19: register[1106:a] = COPY register[1116:a]
	20: register[1116:a] = COPY register[1126:a]
	21: register[1126:a] = COPY register[1136:a]
	22: register[1136:a] = COPY register[1146:a]
	23: register[1146:a] = COPY register[1156:a]
	24: register[1156:a] = COPY register[1166:a]
	25: register[1166:a] = COPY register[1176:a]
	26: register[1106:a] = COPY register[1116:a]
	27: register[1116:a] = COPY register[1126:a]
	28: register[1126:a] = COPY register[1136:a]
	29: register[1136:a] = COPY register[1146:a]
	30: register[1146:a] = COPY register[1156:a]
	31: register[1156:a] = COPY register[1166:a]
	32: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4374 :FISUBR spec_m32 is vexMode=0 & byte=0xDA; reg_opcode=5 ... & spec_m32           { ST0 = int2float(spec_m32) f- ST0; }            
1: Constructor line ia.sinc:4374(id0.803) printpiece=[FISUBR,  ,  A]
Operands 0: spec_m32 : 2662  
Pattern id=803 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4c580:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB unique[4c580:a], register[1106:a]

Line ia.sinc:4132 :FIDIV spec_m32     is vexMode=0 & byte=0xDA; reg_opcode=6 ... & spec_m32            { ST0 = ST0 f/ int2float(spec_m32); }      
0: Constructor line ia.sinc:4132(id0.710) printpiece=[FIDIV,  ,  A]
Operands 0: spec_m32 : 2578  
Pattern id=710 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46080:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_DIV register[1106:a], unique[46080:a]

Line ia.sinc:4141 :FIDIVR spec_m32    is vexMode=0 & byte=0xDA; reg_opcode=7 ... & spec_m32            { ST0 = int2float(spec_m32) f/ ST0; }      
0: Constructor line ia.sinc:4141(id0.718) printpiece=[FIDIVR,  ,  A]
Operands 0: spec_m32 : 2588  
Pattern id=718 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DA:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46680:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_DIV unique[46680:a], register[1106:a]

Line avx.sinc:2173 :VPMINUB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0xDA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminub_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2173(id0.1766) printpiece=[VPMINUB,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 5486  1: XmmReg1 : 5485  2: YmmReg1 : 5488  3: XmmReg2_m128 : 5487  
Pattern id=1766 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:DA:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[aed00:10] = CALLOTHER const[191:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aed00:10]

Line avx2.sinc:391 :VPMINUB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0xDA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminub_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:391(id0.1973) printpiece=[VPMINUB,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6483  1: YmmReg1 : 6482  2: YmmReg2_m256 : 6484  
Pattern id=1973 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:DA:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[227:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4095 :FCMOVNB ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=0 & freg & ST0        { if ( CF ) goto inst_next; ST0 = freg; }    
0: Constructor line ia.sinc:4095(id0.681) printpiece=[FCMOVNB,  ,  B, ,,  ,  A]
Operands 0: freg : 2548  1: ST0 : 2547  
Pattern id=681 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:C[0xxx]:XX:XX)
Template
	0: CBRANCH [curspace][[next]:[curspace_size]], register[200:1]
	1: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4154 :FILD spec_m32      is vexMode=0 & byte=0xDB; reg_opcode=0 ... & spec_m32            { fdec(); ST0 = int2float(spec_m32); }         
1: Constructor line ia.sinc:4154(id0.727) printpiece=[FILD,  ,  A]
Operands 0: spec_m32 : 2598  
Pattern id=727 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[12500:a] = COPY register[1176:a]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[12500:a]
	10: register[1106:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4096 :FCMOVNE ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=1 & freg & ST0        { if ( ZF ) goto inst_next; ST0 = freg; }    
0: Constructor line ia.sinc:4096(id0.682) printpiece=[FCMOVNE,  ,  B, ,,  ,  A]
Operands 0: freg : 2550  1: ST0 : 2549  
Pattern id=682 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:C[1xxx]:XX:XX)
Template
	0: CBRANCH [curspace][[next]:[curspace_size]], register[206:1]
	1: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4190 :FISTTP spec_m32     is vexMode=0 & byte=0xDB; reg_opcode=1 ... & spec_m32            { spec_m32 = trunc(ST0); fpop(); }                 
1: Constructor line ia.sinc:4190(id0.738) printpiece=[FISTTP,  ,  A]
Operands 0: spec_m32 : 2606  
Pattern id=738 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = TRUNC register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4184 :FIST spec_m32       is vexMode=0 & byte=0xDB; (mod != 0b11 & reg_opcode=2) ... & spec_m32            { tmp:10 = round(ST0); spec_m32 = trunc(tmp); }            
0: Constructor line ia.sinc:4184(id0.733) printpiece=[FIST,  ,  A]
Operands 0: spec_m32 : 2601  
Pattern id=733 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:1[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[47100:a] = ROUND register[1106:a]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[47100:a]

Line ia.sinc:4184 :FIST spec_m32       is vexMode=0 & byte=0xDB; (mod != 0b11 & reg_opcode=2) ... & spec_m32            { tmp:10 = round(ST0); spec_m32 = trunc(tmp); }            
0: Constructor line ia.sinc:4184(id0.733) printpiece=[FIST,  ,  A]
Operands 0: spec_m32 : 2601  
Pattern id=733 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:5[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[47100:a] = ROUND register[1106:a]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[47100:a]

Line ia.sinc:4184 :FIST spec_m32       is vexMode=0 & byte=0xDB; (mod != 0b11 & reg_opcode=2) ... & spec_m32            { tmp:10 = round(ST0); spec_m32 = trunc(tmp); }            
0: Constructor line ia.sinc:4184(id0.733) printpiece=[FIST,  ,  A]
Operands 0: spec_m32 : 2601  
Pattern id=733 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:9[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[47100:a] = ROUND register[1106:a]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[47100:a]

Line ia.sinc:4097 :FCMOVNBE ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=0 & freg & ST0        { if ( CF & ZF ) goto inst_next; ST0 = freg; }   
0: Constructor line ia.sinc:4097(id0.683) printpiece=[FCMOVNBE,  ,  B, ,,  ,  A]
Operands 0: freg : 2552  1: ST0 : 2551  
Pattern id=683 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:D[0xxx]:XX:XX)
Template
	0: unique[45700:1] = INT_AND register[200:1], register[206:1]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[45700:1]
	2: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4098 :FCMOVNU  ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=1 & freg & ST0        { if ( PF ) goto inst_next; ST0 = freg; }    
0: Constructor line ia.sinc:4098(id0.684) printpiece=[FCMOVNU,  ,  B, ,,  ,  A]
Operands 0: freg : 2554  1: ST0 : 2553  
Pattern id=684 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:D[1xxx]:XX:XX)
Template
	0: CBRANCH [curspace][[next]:[curspace_size]], register[202:1]
	1: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4186 :FISTP spec_m32      is vexMode=0 & byte=0xDB; reg_opcode=3 ... & spec_m32            { tmp:10 = round(ST0); fpop(); spec_m32 = trunc(tmp); }                
1: Constructor line ia.sinc:4186(id0.735) printpiece=[FISTP,  ,  A]
Operands 0: spec_m32 : 2603  
Pattern id=735 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[47400:a] = ROUND register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]
	9: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[47400:a]

Line ia.sinc:4124 :FNENI              is vexMode=0 & byte=0xDB; byte=0xE0            {}
0: Constructor line ia.sinc:4124(id0.703) printpiece=[FNENI]
Operands 
Pattern id=703 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:E0:XX:XX)
Template

Line ia.sinc:4122 :FNDISI             is vexMode=0 & byte=0xDB; byte=0xE1            {}
0: Constructor line ia.sinc:4122(id0.701) printpiece=[FNDISI]
Operands 
Pattern id=701 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:E1:XX:XX)
Template

Line ia.sinc:4089 :FNCLEX         is vexMode=0 & byte=0xDB; byte=0xE2                 { FPUStatusWord[0,8] = 0; FPUStatusWord[15,1] = 0; } 
0: Constructor line ia.sinc:4089(id0.676) printpiece=[FNCLEX]
Operands 
Pattern id=676 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:E2:XX:XX)
Template
	0: register[10a2:1] = COPY const[0:1]
	1: unique[45280:2] = INT_AND register[10a2:2], const[ffffffffffff7fff:2]
	2: unique[45300:2] = INT_ZEXT const[0:1]
	3: unique[45380:2] = INT_LEFT unique[45300:2], const[f:4]
	4: register[10a2:2] = INT_OR unique[45280:2], unique[45380:2]

Line ia.sinc:4171 :FNINIT         is vexMode=0 & byte=0xDB; byte=0xE3                 {
										  FPUControlWord = 0x037f;        
                                          FPUStatusWord = 0x0000;         
                                          FPUTagWord = 0xffff;            
                                          FPUDataPointer = 0x00000000;        
                                          FPUInstructionPointer = 0x00000000;     
                                          FPULastInstructionOpcode = 0x0000;  
                                          C0 = 0;                 
                                          C1 = 0;                 
                                          C2 = 0;                 
                                          C3 = 0; }          
0: Constructor line ia.sinc:4171(id0.731) printpiece=[FNINIT]
Operands 
Pattern id=731 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:E3:XX:XX)
Template
	0: register[10a0:2] = COPY const[37f:2]
	1: register[10a2:2] = COPY const[0:2]
	2: register[10a4:2] = COPY const[ffff:2]
	3: register[10a8:4] = COPY const[0:4]
	4: register[10ac:4] = COPY const[0:4]
	5: register[10a6:2] = COPY const[0:2]
	6: register[1090:1] = COPY const[0:1]
	7: register[1091:1] = COPY const[0:1]
	8: register[1092:1] = COPY const[0:1]
	9: register[1093:1] = COPY const[0:1]

Line ia.sinc:2691 :FSETPM 	is vexMode=0 & byte=0xdb; byte=0xe4	{ } # 80287 set protected mode

:HLT            is vexMode=0 & byte=0xf4                        { goto inst_start; }
0: Constructor line ia.sinc:2691(id0.178) printpiece=[FSETPM]
Operands 
Pattern id=178 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:E4:XX:XX)
Template

Line ia.sinc:4112 :FUCOMI ST0, freg   is vexMode=0 & byte=0xDB; frow=14 & fpage=1 & freg & ST0        { fcomi(freg); }                 
0: Constructor line ia.sinc:4112(id0.696) printpiece=[FUCOMI,  ,  B, ,,  ,  A]
Operands 0: freg : 2566  1: ST0 : 2565  
Pattern id=696 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:E[1xxx]:XX:XX)
Template
	0: unique[12f00:1] = FLOAT_NAN register[1106:a]
	1: unique[12f80:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	2: register[202:1] = BOOL_OR unique[12f00:1], unique[12f80:1]
	3: unique[13080:1] = FLOAT_EQUAL register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	4: register[206:1] = INT_OR register[202:1], unique[13080:1]
	5: unique[13180:1] = FLOAT_LESS register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	6: register[200:1] = INT_OR register[202:1], unique[13180:1]
	7: register[20b:1] = COPY const[0:1]
	8: register[204:1] = COPY const[0:1]
	9: register[207:1] = COPY const[0:1]
	10: register[10a2:2] = INT_AND register[10a2:2], const[fdff:2]
	11: register[1091:1] = COPY const[0:1]

Line ia.sinc:4195 :FLD spec_m80        is vexMode=0 & byte=0xDB; reg_opcode=5 ... & spec_m80            { fpushv(spec_m80); }                      
1: Constructor line ia.sinc:4195(id0.742) printpiece=[FLD,  ,  A]
Operands 0: spec_m80 : 2610  
Pattern id=742 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[1176:a] = COPY register[1166:a]
	2: register[1166:a] = COPY register[1156:a]
	3: register[1156:a] = COPY register[1146:a]
	4: register[1146:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1126:a]
	6: register[1126:a] = COPY register[1116:a]
	7: register[1116:a] = COPY register[1106:a]
	8: register[1106:a] = COPY [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4110 :FCOMI ST0, freg    is vexMode=0 & byte=0xDB; frow=15 & fpage=0 & freg & ST0        { fcomi(freg); }                 
0: Constructor line ia.sinc:4110(id0.694) printpiece=[FCOMI,  ,  B, ,,  ,  A]
Operands 0: freg : 2562  1: ST0 : 2561  
Pattern id=694 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:F[0xxx]:XX:XX)
Template
	0: unique[12f00:1] = FLOAT_NAN register[1106:a]
	1: unique[12f80:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	2: register[202:1] = BOOL_OR unique[12f00:1], unique[12f80:1]
	3: unique[13080:1] = FLOAT_EQUAL register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	4: register[206:1] = INT_OR register[202:1], unique[13080:1]
	5: unique[13180:1] = FLOAT_LESS register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	6: register[200:1] = INT_OR register[202:1], unique[13180:1]
	7: register[20b:1] = COPY const[0:1]
	8: register[204:1] = COPY const[0:1]
	9: register[207:1] = COPY const[0:1]
	10: register[10a2:2] = INT_AND register[10a2:2], const[fdff:2]
	11: register[1091:1] = COPY const[0:1]

Line ia.sinc:4328 :FSTP spec_m80  is vexMode=0 & byte=0xDB; reg_opcode=7 ... & spec_m80            { fpopv(spec_m80); }             
0: Constructor line ia.sinc:4328(id0.779) printpiece=[FSTP,  ,  A]
Operands 0: spec_m80 : 2634  
Pattern id=779 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DB:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line avx.sinc:1782 :VPAND XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xDB; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpand_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1782(id0.1724) printpiece=[VPAND,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5253  1: vexVVVV_XmmReg : 5251  2: XmmReg1 : 5250  3: YmmReg1 : 5254  4: XmmReg2_m128 : 5252  
Pattern id=1724 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:DB:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab800:10] = CALLOTHER const[166:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab800:10]

Line ia.sinc:8695 :VAESIMC XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG); byte=0xdb; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesimc(XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line ia.sinc:8695(id0.1496) printpiece=[VAESIMC,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4268  1: XmmReg1 : 4266  2: YmmReg1 : 4269  3: XmmReg2_m128 : 4267  
Pattern id=1496 pattern=cmb:(ctx:SS:X[001x]:X8:0[010x]:XX,ins:DB:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e0:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:151 :VPAND YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xDB; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpand_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:151(id0.1943) printpiece=[VPAND,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6338  1: vexVVVV_YmmReg : 6336  2: YmmReg1 : 6335  3: YmmReg2_m256 : 6337  
Pattern id=1943 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:DB:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[209:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4076 :FADD freg, ST0     is vexMode=0 & byte=0xDC; frow=12 & fpage=0 & freg & ST0        { freg = freg f+ ST0; }        
0: Constructor line ia.sinc:4076(id0.667) printpiece=[FADD,  ,  A, ,,  ,  B]
Operands 0: freg : 2531  1: ST0 : 2532  
Pattern id=667 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:C[0xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_ADD [handle:space][[handle:offset]:[handle:size]], register[1106:a]

Line ia.sinc:4074 :FADD spec_m64      is vexMode=0 & byte=0xDC; reg_opcode=0 ... & spec_m64            { ST0 = ST0 f+ float2float(spec_m64); } 
1: Constructor line ia.sinc:4074(id0.665) printpiece=[FADD,  ,  A]
Operands 0: spec_m64 : 2528  
Pattern id=665 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[44b80:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_ADD register[1106:a], unique[44b80:a]

Line ia.sinc:4224 :FMUL freg      is vexMode=0 & byte=0xDC; frow=12 & fpage=1 & freg          { freg = freg f* ST0; }         
0: Constructor line ia.sinc:4224(id0.756) printpiece=[FMUL,  ,  A]
Operands 0: freg : 2618  
Pattern id=756 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:C[1xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_MULT [handle:space][[handle:offset]:[handle:size]], register[1106:a]

Line ia.sinc:4222 :FMUL spec_m64       is vexMode=0 & byte=0xDC; reg_opcode=1 ... & spec_m64            { ST0 = ST0 f* float2float(spec_m64); }  
1: Constructor line ia.sinc:4222(id0.754) printpiece=[FMUL,  ,  A]
Operands 0: spec_m64 : 2616  
Pattern id=754 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[48a80:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_MULT register[1106:a], unique[48a80:a]

Line ia.sinc:4101 :FCOM spec_m64       is vexMode=0 & byte=0xDC; reg_opcode=2 ... & spec_m64            { local tmp=float2float(spec_m64); fcom(tmp); }         
0: Constructor line ia.sinc:4101(id0.686) printpiece=[FCOM,  ,  A]
Operands 0: spec_m64 : 2556  
Pattern id=686 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[45900:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[45900:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[45900:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[45900:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]

Line ia.sinc:4105 :FCOMP spec_m64      is vexMode=0 & byte=0xDC; reg_opcode=3 ... & spec_m64            { local tmp=float2float(spec_m64); fcom(tmp); fpop(); }     
0: Constructor line ia.sinc:4105(id0.690) printpiece=[FCOMP,  ,  A]
Operands 0: spec_m64 : 2559  
Pattern id=690 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[45b00:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[45b00:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[45b00:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[45b00:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	21: register[1106:a] = COPY register[1116:a]
	22: register[1116:a] = COPY register[1126:a]
	23: register[1126:a] = COPY register[1136:a]
	24: register[1136:a] = COPY register[1146:a]
	25: register[1146:a] = COPY register[1156:a]
	26: register[1156:a] = COPY register[1166:a]
	27: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4371 :FSUBR freg,ST0  is vexMode=0 & byte=0xDC; frow=14 & fpage=0 & freg & ST0       { freg = ST0 f- freg; }                 
0: Constructor line ia.sinc:4371(id0.800) printpiece=[FSUBR,  ,  A, ,,  B]
Operands 0: freg : 2658  1: ST0 : 2659  
Pattern id=800 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:E[0xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_SUB register[1106:a], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4360 :FSUB spec_m64  is vexMode=0 & byte=0xDC; reg_opcode=4 ... & spec_m64            { ST0 = ST0 f- float2float(spec_m64); }          
1: Constructor line ia.sinc:4360(id0.790) printpiece=[FSUB,  ,  A]
Operands 0: spec_m64 : 2645  
Pattern id=790 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4bc80:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB register[1106:a], unique[4bc80:a]

Line ia.sinc:4362 :FSUB freg,ST0  is vexMode=0 & byte=0xDC; frow=14 & fpage=1 & freg & ST0        { freg = freg f- ST0; }                 
0: Constructor line ia.sinc:4362(id0.792) printpiece=[FSUB,  ,  A, ,,  B]
Operands 0: freg : 2648  1: ST0 : 2649  
Pattern id=792 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:E[1xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_SUB [handle:space][[handle:offset]:[handle:size]], register[1106:a]

Line ia.sinc:4369 :FSUBR spec_m64  is vexMode=0 & byte=0xDC; reg_opcode=5 ... & spec_m64           { ST0 = float2float(spec_m64) f- ST0; }          
1: Constructor line ia.sinc:4369(id0.798) printpiece=[FSUBR,  ,  A]
Operands 0: spec_m64 : 2655  
Pattern id=798 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4c280:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB unique[4c280:a], register[1106:a]

Line ia.sinc:4138 :FDIVR freg,ST0     is vexMode=0 & byte=0xDC; frow=15 & fpage=0 & freg & ST0        { freg = ST0 f/ freg; }           
0: Constructor line ia.sinc:4138(id0.715) printpiece=[FDIVR,  ,  A, ,,  B]
Operands 0: freg : 2584  1: ST0 : 2585  
Pattern id=715 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:F[0xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_DIV register[1106:a], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4127 :FDIV spec_m64      is vexMode=0 & byte=0xDC; reg_opcode=6 ... & spec_m64            { ST0 = ST0 f/ float2float(spec_m64); }    
1: Constructor line ia.sinc:4127(id0.705) printpiece=[FDIV,  ,  A]
Operands 0: spec_m64 : 2571  
Pattern id=705 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[45d80:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_DIV register[1106:a], unique[45d80:a]

Line ia.sinc:4129 :FDIV freg,ST0      is vexMode=0 & byte=0xDC; frow=15 & fpage=1 & freg & ST0        { freg = freg f/ ST0; }           
0: Constructor line ia.sinc:4129(id0.707) printpiece=[FDIV,  ,  A, ,,  B]
Operands 0: freg : 2574  1: ST0 : 2575  
Pattern id=707 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:F[1xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_DIV [handle:space][[handle:offset]:[handle:size]], register[1106:a]

Line ia.sinc:4136 :FDIVR spec_m64     is vexMode=0 & byte=0xDC; reg_opcode=7 ... & spec_m64            { ST0 = float2float(spec_m64) f/ ST0; }    
1: Constructor line ia.sinc:4136(id0.713) printpiece=[FDIVR,  ,  A]
Operands 0: spec_m64 : 2581  
Pattern id=713 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DC:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46380:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_DIV unique[46380:a], register[1106:a]

Line avx.sinc:1755 :VPADDUSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xDC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddusb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1755(id0.1721) printpiece=[VPADDUSB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5234  1: vexVVVV_XmmReg : 5232  2: XmmReg1 : 5231  3: YmmReg1 : 5235  4: XmmReg2_m128 : 5233  
Pattern id=1721 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:DC:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab380:10] = CALLOTHER const[163:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab380:10]

Line ia.sinc:8677 :VAESENC XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xdc; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesenc(vexVVVV_XmmReg, XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line ia.sinc:8677(id0.1492) printpiece=[VAESENC,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4253  1: vexVVVV_XmmReg : 4251  2: XmmReg1 : 4250  3: YmmReg1 : 4254  4: XmmReg2_m128 : 4252  
Pattern id=1492 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:DC:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[de:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:127 :VPADDUSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xDC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddusb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:127(id0.1940) printpiece=[VPADDUSB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6322  1: vexVVVV_YmmReg : 6320  2: YmmReg1 : 6319  3: YmmReg2_m256 : 6321  
Pattern id=1940 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:DC:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[206:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4145 :FFREE freg         is vexMode=0 & byte=0xDD; frow=12 & fpage=0 & freg          { FPUTagWord = ffree(freg); }  # Set freg to invalid value
:FFREEP freg        is vexMode=0 & byte=0xDF; frow=12 & fpage=0 & freg          { FPUTagWord = ffree(freg); fpop(); }  # FFREE and pop
                                                                  
:FICOM spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=2 ... & spec_m16            { local tmp = int2float(spec_m16); fcom(tmp); }          
0: Constructor line ia.sinc:4145(id0.720) printpiece=[FFREE,  ,  A]
Operands 0: freg : 2591  
Pattern id=720 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:C[0xxx]:XX:XX)
Template
	0: register[10a4:2] = CALLOTHER const[60:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4194 :FLD spec_m64        is vexMode=0 & byte=0xDD; reg_opcode=0 ... & spec_m64            { fdec(); ST0 = float2float(spec_m64);}            
1: Constructor line ia.sinc:4194(id0.741) printpiece=[FLD,  ,  A]
Operands 0: spec_m64 : 2609  
Pattern id=741 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[12500:a] = COPY register[1176:a]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[12500:a]
	10: register[1106:a] = FLOAT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4191 :FISTTP spec_m64     is vexMode=0 & byte=0xDD; reg_opcode=1 ... & spec_m64            { spec_m64 = trunc(ST0); fpop(); }                 
0: Constructor line ia.sinc:4191(id0.739) printpiece=[FISTTP,  ,  A]
Operands 0: spec_m64 : 2607  
Pattern id=739 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = TRUNC register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4325 :FST freg       is vexMode=0 & byte=0xDD; frow=13 & fpage=0 & freg          { freg = ST0; }             
0: Constructor line ia.sinc:4325(id0.776) printpiece=[FST,  ,  A]
Operands 0: freg : 2631  
Pattern id=776 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:D[0xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY register[1106:a]

Line ia.sinc:4324 :FST spec_m64   is vexMode=0 & byte=0xDD; reg_opcode=2 ... & spec_m64            { spec_m64 = float2float(ST0); }     
1: Constructor line ia.sinc:4324(id0.775) printpiece=[FST,  ,  A]
Operands 0: spec_m64 : 2630  
Pattern id=775 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = FLOAT2FLOAT register[1106:a]

Line ia.sinc:4329 :FSTP freg      is vexMode=0 & byte=0xDD; frow=13 & fpage=1 & freg          { fpopv(freg); }                    
0: Constructor line ia.sinc:4329(id0.780) printpiece=[FSTP,  ,  A]
Operands 0: freg : 2635  
Pattern id=780 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:D[1xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = COPY register[1106:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4327 :FSTP spec_m64  is vexMode=0 & byte=0xDD; reg_opcode=3 ... & spec_m64            { spec_m64 = float2float(ST0); fpop(); } 
1: Constructor line ia.sinc:4327(id0.778) printpiece=[FSTP,  ,  A]
Operands 0: spec_m64 : 2633  
Pattern id=778 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = FLOAT2FLOAT register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4380 :FUCOM          is vexMode=0 & byte=0xDD; byte=0xE1                 { fcom(ST1); }                      
0: Constructor line ia.sinc:4380(id0.807) printpiece=[FUCOM]
Operands 
Pattern id=807 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:E1:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN register[1116:a]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], register[1116:a]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], register[1116:a]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]

Line ia.sinc:4379 :FUCOM freg     is vexMode=0 & byte=0xDD; frow=14 & fpage=0 & freg          { fcom(freg); }                     
1: Constructor line ia.sinc:4379(id0.806) printpiece=[FUCOM,  ,  A]
Operands 0: freg : 2664  
Pattern id=806 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:E[0xxx]:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]

Line ia.sinc:4244 :FRSTOR Mem     is vexMode=0 & byte=0xDD; reg_opcode=4 ... & Mem
{
  FPUControlWord           = *:2  (Mem);
  FPUStatusWord            = *:2  (Mem +  4);
  FPUTagWord               = *:2  (Mem +  8);
  FPUDataPointer           = *:4  (Mem + 20);
  FPUInstructionPointer    = *:4  (Mem + 12);
  FPULastInstructionOpcode = *:2  (Mem + 18);

  ST0                      = *:10 (Mem + 28);
  ST1                      = *:10 (Mem + 38);
  ST2                      = *:10 (Mem + 48);
  ST3                      = *:10 (Mem + 58);
  ST4                      = *:10 (Mem + 68);
  ST5                      = *:10 (Mem + 78);
  ST6                      = *:10 (Mem + 88);
  ST7                      = *:10 (Mem + 98);
}
2: Constructor line ia.sinc:4244(id0.767) printpiece=[FRSTOR,  ,  A]
Operands 0: Mem : 2624  
Pattern id=767 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10a0:2] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[49780:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: register[10a2:2] = LOAD const[ram:8], unique[49780:[handle:size]]
	4: unique[49880:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: register[10a4:2] = LOAD const[ram:8], unique[49880:[handle:size]]
	6: unique[49980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: register[10a8:4] = LOAD const[ram:8], unique[49980:[handle:size]]
	8: unique[49a80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: register[10ac:4] = LOAD const[ram:8], unique[49a80:[handle:size]]
	10: unique[49b80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: register[10a6:2] = LOAD const[ram:8], unique[49b80:[handle:size]]
	12: unique[49c80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[1c:[handle:size]]
	13: register[1106:a] = LOAD const[ram:8], unique[49c80:[handle:size]]
	14: unique[49d80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[26:[handle:size]]
	15: register[1116:a] = LOAD const[ram:8], unique[49d80:[handle:size]]
	16: unique[49e80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[30:[handle:size]]
	17: register[1126:a] = LOAD const[ram:8], unique[49e80:[handle:size]]
	18: unique[49f80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[3a:[handle:size]]
	19: register[1136:a] = LOAD const[ram:8], unique[49f80:[handle:size]]
	20: unique[4a080:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[44:[handle:size]]
	21: register[1146:a] = LOAD const[ram:8], unique[4a080:[handle:size]]
	22: unique[4a180:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4e:[handle:size]]
	23: register[1156:a] = LOAD const[ram:8], unique[4a180:[handle:size]]
	24: unique[4a280:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[58:[handle:size]]
	25: register[1166:a] = LOAD const[ram:8], unique[4a280:[handle:size]]
	26: unique[4a380:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[62:[handle:size]]
	27: register[1176:a] = LOAD const[ram:8], unique[4a380:[handle:size]]

Line ia.sinc:4382 :FUCOMP         is vexMode=0 & byte=0xDD; byte=0xE9                 { fcom(ST1); fpop(); }                  
0: Constructor line ia.sinc:4382(id0.809) printpiece=[FUCOMP]
Operands 
Pattern id=809 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:E9:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN register[1116:a]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], register[1116:a]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], register[1116:a]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	19: register[1106:a] = COPY register[1116:a]
	20: register[1116:a] = COPY register[1126:a]
	21: register[1126:a] = COPY register[1136:a]
	22: register[1136:a] = COPY register[1146:a]
	23: register[1146:a] = COPY register[1156:a]
	24: register[1156:a] = COPY register[1166:a]
	25: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4381 :FUCOMP freg    is vexMode=0 & byte=0xDD; frow=14 & fpage=1 & freg          { fcom(freg); fpop(); }                 
1: Constructor line ia.sinc:4381(id0.808) printpiece=[FUCOMP,  ,  A]
Operands 0: freg : 2665  
Pattern id=808 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:E[1xxx]:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	19: register[1106:a] = COPY register[1116:a]
	20: register[1116:a] = COPY register[1126:a]
	21: register[1126:a] = COPY register[1136:a]
	22: register[1136:a] = COPY register[1146:a]
	23: register[1146:a] = COPY register[1156:a]
	24: register[1156:a] = COPY register[1166:a]
	25: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4289 :FNSAVE Mem     is vexMode=0 & byte=0xDD; reg_opcode=6 ... & Mem
{
  *:2  (Mem)      = FPUControlWord;
  *:2  (Mem +  4) = FPUStatusWord;
  *:2  (Mem +  8) = FPUTagWord;
  *:4  (Mem + 20) = FPUDataPointer;
  *:4  (Mem + 12) = FPUInstructionPointer;
  *:2  (Mem + 18) = FPULastInstructionOpcode;

  *:10 (Mem + 28) = ST0;
  *:10 (Mem + 38) = ST1;
  *:10 (Mem + 48) = ST2;
  *:10 (Mem + 58) = ST3;
  *:10 (Mem + 68) = ST4;
  *:10 (Mem + 78) = ST5;
  *:10 (Mem + 88) = ST6;
  *:10 (Mem + 98) = ST7;

  FPUControlWord = 0x037f;
  FPUStatusWord = 0x0000;
  FPUTagWord = 0xffff;
  FPUDataPointer = 0x00000000;
  FPUInstructionPointer = 0x00000000;
  FPULastInstructionOpcode = 0x0000;
}
0: Constructor line ia.sinc:4289(id0.769) printpiece=[FNSAVE,  ,  A]
Operands 0: Mem : 2626  
Pattern id=769 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: STORE const[ram:8], [handle:space][[handle:offset]:[handle:size]], register[10a0:2]
	2: unique[4ab00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4:[handle:size]]
	3: STORE const[ram:8], unique[4ab00:[handle:size]], register[10a2:2]
	4: unique[4ab80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[8:[handle:size]]
	5: STORE const[ram:8], unique[4ab80:[handle:size]], register[10a4:2]
	6: unique[4ac00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[14:[handle:size]]
	7: STORE const[ram:8], unique[4ac00:[handle:size]], register[10a8:4]
	8: unique[4ac80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[c:[handle:size]]
	9: STORE const[ram:8], unique[4ac80:[handle:size]], register[10ac:4]
	10: unique[4ad00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[12:[handle:size]]
	11: STORE const[ram:8], unique[4ad00:[handle:size]], register[10a6:2]
	12: unique[4ad80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[1c:[handle:size]]
	13: STORE const[ram:8], unique[4ad80:[handle:size]], register[1106:a]
	14: unique[4ae00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[26:[handle:size]]
	15: STORE const[ram:8], unique[4ae00:[handle:size]], register[1116:a]
	16: unique[4ae80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[30:[handle:size]]
	17: STORE const[ram:8], unique[4ae80:[handle:size]], register[1126:a]
	18: unique[4af00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[3a:[handle:size]]
	19: STORE const[ram:8], unique[4af00:[handle:size]], register[1136:a]
	20: unique[4af80:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[44:[handle:size]]
	21: STORE const[ram:8], unique[4af80:[handle:size]], register[1146:a]
	22: unique[4b000:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[4e:[handle:size]]
	23: STORE const[ram:8], unique[4b000:[handle:size]], register[1156:a]
	24: unique[4b080:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[58:[handle:size]]
	25: STORE const[ram:8], unique[4b080:[handle:size]], register[1166:a]
	26: unique[4b100:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[62:[handle:size]]
	27: STORE const[ram:8], unique[4b100:[handle:size]], register[1176:a]
	28: register[10a0:2] = COPY const[37f:2]
	29: register[10a2:2] = COPY const[0:2]
	30: register[10a4:2] = COPY const[ffff:2]
	31: register[10a8:4] = COPY const[0:4]
	32: register[10ac:4] = COPY const[0:4]
	33: register[10a6:2] = COPY const[0:2]

Line ia.sinc:4356 :FNSTSW m16     is vexMode=0 & byte=0xDD; reg_opcode=7 ... & m16            { m16 = FPUStatusWord; }
0: Constructor line ia.sinc:4356(id0.787) printpiece=[FNSTSW,  ,  A]
Operands 0: m16 : 2642  
Pattern id=787 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DD:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[10a2:2]

Line avx.sinc:1764 :VPADDUSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xDD; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddusw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1764(id0.1722) printpiece=[VPADDUSW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5240  1: vexVVVV_XmmReg : 5238  2: XmmReg1 : 5237  3: YmmReg1 : 5241  4: XmmReg2_m128 : 5239  
Pattern id=1722 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:DD:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab500:10] = CALLOTHER const[164:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab500:10]

Line ia.sinc:8686 :VAESENCLAST XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xdd; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesenclast(vexVVVV_XmmReg, XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line ia.sinc:8686(id0.1494) printpiece=[VAESENCLAST,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4261  1: vexVVVV_XmmReg : 4259  2: XmmReg1 : 4258  3: YmmReg1 : 4262  4: XmmReg2_m128 : 4260  
Pattern id=1494 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:DD:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[df:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:135 :VPADDUSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xDD; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddusw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:135(id0.1941) printpiece=[VPADDUSW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6327  1: vexVVVV_YmmReg : 6325  2: YmmReg1 : 6324  3: YmmReg2_m256 : 6326  
Pattern id=1941 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:DD:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[207:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4077 :FADDP              is vexMode=0 & byte=0xDE; byte=0xC1                 { ST1 = ST0 f+ ST1; fpop(); }      
0: Constructor line ia.sinc:4077(id0.668) printpiece=[FADDP]
Operands 
Pattern id=668 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:C1:XX:XX)
Template
	0: register[1116:a] = FLOAT_ADD register[1106:a], register[1116:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4078 :FADDP freg, ST0    is vexMode=0 & byte=0xDE; frow=12 & fpage=0 & freg & ST0        { freg = ST0 f+ freg; fpop(); }    
1: Constructor line ia.sinc:4078(id0.669) printpiece=[FADDP,  ,  A, ,,  ,  B]
Operands 0: freg : 2533  1: ST0 : 2534  
Pattern id=669 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:C[0xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_ADD register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4080 :FIADD spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=0 ... & spec_m16            { ST0 = ST0 f+ int2float(spec_m16); }   
2: Constructor line ia.sinc:4080(id0.671) printpiece=[FIADD,  ,  A]
Operands 0: spec_m16 : 2536  
Pattern id=671 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[44f80:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_ADD register[1106:a], unique[44f80:a]

Line ia.sinc:4226 :FMULP          is vexMode=0 & byte=0xDE; byte=0xC9                         { ST1 = ST0 f* ST1; fpop(); }       
0: Constructor line ia.sinc:4226(id0.758) printpiece=[FMULP]
Operands 
Pattern id=758 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:C9:XX:XX)
Template
	0: register[1116:a] = FLOAT_MULT register[1106:a], register[1116:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4225 :FMULP freg     is vexMode=0 & byte=0xDE; frow=12 & fpage=1 & freg          { freg = ST0 f* freg; fpop(); }     
1: Constructor line ia.sinc:4225(id0.757) printpiece=[FMULP,  ,  A]
Operands 0: freg : 2619  
Pattern id=757 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:C[1xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_MULT register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4228 :FIMUL spec_m16      is vexMode=0 & byte=0xDE; reg_opcode=1 ... & spec_m16            { ST0 = ST0 f* int2float(spec_m16); }    
2: Constructor line ia.sinc:4228(id0.760) printpiece=[FIMUL,  ,  A]
Operands 0: spec_m16 : 2621  
Pattern id=760 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[48e80:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_MULT register[1106:a], unique[48e80:a]

Line ia.sinc:4148 :FICOM spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=2 ... & spec_m16            { local tmp = int2float(spec_m16); fcom(tmp); }          
0: Constructor line ia.sinc:4148(id0.722) printpiece=[FICOM,  ,  A]
Operands 0: spec_m16 : 2593  
Pattern id=722 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46a00:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[46a00:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[46a00:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[46a00:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]

Line ia.sinc:4150 :FICOMP spec_m16    is vexMode=0 & byte=0xDE; (mod != 0b11 & reg_opcode=3) ... & spec_m16            { local tmp = int2float(spec_m16); fcom(tmp); fpop(); }  
0: Constructor line ia.sinc:4150(id0.724) printpiece=[FICOMP,  ,  A]
Operands 0: spec_m16 : 2595  
Pattern id=724 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:1[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46c00:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[46c00:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[46c00:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[46c00:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	21: register[1106:a] = COPY register[1116:a]
	22: register[1116:a] = COPY register[1126:a]
	23: register[1126:a] = COPY register[1136:a]
	24: register[1136:a] = COPY register[1146:a]
	25: register[1146:a] = COPY register[1156:a]
	26: register[1156:a] = COPY register[1166:a]
	27: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4150 :FICOMP spec_m16    is vexMode=0 & byte=0xDE; (mod != 0b11 & reg_opcode=3) ... & spec_m16            { local tmp = int2float(spec_m16); fcom(tmp); fpop(); }  
0: Constructor line ia.sinc:4150(id0.724) printpiece=[FICOMP,  ,  A]
Operands 0: spec_m16 : 2595  
Pattern id=724 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:5[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46c00:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[46c00:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[46c00:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[46c00:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	21: register[1106:a] = COPY register[1116:a]
	22: register[1116:a] = COPY register[1126:a]
	23: register[1126:a] = COPY register[1136:a]
	24: register[1136:a] = COPY register[1146:a]
	25: register[1146:a] = COPY register[1156:a]
	26: register[1156:a] = COPY register[1166:a]
	27: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4150 :FICOMP spec_m16    is vexMode=0 & byte=0xDE; (mod != 0b11 & reg_opcode=3) ... & spec_m16            { local tmp = int2float(spec_m16); fcom(tmp); fpop(); }  
0: Constructor line ia.sinc:4150(id0.724) printpiece=[FICOMP,  ,  A]
Operands 0: spec_m16 : 2595  
Pattern id=724 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:9[1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46c00:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1091:1] = COPY const[0:1]
	3: unique[12600:1] = FLOAT_NAN register[1106:a]
	4: unique[12680:1] = FLOAT_NAN unique[46c00:a]
	5: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	6: unique[12780:1] = FLOAT_LESS register[1106:a], unique[46c00:a]
	7: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	8: unique[12880:1] = FLOAT_EQUAL register[1106:a], unique[46c00:a]
	9: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	10: unique[12980:2] = INT_ZEXT register[1090:1]
	11: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	12: unique[12a80:2] = INT_ZEXT register[1091:1]
	13: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	14: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	15: unique[12c00:2] = INT_ZEXT register[1092:1]
	16: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	17: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	18: unique[12d80:2] = INT_ZEXT register[1093:1]
	19: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	20: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	21: register[1106:a] = COPY register[1116:a]
	22: register[1116:a] = COPY register[1126:a]
	23: register[1126:a] = COPY register[1136:a]
	24: register[1136:a] = COPY register[1146:a]
	25: register[1146:a] = COPY register[1156:a]
	26: register[1156:a] = COPY register[1166:a]
	27: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4108 :FCOMPP         is vexMode=0 & byte=0xDE; byte=0xD9                 { fcom(ST1); fpop(); fpop(); }           
0: Constructor line ia.sinc:4108(id0.693) printpiece=[FCOMPP]
Operands 
Pattern id=693 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:D9:XX:XX)
Template
	0: register[1091:1] = COPY const[0:1]
	1: unique[12600:1] = FLOAT_NAN register[1106:a]
	2: unique[12680:1] = FLOAT_NAN register[1116:a]
	3: register[1092:1] = BOOL_OR unique[12600:1], unique[12680:1]
	4: unique[12780:1] = FLOAT_LESS register[1106:a], register[1116:a]
	5: register[1090:1] = INT_OR register[1092:1], unique[12780:1]
	6: unique[12880:1] = FLOAT_EQUAL register[1106:a], register[1116:a]
	7: register[1093:1] = INT_OR register[1092:1], unique[12880:1]
	8: unique[12980:2] = INT_ZEXT register[1090:1]
	9: unique[12a00:2] = INT_LEFT unique[12980:2], const[8:4]
	10: unique[12a80:2] = INT_ZEXT register[1091:1]
	11: unique[12b00:2] = INT_LEFT unique[12a80:2], const[9:4]
	12: unique[12b80:2] = INT_OR unique[12a00:2], unique[12b00:2]
	13: unique[12c00:2] = INT_ZEXT register[1092:1]
	14: unique[12c80:2] = INT_LEFT unique[12c00:2], const[a:4]
	15: unique[12d00:2] = INT_OR unique[12b80:2], unique[12c80:2]
	16: unique[12d80:2] = INT_ZEXT register[1093:1]
	17: unique[12e00:2] = INT_LEFT unique[12d80:2], const[e:4]
	18: register[10a2:2] = INT_OR unique[12d00:2], unique[12e00:2]
	19: register[1106:a] = COPY register[1116:a]
	20: register[1116:a] = COPY register[1126:a]
	21: register[1126:a] = COPY register[1136:a]
	22: register[1136:a] = COPY register[1146:a]
	23: register[1146:a] = COPY register[1156:a]
	24: register[1156:a] = COPY register[1166:a]
	25: register[1166:a] = COPY register[1176:a]
	26: register[1106:a] = COPY register[1116:a]
	27: register[1116:a] = COPY register[1126:a]
	28: register[1126:a] = COPY register[1136:a]
	29: register[1136:a] = COPY register[1146:a]
	30: register[1146:a] = COPY register[1156:a]
	31: register[1156:a] = COPY register[1166:a]
	32: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4372 :FSUBRP          is vexMode=0 & byte=0xDE; byte=0xE1                    { ST1 = ST0 f- ST1; fpop(); }               
0: Constructor line ia.sinc:4372(id0.801) printpiece=[FSUBRP]
Operands 
Pattern id=801 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:E1:XX:XX)
Template
	0: register[1116:a] = FLOAT_SUB register[1106:a], register[1116:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4373 :FSUBRP freg,ST0 is vexMode=0 & byte=0xDE; frow=14 & fpage=0 & freg & ST0       { freg = ST0 f- freg; fpop(); }             
1: Constructor line ia.sinc:4373(id0.802) printpiece=[FSUBRP,  ,  A, ,,  B]
Operands 0: freg : 2660  1: ST0 : 2661  
Pattern id=802 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:E[0xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_SUB register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4366 :FISUB spec_m16 is vexMode=0 & byte=0xDE; reg_opcode=4 ... & spec_m16            { ST0 = ST0 f- int2float(spec_m16); }            
2: Constructor line ia.sinc:4366(id0.796) printpiece=[FISUB,  ,  A]
Operands 0: spec_m16 : 2653  
Pattern id=796 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4c080:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB register[1106:a], unique[4c080:a]

Line ia.sinc:4363 :FSUBP          is vexMode=0 & byte=0xDE; byte=0xE9                 { ST1 = ST1 f- ST0; fpop(); }               
0: Constructor line ia.sinc:4363(id0.793) printpiece=[FSUBP]
Operands 
Pattern id=793 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:E9:XX:XX)
Template
	0: register[1116:a] = FLOAT_SUB register[1116:a], register[1106:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4364 :FSUBP freg,ST0 is vexMode=0 & byte=0xDE; frow=14 & fpage=1 & freg & ST0        { freg = freg f- ST0; fpop(); }             
1: Constructor line ia.sinc:4364(id0.794) printpiece=[FSUBP,  ,  A, ,,  B]
Operands 0: freg : 2650  1: ST0 : 2651  
Pattern id=794 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:E[1xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_SUB [handle:space][[handle:offset]:[handle:size]], register[1106:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4375 :FISUBR spec_m16 is vexMode=0 & byte=0xDE; reg_opcode=5 ... & spec_m16           { ST0 = int2float(spec_m16) f- ST0; }            
2: Constructor line ia.sinc:4375(id0.804) printpiece=[FISUBR,  ,  A]
Operands 0: spec_m16 : 2663  
Pattern id=804 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4c680:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_SUB unique[4c680:a], register[1106:a]

Line ia.sinc:4140 :FDIVRP             is vexMode=0 & byte=0xDE; byte=0xF1                 { ST1 = ST0 f/ ST1; fpop(); }         
0: Constructor line ia.sinc:4140(id0.717) printpiece=[FDIVRP]
Operands 
Pattern id=717 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:F1:XX:XX)
Template
	0: register[1116:a] = FLOAT_DIV register[1106:a], register[1116:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4139 :FDIVRP freg,ST0    is vexMode=0 & byte=0xDE; frow=15 & fpage=0 & freg & ST0        { freg = freg f/ ST0; fpop(); }       
1: Constructor line ia.sinc:4139(id0.716) printpiece=[FDIVRP,  ,  A, ,,  B]
Operands 0: freg : 2586  1: ST0 : 2587  
Pattern id=716 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:F[0xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_DIV [handle:space][[handle:offset]:[handle:size]], register[1106:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4133 :FIDIV spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=6 ... & spec_m16            { ST0 = ST0 f/ int2float(spec_m16); }      
2: Constructor line ia.sinc:4133(id0.711) printpiece=[FIDIV,  ,  A]
Operands 0: spec_m16 : 2579  
Pattern id=711 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46180:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_DIV register[1106:a], unique[46180:a]

Line ia.sinc:4131 :FDIVP              is vexMode=0 & byte=0xDE; byte=0xF9                 { ST1 = ST1 f/ ST0; fpop(); }         
0: Constructor line ia.sinc:4131(id0.709) printpiece=[FDIVP]
Operands 
Pattern id=709 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:F9:XX:XX)
Template
	0: register[1116:a] = FLOAT_DIV register[1116:a], register[1106:a]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4130 :FDIVP freg,ST0     is vexMode=0 & byte=0xDE; frow=15 & fpage=1 & freg & ST0        { freg = ST0 f/ freg; fpop(); }       
1: Constructor line ia.sinc:4130(id0.708) printpiece=[FDIVP,  ,  A, ,,  B]
Operands 0: freg : 2576  1: ST0 : 2577  
Pattern id=708 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:F[1xxx]:XX:XX)
Template
	0: [handle:space][[handle:offset]:[handle:size]] = FLOAT_DIV register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4142 :FIDIVR spec_m16    is vexMode=0 & byte=0xDE; reg_opcode=7 ... & spec_m16            { ST0 = int2float(spec_m16) f/ ST0; }      
2: Constructor line ia.sinc:4142(id0.719) printpiece=[FIDIVR,  ,  A]
Operands 0: spec_m16 : 2589  
Pattern id=719 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DE:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46780:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]
	2: register[1106:a] = FLOAT_DIV unique[46780:a], register[1106:a]

Line avx.sinc:2119 :VPMAXUB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0xDE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxub_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2119(id0.1760) printpiece=[VPMAXUB,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 5454  1: XmmReg1 : 5453  2: YmmReg1 : 5456  3: XmmReg2_m128 : 5455  
Pattern id=1760 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:DE:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[ae400:10] = CALLOTHER const[18b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ae400:10]

Line ia.sinc:8659 :VAESDEC XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xde; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesdec(vexVVVV_XmmReg, XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line ia.sinc:8659(id0.1488) printpiece=[VAESDEC,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4237  1: vexVVVV_XmmReg : 4235  2: XmmReg1 : 4234  3: YmmReg1 : 4238  4: XmmReg2_m128 : 4236  
Pattern id=1488 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:DE:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[dc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line avx2.sinc:343 :VPMAXUB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0xDE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxub_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:343(id0.1967) printpiece=[VPMAXUB,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6457  1: YmmReg1 : 6456  2: YmmReg2_m256 : 6458  
Pattern id=1967 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:DE:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[221:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4146 :FFREEP freg        is vexMode=0 & byte=0xDF; frow=12 & fpage=0 & freg          { FPUTagWord = ffree(freg); fpop(); }  # FFREE and pop
                                                                  
:FICOM spec_m16     is vexMode=0 & byte=0xDE; reg_opcode=2 ... & spec_m16            { local tmp = int2float(spec_m16); fcom(tmp); }          
0: Constructor line ia.sinc:4146(id0.721) printpiece=[FFREEP,  ,  A]
Operands 0: freg : 2592  
Pattern id=721 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:C[0xxx]:XX:XX)
Template
	0: register[10a4:2] = CALLOTHER const[60:4], [handle:space][[handle:offset]:[handle:size]]
	1: register[1106:a] = COPY register[1116:a]
	2: register[1116:a] = COPY register[1126:a]
	3: register[1126:a] = COPY register[1136:a]
	4: register[1136:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1156:a]
	6: register[1156:a] = COPY register[1166:a]
	7: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4153 :FILD spec_m16      is vexMode=0 & byte=0xDF; reg_opcode=0 ... & spec_m16            { fdec(); ST0 = int2float(spec_m16); }         
1: Constructor line ia.sinc:4153(id0.726) printpiece=[FILD,  ,  A]
Operands 0: spec_m16 : 2597  
Pattern id=726 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[12500:a] = COPY register[1176:a]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[12500:a]
	10: register[1106:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4189 :FISTTP spec_m16     is vexMode=0 & byte=0xDF; reg_opcode=1 ... & spec_m16            { spec_m16 = trunc(ST0); fpop(); }                 
0: Constructor line ia.sinc:4189(id0.737) printpiece=[FISTTP,  ,  A]
Operands 0: spec_m16 : 2605  
Pattern id=737 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = TRUNC register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4183 :FIST spec_m16       is vexMode=0 & byte=0xDF; (mod != 0b11 & reg_opcode=2) ... & spec_m16            { tmp:10 = round(ST0); spec_m16 = trunc(tmp); }                    
0: Constructor line ia.sinc:4183(id0.732) printpiece=[FIST,  ,  A]
Operands 0: spec_m16 : 2600  
Pattern id=732 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:1[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46f80:a] = ROUND register[1106:a]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[46f80:a]

Line ia.sinc:4183 :FIST spec_m16       is vexMode=0 & byte=0xDF; (mod != 0b11 & reg_opcode=2) ... & spec_m16            { tmp:10 = round(ST0); spec_m16 = trunc(tmp); }                    
0: Constructor line ia.sinc:4183(id0.732) printpiece=[FIST,  ,  A]
Operands 0: spec_m16 : 2600  
Pattern id=732 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:5[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46f80:a] = ROUND register[1106:a]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[46f80:a]

Line ia.sinc:4183 :FIST spec_m16       is vexMode=0 & byte=0xDF; (mod != 0b11 & reg_opcode=2) ... & spec_m16            { tmp:10 = round(ST0); spec_m16 = trunc(tmp); }                    
0: Constructor line ia.sinc:4183(id0.732) printpiece=[FIST,  ,  A]
Operands 0: spec_m16 : 2600  
Pattern id=732 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:9[0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[46f80:a] = ROUND register[1106:a]
	2: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[46f80:a]

Line ia.sinc:4185 :FISTP spec_m16      is vexMode=0 & byte=0xDF; reg_opcode=3 ... & spec_m16            { tmp:10 = round(ST0); fpop(); spec_m16 = trunc(tmp); }                
0: Constructor line ia.sinc:4185(id0.734) printpiece=[FISTP,  ,  A]
Operands 0: spec_m16 : 2602  
Pattern id=734 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[47280:a] = ROUND register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]
	9: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[47280:a]

Line ia.sinc:4357 :FNSTSW AX      is vexMode=0 & byte=0xDF; byte=0xE0 & AX                { AX = FPUStatusWord; }
0: Constructor line ia.sinc:4357(id0.788) printpiece=[FNSTSW,  ,  A]
Operands 0: AX : 2643  
Pattern id=788 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:E0:XX:XX)
Template
	0: register[0:2] = COPY register[10a2:2]

Line ia.sinc:4082 :FBLD  spec_m80     is vexMode=0 & byte=0xDF; reg_opcode=4 ... & spec_m80            { spec_m80 = ST0; fpop(); }
1: Constructor line ia.sinc:4082(id0.672) printpiece=[FBLD,  ,  A]
Operands 0: spec_m80 : 2537  
Pattern id=672 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4113 :FUCOMIP ST0, freg  is vexMode=0 & byte=0xDF; frow=14 & fpage=1 & freg & ST0        { fcomi(freg); fpop(); }             
0: Constructor line ia.sinc:4113(id0.697) printpiece=[FUCOMIP,  ,  B, ,,  ,  A]
Operands 0: freg : 2568  1: ST0 : 2567  
Pattern id=697 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:E[1xxx]:XX:XX)
Template
	0: unique[12f00:1] = FLOAT_NAN register[1106:a]
	1: unique[12f80:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	2: register[202:1] = BOOL_OR unique[12f00:1], unique[12f80:1]
	3: unique[13080:1] = FLOAT_EQUAL register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	4: register[206:1] = INT_OR register[202:1], unique[13080:1]
	5: unique[13180:1] = FLOAT_LESS register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	6: register[200:1] = INT_OR register[202:1], unique[13180:1]
	7: register[20b:1] = COPY const[0:1]
	8: register[204:1] = COPY const[0:1]
	9: register[207:1] = COPY const[0:1]
	10: register[10a2:2] = INT_AND register[10a2:2], const[fdff:2]
	11: register[1091:1] = COPY const[0:1]
	12: register[1106:a] = COPY register[1116:a]
	13: register[1116:a] = COPY register[1126:a]
	14: register[1126:a] = COPY register[1136:a]
	15: register[1136:a] = COPY register[1146:a]
	16: register[1146:a] = COPY register[1156:a]
	17: register[1156:a] = COPY register[1166:a]
	18: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4155 :FILD spec_m64      is vexMode=0 & byte=0xDF; reg_opcode=5 ... & spec_m64            { fdec(); ST0 = int2float(spec_m64); }         
1: Constructor line ia.sinc:4155(id0.728) printpiece=[FILD,  ,  A]
Operands 0: spec_m64 : 2599  
Pattern id=728 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[12500:a] = COPY register[1176:a]
	2: register[1176:a] = COPY register[1166:a]
	3: register[1166:a] = COPY register[1156:a]
	4: register[1156:a] = COPY register[1146:a]
	5: register[1146:a] = COPY register[1136:a]
	6: register[1136:a] = COPY register[1126:a]
	7: register[1126:a] = COPY register[1116:a]
	8: register[1116:a] = COPY register[1106:a]
	9: register[1106:a] = COPY unique[12500:a]
	10: register[1106:a] = INT2FLOAT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:4111 :FCOMIP ST0, freg   is vexMode=0 & byte=0xDF; frow=15 & fpage=0 & freg & ST0        { fcomi(freg); fpop(); }             
0: Constructor line ia.sinc:4111(id0.695) printpiece=[FCOMIP,  ,  B, ,,  ,  A]
Operands 0: freg : 2564  1: ST0 : 2563  
Pattern id=695 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:F[0xxx]:XX:XX)
Template
	0: unique[12f00:1] = FLOAT_NAN register[1106:a]
	1: unique[12f80:1] = FLOAT_NAN [handle:space][[handle:offset]:[handle:size]]
	2: register[202:1] = BOOL_OR unique[12f00:1], unique[12f80:1]
	3: unique[13080:1] = FLOAT_EQUAL register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	4: register[206:1] = INT_OR register[202:1], unique[13080:1]
	5: unique[13180:1] = FLOAT_LESS register[1106:a], [handle:space][[handle:offset]:[handle:size]]
	6: register[200:1] = INT_OR register[202:1], unique[13180:1]
	7: register[20b:1] = COPY const[0:1]
	8: register[204:1] = COPY const[0:1]
	9: register[207:1] = COPY const[0:1]
	10: register[10a2:2] = INT_AND register[10a2:2], const[fdff:2]
	11: register[1091:1] = COPY const[0:1]
	12: register[1106:a] = COPY register[1116:a]
	13: register[1116:a] = COPY register[1126:a]
	14: register[1126:a] = COPY register[1136:a]
	15: register[1136:a] = COPY register[1146:a]
	16: register[1146:a] = COPY register[1156:a]
	17: register[1156:a] = COPY register[1166:a]
	18: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4084 :FBSTP spec_m80     is vexMode=0 & byte=0xDF; reg_opcode=6 ... & spec_m80            { spec_m80 = ST0; fpop(); }
1: Constructor line ia.sinc:4084(id0.673) printpiece=[FBSTP,  ,  A]
Operands 0: spec_m80 : 2538  
Pattern id=673 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = COPY register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]

Line ia.sinc:4187 :FISTP spec_m64      is vexMode=0 & byte=0xDF; reg_opcode=7 ... & spec_m64            { tmp:10 = round(ST0); fpop(); spec_m64 = trunc(tmp); }                
0: Constructor line ia.sinc:4187(id0.736) printpiece=[FISTP,  ,  A]
Operands 0: spec_m64 : 2604  
Pattern id=736 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:DF:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[47580:a] = ROUND register[1106:a]
	2: register[1106:a] = COPY register[1116:a]
	3: register[1116:a] = COPY register[1126:a]
	4: register[1126:a] = COPY register[1136:a]
	5: register[1136:a] = COPY register[1146:a]
	6: register[1146:a] = COPY register[1156:a]
	7: register[1156:a] = COPY register[1166:a]
	8: register[1166:a] = COPY register[1176:a]
	9: [handle:space][[handle:offset]:[handle:size]] = TRUNC unique[47580:a]

Line avx.sinc:1791 :VPANDN XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xDF; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpandn_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1791(id0.1725) printpiece=[VPANDN,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5259  1: vexVVVV_XmmReg : 5257  2: XmmReg1 : 5256  3: YmmReg1 : 5260  4: XmmReg2_m128 : 5258  
Pattern id=1725 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:DF:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab980:10] = CALLOTHER const[167:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab980:10]

Line avx2.sinc:159 :VPANDN YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xDF; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpandn_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:159(id0.1944) printpiece=[VPANDN,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6343  1: vexVVVV_YmmReg : 6341  2: YmmReg1 : 6340  3: YmmReg2_m256 : 6342  
Pattern id=1944 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:DF:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[20a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8668 :VAESDECLAST XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xdf; (XmmReg1 & YmmReg1) ... & XmmReg2_m128 {
	XmmReg1 = aesdeclast(vexVVVV_XmmReg, XmmReg2_m128);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line ia.sinc:8668(id0.1490) printpiece=[VAESDECLAST,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 4245  1: vexVVVV_XmmReg : 4243  2: XmmReg1 : 4242  3: YmmReg1 : 4246  4: XmmReg2_m128 : 4244  
Pattern id=1490 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][010x]:XX,ins:DF:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[dd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:8704 :VAESKEYGENASSIST XmmReg1, XmmReg2_m128, imm8 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F3A) & $(VEX_WIG); byte=0xdf; (XmmReg1 & YmmReg1) ... & XmmReg2_m128; imm8 {
	XmmReg1 = aeskeygenassist(XmmReg2_m128, imm8:1);
	YmmReg1 = zext(XmmReg1);
}
0: Constructor line ia.sinc:8704(id0.1498) printpiece=[VAESKEYGENASSIST,  ,  B, ,,  ,  D, ,,  ,  E]
Operands 0: rexWprefix : 4277  1: XmmReg1 : 4274  2: YmmReg1 : 4278  3: XmmReg2_m128 : 4275  4: imm8 : 4276  
Pattern id=1498 pattern=cmb:(ctx:SS:X[001x]:X8:0[011x]:XX,ins:DF:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[e1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:1]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3010 :LOOPNZ rel8        is vexMode=0 & addrsize=0 & byte=0xE0; rel8             { CX = CX -1; if (CX!=0 && ZF==0) goto rel8; }
0: Constructor line ia.sinc:3010(id0.271) printpiece=[LOOPNZ,  ,  A]
Operands 0: rel8 : 1856  
Pattern id=271 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:E0:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[4:2] = INT_SUB register[4:2], const[1:2]
	2: unique[2d500:1] = INT_NOTEQUAL register[4:2], const[0:2]
	3: unique[2d580:1] = INT_EQUAL register[206:1], const[0:1]
	4: unique[2d600:1] = BOOL_AND unique[2d500:1], unique[2d580:1]
	5: CBRANCH [handle:space][[handle:offset]:[handle:size]], unique[2d600:1]

Line ia.sinc:3011 :LOOPNZ rel8        is vexMode=0 & addrsize=1 & byte=0xE0; rel8             { ECX = ECX -1; if (ECX!=0 && ZF==0) goto rel8; }
0: Constructor line ia.sinc:3011(id0.272) printpiece=[LOOPNZ,  ,  A]
Operands 0: rel8 : 1857  
Pattern id=272 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:E0:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[4:4] = INT_SUB register[4:4], const[1:4]
	2: unique[2d700:1] = INT_NOTEQUAL register[4:4], const[0:4]
	3: unique[2d780:1] = INT_EQUAL register[206:1], const[0:1]
	4: unique[2d800:1] = BOOL_AND unique[2d700:1], unique[2d780:1]
	5: CBRANCH [handle:space][[handle:offset]:[handle:size]], unique[2d800:1]

Line avx.sinc:1800 :VPAVGB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE0; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpavgb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1800(id0.1726) printpiece=[VPAVGB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5265  1: vexVVVV_XmmReg : 5263  2: XmmReg1 : 5262  3: YmmReg1 : 5266  4: XmmReg2_m128 : 5264  
Pattern id=1726 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:E0:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[abb00:10] = CALLOTHER const[168:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[abb00:10]

Line avx2.sinc:167 :VPAVGB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE0; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpavgb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:167(id0.1945) printpiece=[VPAVGB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6348  1: vexVVVV_YmmReg : 6346  2: YmmReg1 : 6345  3: YmmReg2_m256 : 6347  
Pattern id=1945 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:E0:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[20b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3004 :LOOPZ  rel8        is vexMode=0 & addrsize=0 & byte=0xE1; rel8             { CX = CX -1; if (CX!=0 && ZF!=0) goto rel8; }
0: Constructor line ia.sinc:3004(id0.269) printpiece=[LOOPZ,  ,  A]
Operands 0: rel8 : 1854  
Pattern id=269 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:E1:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[4:2] = INT_SUB register[4:2], const[1:2]
	2: unique[2d100:1] = INT_NOTEQUAL register[4:2], const[0:2]
	3: unique[2d180:1] = INT_NOTEQUAL register[206:1], const[0:1]
	4: unique[2d200:1] = BOOL_AND unique[2d100:1], unique[2d180:1]
	5: CBRANCH [handle:space][[handle:offset]:[handle:size]], unique[2d200:1]

Line ia.sinc:3005 :LOOPZ  rel8        is vexMode=0 & addrsize=1 & byte=0xE1; rel8             { ECX = ECX -1; if (ECX!=0 && ZF!=0) goto rel8; }
0: Constructor line ia.sinc:3005(id0.270) printpiece=[LOOPZ,  ,  A]
Operands 0: rel8 : 1855  
Pattern id=270 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:E1:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[4:4] = INT_SUB register[4:4], const[1:4]
	2: unique[2d300:1] = INT_NOTEQUAL register[4:4], const[0:4]
	3: unique[2d380:1] = INT_NOTEQUAL register[206:1], const[0:1]
	4: unique[2d400:1] = BOOL_AND unique[2d300:1], unique[2d380:1]
	5: CBRANCH [handle:space][[handle:offset]:[handle:size]], unique[2d400:1]

Line avx.sinc:2504 :VPSRAW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE1; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsraw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2504(id0.1804) printpiece=[VPSRAW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5695  1: vexVVVV_XmmReg : 5693  2: XmmReg1 : 5692  3: YmmReg1 : 5696  4: XmmReg2_m128 : 5694  
Pattern id=1804 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:E1:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b2200:10] = CALLOTHER const[1b4:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b2200:10]

Line avx2.sinc:688 :VPSRAW YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE1; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsraw_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:688(id0.2011) printpiece=[VPSRAW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6658  1: vexVVVV_YmmReg : 6656  2: YmmReg1 : 6655  3: XmmReg2_m128 : 6657  
Pattern id=2011 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:E1:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24a:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2998 :LOOP   rel8        is vexMode=0 & addrsize=0 & byte=0xE2; rel8             { CX = CX -1; if (CX!=0) goto rel8; }
0: Constructor line ia.sinc:2998(id0.267) printpiece=[LOOP,  ,  A]
Operands 0: rel8 : 1852  
Pattern id=267 pattern=cmb:(ctx:X[x0xx]:XX:X[0xxx]:XX,ins:E2:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[4:2] = INT_SUB register[4:2], const[1:2]
	2: unique[2cf00:1] = INT_NOTEQUAL register[4:2], const[0:2]
	3: CBRANCH [handle:space][[handle:offset]:[handle:size]], unique[2cf00:1]

Line ia.sinc:2999 :LOOP   rel8        is vexMode=0 & addrsize=1 & byte=0xE2; rel8             { ECX = ECX -1; if (ECX!=0) goto rel8; }
0: Constructor line ia.sinc:2999(id0.268) printpiece=[LOOP,  ,  A]
Operands 0: rel8 : 1853  
Pattern id=268 pattern=cmb:(ctx:X[x1xx]:XX:X[0xxx]:XX,ins:E2:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[4:4] = INT_SUB register[4:4], const[1:4]
	2: unique[2d000:1] = INT_NOTEQUAL register[4:4], const[0:4]
	3: CBRANCH [handle:space][[handle:offset]:[handle:size]], unique[2d000:1]

Line avx.sinc:2519 :VPSRAD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsrad_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2519(id0.1806) printpiece=[VPSRAD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5705  1: vexVVVV_XmmReg : 5703  2: XmmReg1 : 5702  3: YmmReg1 : 5706  4: XmmReg2_m128 : 5704  
Pattern id=1806 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:E2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b2400:10] = CALLOTHER const[1b5:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b2400:10]

Line avx2.sinc:702 :VPSRAD YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE2; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsrad_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:702(id0.2013) printpiece=[VPSRAD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6667  1: vexVVVV_YmmReg : 6665  2: YmmReg1 : 6664  3: XmmReg2_m128 : 6666  
Pattern id=2013 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:E2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[24b:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2842 :JCXZ rel8      is vexMode=0 & opsize=0 & byte=0xe3; rel8               { if (CX==0) goto rel8; }
0: Constructor line ia.sinc:2842(id0.224) printpiece=[JCXZ,  ,  A]
Operands 0: rel8 : 1780  
Pattern id=224 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:E3:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2aa80:1] = INT_EQUAL register[4:2], const[0:2]
	2: CBRANCH [handle:space][[handle:offset]:[handle:size]], unique[2aa80:1]

Line ia.sinc:2843 :JECXZ rel8     is vexMode=0 & opsize=1 & byte=0xe3; rel8               { if (ECX==0) goto rel8; }
0: Constructor line ia.sinc:2843(id0.225) printpiece=[JECXZ,  ,  A]
Operands 0: rel8 : 1781  
Pattern id=225 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:E3:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2ab00:1] = INT_EQUAL register[4:4], const[0:4]
	2: CBRANCH [handle:space][[handle:offset]:[handle:size]], unique[2ab00:1]

Line avx.sinc:1809 :VPAVGW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE3; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpavgw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1809(id0.1727) printpiece=[VPAVGW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5271  1: vexVVVV_XmmReg : 5269  2: XmmReg1 : 5268  3: YmmReg1 : 5272  4: XmmReg2_m128 : 5270  
Pattern id=1727 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:E3:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[abc80:10] = CALLOTHER const[169:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[abc80:10]

Line avx2.sinc:175 :VPAVGW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE3; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpavgw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:175(id0.1946) printpiece=[VPAVGW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6353  1: vexVVVV_YmmReg : 6351  2: YmmReg1 : 6350  3: YmmReg2_m256 : 6352  
Pattern id=1946 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:E3:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[20c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2766 :IN    AL, imm8     is vexMode=0 & AL & (byte=0xe4; imm8)               { tmp:1 = imm8; AL = in(tmp); }
0: Constructor line ia.sinc:2766(id0.192) printpiece=[IN,  ,  A, ,,  ,  B]
Operands 0: AL : 1732  1: imm8 : 1733  
Pattern id=192 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:E4:XX:XX:XX)
Template
	0: register[0:1] = CALLOTHER const[1:4], [handle:space][[handle:offset]:1]

Line avx.sinc:2326 :VPMULHUW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE4; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmulhuw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2326(id0.1783) printpiece=[VPMULHUW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5576  1: vexVVVV_XmmReg : 5574  2: XmmReg1 : 5573  3: YmmReg1 : 5577  4: XmmReg2_m128 : 5575  
Pattern id=1783 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:E4:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b0680:10] = CALLOTHER const[1a2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0680:10]

Line avx2.sinc:527 :VPMULHUW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE4; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmulhuw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:527(id0.1990) printpiece=[VPMULHUW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6556  1: vexVVVV_YmmReg : 6554  2: YmmReg1 : 6553  3: YmmReg2_m256 : 6555  
Pattern id=1990 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:E4:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[238:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2767 :IN    AX, imm8     is vexMode=0 & opsize=0 & AX & (byte=0xe5; imm8)    { tmp:1 = imm8; AX = in(tmp); }
0: Constructor line ia.sinc:2767(id0.193) printpiece=[IN,  ,  A, ,,  ,  B]
Operands 0: AX : 1734  1: imm8 : 1735  
Pattern id=193 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:E5:XX:XX:XX)
Template
	0: register[0:2] = CALLOTHER const[1:4], [handle:space][[handle:offset]:1]

Line ia.sinc:2768 :IN    EAX, imm8    is vexMode=0 & opsize=1 & EAX & check_EAX_dest & (byte=0xe5; imm8)   { tmp:1 = imm8; EAX = in(tmp); build check_EAX_dest; }
0: Constructor line ia.sinc:2768(id0.194) printpiece=[IN,  ,  A, ,,  ,  C]
Operands 0: EAX : 1736  1: check_EAX_dest : 1738  2: imm8 : 1737  
Pattern id=194 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:E5:XX:XX:XX)
Template
	0: register[0:4] = CALLOTHER const[1:4], [handle:space][[handle:offset]:1]
	1: MULTIEQUAL const[1:4]

Line avx.sinc:2335 :VPMULHW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE5; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmulhw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2335(id0.1784) printpiece=[VPMULHW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5582  1: vexVVVV_XmmReg : 5580  2: XmmReg1 : 5579  3: YmmReg1 : 5583  4: XmmReg2_m128 : 5581  
Pattern id=1784 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:E5:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b0800:10] = CALLOTHER const[1a3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0800:10]

Line avx2.sinc:535 :VPMULHW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE5; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmulhw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:535(id0.1991) printpiece=[VPMULHW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6561  1: vexVVVV_YmmReg : 6559  2: YmmReg1 : 6558  3: YmmReg2_m256 : 6560  
Pattern id=1991 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:E5:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[239:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3256 :OUT imm8,AL        is vexMode=0 & byte=0xe6; imm8 & AL                 { tmp:1 = imm8; out(tmp,AL); }
0: Constructor line ia.sinc:3256(id0.354) printpiece=[OUT,  ,  A, ,,  B]
Operands 0: imm8 : 2025  1: AL : 2026  
Pattern id=354 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:E6:XX:XX:XX)
Template
	0: CALLOTHER const[2:4], [handle:space][[handle:offset]:1], register[0:1]

Line avx.sinc:767 :VCVTTPD2DQ XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvttpd2dq_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:767(id0.1605) printpiece=[VCVTTPD2DQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4695  1: XmmReg1 : 4693  2: YmmReg1 : 4696  3: XmmReg2_m128 : 4694  
Pattern id=1605 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:E6:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a3c80:10] = CALLOTHER const[11e:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3c80:10]

Line avx.sinc:775 :VCVTTPD2DQ XmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & YmmReg2_m256
{
	local tmp:16 = vcvttpd2dq_avx( YmmReg2_m256 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:775(id0.1606) printpiece=[VCVTTPD2DQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4699  1: XmmReg1 : 4697  2: YmmReg1 : 4700  3: YmmReg2_m256 : 4698  
Pattern id=1606 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:E6:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a3e00:10] = CALLOTHER const[11e:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a3e00:10]

Line avx.sinc:549 :VCVTDQ2PD XmmReg1, XmmReg2_m64 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & XmmReg2_m64
{
	local tmp:16 = vcvtdq2pd_avx( XmmReg2_m64 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:549(id0.1583) printpiece=[VCVTDQ2PD,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4604  1: XmmReg1 : 4602  2: YmmReg1 : 4605  3: XmmReg2_m64 : 4603  
Pattern id=1583 pattern=cmb:(ctx:SS:X[010x]:X8:0[001x]:XX,ins:E6:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a2480:10] = CALLOTHER const[110:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2480:10]

Line avx.sinc:557 :VCVTDQ2PD YmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F3) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vcvtdq2pd_avx( XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:557(id0.1584) printpiece=[VCVTDQ2PD,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4608  1: YmmReg1 : 4606  2: XmmReg2_m128 : 4607  
Pattern id=1584 pattern=cmb:(ctx:SS:X[010x]:XC:0[001x]:XX,ins:E6:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[110:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:581 :VCVTPD2DQ XmmReg1, XmmReg2_m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vcvtpd2dq_avx( XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:581(id0.1587) printpiece=[VCVTPD2DQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4620  1: XmmReg1 : 4618  2: YmmReg1 : 4621  3: XmmReg2_m128 : 4619  
Pattern id=1587 pattern=cmb:(ctx:SS:X[100x]:X8:0[001x]:XX,ins:E6:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a2880:10] = CALLOTHER const[112:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2880:10]

Line avx.sinc:589 :VCVTPD2DQ XmmReg1, YmmReg2_m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0xE6; (XmmReg1 & YmmReg1) ... & YmmReg2_m256
{
	local tmp:16 = vcvtpd2dq_avx( YmmReg2_m256 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:589(id0.1588) printpiece=[VCVTPD2DQ,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4624  1: XmmReg1 : 4622  2: YmmReg1 : 4625  3: YmmReg2_m256 : 4623  
Pattern id=1588 pattern=cmb:(ctx:SS:X[100x]:XC:0[001x]:XX,ins:E6:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a2a00:10] = CALLOTHER const[112:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a2a00:10]

Line ia.sinc:3257 :OUT imm8,AX        is vexMode=0 & opsize=0 & byte=0xe7; imm8 & AX      { tmp:1 = imm8; out(tmp,AX); }
0: Constructor line ia.sinc:3257(id0.355) printpiece=[OUT,  ,  A, ,,  B]
Operands 0: imm8 : 2027  1: AX : 2028  
Pattern id=355 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:E7:XX:XX:XX)
Template
	0: CALLOTHER const[2:4], [handle:space][[handle:offset]:1], register[0:2]

Line ia.sinc:3258 :OUT imm8,EAX       is vexMode=0 &            byte=0xe7; imm8 & EAX     { tmp:1 = imm8; out(tmp,EAX); }
1: Constructor line ia.sinc:3258(id0.356) printpiece=[OUT,  ,  A, ,,  B]
Operands 0: imm8 : 2029  1: EAX : 2030  
Pattern id=356 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:E7:XX:XX:XX)
Template
	0: CALLOTHER const[2:4], [handle:space][[handle:offset]:1], register[0:4]

Line avx.sinc:1376 :VMOVNTDQ m128, XmmReg1 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xE7; XmmReg1 ... & m128
{
	m128 = vmovntdq_avx( XmmReg1 );
}
0: Constructor line avx.sinc:1376(id0.1677) printpiece=[VMOVNTDQ,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5024  1: XmmReg1 : 5023  2: m128 : 5022  
Pattern id=1677 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:E7:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[148:4], [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:1382 :VMOVNTDQ m256, YmmReg1 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xE7; YmmReg1 ... & m256
{
	m256 = vmovntdq_avx( YmmReg1 );
}
0: Constructor line avx.sinc:1382(id0.1678) printpiece=[VMOVNTDQ,  ,  C, ,,  ,  B]
Operands 0: rexWprefix : 5027  1: YmmReg1 : 5026  2: m256 : 5025  
Pattern id=1678 pattern=cmb:(ctx:SS:X[001x]:XC:0[001x]:XX,ins:E7:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[148:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2097 :CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; simm16=0 & rel16      { push22(&:2 inst_next); goto rel16; }
0: Constructor line ia.sinc:2097(id0.100) printpiece=[CALL,  ,  A]
Operands 0: rel16 : 1564  
Pattern id=100 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:E8:00:00:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9400:2] = COPY const[[next]:2]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]
	5: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2090 :CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; rel16     { push22(&:2 inst_next); call rel16; }
1: Constructor line ia.sinc:2090(id0.98) printpiece=[CALL,  ,  A]
Operands 0: rel16 : 1562  
Pattern id=98 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:E8:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9400:2] = COPY const[[next]:2]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]
	5: CALL [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2111 :CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; simm32=0 & rel32      { push24(&:4 inst_next); goto rel32; }
0: Constructor line ia.sinc:2111(id0.104) printpiece=[CALL,  ,  A]
Operands 0: rel32 : 1568  
Pattern id=104 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:E8:00:00:00:00:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9600:4] = COPY const[[next]:4]
	2: register[10:2] = INT_SUB register[10:2], const[4:2]
	3: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9780:4], unique[9600:4]
	5: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2103 :CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; rel32     { push24(&:4 inst_next); call rel32; }
1: Constructor line ia.sinc:2103(id0.102) printpiece=[CALL,  ,  A]
Operands 0: rel32 : 1566  
Pattern id=102 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:E8:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9600:4] = COPY const[[next]:4]
	2: register[10:2] = INT_SUB register[10:2], const[4:2]
	3: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9780:4], unique[9600:4]
	5: CALL [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2098 :CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; simm16=0 & rel16      { push42(&:2 inst_next); goto rel16; }
0: Constructor line ia.sinc:2098(id0.101) printpiece=[CALL,  ,  A]
Operands 0: rel16 : 1565  
Pattern id=101 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:E8:00:00:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10:4] = INT_SUB register[10:4], const[2:4]
	2: STORE const[ram:8], register[10:4], const[[next]:2]
	3: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2091 :CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; rel16     { push42(&:2 inst_next); call rel16; }
1: Constructor line ia.sinc:2091(id0.99) printpiece=[CALL,  ,  A]
Operands 0: rel16 : 1563  
Pattern id=99 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:E8:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10:4] = INT_SUB register[10:4], const[2:4]
	2: STORE const[ram:8], register[10:4], const[[next]:2]
	3: CALL [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2112 :CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32      { push44(&:4 inst_next); goto rel32; }
0: Constructor line ia.sinc:2112(id0.105) printpiece=[CALL,  ,  A]
Operands 0: rel32 : 1569  
Pattern id=105 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:E8:00:00:00:00:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10:4] = INT_SUB register[10:4], const[4:4]
	2: STORE const[ram:8], register[10:4], const[[next]:4]
	3: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2104 :CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32     { push44(&:4 inst_next); call rel32; }
1: Constructor line ia.sinc:2104(id0.103) printpiece=[CALL,  ,  A]
Operands 0: rel32 : 1567  
Pattern id=103 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:E8:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[10:4] = INT_SUB register[10:4], const[4:4]
	2: STORE const[ram:8], register[10:4], const[[next]:4]
	3: CALL [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2622 :VPSUBSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubsb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2622(id0.1819) printpiece=[VPSUBSB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5774  1: vexVVVV_XmmReg : 5772  2: XmmReg1 : 5771  3: YmmReg1 : 5775  4: XmmReg2_m128 : 5773  
Pattern id=1819 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:E8:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3280:10] = CALLOTHER const[1be:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3280:10]

Line avx2.sinc:797 :VPSUBSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubsb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:797(id0.2026) printpiece=[VPSUBSB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6728  1: vexVVVV_YmmReg : 6726  2: YmmReg1 : 6725  3: YmmReg2_m256 : 6727  
Pattern id=2026 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:E8:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[254:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2849 :JMP rel16      is vexMode=0 & opsize=0 & byte=0xe9; rel16                      { goto rel16; }
0: Constructor line ia.sinc:2849(id0.227) printpiece=[JMP,  ,  A]
Operands 0: rel16 : 1783  
Pattern id=227 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:E9:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2850 :JMP rel32      is vexMode=0 & opsize=1 & byte=0xe9; rel32                      { goto rel32; }
0: Constructor line ia.sinc:2850(id0.228) printpiece=[JMP,  ,  A]
Operands 0: rel32 : 1784  
Pattern id=228 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:E9:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2851 :JMP rel32      is vexMode=0 & opsize=2 & byte=0xe9; rel32                      { goto rel32; }
0: Constructor line ia.sinc:2851(id0.229) printpiece=[JMP,  ,  A]
Operands 0: rel32 : 1785  
Pattern id=229 pattern=cmb:(ctx:X[xx10]:XX:X[0xxx]:XX,ins:E9:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2631 :VPSUBSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xE9; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2631(id0.1820) printpiece=[VPSUBSW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5780  1: vexVVVV_XmmReg : 5778  2: XmmReg1 : 5777  3: YmmReg1 : 5781  4: XmmReg2_m128 : 5779  
Pattern id=1820 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:E9:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3400:10] = CALLOTHER const[1bf:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3400:10]

Line avx2.sinc:805 :VPSUBSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xE9; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:805(id0.2027) printpiece=[VPSUBSW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6733  1: vexVVVV_YmmReg : 6731  2: YmmReg1 : 6730  3: YmmReg2_m256 : 6732  
Pattern id=2027 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:E9:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[255:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2859 :JMPF ptr1616   is vexMode=0 & opsize=0 & byte=0xea; ptr1616                    { goto ptr1616; }
0: Constructor line ia.sinc:2859(id0.233) printpiece=[JMPF,  ,  A]
Operands 0: ptr1616 : 1790  
Pattern id=233 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:EA:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2860 :JMPF ptr1632   is vexMode=0 & opsize=1 & byte=0xea; ptr1632                    { goto ptr1632; }
0: Constructor line ia.sinc:2860(id0.234) printpiece=[JMPF,  ,  A]
Operands 0: ptr1632 : 1791  
Pattern id=234 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:EA:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2155 :VPMINSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_XmmReg; byte=0xEA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpminsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2155(id0.1764) printpiece=[VPMINSW,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_XmmReg : 5475  1: XmmReg1 : 5474  2: YmmReg1 : 5477  3: XmmReg2_m128 : 5476  
Pattern id=1764 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:EA:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[aea00:10] = CALLOTHER const[18f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aea00:10]

Line avx2.sinc:375 :VPMINSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & vexVVVV_YmmReg; byte=0xEA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpminsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:375(id0.1971) printpiece=[VPMINSW,  ,  B, ,,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_YmmReg : 6474  1: YmmReg1 : 6473  2: YmmReg2_m256 : 6475  
Pattern id=1971 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:EA:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[225:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2848 :JMP rel8       is vexMode=0 & byte=0xeb; rel8                                  { goto rel8; }
0: Constructor line ia.sinc:2848(id0.226) printpiece=[JMP,  ,  A]
Operands 0: rel8 : 1782  
Pattern id=226 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:EB:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: BRANCH [handle:space][[handle:offset]:[handle:size]]

Line avx.sinc:2371 :VPOR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xEB; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpor_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2371(id0.1788) printpiece=[VPOR,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5606  1: vexVVVV_XmmReg : 5604  2: XmmReg1 : 5603  3: YmmReg1 : 5607  4: XmmReg2_m128 : 5605  
Pattern id=1788 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:EB:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b0e00:10] = CALLOTHER const[1a7:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0e00:10]

Line avx2.sinc:567 :VPOR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xEB; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpor_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:567(id0.1995) printpiece=[VPOR,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6581  1: vexVVVV_YmmReg : 6579  2: YmmReg1 : 6578  3: YmmReg2_m256 : 6580  
Pattern id=1995 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:EB:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[23d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2772 :IN    AL, DX       is vexMode=0 & AL & DX & (byte=0xec)                { AL  = in(DX); }
0: Constructor line ia.sinc:2772(id0.195) printpiece=[IN,  ,  A, ,,  ,  B]
Operands 0: AL : 1739  1: DX : 1740  
Pattern id=195 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:EC:XX:XX:XX)
Template
	0: register[0:1] = CALLOTHER const[1:4], register[8:2]

Line avx.sinc:1737 :VPADDSB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xEC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddsb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1737(id0.1719) printpiece=[VPADDSB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5222  1: vexVVVV_XmmReg : 5220  2: XmmReg1 : 5219  3: YmmReg1 : 5223  4: XmmReg2_m128 : 5221  
Pattern id=1719 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:EC:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab080:10] = CALLOTHER const[161:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab080:10]

Line avx2.sinc:111 :VPADDSB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xEC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddsb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:111(id0.1938) printpiece=[VPADDSB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6312  1: vexVVVV_YmmReg : 6310  2: YmmReg1 : 6309  3: YmmReg2_m256 : 6311  
Pattern id=1938 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:EC:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[204:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2773 :IN    AX, DX       is vexMode=0 & opsize=0 & AX & DX & (byte=0xed)     { AX  = in(DX); }
0: Constructor line ia.sinc:2773(id0.196) printpiece=[IN,  ,  A, ,,  ,  B]
Operands 0: AX : 1741  1: DX : 1742  
Pattern id=196 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:ED:XX:XX:XX)
Template
	0: register[0:2] = CALLOTHER const[1:4], register[8:2]

Line ia.sinc:2774 :IN    EAX, DX      is vexMode=0 & opsize=1 & EAX & check_EAX_dest & DX & (byte=0xed)    { EAX = in(DX); build check_EAX_dest; }
0: Constructor line ia.sinc:2774(id0.197) printpiece=[IN,  ,  A, ,,  ,  C]
Operands 0: EAX : 1743  1: check_EAX_dest : 1745  2: DX : 1744  
Pattern id=197 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:ED:XX:XX:XX)
Template
	0: register[0:4] = CALLOTHER const[1:4], register[8:2]
	1: MULTIEQUAL const[1:4]

Line avx.sinc:1746 :VPADDSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xED; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1746(id0.1720) printpiece=[VPADDSW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5228  1: vexVVVV_XmmReg : 5226  2: XmmReg1 : 5225  3: YmmReg1 : 5229  4: XmmReg2_m128 : 5227  
Pattern id=1720 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:ED:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ab200:10] = CALLOTHER const[162:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ab200:10]

Line avx2.sinc:119 :VPADDSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xED; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:119(id0.1939) printpiece=[VPADDSW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6317  1: vexVVVV_YmmReg : 6315  2: YmmReg1 : 6314  3: YmmReg2_m256 : 6316  
Pattern id=1939 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:ED:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[205:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3259 :OUT DX,AL          is vexMode=0 & byte=0xee & DX & AL                  { out(DX,AL); }
0: Constructor line ia.sinc:3259(id0.357) printpiece=[OUT,  ,  A, ,,  B]
Operands 0: DX : 2031  1: AL : 2032  
Pattern id=357 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:EE:XX:XX:XX)
Template
	0: CALLOTHER const[2:4], register[8:2], register[0:1]

Line avx.sinc:2101 :VPMAXSW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xEE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaxsw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2101(id0.1758) printpiece=[VPMAXSW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5444  1: vexVVVV_XmmReg : 5442  2: XmmReg1 : 5441  3: YmmReg1 : 5445  4: XmmReg2_m128 : 5443  
Pattern id=1758 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:EE:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ae100:10] = CALLOTHER const[189:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ae100:10]

Line avx2.sinc:327 :VPMAXSW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xEE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaxsw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:327(id0.1965) printpiece=[VPMAXSW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6449  1: vexVVVV_YmmReg : 6447  2: YmmReg1 : 6446  3: YmmReg2_m256 : 6448  
Pattern id=1965 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:EE:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[21f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3260 :OUT DX,AX          is vexMode=0 & opsize=0 & byte=0xef & DX & AX       { out(DX,AX); }
0: Constructor line ia.sinc:3260(id0.358) printpiece=[OUT,  ,  A, ,,  B]
Operands 0: DX : 2033  1: AX : 2034  
Pattern id=358 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:EF:XX:XX:XX)
Template
	0: CALLOTHER const[2:4], register[8:2], register[0:2]

Line ia.sinc:3261 :OUT DX,EAX         is vexMode=0 &            byte=0xef & DX & EAX      { out(DX,EAX); }
1: Constructor line ia.sinc:3261(id0.359) printpiece=[OUT,  ,  A, ,,  B]
Operands 0: DX : 2035  1: EAX : 2036  
Pattern id=359 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:EF:XX:XX:XX)
Template
	0: CALLOTHER const[2:4], register[8:2], register[0:4]

Line avx.sinc:2745 :VPXOR XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xEF; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpxor_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2745(id0.1833) printpiece=[VPXOR,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5853  1: vexVVVV_XmmReg : 5851  2: XmmReg1 : 5850  3: YmmReg1 : 5854  4: XmmReg2_m128 : 5852  
Pattern id=1833 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:EF:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b4480:10] = CALLOTHER const[1cb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b4480:10]

Line avx2.sinc:893 :VPXOR YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xEF; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpxor_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:893(id0.2038) printpiece=[VPXOR,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6788  1: vexVVVV_YmmReg : 6786  2: YmmReg1 : 6785  3: YmmReg2_m256 : 6787  
Pattern id=2038 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:EF:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[260:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2989 :LOCK 		is vexMode=0 & byte=0xf0 { LOCK(); }
0: Constructor line ia.sinc:2989(id0.263) printpiece=[LOCK]
Operands 
Pattern id=263 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F0:XX:XX:XX)
Template
	0: CALLOTHER const[11:4]

Line avx.sinc:987 :VLDDQU XmmReg1, m128 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0xF0; (XmmReg1 & YmmReg1) ... & m128
{
	local tmp:16 = vlddqu_avx( m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:987(id0.1630) printpiece=[VLDDQU,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 4821  1: XmmReg1 : 4819  2: YmmReg1 : 4822  3: m128 : 4820  
Pattern id=1630 pattern=cmb:(ctx:SS:X[100x]:X8:0[001x]:XX,ins:F0:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[3:4]
	2: MULTIEQUAL const[1:4]
	3: unique[a5700:10] = CALLOTHER const[12e:4], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[a5700:10]

Line bmi2.sinc:151 :RORX Reg32, rm32, imm8 is $(VEX_NONE) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F3A) & $(VEX_W0); byte=0xf0; Reg32 ... & check_Reg32_dest ... & rm32; imm8
{
  shiftTmp:1 = (imm8:1 & 0x1F);

  Reg32 = (rm32 >> shiftTmp) | ( rm32 << (32 - shiftTmp));
  build check_Reg32_dest;
}
0: Constructor line bmi2.sinc:151(id0.2126) printpiece=[RORX,  ,  A, ,,  ,  C, ,,  ,  D]
Operands 0: Reg32 : 7152  1: check_Reg32_dest : 7155  2: rm32 : 7153  3: imm8 : 7154  
Pattern id=2126 pattern=cmb:(ctx:SS:X8:X8:0[011x]:XX,ins:F0:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]
	2: unique[cfd00:1] = INT_AND [handle:space][[handle:offset]:1], const[1f:1]
	3: unique[cfd80:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[cfd00:1]
	4: unique[cfe00:1] = INT_SUB const[20:1], unique[cfd00:1]
	5: unique[cfe80:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[cfe00:1]
	6: [handle:space][[handle:offset]:[handle:size]] = INT_OR unique[cfd80:[handle:size]], unique[cfe80:[handle:size]]
	7: MULTIEQUAL const[1:4]

Line avx.sinc:995 :VLDDQU YmmReg1, m256 is $(VEX_NONE) & $(VEX_L256) & $(VEX_PRE_F2) & $(VEX_0F) & $(VEX_WIG); byte=0xF0; YmmReg1 ... & m256
{
	YmmReg1 = vlddqu_avx( m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx.sinc:995(id0.1631) printpiece=[VLDDQU,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4825  1: YmmReg1 : 4823  2: m256 : 4824  
Pattern id=1631 pattern=cmb:(ctx:SS:X[100x]:XC:0[001x]:XX,ins:F0:XX:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[12e:4], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2794 :INT1           is vexMode=0 & byte=0xf1                            { tmp:1 = 0x1; intloc:$(SIZE) = swi(tmp); call [intloc]; return [0:1]; }
0: Constructor line ia.sinc:2794(id0.207) printpiece=[INT1]
Operands 
Pattern id=207 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F1:XX:XX:XX)
Template
	0: unique[2a180:4] = CALLOTHER const[10:4], const[1:1]
	1: CALLIND unique[2a180:4]
	2: RETURN const[0:1]

Line avx.sinc:2459 :VPSLLW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF1; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsllw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2459(id0.1798) printpiece=[VPSLLW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5665  1: vexVVVV_XmmReg : 5663  2: XmmReg1 : 5662  3: YmmReg1 : 5666  4: XmmReg2_m128 : 5664  
Pattern id=1798 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:F1:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b1c00:10] = CALLOTHER const[1b1:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b1c00:10]

Line avx2.sinc:646 :VPSLLW YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF1; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsllw_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:646(id0.2005) printpiece=[VPSLLW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6631  1: vexVVVV_YmmReg : 6629  2: YmmReg1 : 6628  3: XmmReg2_m128 : 6630  
Pattern id=2005 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:F1:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[247:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1508 :^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1508(id0.8) printpiece=[ A]
Operands 0: instruction : 1343  
Pattern id=8 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:F2:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line bmi1.sinc:13 :ANDN Reg32, vexVVVV_r32, rm32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf2; Reg32 ... & check_Reg32_dest ... &rm32
{
  Reg32 = ~(vexVVVV_r32) & rm32;
  resultflags(Reg32);
  OF = 0;
  CF = 0;
  build check_Reg32_dest;
}
1: Constructor line bmi1.sinc:13(id0.2115) printpiece=[ANDN,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_r32 : 7114  1: Reg32 : 7113  2: check_Reg32_dest : 7116  3: rm32 : 7115  
Pattern id=2115 pattern=cmb:(ctx:SS:X0:X[10xx]:[xx00][010x]:XX,ins:F2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[cd600:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_AND unique[cd600:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	10: register[20b:1] = COPY const[0:1]
	11: register[200:1] = COPY const[0:1]
	12: MULTIEQUAL const[2:4]

Line ia.sinc:1508 :^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1508(id0.8) printpiece=[ A]
Operands 0: instruction : 1343  
Pattern id=8 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:F2:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:2474 :VPSLLD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF2; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpslld_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:2474(id0.1800) printpiece=[VPSLLD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5675  1: vexVVVV_XmmReg : 5673  2: XmmReg1 : 5672  3: YmmReg1 : 5676  4: XmmReg2_m128 : 5674  
Pattern id=1800 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:F2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b1e00:10] = CALLOTHER const[1b2:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b1e00:10]

Line ia.sinc:1508 :^instruction is instrPhase=0 & over=0xf2; instruction     [ repneprefx=1; ] {}
0: Constructor line ia.sinc:1508(id0.8) printpiece=[ A]
Operands 0: instruction : 1343  
Pattern id=8 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:F2:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx2.sinc:660 :VPSLLD YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF2; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpslld_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:660(id0.2007) printpiece=[VPSLLD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6640  1: vexVVVV_YmmReg : 6638  2: YmmReg1 : 6637  3: XmmReg2_m128 : 6639  
Pattern id=2007 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:F2:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[248:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:1509 :^instruction is instrPhase=0 & over=0xf3; instruction     [ repprefx=1; ] {}
0: Constructor line ia.sinc:1509(id0.9) printpiece=[ A]
Operands 0: instruction : 1344  
Pattern id=9 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:F3:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:1509 :^instruction is instrPhase=0 & over=0xf3; instruction     [ repprefx=1; ] {}
0: Constructor line ia.sinc:1509(id0.9) printpiece=[ A]
Operands 0: instruction : 1344  
Pattern id=9 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:F3:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line bmi1.sinc:116 :BLSR vexVVVV_r32, rm32 is $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf3; reg_opcode=1 ... & check_vexVVVV_r32_dest ... &rm32
{
  CF = (rm32 == 0);
  vexVVVV_r32 = (rm32 - 1) & rm32;
  build check_vexVVVV_r32_dest;

  ZF = (vexVVVV_r32 == 0);
  SF = (vexVVVV_r32 s< 0);
  OF = 0;
  # AF and PF are undefined
}
1: Constructor line bmi1.sinc:116(id0.2119) printpiece=[BLSR,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_r32 : 7127  1: check_vexVVVV_r32_dest : 7129  2: rm32 : 7128  
Pattern id=2119 pattern=cmb:(ctx:SS:X0:X[10xx]:[xx00][010x]:XX,ins:F3:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: register[200:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	2: unique[cdf80:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_AND unique[cdf80:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: MULTIEQUAL const[1:4]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[20b:1] = COPY const[0:1]

Line ia.sinc:1509 :^instruction is instrPhase=0 & over=0xf3; instruction     [ repprefx=1; ] {}
0: Constructor line ia.sinc:1509(id0.9) printpiece=[ A]
Operands 0: instruction : 1344  
Pattern id=9 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:F3:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line bmi1.sinc:90 :BLSMSK vexVVVV_r32, rm32 is $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf3; reg_opcode=2 ... & check_vexVVVV_r32_dest ... &rm32
{
  CF = (rm32 == 0);
  vexVVVV_r32 = (rm32 - 1) ^ rm32;

  SF = (vexVVVV_r32 s< 0);
  build check_vexVVVV_r32_dest;
  ZF = 0;
  OF = 0;
  # AF and PF are undefined
}
1: Constructor line bmi1.sinc:90(id0.2118) printpiece=[BLSMSK,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_r32 : 7124  1: check_vexVVVV_r32_dest : 7126  2: rm32 : 7125  
Pattern id=2118 pattern=cmb:(ctx:SS:X0:X[10xx]:[xx00][010x]:XX,ins:F3:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: register[200:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	2: unique[cdd80:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_XOR unique[cdd80:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: MULTIEQUAL const[1:4]
	6: register[206:1] = COPY const[0:1]
	7: register[20b:1] = COPY const[0:1]

Line ia.sinc:1509 :^instruction is instrPhase=0 & over=0xf3; instruction     [ repprefx=1; ] {}
0: Constructor line ia.sinc:1509(id0.9) printpiece=[ A]
Operands 0: instruction : 1344  
Pattern id=9 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:F3:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line bmi1.sinc:64 :BLSI vexVVVV_r32, rm32 is $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf3; reg_opcode=3 ... & check_vexVVVV_r32_dest ... & rm32
{
  vexVVVV_r32 = -rm32 & rm32;
  build check_vexVVVV_r32_dest;

  ZF = (vexVVVV_r32 == 0);
  SF = (vexVVVV_r32 s< 0);
  CF = (rm32 != 0);
  OF = 0;
  # AF and PF are undefined
}
1: Constructor line bmi1.sinc:64(id0.2117) printpiece=[BLSI,  ,  A, ,,  ,  C]
Operands 0: vexVVVV_r32 : 7121  1: check_vexVVVV_r32_dest : 7123  2: rm32 : 7122  
Pattern id=2117 pattern=cmb:(ctx:SS:X0:X[10xx]:[xx00][010x]:XX,ins:F3:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: unique[cda80:[handle:size]] = INT_2COMP [handle:space][[handle:offset]:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_AND unique[cda80:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: MULTIEQUAL const[1:4]
	4: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: register[200:1] = INT_NOTEQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	7: register[20b:1] = COPY const[0:1]

Line ia.sinc:1509 :^instruction is instrPhase=0 & over=0xf3; instruction     [ repprefx=1; ] {}
0: Constructor line ia.sinc:1509(id0.9) printpiece=[ A]
Operands 0: instruction : 1344  
Pattern id=9 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:F3:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx.sinc:2489 :VPSLLQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF3; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsllq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
1: Constructor line avx.sinc:2489(id0.1802) printpiece=[VPSLLQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5685  1: vexVVVV_XmmReg : 5683  2: XmmReg1 : 5682  3: YmmReg1 : 5686  4: XmmReg2_m128 : 5684  
Pattern id=1802 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:F3:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b2000:10] = CALLOTHER const[1b3:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b2000:10]

Line ia.sinc:1509 :^instruction is instrPhase=0 & over=0xf3; instruction     [ repprefx=1; ] {}
0: Constructor line ia.sinc:1509(id0.9) printpiece=[ A]
Operands 0: instruction : 1344  
Pattern id=9 pattern=cmb:(ctx:SS:SS:SS:X[xxx0]:XX:XX:XX,ins:F3:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line avx2.sinc:674 :VPSLLQ YmmReg1, vexVVVV_YmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF3; YmmReg1 ... & XmmReg2_m128
{
	YmmReg1 = vpsllq_avx2( vexVVVV_YmmReg, XmmReg2_m128 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
1: Constructor line avx2.sinc:674(id0.2009) printpiece=[VPSLLQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6649  1: vexVVVV_YmmReg : 6647  2: YmmReg1 : 6646  3: XmmReg2_m128 : 6648  
Pattern id=2009 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:F3:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[249:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2693 :HLT            is vexMode=0 & byte=0xf4                        { goto inst_start; }
0: Constructor line ia.sinc:2693(id0.179) printpiece=[HLT]
Operands 
Pattern id=179 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F4:XX:XX:XX)
Template
	0: BRANCH [curspace][[start]:[curspace_size]]

Line avx.sinc:2362 :VPMULUDQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF4; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmuludq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2362(id0.1787) printpiece=[VPMULUDQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5600  1: vexVVVV_XmmReg : 5598  2: XmmReg1 : 5597  3: YmmReg1 : 5601  4: XmmReg2_m128 : 5599  
Pattern id=1787 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:F4:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b0c80:10] = CALLOTHER const[1a6:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0c80:10]

Line avx2.sinc:559 :VPMULUDQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF4; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmuludq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:559(id0.1994) printpiece=[VPMULUDQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6576  1: vexVVVV_YmmReg : 6574  2: YmmReg1 : 6573  3: YmmReg2_m256 : 6575  
Pattern id=1994 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:F4:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[23c:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2189 :CMC			is vexMode=0 & byte=0xf5						{ CF = CF==0; }
0: Constructor line ia.sinc:2189(id0.131) printpiece=[CMC]
Operands 
Pattern id=131 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F5:XX:XX:XX)
Template
	0: register[200:1] = INT_EQUAL register[200:1], const[0:1]

Line bmi2.sinc:6 :BZHI Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf5; Reg32 ... & check_Reg32_dest ... & rm32
{
  indexTmp:1 = vexVVVV_r32:1;

  # saturate index amount to 32; operand size or higher does not clear any bits
  shift:1 = (indexTmp <= 32) * (32 - indexTmp);

  # clear the upper bits
  Reg32 = (rm32 << shift) >> shift;
  build check_Reg32_dest;

  ZF = (Reg32 == 0);
  SF = (Reg32 s< 0);
  CF = indexTmp > 31;
  OF = 0;
  # AF and PF are undefined
}
0: Constructor line bmi2.sinc:6(id0.2122) printpiece=[BZHI,  ,  B, ,,  ,  D, ,,  ,  A]
Operands 0: vexVVVV_r32 : 7137  1: Reg32 : 7135  2: check_Reg32_dest : 7138  3: rm32 : 7136  
Pattern id=2122 pattern=cmb:(ctx:SS:X0:X[10xx]:[xx00][010x]:XX,ins:F5:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[ce880:1] = COPY [handle:space][[handle:offset+0]:1]
	3: unique[ce900:1] = INT_LESSEQUAL unique[ce880:1], const[20:1]
	4: unique[ce980:1] = INT_SUB const[20:1], unique[ce880:1]
	5: unique[cea80:1] = INT_MULT unique[ce900:1], unique[ce980:1]
	6: unique[ceb00:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[cea80:1]
	7: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT unique[ceb00:[handle:size]], unique[cea80:1]
	8: MULTIEQUAL const[2:4]
	9: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	10: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	11: register[200:1] = INT_LESS const[1f:1], unique[ce880:1]
	12: register[20b:1] = COPY const[0:1]

Line avx.sinc:2083 :VPMADDWD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF5; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpmaddwd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2083(id0.1756) printpiece=[VPMADDWD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5432  1: vexVVVV_XmmReg : 5430  2: XmmReg1 : 5429  3: YmmReg1 : 5433  4: XmmReg2_m128 : 5431  
Pattern id=1756 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:F5:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[ade00:10] = CALLOTHER const[187:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[ade00:10]

Line avx2.sinc:311 :VPMADDWD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF5; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpmaddwd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:311(id0.1963) printpiece=[VPMADDWD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6439  1: vexVVVV_YmmReg : 6437  2: YmmReg1 : 6436  3: YmmReg2_m256 : 6438  
Pattern id=1963 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:F5:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[21d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line bmi2.sinc:111 :PEXT Reg32, vexVVVV_r32, rm32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F3) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf5; Reg32 ... & check_Reg32_dest ... & rm32
{
  indexTmp:4 = 0x80000000;
  resultTmp:4 = 0;

 <loop>
  maskBit:4 = rm32 & indexTmp;

  if (maskBit == 0) goto <nextMaskBit>;
  resultTmp = (resultTmp << 1) | zext((maskBit & vexVVVV_r32) != 0);

 <nextMaskBit>
  indexTmp = indexTmp >> 1;
  if (indexTmp != 0) goto <loop>;

  build check_Reg32_dest;
  Reg32 = resultTmp;
}
0: Constructor line bmi2.sinc:111(id0.2125) printpiece=[PEXT,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_r32 : 7149  1: Reg32 : 7148  2: check_Reg32_dest : 7151  3: rm32 : 7150  
Pattern id=2125 pattern=cmb:(ctx:SS:X4:X[10xx]:[xx00][010x]:XX,ins:F5:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[cf680:4] = COPY const[80000000:4]
	3: unique[cf700:4] = COPY const[0:4]
	4: PTRADD const[0:4]
	5: unique[cf800:4] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[cf680:4]
	6: unique[cf880:1] = INT_EQUAL unique[cf800:4], const[0:4]
	7: CBRANCH const[[rel:1]:4], unique[cf880:1]
	8: unique[cf900:4] = INT_LEFT unique[cf700:4], const[1:4]
	9: unique[cf980:4] = INT_AND unique[cf800:4], [handle:space][[handle:offset]:[handle:size]]
	10: unique[cfa00:1] = INT_NOTEQUAL unique[cf980:4], const[0:4]
	11: unique[cfa80:4] = INT_ZEXT unique[cfa00:1]
	12: unique[cf700:4] = INT_OR unique[cf900:4], unique[cfa80:4]
	13: PTRADD const[1:4]
	14: unique[cf680:4] = INT_RIGHT unique[cf680:4], const[1:4]
	15: unique[cfc00:1] = INT_NOTEQUAL unique[cf680:4], const[0:4]
	16: CBRANCH const[[rel:0]:4], unique[cfc00:1]
	17: MULTIEQUAL const[2:4]
	18: [handle:space][[handle:offset]:[handle:size]] = COPY unique[cf700:4]

Line bmi2.sinc:65 :PDEP Reg32, vexVVVV_r32, rm32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf5; Reg32 ... & check_Reg32_dest ... & rm32
{
  sourceTmp:4 = vexVVVV_r32;

  indexTmp:4 = 1;
  resultTmp:4 = 0;

 <loop>
  maskBit:4 = rm32 & indexTmp;

  if (maskBit == 0) goto <nextMaskBit>;
  resultTmp = resultTmp | (maskBit * (sourceTmp & 1));
  sourceTmp = sourceTmp >> 1;

 <nextMaskBit>
  indexTmp = indexTmp << 1;
  if (indexTmp != 0) goto <loop>;

  Reg32 = resultTmp;
  build check_Reg32_dest;
}
0: Constructor line bmi2.sinc:65(id0.2124) printpiece=[PDEP,  ,  B, ,,  ,  A, ,,  ,  D]
Operands 0: vexVVVV_r32 : 7145  1: Reg32 : 7144  2: check_Reg32_dest : 7147  3: rm32 : 7146  
Pattern id=2124 pattern=cmb:(ctx:SS:X8:X[10xx]:[xx00][010x]:XX,ins:F5:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[cf080:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	3: unique[cf100:4] = COPY const[1:4]
	4: unique[cf180:4] = COPY const[0:4]
	5: PTRADD const[0:4]
	6: unique[cf280:4] = INT_AND [handle:space][[handle:offset]:[handle:size]], unique[cf100:4]
	7: unique[cf300:1] = INT_EQUAL unique[cf280:4], const[0:4]
	8: CBRANCH const[[rel:1]:4], unique[cf300:1]
	9: unique[cf380:4] = INT_AND unique[cf080:4], const[1:4]
	10: unique[cf400:4] = INT_MULT unique[cf280:4], unique[cf380:4]
	11: unique[cf180:4] = INT_OR unique[cf180:4], unique[cf400:4]
	12: unique[cf080:4] = INT_RIGHT unique[cf080:4], const[1:4]
	13: PTRADD const[1:4]
	14: unique[cf100:4] = INT_LEFT unique[cf100:4], const[1:4]
	15: unique[cf600:1] = INT_NOTEQUAL unique[cf100:4], const[0:4]
	16: CBRANCH const[[rel:0]:4], unique[cf600:1]
	17: [handle:space][[handle:offset]:[handle:size]] = COPY unique[cf180:4]
	18: MULTIEQUAL const[2:4]

Line ia.sinc:3840 :TEST  spec_rm8,imm8     is vexMode=0 & byte=0xF6;  spec_rm8 & (reg_opcode=0 | reg_opcode=1) ... ; imm8        { logicalflags(); local tmp =  spec_rm8 & imm8;  resultflags(tmp); }
0: Constructor line ia.sinc:3840(id0.591) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: spec_rm8 : 2402  1: imm8 : 2403  
Pattern id=591 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F6:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: unique[42800:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[42800:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[42800:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[42800:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3840 :TEST  spec_rm8,imm8     is vexMode=0 & byte=0xF6;  spec_rm8 & (reg_opcode=0 | reg_opcode=1) ... ; imm8        { logicalflags(); local tmp =  spec_rm8 & imm8;  resultflags(tmp); }
0: Constructor line ia.sinc:3840(id0.591) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: spec_rm8 : 2402  1: imm8 : 2403  
Pattern id=591 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F6:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: unique[42800:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[42800:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[42800:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[42800:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3219 :NOT rm8       is vexMode=0 & byte=0xf6; rm8 & reg_opcode=2 ...         {  rm8 =  ~rm8; }
0: Constructor line ia.sinc:3219(id0.337) printpiece=[NOT,  ,  A]
Operands 0: rm8 : 1988  
Pattern id=337 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F6:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3203 :NEG rm8       is vexMode=0 & byte=0xf6; rm8 & reg_opcode=3 ...         { negflags(rm8);   rm8 =  -rm8; resultflags(rm8 ); }
0: Constructor line ia.sinc:3203(id0.326) printpiece=[NEG,  ,  A]
Operands 0: rm8 : 1972  
Pattern id=326 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F6:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_NOTEQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	2: register[20b:1] = INT_SBORROW const[0:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_2COMP [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3191 :MUL rm8        is vexMode=0 & byte=0xf6; rm8 & reg_opcode=4 ...            { AX=zext(AL)*zext(rm8); multflags(AH); }
0: Constructor line ia.sinc:3191(id0.319) printpiece=[MUL,  ,  A]
Operands 0: rm8 : 1967  
Pattern id=319 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F6:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2e300:2] = INT_ZEXT register[0:1]
	2: unique[2e380:2] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: register[0:2] = INT_MULT unique[2e300:2], unique[2e380:2]
	4: register[200:1] = INT_NOTEQUAL register[1:1], const[0:1]
	5: register[20b:1] = COPY register[200:1]

Line ia.sinc:2723 :IMUL             rm8   is vexMode=0 & byte=0xf6; rm8 & reg_opcode=5 ...            { AX = sext(AL) * sext(rm8); imultflags(AL,AX); }    
0: Constructor line ia.sinc:2723(id0.183) printpiece=[IMUL,  ,  A]
Operands 0: rm8 : 1708  
Pattern id=183 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F6:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[27880:2] = INT_SEXT register[0:1]
	2: unique[27900:2] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: register[0:2] = INT_MULT unique[27880:2], unique[27900:2]
	4: unique[ec00:2] = INT_SEXT register[0:1]
	5: register[200:1] = INT_NOTEQUAL unique[ec00:2], register[0:2]
	6: register[20b:1] = COPY register[200:1]

Line ia.sinc:2435 :DIV rm8        is vexMode=0 & byte=0xf6; rm8 & reg_opcode=6 ...            { rm8ext:2 = zext(rm8);
                                                  local quotient = AX / rm8ext;  # DE exception if quotient doesn't fit in AL
                                                  local rem      = AX % rm8ext;
                                                  AL = quotient:1;
                                                  AH = rem:1; }
0: Constructor line ia.sinc:2435(id0.167) printpiece=[DIV,  ,  A]
Operands 0: rm8 : 1678  
Pattern id=167 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F6:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[22c80:2] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[22d80:2] = INT_DIV register[0:2], unique[22c80:2]
	3: unique[22e80:2] = INT_REM register[0:2], unique[22c80:2]
	4: register[0:1] = SUBPIECE unique[22d80:2], const[0:4]
	5: register[1:1] = SUBPIECE unique[22e80:2], const[0:4]

Line ia.sinc:2695 :IDIV rm8       is vexMode=0 & byte=0xf6;  rm8 & reg_opcode=7 ...           { rm8ext:2 = sext(rm8);
                                                  local quotient = AX s/ rm8ext;  # DE exception if quotient doesn't fit in AL
                                                  local rem = AX s% rm8ext;
                                                  AL = quotient:1;
                                                  AH = rem:1; }
0: Constructor line ia.sinc:2695(id0.180) printpiece=[IDIV,  ,  A]
Operands 0: rm8 : 1703  
Pattern id=180 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F6:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[26800:2] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[26900:2] = INT_SDIV register[0:2], unique[26800:2]
	3: unique[26a00:2] = INT_SREM register[0:2], unique[26800:2]
	4: register[0:1] = SUBPIECE unique[26900:2], const[0:4]
	5: register[1:1] = SUBPIECE unique[26a00:2], const[0:4]

Line avx.sinc:2380 :VPSADBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF6; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsadbw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2380(id0.1789) printpiece=[VPSADBW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5612  1: vexVVVV_XmmReg : 5610  2: XmmReg1 : 5609  3: YmmReg1 : 5613  4: XmmReg2_m128 : 5611  
Pattern id=1789 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:F6:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b0f80:10] = CALLOTHER const[1a8:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b0f80:10]

Line avx2.sinc:575 :VPSADBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF6; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsadbw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:575(id0.1996) printpiece=[VPSADBW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6586  1: vexVVVV_YmmReg : 6584  2: YmmReg1 : 6583  3: YmmReg2_m256 : 6585  
Pattern id=1996 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:F6:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[23e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line bmi2.sinc:44 :MULX Reg32, vexVVVV_r32, rm32 is $(VEX_NDD) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf6; Reg32 ... & check_Reg32_dest ... &  check_vexVVVV_r32_dest ... & rm32
{
  temp:8 = zext(EDX) * zext(rm32);

  vexVVVV_r32 = temp:4;
  build check_vexVVVV_r32_dest;
  Reg32 = temp(4);
  build check_Reg32_dest;
}
0: Constructor line bmi2.sinc:44(id0.2123) printpiece=[MULX,  ,  B, ,,  ,  A, ,,  ,  E]
Operands 0: vexVVVV_r32 : 7140  1: Reg32 : 7139  2: check_Reg32_dest : 7142  3: check_vexVVVV_r32_dest : 7143  4: rm32 : 7141  
Pattern id=2123 pattern=cmb:(ctx:SS:X8:X[10xx]:[xx00][010x]:XX,ins:F6:XX:XX:XX)
Template
	0: MULTIEQUAL const[4:4]
	1: MULTIEQUAL const[1:4]
	2: unique[ced80:8] = INT_ZEXT register[8:4]
	3: unique[cee00:8] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	4: unique[cef00:8] = INT_MULT unique[ced80:8], unique[cee00:8]
	5: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[cef00:8], const[0:4]
	6: MULTIEQUAL const[3:4]
	7: [handle:space][[handle:offset]:[handle:size]] = SUBPIECE unique[cef00:8], const[4:4]
	8: MULTIEQUAL const[2:4]

Line ia.sinc:3841 :TEST spec_rm16,imm16    is vexMode=0 & opsize=0; byte=0xF7; spec_rm16 & (reg_opcode=0 | reg_opcode=1) ... ; imm16 { logicalflags(); local tmp = spec_rm16 & imm16; resultflags(tmp); }
0: Constructor line ia.sinc:3841(id0.592) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: spec_rm16 : 2404  1: imm16 : 2405  
Pattern id=592 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:F7:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: unique[42900:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[42900:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[42900:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[42900:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3842 :TEST spec_rm32,imm32    is vexMode=0 & opsize=1; byte=0xF7; spec_rm32 & (reg_opcode=0 | reg_opcode=1) ... ; imm32 { logicalflags(); local tmp = spec_rm32 & imm32; resultflags(tmp); }
0: Constructor line ia.sinc:3842(id0.593) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: spec_rm32 : 2406  1: imm32 : 2407  
Pattern id=593 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:F7:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: unique[42a00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[42a00:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[42a00:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[42a00:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3841 :TEST spec_rm16,imm16    is vexMode=0 & opsize=0; byte=0xF7; spec_rm16 & (reg_opcode=0 | reg_opcode=1) ... ; imm16 { logicalflags(); local tmp = spec_rm16 & imm16; resultflags(tmp); }
0: Constructor line ia.sinc:3841(id0.592) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: spec_rm16 : 2404  1: imm16 : 2405  
Pattern id=592 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:F7:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: unique[42900:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[42900:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[42900:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[42900:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3842 :TEST spec_rm32,imm32    is vexMode=0 & opsize=1; byte=0xF7; spec_rm32 & (reg_opcode=0 | reg_opcode=1) ... ; imm32 { logicalflags(); local tmp = spec_rm32 & imm32; resultflags(tmp); }
0: Constructor line ia.sinc:3842(id0.593) printpiece=[TEST,  ,  A, ,,  B]
Operands 0: spec_rm32 : 2406  1: imm32 : 2407  
Pattern id=593 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:F7:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = COPY const[0:1]
	2: register[20b:1] = COPY const[0:1]
	3: unique[42a00:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS unique[42a00:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL unique[42a00:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND unique[42a00:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3220 :NOT rm16      is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=2 ... { rm16 = ~rm16; }
0: Constructor line ia.sinc:3220(id0.338) printpiece=[NOT,  ,  A]
Operands 0: rm16 : 1989  
Pattern id=338 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:F7:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3221 :NOT rm32      is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_rm32_dest ... & reg_opcode=2 ... { rm32 = ~rm32; build check_rm32_dest;}
0: Constructor line ia.sinc:3221(id0.339) printpiece=[NOT,  ,  A]
Operands 0: rm32 : 1990  1: check_rm32_dest : 1991  
Pattern id=339 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:F7:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: [handle:space][[handle:offset]:[handle:size]] = INT_NEGATE [handle:space][[handle:offset]:[handle:size]]
	2: MULTIEQUAL const[1:4]

Line ia.sinc:3204 :NEG rm16      is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=3 ... { negflags(rm16); rm16 = -rm16; resultflags(rm16); }
0: Constructor line ia.sinc:3204(id0.327) printpiece=[NEG,  ,  A]
Operands 0: rm16 : 1973  
Pattern id=327 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:F7:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_NOTEQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	2: register[20b:1] = INT_SBORROW const[0:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_2COMP [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:3205 :NEG rm32      is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_rm32_dest ... & reg_opcode=3 ... { negflags(rm32); rm32 = -rm32; resultflags(rm32); build check_rm32_dest;}
0: Constructor line ia.sinc:3205(id0.328) printpiece=[NEG,  ,  A]
Operands 0: rm32 : 1974  1: check_rm32_dest : 1975  
Pattern id=328 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:F7:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[200:1] = INT_NOTEQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	2: register[20b:1] = INT_SBORROW const[0:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_2COMP [handle:space][[handle:offset]:[handle:size]]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]
	10: MULTIEQUAL const[1:4]

Line ia.sinc:3192 :MUL rm16       is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=4 ...    { tmp:4=zext(AX)*zext(rm16); DX=tmp(2); AX=tmp(0); multflags(DX); }
0: Constructor line ia.sinc:3192(id0.320) printpiece=[MUL,  ,  A]
Operands 0: rm16 : 1968  
Pattern id=320 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:F7:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2e480:4] = INT_ZEXT register[0:2]
	2: unique[2e500:4] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[2e600:4] = INT_MULT unique[2e480:4], unique[2e500:4]
	4: register[8:2] = SUBPIECE unique[2e600:4], const[2:4]
	5: register[0:2] = SUBPIECE unique[2e600:4], const[0:4]
	6: register[200:1] = INT_NOTEQUAL register[8:2], const[0:2]
	7: register[20b:1] = COPY register[200:1]

Line ia.sinc:3193 :MUL rm32       is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_EAX_dest ... & check_EDX_dest ... & reg_opcode=4 ...    { tmp:8=zext(EAX)*zext(rm32); EDX=tmp(4); build check_EDX_dest; multflags(EDX);  EAX=tmp(0); build check_EAX_dest;  }
0: Constructor line ia.sinc:3193(id0.321) printpiece=[MUL,  ,  A]
Operands 0: rm32 : 1969  1: check_EAX_dest : 1970  2: check_EDX_dest : 1971  
Pattern id=321 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:F7:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2e780:8] = INT_ZEXT register[0:4]
	2: unique[2e800:8] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[2e900:8] = INT_MULT unique[2e780:8], unique[2e800:8]
	4: register[8:4] = SUBPIECE unique[2e900:8], const[4:4]
	5: MULTIEQUAL const[2:4]
	6: register[200:1] = INT_NOTEQUAL register[8:4], const[0:4]
	7: register[20b:1] = COPY register[200:1]
	8: register[0:4] = SUBPIECE unique[2e900:8], const[0:4]
	9: MULTIEQUAL const[1:4]

Line ia.sinc:2724 :IMUL            rm16   is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=5 ...    { tmp:4 = sext(AX) * sext(rm16);
                                          DX = tmp(2); AX = tmp(0); imultflags(AX,tmp); }
0: Constructor line ia.sinc:2724(id0.184) printpiece=[IMUL,  ,  A]
Operands 0: rm16 : 1709  
Pattern id=184 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:F7:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[27a00:4] = INT_SEXT register[0:2]
	2: unique[27a80:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[27b80:4] = INT_MULT unique[27a00:4], unique[27a80:4]
	4: register[8:2] = SUBPIECE unique[27b80:4], const[2:4]
	5: register[0:2] = SUBPIECE unique[27b80:4], const[0:4]
	6: unique[ec00:4] = INT_SEXT register[0:2]
	7: register[200:1] = INT_NOTEQUAL unique[ec00:4], unique[27b80:4]
	8: register[20b:1] = COPY register[200:1]

Line ia.sinc:2726 :IMUL            rm32   is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_EAX_dest ... & check_EDX_dest ... & reg_opcode=5 ...    { tmp:8 = sext(EAX) * sext(rm32);
                                          EDX = tmp(4); build check_EDX_dest; EAX = tmp(0); build check_EAX_dest; imultflags(EAX,tmp); }
0: Constructor line ia.sinc:2726(id0.185) printpiece=[IMUL,  ,  A]
Operands 0: rm32 : 1710  1: check_EAX_dest : 1711  2: check_EDX_dest : 1712  
Pattern id=185 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:F7:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[27d00:8] = INT_SEXT register[0:4]
	2: unique[27d80:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	3: unique[27e80:8] = INT_MULT unique[27d00:8], unique[27d80:8]
	4: register[8:4] = SUBPIECE unique[27e80:8], const[4:4]
	5: MULTIEQUAL const[2:4]
	6: register[0:4] = SUBPIECE unique[27e80:8], const[0:4]
	7: MULTIEQUAL const[1:4]
	8: unique[ec00:8] = INT_SEXT register[0:4]
	9: register[200:1] = INT_NOTEQUAL unique[ec00:8], unique[27e80:8]
	10: register[20b:1] = COPY register[200:1]

Line ia.sinc:2440 :DIV rm16       is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=6 ...    { rm16ext:4 = zext(rm16);
                                                  tmp:4 = (zext(DX) << 16) | zext(AX);   # DE exception if quotient doesn't fit in AX
                                                  local quotient = tmp / rm16ext;
                                                  AX = quotient:2;
                                                  local rem = tmp % rm16ext;
                                                  DX = rem:2; }
0: Constructor line ia.sinc:2440(id0.168) printpiece=[DIV,  ,  A]
Operands 0: rm16 : 1679  
Pattern id=168 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:F7:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[23080:4] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[23100:4] = INT_ZEXT register[8:2]
	3: unique[23180:4] = INT_LEFT unique[23100:4], const[10:4]
	4: unique[23200:4] = INT_ZEXT register[0:2]
	5: unique[23300:4] = INT_OR unique[23180:4], unique[23200:4]
	6: unique[23400:4] = INT_DIV unique[23300:4], unique[23080:4]
	7: register[0:2] = SUBPIECE unique[23400:4], const[0:4]
	8: unique[23580:4] = INT_REM unique[23300:4], unique[23080:4]
	9: register[8:2] = SUBPIECE unique[23580:4], const[0:4]

Line ia.sinc:2446 :DIV rm32       is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_EDX_dest ... & check_EAX_dest ... & reg_opcode=6 ...    { rm32ext:8 = zext(rm32);
                                                  tmp:8 = (zext(EDX) << 32) | zext(EAX); # DE exception if quotient doesn't fit in EAX
                                                  local quotient = tmp / rm32ext;
                                                  EAX = quotient:4;
                                                  build check_EAX_dest;
                                                  local rem = tmp % rm32ext;
                                                  EDX = rem:4;
                                                  build check_EDX_dest; }
0: Constructor line ia.sinc:2446(id0.169) printpiece=[DIV,  ,  A]
Operands 0: rm32 : 1680  1: check_EDX_dest : 1681  2: check_EAX_dest : 1682  
Pattern id=169 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:F7:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[23700:8] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[23780:8] = INT_ZEXT register[8:4]
	3: unique[23800:8] = INT_LEFT unique[23780:8], const[20:4]
	4: unique[23880:8] = INT_ZEXT register[0:4]
	5: unique[23980:8] = INT_OR unique[23800:8], unique[23880:8]
	6: unique[23a80:8] = INT_DIV unique[23980:8], unique[23700:8]
	7: register[0:4] = SUBPIECE unique[23a80:8], const[0:4]
	8: MULTIEQUAL const[2:4]
	9: unique[23c00:8] = INT_REM unique[23980:8], unique[23700:8]
	10: register[8:4] = SUBPIECE unique[23c00:8], const[0:4]
	11: MULTIEQUAL const[1:4]

Line ia.sinc:2700 :IDIV rm16      is vexMode=0 & opsize=0 & byte=0xf7; rm16 & reg_opcode=7 ...    { rm16ext:4 = sext(rm16);
                                                  tmp:4 = (zext(DX) << 16) | zext(AX);   # DE exception if quotient doesn't fit in AX
                                                  local quotient = tmp s/ rm16ext;
                                                  AX = quotient:2;
                                                  local rem = tmp s% rm16ext;
                                                  DX = rem:2; }
0: Constructor line ia.sinc:2700(id0.181) printpiece=[IDIV,  ,  A]
Operands 0: rm16 : 1704  
Pattern id=181 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:F7:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[26c00:4] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[26c80:4] = INT_ZEXT register[8:2]
	3: unique[26d00:4] = INT_LEFT unique[26c80:4], const[10:4]
	4: unique[26d80:4] = INT_ZEXT register[0:2]
	5: unique[26e80:4] = INT_OR unique[26d00:4], unique[26d80:4]
	6: unique[26f80:4] = INT_SDIV unique[26e80:4], unique[26c00:4]
	7: register[0:2] = SUBPIECE unique[26f80:4], const[0:4]
	8: unique[27100:4] = INT_SREM unique[26e80:4], unique[26c00:4]
	9: register[8:2] = SUBPIECE unique[27100:4], const[0:4]

Line ia.sinc:2706 :IDIV rm32      is vexMode=0 & opsize=1 & byte=0xf7; rm32 & check_EAX_dest ... & check_EDX_dest ... & reg_opcode=7 ...    { rm32ext:8 = sext(rm32);
                                                  tmp:8 = (zext(EDX) << 32) | zext(EAX); # DE exception if quotient doesn't fit in EAX
                                                  local quotient = tmp s/ rm32ext;
                                                  EAX = quotient:4;
                                                  build check_EAX_dest;
                                                  local rem = tmp s% rm32ext;
                                                  EDX = rem:4; 
                                                  build check_EDX_dest; }
0: Constructor line ia.sinc:2706(id0.182) printpiece=[IDIV,  ,  A]
Operands 0: rm32 : 1705  1: check_EAX_dest : 1706  2: check_EDX_dest : 1707  
Pattern id=182 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:F7:[xx11][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[27280:8] = INT_SEXT [handle:space][[handle:offset]:[handle:size]]
	2: unique[27300:8] = INT_ZEXT register[8:4]
	3: unique[27380:8] = INT_LEFT unique[27300:8], const[20:4]
	4: unique[27400:8] = INT_ZEXT register[0:4]
	5: unique[27500:8] = INT_OR unique[27380:8], unique[27400:8]
	6: unique[27600:8] = INT_SDIV unique[27500:8], unique[27280:8]
	7: register[0:4] = SUBPIECE unique[27600:8], const[0:4]
	8: MULTIEQUAL const[1:4]
	9: unique[27780:8] = INT_SREM unique[27500:8], unique[27280:8]
	10: register[8:4] = SUBPIECE unique[27780:8], const[0:4]
	11: MULTIEQUAL const[2:4]

Line bmi1.sinc:34 :BEXTR Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_NONE) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf7; Reg32 ... & check_Reg32_dest ... & rm32
{
  sourceTmp:1 = vexVVVV_r32[0,8];
  lengthTmp:1 = vexVVVV_r32[8,8];

  Reg32 = (rm32 >> sourceTmp) & ((1 << lengthTmp) - 1);
  build check_Reg32_dest;

  ZF = (Reg32 == 0);
  OF = 0;
  CF = 0;
  # AF, SF, and PF are undefined
}
0: Constructor line bmi1.sinc:34(id0.2116) printpiece=[BEXTR,  ,  B, ,,  ,  D, ,,  ,  A]
Operands 0: vexVVVV_r32 : 7119  1: Reg32 : 7117  2: check_Reg32_dest : 7120  3: rm32 : 7118  
Pattern id=2116 pattern=cmb:(ctx:SS:X0:X[10xx]:[xx00][010x]:XX,ins:F7:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[cd800:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset+0]:1]
	3: unique[cd880:[handle:size]] = INT_LEFT const[1:[handle:size]], [handle:space][[handle:offset+10001]:1]
	4: unique[cd900:[handle:size]] = INT_SUB unique[cd880:[handle:size]], const[1:[handle:size]]
	5: [handle:space][[handle:offset]:[handle:size]] = INT_AND unique[cd800:[handle:size]], unique[cd900:[handle:size]]
	6: MULTIEQUAL const[2:4]
	7: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	8: register[20b:1] = COPY const[0:1]
	9: register[200:1] = COPY const[0:1]

Line avx.sinc:1011 :VMASKMOVDQU XmmReg1, XmmReg2 is $(VEX_NONE) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG); byte=0xF7; XmmReg1 & (mod=0x3 & XmmReg2)
{
	vmaskmovdqu_avx( XmmReg1, XmmReg2 );
	# TODO missing destination or side effects
}
0: Constructor line avx.sinc:1011(id0.1633) printpiece=[VMASKMOVDQU,  ,  B, ,,  ,  C]
Operands 0: rexWprefix : 4832  1: XmmReg1 : 4830  2: XmmReg2 : 4831  
Pattern id=1633 pattern=cmb:(ctx:SS:X[001x]:X8:0[001x]:XX,ins:F7:[11xx]X:XX:XX)
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[1:4]
	2: CALLOTHER const[130:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line bmi2.sinc:183 :SHLX Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_66) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf7; Reg32 ... & check_Reg32_dest ... & rm32
{
  Reg32 = rm32 << (vexVVVV_r32 & 0x0000001F);
  build check_Reg32_dest;
}
0: Constructor line bmi2.sinc:183(id0.2128) printpiece=[SHLX,  ,  B, ,,  ,  D, ,,  ,  A]
Operands 0: vexVVVV_r32 : 7162  1: Reg32 : 7160  2: check_Reg32_dest : 7163  3: rm32 : 7161  
Pattern id=2128 pattern=cmb:(ctx:SS:X2:X[10xx]:[xx00][010x]:XX,ins:F7:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d0080:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1f:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_LEFT [handle:space][[handle:offset]:[handle:size]], unique[d0080:[handle:size]]
	4: MULTIEQUAL const[2:4]

Line bmi2.sinc:169 :SARX Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F3) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf7; Reg32 ... & check_Reg32_dest ... & rm32
{
  Reg32 = rm32 s>> (vexVVVV_r32 & 0x0000001F);
  build check_Reg32_dest;
}
0: Constructor line bmi2.sinc:169(id0.2127) printpiece=[SARX,  ,  B, ,,  ,  D, ,,  ,  A]
Operands 0: vexVVVV_r32 : 7158  1: Reg32 : 7156  2: check_Reg32_dest : 7159  3: rm32 : 7157  
Pattern id=2127 pattern=cmb:(ctx:SS:X4:X[10xx]:[xx00][010x]:XX,ins:F7:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[cff80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1f:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_SRIGHT [handle:space][[handle:offset]:[handle:size]], unique[cff80:[handle:size]]
	4: MULTIEQUAL const[2:4]

Line bmi2.sinc:197 :SHRX Reg32, rm32, vexVVVV_r32 is $(VEX_NDS) & $(VEX_LZ) & $(VEX_PRE_F2) & $(VEX_0F38) & $(VEX_W0) & vexVVVV_r32; byte=0xf7; Reg32 ... & check_Reg32_dest ... & rm32
{
  Reg32 = rm32 >> (vexVVVV_r32 & 0x0000001F);
  build check_Reg32_dest;
}
0: Constructor line bmi2.sinc:197(id0.2129) printpiece=[SHRX,  ,  B, ,,  ,  D, ,,  ,  A]
Operands 0: vexVVVV_r32 : 7166  1: Reg32 : 7164  2: check_Reg32_dest : 7167  3: rm32 : 7165  
Pattern id=2129 pattern=cmb:(ctx:SS:X8:X[10xx]:[xx00][010x]:XX,ins:F7:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[1:4]
	2: unique[d0180:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[1f:[handle:size]]
	3: [handle:space][[handle:offset]:[handle:size]] = INT_RIGHT [handle:space][[handle:offset]:[handle:size]], unique[d0180:[handle:size]]
	4: MULTIEQUAL const[2:4]

Line ia.sinc:2170 :CLC			is vexMode=0 & byte=0xf8						{ CF = 0; }
0: Constructor line ia.sinc:2170(id0.124) printpiece=[CLC]
Operands 
Pattern id=124 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F8:XX:XX:XX)
Template
	0: register[200:1] = COPY const[0:1]

Line avx.sinc:2586 :VPSUBB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF8; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2586(id0.1815) printpiece=[VPSUBB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5750  1: vexVVVV_XmmReg : 5748  2: XmmReg1 : 5747  3: YmmReg1 : 5751  4: XmmReg2_m128 : 5749  
Pattern id=1815 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:F8:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b2c80:10] = CALLOTHER const[1ba:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b2c80:10]

Line avx2.sinc:765 :VPSUBB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF8; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:765(id0.2022) printpiece=[VPSUBB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6708  1: vexVVVV_YmmReg : 6706  2: YmmReg1 : 6705  3: YmmReg2_m256 : 6707  
Pattern id=2022 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:F8:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[250:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3764 :STC            is vexMode=0 & byte=0xf9                        { CF = 1; }
0: Constructor line ia.sinc:3764(id0.559) printpiece=[STC]
Operands 
Pattern id=559 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:F9:XX:XX:XX)
Template
	0: register[200:1] = COPY const[1:1]

Line avx.sinc:2595 :VPSUBW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xF9; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2595(id0.1816) printpiece=[VPSUBW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5756  1: vexVVVV_XmmReg : 5754  2: XmmReg1 : 5753  3: YmmReg1 : 5757  4: XmmReg2_m128 : 5755  
Pattern id=1816 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:F9:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b2e00:10] = CALLOTHER const[1bb:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b2e00:10]

Line avx2.sinc:773 :VPSUBW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xF9; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:773(id0.2023) printpiece=[VPSUBW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6713  1: vexVVVV_YmmReg : 6711  2: YmmReg1 : 6710  3: YmmReg2_m256 : 6712  
Pattern id=2023 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:F9:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[251:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2176 :CLI			is vexMode=0 & byte=0xfa						{ IF = 0; }
0: Constructor line ia.sinc:2176(id0.127) printpiece=[CLI]
Operands 
Pattern id=127 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:FA:XX:XX:XX)
Template
	0: register[209:1] = COPY const[0:1]

Line avx.sinc:2604 :VPSUBD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFA; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2604(id0.1817) printpiece=[VPSUBD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5762  1: vexVVVV_XmmReg : 5760  2: XmmReg1 : 5759  3: YmmReg1 : 5763  4: XmmReg2_m128 : 5761  
Pattern id=1817 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:FA:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b2f80:10] = CALLOTHER const[1bc:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b2f80:10]

Line avx2.sinc:781 :VPSUBD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFA; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:781(id0.2024) printpiece=[VPSUBD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6718  1: vexVVVV_YmmReg : 6716  2: YmmReg1 : 6715  3: YmmReg2_m256 : 6717  
Pattern id=2024 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:FA:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[252:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3770 :STI            is vexMode=0 & byte=0xfb                        { IF = 1; }
0: Constructor line ia.sinc:3770(id0.562) printpiece=[STI]
Operands 
Pattern id=562 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:FB:XX:XX:XX)
Template
	0: register[209:1] = COPY const[1:1]

Line avx.sinc:2613 :VPSUBQ XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFB; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpsubq_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:2613(id0.1818) printpiece=[VPSUBQ,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5768  1: vexVVVV_XmmReg : 5766  2: XmmReg1 : 5765  3: YmmReg1 : 5769  4: XmmReg2_m128 : 5767  
Pattern id=1818 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:FB:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[b3100:10] = CALLOTHER const[1bd:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[b3100:10]

Line avx2.sinc:789 :VPSUBQ YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFB; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpsubq_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:789(id0.2025) printpiece=[VPSUBQ,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6723  1: vexVVVV_YmmReg : 6721  2: YmmReg1 : 6720  3: YmmReg2_m256 : 6722  
Pattern id=2025 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:FB:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[253:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2171 :CLD			is vexMode=0 & byte=0xfc						{ DF = 0; }
0: Constructor line ia.sinc:2171(id0.125) printpiece=[CLD]
Operands 
Pattern id=125 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:FC:XX:XX:XX)
Template
	0: register[20a:1] = COPY const[0:1]

Line avx.sinc:1701 :VPADDB XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFC; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddb_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1701(id0.1715) printpiece=[VPADDB,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5198  1: vexVVVV_XmmReg : 5196  2: XmmReg1 : 5195  3: YmmReg1 : 5199  4: XmmReg2_m128 : 5197  
Pattern id=1715 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:FC:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[aaa80:10] = CALLOTHER const[15d:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aaa80:10]

Line avx2.sinc:79 :VPADDB YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFC; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddb_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:79(id0.1934) printpiece=[VPADDB,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6292  1: vexVVVV_YmmReg : 6290  2: YmmReg1 : 6289  3: YmmReg2_m256 : 6291  
Pattern id=1934 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:FC:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[200:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:3765 :STD            is vexMode=0 & byte=0xfd                        { DF = 1; }
0: Constructor line ia.sinc:3765(id0.560) printpiece=[STD]
Operands 
Pattern id=560 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:FD:XX:XX:XX)
Template
	0: register[20a:1] = COPY const[1:1]

Line avx.sinc:1710 :VPADDW XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFD; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddw_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1710(id0.1716) printpiece=[VPADDW,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5204  1: vexVVVV_XmmReg : 5202  2: XmmReg1 : 5201  3: YmmReg1 : 5205  4: XmmReg2_m128 : 5203  
Pattern id=1716 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:FD:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[aac00:10] = CALLOTHER const[15e:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aac00:10]

Line avx2.sinc:87 :VPADDW YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFD; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddw_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:87(id0.1935) printpiece=[VPADDW,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6297  1: vexVVVV_YmmReg : 6295  2: YmmReg1 : 6294  3: YmmReg2_m256 : 6296  
Pattern id=1935 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:FD:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[201:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2779 :INC  spec_rm8		is vexMode=0 & byte=0xfe;  spec_rm8 & reg_opcode=0 ...			{ OF = scarry(spec_rm8,1);   spec_rm8 =  spec_rm8 + 1; resultflags( spec_rm8); }
0: Constructor line ia.sinc:2779(id0.198) printpiece=[INC,  ,  A]
Operands 0: spec_rm8 : 1746  
Pattern id=198 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:FE:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	6: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2425 :DEC spec_rm8       is vexMode=0 & byte=0xfe; spec_rm8 & reg_opcode=1 ...         { OF = sborrow(spec_rm8,1);   spec_rm8 =  spec_rm8 - 1; resultflags( spec_rm8); }
0: Constructor line ia.sinc:2425(id0.162) printpiece=[DEC,  ,  A]
Operands 0: spec_rm8 : 1671  
Pattern id=162 pattern=cmb:(ctx:SS:SS:X[0xxx]:XX:XX:XX,ins:FE:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	6: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line avx.sinc:1719 :VPADDD XmmReg1, vexVVVV_XmmReg, XmmReg2_m128 is $(VEX_NDS) & $(VEX_L128) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_XmmReg; byte=0xFE; (XmmReg1 & YmmReg1) ... & XmmReg2_m128
{
	local tmp:16 = vpaddd_avx( vexVVVV_XmmReg, XmmReg2_m128 );
	YmmReg1 = zext(tmp);
	# TODO ZmmReg1 = zext(XmmReg1)
}
0: Constructor line avx.sinc:1719(id0.1717) printpiece=[VPADDD,  ,  C, ,,  ,  B, ,,  ,  E]
Operands 0: rexWprefix : 5210  1: vexVVVV_XmmReg : 5208  2: XmmReg1 : 5207  3: YmmReg1 : 5211  4: XmmReg2_m128 : 5209  
Pattern id=1717 pattern=cmb:(ctx:SS:X[001x]:X[10xx]:[xx00][001x]:XX,ins:FE:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[4:4]
	2: MULTIEQUAL const[2:4]
	3: unique[aad80:10] = CALLOTHER const[15f:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: [handle:space][[handle:offset]:[handle:size]] = INT_ZEXT unique[aad80:10]

Line avx2.sinc:95 :VPADDD YmmReg1, vexVVVV_YmmReg, YmmReg2_m256 is $(VEX_NDS) & $(VEX_L256) & $(VEX_PRE_66) & $(VEX_0F) & $(VEX_WIG) & vexVVVV_YmmReg; byte=0xFE; YmmReg1 ... & YmmReg2_m256
{
	YmmReg1 = vpaddd_avx2( vexVVVV_YmmReg, YmmReg2_m256 );
	# TODO ZmmReg1 = zext(YmmReg1)
}
0: Constructor line avx2.sinc:95(id0.1936) printpiece=[VPADDD,  ,  C, ,,  ,  B, ,,  ,  D]
Operands 0: rexWprefix : 6302  1: vexVVVV_YmmReg : 6300  2: YmmReg1 : 6299  3: YmmReg2_m256 : 6301  
Pattern id=1936 pattern=cmb:(ctx:SS:X[001x]:X[11xx]:[xx00][001x]:XX,ins:FE:XX:XX:XX)
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[2:4]
	2: [handle:space][[handle:offset]:[handle:size]] = CALLOTHER const[202:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2780 :INC spec_rm16		is vexMode=0 & opsize=0 & byte=0xff; spec_rm16 & reg_opcode=0 ...	{ OF = scarry(spec_rm16,1); spec_rm16 = spec_rm16 + 1; resultflags(spec_rm16); }
0: Constructor line ia.sinc:2780(id0.199) printpiece=[INC,  ,  A]
Operands 0: spec_rm16 : 1747  
Pattern id=199 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:FF:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	6: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2781 :INC spec_rm32		is vexMode=0 & opsize=1 & byte=0xff; spec_rm32 & check_rm32_dest ... & reg_opcode=0 ...	{ OF = scarry(spec_rm32,1); spec_rm32 = spec_rm32 + 1; build check_rm32_dest; resultflags(spec_rm32); }
0: Constructor line ia.sinc:2781(id0.200) printpiece=[INC,  ,  A]
Operands 0: spec_rm32 : 1748  1: check_rm32_dest : 1749  
Pattern id=200 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:FF:[xx00][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SCARRY [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: MULTIEQUAL const[1:4]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2426 :DEC spec_rm16      is vexMode=0 & opsize=0 & byte=0xff; spec_rm16 & reg_opcode=1 ... { OF = sborrow(spec_rm16,1); spec_rm16 = spec_rm16 - 1; resultflags(spec_rm16); }
0: Constructor line ia.sinc:2426(id0.163) printpiece=[DEC,  ,  A]
Operands 0: spec_rm16 : 1672  
Pattern id=163 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:FF:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	4: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	6: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	7: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	8: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2427 :DEC spec_rm32      is vexMode=0 & opsize=1 & byte=0xff; spec_rm32 & check_rm32_dest ... & reg_opcode=1 ... { OF = sborrow(spec_rm32,1); spec_rm32 = spec_rm32 - 1; build check_rm32_dest; resultflags(spec_rm32); }
0: Constructor line ia.sinc:2427(id0.164) printpiece=[DEC,  ,  A]
Operands 0: spec_rm32 : 1673  1: check_rm32_dest : 1674  
Pattern id=164 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:FF:[xx00][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: register[20b:1] = INT_SBORROW [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	2: [handle:space][[handle:offset]:[handle:size]] = INT_SUB [handle:space][[handle:offset]:[handle:size]], const[1:[handle:size]]
	3: MULTIEQUAL const[1:4]
	4: register[207:1] = INT_SLESS [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	5: register[206:1] = INT_EQUAL [handle:space][[handle:offset]:[handle:size]], const[0:[handle:size]]
	6: unique[dc80:[handle:size]] = INT_AND [handle:space][[handle:offset]:[handle:size]], const[ff:[handle:size]]
	7: unique[dd00:1] = POPCOUNT unique[dc80:[handle:size]]
	8: unique[dd80:1] = INT_AND unique[dd00:1], const[1:1]
	9: register[202:1] = INT_EQUAL unique[dd80:1], const[0:1]

Line ia.sinc:2118 :CALL rm16	    is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xff & currentCS; rm16 & reg_opcode=2 ...	{ local dest:4 = segment(currentCS,rm16); push22(&:2 inst_next); call [dest]; }
0: Constructor line ia.sinc:2118(id0.106) printpiece=[CALL,  ,  B]
Operands 0: currentCS : 1571  1: rm16 : 1570  
Pattern id=106 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:FF:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[1d300:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[9400:2] = COPY const[[next]:2]
	4: register[10:2] = INT_SUB register[10:2], const[2:2]
	5: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	6: STORE const[ram:8], unique[9580:4], unique[9400:2]
	7: CALLIND unique[1d300:4]

Line ia.sinc:2124 :CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   { local dest:4 = rm32; push24(&:4 inst_next); call [dest]; }
0: Constructor line ia.sinc:2124(id0.108) printpiece=[CALL,  ,  A]
Operands 0: rm32 : 1573  
Pattern id=108 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:FF:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1d400:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[9600:4] = COPY const[[next]:4]
	3: register[10:2] = INT_SUB register[10:2], const[4:2]
	4: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: STORE const[ram:8], unique[9780:4], unique[9600:4]
	6: CALLIND unique[1d400:4]

Line ia.sinc:2119 :CALL rm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...   { local dest:2 = rm16; push42(&:2 inst_next); call [dest]; }
0: Constructor line ia.sinc:2119(id0.107) printpiece=[CALL,  ,  A]
Operands 0: rm16 : 1572  
Pattern id=107 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:FF:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1d380:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[2:4]
	3: STORE const[ram:8], register[10:4], const[[next]:2]
	4: CALLIND unique[1d380:2]

Line ia.sinc:2125 :CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   { local dest:4 = rm32; push44(&:4 inst_next); call [dest]; }
0: Constructor line ia.sinc:2125(id0.109) printpiece=[CALL,  ,  A]
Operands 0: rm32 : 1574  
Pattern id=109 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:FF:[xx01][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1d480:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], const[[next]:4]
	4: CALLIND unique[1d480:4]

Line ia.sinc:2135 :CALLF addr16       is vexMode=0 & addrsize=0 & opsize=0 & byte=0xff; addr16 & reg_opcode=3 ... { local ptr:$(SIZE) = segment(DS,addr16); local addrptr:$(SIZE) = segment(*:2 (ptr+2),*:2 ptr);
                                                                                                  push22(CS); push22(&:2 inst_next); call [addrptr]; }
0: Constructor line ia.sinc:2135(id0.114) printpiece=[CALLF,  ,  A]
Operands 0: addr16 : 1579  
Pattern id=114 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:FF:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1d580:4] = CALLOTHER const[0:4], register[106:2], [handle:space][[handle:offset]:[handle:size]]
	2: unique[1d600:4] = INT_ADD unique[1d580:4], const[2:4]
	3: unique[1d680:2] = LOAD const[ram:8], unique[1d600:4]
	4: unique[1d700:2] = LOAD const[ram:8], unique[1d580:4]
	5: unique[1d800:4] = CALLOTHER const[0:4], unique[1d680:2], unique[1d700:2]
	6: unique[9400:2] = COPY register[102:2]
	7: register[10:2] = INT_SUB register[10:2], const[2:2]
	8: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	9: STORE const[ram:8], unique[9580:4], unique[9400:2]
	10: unique[9400:2] = COPY const[[next]:2]
	11: register[10:2] = INT_SUB register[10:2], const[2:2]
	12: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	13: STORE const[ram:8], unique[9580:4], unique[9400:2]
	14: CALLIND unique[1d800:4]

Line ia.sinc:2143 :CALLF addr16       is vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; addr16 & reg_opcode=3 ... { local dest:2 = addr16; push22(CS); push24(&:4 inst_next); call [dest]; }
0: Constructor line ia.sinc:2143(id0.116) printpiece=[CALLF,  ,  A]
Operands 0: addr16 : 1581  
Pattern id=116 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:FF:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1d900:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[9400:2] = COPY register[102:2]
	3: register[10:2] = INT_SUB register[10:2], const[2:2]
	4: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	5: STORE const[ram:8], unique[9580:4], unique[9400:2]
	6: unique[9600:4] = COPY const[[next]:4]
	7: register[10:2] = INT_SUB register[10:2], const[4:2]
	8: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	9: STORE const[ram:8], unique[9780:4], unique[9600:4]
	10: CALLIND unique[1d900:2]

Line ia.sinc:2137 :CALLF addr32       is vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; push42(CS); push42(&:2 inst_next); call [dest]; }
0: Constructor line ia.sinc:2137(id0.115) printpiece=[CALLF,  ,  A]
Operands 0: addr32 : 1580  
Pattern id=115 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:FF:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1d880:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: unique[9a00:2] = COPY register[102:2]
	3: register[10:4] = INT_SUB register[10:4], const[2:4]
	4: STORE const[ram:8], register[10:4], unique[9a00:2]
	5: unique[9a00:2] = COPY const[[next]:2]
	6: register[10:4] = INT_SUB register[10:4], const[2:4]
	7: STORE const[ram:8], register[10:4], unique[9a00:2]
	8: CALLIND unique[1d880:4]

Line ia.sinc:2144 :CALLF addr32       is vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; push42(CS); push44(&:4 inst_next); call [dest]; }
0: Constructor line ia.sinc:2144(id0.117) printpiece=[CALLF,  ,  A]
Operands 0: addr32 : 1582  
Pattern id=117 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:FF:[xx01][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1d980:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[2:4]
	3: STORE const[ram:8], register[10:4], register[102:2]
	4: register[10:4] = INT_SUB register[10:4], const[4:4]
	5: STORE const[ram:8], register[10:4], const[[next]:4]
	6: CALLIND unique[1d980:4]

Line ia.sinc:2852 :JMP rm16	is vexMode=0 & addrsize=0 & opsize=0 & byte=0xff & currentCS; rm16 & reg_opcode=4 ...	{ target:4 = segment(currentCS,rm16); goto [target]; }
0: Constructor line ia.sinc:2852(id0.230) printpiece=[JMP,  ,  B]
Operands 0: currentCS : 1787  1: rm16 : 1786  
Pattern id=230 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:FF:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2ac00:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: BRANCHIND unique[2ac00:4]

Line ia.sinc:2853 :JMP rm16	is vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=4 ...	{ goto [rm16]; }
0: Constructor line ia.sinc:2853(id0.231) printpiece=[JMP,  ,  A]
Operands 0: rm16 : 1788  
Pattern id=231 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:FF:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: BRANCHIND [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2854 :JMP rm32       is vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=4 ...    { goto [rm32]; }
0: Constructor line ia.sinc:2854(id0.232) printpiece=[JMP,  ,  A]
Operands 0: rm32 : 1789  
Pattern id=232 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:FF:[xx10][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: BRANCHIND [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:2861 :JMPF Mem       is vexMode=0 & opsize=0 & byte=0xff; Mem & reg_opcode=5 ...     { target:$(SIZE) = zext(*:2 Mem); goto [target]; }
0: Constructor line ia.sinc:2861(id0.235) printpiece=[JMPF,  ,  A]
Operands 0: Mem : 1792  
Pattern id=235 pattern=cmb:(ctx:X[xx00]:XX:X[0xxx]:XX,ins:FF:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2ac80:2] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: unique[2ad80:4] = INT_ZEXT unique[2ac80:2]
	3: BRANCHIND unique[2ad80:4]

Line ia.sinc:2862 :JMPF Mem       is vexMode=0 & opsize=1 & byte=0xff; Mem & reg_opcode=5 ...     {
@ifdef IA64
    target:$(SIZE) = zext(*:4 Mem);
@else
    target:$(SIZE) = *:4 Mem;
@endif
    goto [target];
}
0: Constructor line ia.sinc:2862(id0.236) printpiece=[JMPF,  ,  A]
Operands 0: Mem : 1793  
Pattern id=236 pattern=cmb:(ctx:X[xx01]:XX:X[0xxx]:XX,ins:FF:[xx10][1xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2ae80:4] = LOAD const[ram:8], [handle:space][[handle:offset]:[handle:size]]
	2: BRANCHIND unique[2ae80:4]

Line ia.sinc:3333 :PUSH rm16      is vexMode=0 & addrsize=0 & opsize=0 & byte=0xff; rm16 & reg_opcode=6 ... { push22(rm16); }
0: Constructor line ia.sinc:3333(id0.400) printpiece=[PUSH,  ,  A]
Operands 0: rm16 : 2078  
Pattern id=400 pattern=cmb:(ctx:X[x000]:XX:X[0xxx]:XX,ins:FF:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9400:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:2] = INT_SUB register[10:2], const[2:2]
	3: unique[9580:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9580:4], unique[9400:2]

Line ia.sinc:3335 :PUSH rm32      is vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; rm32 & reg_opcode=6 ... { push24(rm32); }
0: Constructor line ia.sinc:3335(id0.402) printpiece=[PUSH,  ,  A]
Operands 0: rm32 : 2080  
Pattern id=402 pattern=cmb:(ctx:X[x001]:XX:X[0xxx]:XX,ins:FF:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9600:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:2] = INT_SUB register[10:2], const[4:2]
	3: unique[9780:4] = CALLOTHER const[0:4], register[104:2], register[10:2]
	4: STORE const[ram:8], unique[9780:4], unique[9600:4]

Line ia.sinc:3334 :PUSH rm16      is vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=6 ... { push42(rm16); }
0: Constructor line ia.sinc:3334(id0.401) printpiece=[PUSH,  ,  A]
Operands 0: rm16 : 2079  
Pattern id=401 pattern=cmb:(ctx:X[x100]:XX:X[0xxx]:XX,ins:FF:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9a00:2] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[2:4]
	3: STORE const[ram:8], register[10:4], unique[9a00:2]

Line ia.sinc:3336 :PUSH rm32      is vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=6 ... { push44(rm32); }
0: Constructor line ia.sinc:3336(id0.403) printpiece=[PUSH,  ,  A]
Operands 0: rm32 : 2081  
Pattern id=403 pattern=cmb:(ctx:X[x101]:XX:X[0xxx]:XX,ins:FF:[xx11][0xxx]:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[9b00:4] = COPY [handle:space][[handle:offset]:[handle:size]]
	2: register[10:4] = INT_SUB register[10:4], const[4:4]
	3: STORE const[ram:8], register[10:4], unique[9b00:4]

Line ia.sinc:622 Reg8:   reg8        is reg8                              { export reg8; }
0: Constructor line ia.sinc:622(id968.0) printpiece=[ A]
Operands 0: reg8 : 969  
Pattern id=0 pattern=always
Template

Line ia.sinc:623 Reg16:  reg16       is reg16                             { export reg16; }
0: Constructor line ia.sinc:623(id970.0) printpiece=[ A]
Operands 0: reg16 : 971  
Pattern id=0 pattern=always
Template

Line ia.sinc:624 Reg32:  reg32       is reg32                             { export reg32; }
0: Constructor line ia.sinc:624(id972.0) printpiece=[ A]
Operands 0: reg32 : 973  
Pattern id=0 pattern=always
Template

Line ia.sinc:625 Rmr8:   r8          is r8                                { export r8; }
0: Constructor line ia.sinc:625(id974.0) printpiece=[ A]
Operands 0: r8 : 975  
Pattern id=0 pattern=always
Template

Line ia.sinc:626 CRmr8:  r8          is r8                                { export r8; }
0: Constructor line ia.sinc:626(id976.0) printpiece=[ A]
Operands 0: r8 : 977  
Pattern id=0 pattern=always
Template

Line ia.sinc:627 Rmr16:  r16         is r16                               { export r16; }
0: Constructor line ia.sinc:627(id978.0) printpiece=[ A]
Operands 0: r16 : 979  
Pattern id=0 pattern=always
Template

Line ia.sinc:628 CRmr16: r16         is r16                               { export r16; }
0: Constructor line ia.sinc:628(id980.0) printpiece=[ A]
Operands 0: r16 : 981  
Pattern id=0 pattern=always
Template

Line ia.sinc:629 Rmr32:  r32         is r32                               { export r32; }
0: Constructor line ia.sinc:629(id982.0) printpiece=[ A]
Operands 0: r32 : 983  
Pattern id=0 pattern=always
Template

Line ia.sinc:630 CRmr32: r32         is r32                               { export r32; }
0: Constructor line ia.sinc:630(id984.0) printpiece=[ A]
Operands 0: r32 : 985  
Pattern id=0 pattern=always
Template

Line ia.sinc:631 Base:   base        is base                              { export base; }
0: Constructor line ia.sinc:631(id986.0) printpiece=[ A]
Operands 0: base : 987  
Pattern id=0 pattern=always
Template

Line ia.sinc:632 Index:  index       is index                             { export index; }
0: Constructor line ia.sinc:632(id988.0) printpiece=[ A]
Operands 0: index : 989  
Pattern id=0 pattern=always
Template

Line ia.sinc:633 XmmReg:   xmmreg    is xmmreg                            { export xmmreg; }
0: Constructor line ia.sinc:633(id990.0) printpiece=[ A]
Operands 0: xmmreg : 991  
Pattern id=0 pattern=always
Template

Line ia.sinc:634 XmmReg1:  xmmreg1   is xmmreg1                           { export xmmreg1; }
0: Constructor line ia.sinc:634(id992.0) printpiece=[ A]
Operands 0: xmmreg1 : 993  
Pattern id=0 pattern=always
Template

Line ia.sinc:635 XmmReg2:  xmmreg2   is xmmreg2                           { export xmmreg2; }
0: Constructor line ia.sinc:635(id994.0) printpiece=[ A]
Operands 0: xmmreg2 : 995  
Pattern id=0 pattern=always
Template

Line ia.sinc:636 YmmReg1:  ymmreg1   is ymmreg1                           { export ymmreg1; }
0: Constructor line ia.sinc:636(id996.0) printpiece=[ A]
Operands 0: ymmreg1 : 997  
Pattern id=0 pattern=always
Template

Line ia.sinc:637 YmmReg2:  ymmreg2   is ymmreg2                           { export ymmreg2; }
0: Constructor line ia.sinc:637(id998.0) printpiece=[ A]
Operands 0: ymmreg2 : 999  
Pattern id=0 pattern=always
Template

Line ia.sinc:638 Xmm_vsib:  xmm_vsib       is xmm_vsib                    { export xmm_vsib; }
0: Constructor line ia.sinc:638(id1000.0) printpiece=[ A]
Operands 0: xmm_vsib : 1001  
Pattern id=0 pattern=always
Template

Line ia.sinc:639 Ymm_vsib:  ymm_vsib       is ymm_vsib                    { export ymm_vsib; }
0: Constructor line ia.sinc:639(id1002.0) printpiece=[ A]
Operands 0: ymm_vsib : 1003  
Pattern id=0 pattern=always
Template

Line ia.sinc:644 simm8_16: simm8 is simm8 { export *[const]:2 simm8; }
0: Constructor line ia.sinc:644(id1004.0) printpiece=[ A]
Operands 0: simm8 : 1005  
Pattern id=0 pattern=always
Template

Line ia.sinc:645 simm8_32: simm8 is simm8 { export *[const]:4 simm8; }
0: Constructor line ia.sinc:645(id1006.0) printpiece=[ A]
Operands 0: simm8 : 1007  
Pattern id=0 pattern=always
Template

Line ia.sinc:649 simm16_16: simm16 is simm16 { export *[const]:2 simm16; }
0: Constructor line ia.sinc:649(id1008.0) printpiece=[ A]
Operands 0: simm16 : 1009  
Pattern id=0 pattern=always
Template

Line ia.sinc:650 simm32_32: simm32 is simm32 { export *[const]:4 simm32; }
0: Constructor line ia.sinc:650(id1010.0) printpiece=[ A]
Operands 0: simm32 : 1011  
Pattern id=0 pattern=always
Template

Line ia.sinc:656 usimm8_16: imm8 is imm8 & imm8_7=0 { export *[const]:2 imm8; }
0: Constructor line ia.sinc:656(id1012.0) printpiece=[ A]
Operands 0: imm8 : 1013  
Pattern id=0 pattern=ins:[0xxx]X:XX:XX:XX
Template

Line ia.sinc:657 usimm8_16: val is imm8 & imm8_7=1 [ val = 0xff00 | imm8; ] { export *[const]:2 val; }
0: Constructor line ia.sinc:657(id1012.1) printpiece=[ B]
Operands 0: imm8 : 1015  1: val : 1014  
Pattern id=1 pattern=ins:[1xxx]X:XX:XX:XX
Template

Line ia.sinc:658 usimm8_32: imm8 is imm8 & imm8_7=0 { export *[const]:4 imm8; }
0: Constructor line ia.sinc:658(id1016.0) printpiece=[ A]
Operands 0: imm8 : 1017  
Pattern id=0 pattern=ins:[0xxx]X:XX:XX:XX
Template

Line ia.sinc:659 usimm8_32: val is imm8 & imm8_7=1 [ val = 0xffffff00 | imm8; ] { export *[const]:4 val; }
0: Constructor line ia.sinc:659(id1016.1) printpiece=[ B]
Operands 0: imm8 : 1019  1: val : 1018  
Pattern id=1 pattern=ins:[1xxx]X:XX:XX:XX
Template

Line ia.sinc:673 addr16: [BX + SI]		is mod=0 & r_m=0 & BX & SI		{ local tmp=BX+SI; export tmp; }
0: Constructor line ia.sinc:673(id1020.0) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: BX : 1021  1: SI : 1022  
Pattern id=0 pattern=ins:[00xx][x000]:XX:XX:XX
Template
	0: unique[480:2] = INT_ADD register[c:2], register[18:2]

Line ia.sinc:681 addr16: [BX + SI + simm8_16]   is mod=1 & r_m=0 & BX & SI; simm8_16   { local tmp=BX+SI+simm8_16; export tmp; }
0: Constructor line ia.sinc:681(id1020.8) printpiece=[[,  A,  , +,  ,  B,  , +,  ,  C, ]]
Operands 0: BX : 1033  1: SI : 1034  2: simm8_16 : 1035  
Pattern id=8 pattern=ins:[01xx][x000]:XX:XX:XX
Template
	0: MULTIEQUAL const[2:4]
	1: unique[880:2] = INT_ADD register[c:2], register[18:2]
	2: unique[980:2] = INT_ADD unique[880:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:689 addr16: [BX + SI + imm16]   is mod=2 & r_m=0 & BX & SI; imm16   { local tmp=BX+SI+imm16; export tmp; }
0: Constructor line ia.sinc:689(id1020.16) printpiece=[[,  A,  , +,  ,  B,  , +,  ,  C, ]]
Operands 0: BX : 1053  1: SI : 1054  2: imm16 : 1055  
Pattern id=16 pattern=ins:[10xx][x000]:XX:XX:XX
Template
	0: unique[1280:2] = INT_ADD register[c:2], register[18:2]
	1: unique[1380:2] = INT_ADD unique[1280:2], [handle:space][[handle:offset]:2]

Line ia.sinc:674 addr16: [BX + DI]		is mod=0 & r_m=1 & BX & DI		{ local tmp=BX+DI; export tmp; }
0: Constructor line ia.sinc:674(id1020.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: BX : 1023  1: DI : 1024  
Pattern id=1 pattern=ins:[00xx][x001]:XX:XX:XX
Template
	0: unique[580:2] = INT_ADD register[c:2], register[1c:2]

Line ia.sinc:682 addr16: [BX + DI + simm8_16]   is mod=1 & r_m=1 & BX & DI; simm8_16   { local tmp=BX+DI+simm8_16; export tmp; }
0: Constructor line ia.sinc:682(id1020.9) printpiece=[[,  A,  , +,  ,  B,  , +,  ,  C, ]]
Operands 0: BX : 1036  1: DI : 1037  2: simm8_16 : 1038  
Pattern id=9 pattern=ins:[01xx][x001]:XX:XX:XX
Template
	0: MULTIEQUAL const[2:4]
	1: unique[a00:2] = INT_ADD register[c:2], register[1c:2]
	2: unique[b00:2] = INT_ADD unique[a00:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:690 addr16: [BX + DI + imm16]   is mod=2 & r_m=1 & BX & DI; imm16   { local tmp=BX+DI+imm16; export tmp; }
0: Constructor line ia.sinc:690(id1020.17) printpiece=[[,  A,  , +,  ,  B,  , +,  ,  C, ]]
Operands 0: BX : 1056  1: DI : 1057  2: imm16 : 1058  
Pattern id=17 pattern=ins:[10xx][x001]:XX:XX:XX
Template
	0: unique[1400:2] = INT_ADD register[c:2], register[1c:2]
	1: unique[1500:2] = INT_ADD unique[1400:2], [handle:space][[handle:offset]:2]

Line ia.sinc:675 addr16: [BP + SI]		is mod=0 & r_m=2 & BP & SI		{ local tmp=BP+SI; export tmp; }
0: Constructor line ia.sinc:675(id1020.2) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: BP : 1025  1: SI : 1026  
Pattern id=2 pattern=ins:[00xx][x010]:XX:XX:XX
Template
	0: unique[680:2] = INT_ADD register[14:2], register[18:2]

Line ia.sinc:683 addr16: [BP + SI + simm8_16]   is mod=1 & r_m=2 & BP & SI; simm8_16   { local tmp=BP+SI+simm8_16; export tmp; }
0: Constructor line ia.sinc:683(id1020.10) printpiece=[[,  A,  , +,  ,  B,  , +,  ,  C, ]]
Operands 0: BP : 1039  1: SI : 1040  2: simm8_16 : 1041  
Pattern id=10 pattern=ins:[01xx][x010]:XX:XX:XX
Template
	0: MULTIEQUAL const[2:4]
	1: unique[b80:2] = INT_ADD register[14:2], register[18:2]
	2: unique[c80:2] = INT_ADD unique[b80:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:691 addr16: [BP + SI + imm16]   is mod=2 & r_m=2 & BP & SI; imm16   { local tmp=BP+SI+imm16; export tmp; }
0: Constructor line ia.sinc:691(id1020.18) printpiece=[[,  A,  , +,  ,  B,  , +,  ,  C, ]]
Operands 0: BP : 1059  1: SI : 1060  2: imm16 : 1061  
Pattern id=18 pattern=ins:[10xx][x010]:XX:XX:XX
Template
	0: unique[1580:2] = INT_ADD register[14:2], register[18:2]
	1: unique[1680:2] = INT_ADD unique[1580:2], [handle:space][[handle:offset]:2]

Line ia.sinc:676 addr16: [BP + DI]		is mod=0 & r_m=3 & BP & DI		{ local tmp=BP+DI; export tmp; }
0: Constructor line ia.sinc:676(id1020.3) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: BP : 1027  1: DI : 1028  
Pattern id=3 pattern=ins:[00xx][x011]:XX:XX:XX
Template
	0: unique[780:2] = INT_ADD register[14:2], register[1c:2]

Line ia.sinc:684 addr16: [BP + DI + simm8_16]   is mod=1 & r_m=3 & BP & DI; simm8_16   { local tmp=BP+DI+simm8_16; export tmp; }
0: Constructor line ia.sinc:684(id1020.11) printpiece=[[,  A,  , +,  ,  B,  , +,  ,  C, ]]
Operands 0: BP : 1042  1: DI : 1043  2: simm8_16 : 1044  
Pattern id=11 pattern=ins:[01xx][x011]:XX:XX:XX
Template
	0: MULTIEQUAL const[2:4]
	1: unique[d00:2] = INT_ADD register[14:2], register[1c:2]
	2: unique[e00:2] = INT_ADD unique[d00:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:692 addr16: [BP + DI + imm16]   is mod=2 & r_m=3 & BP & DI; imm16   {local tmp=BP+DI+imm16; export tmp; }
0: Constructor line ia.sinc:692(id1020.19) printpiece=[[,  A,  , +,  ,  B,  , +,  ,  C, ]]
Operands 0: BP : 1062  1: DI : 1063  2: imm16 : 1064  
Pattern id=19 pattern=ins:[10xx][x011]:XX:XX:XX
Template
	0: unique[1700:2] = INT_ADD register[14:2], register[1c:2]
	1: unique[1800:2] = INT_ADD unique[1700:2], [handle:space][[handle:offset]:2]

Line ia.sinc:677 addr16: [SI]		is mod=0 & r_m=4 & SI			{ export SI; }
0: Constructor line ia.sinc:677(id1020.4) printpiece=[[,  A, ]]
Operands 0: SI : 1029  
Pattern id=4 pattern=ins:[00xx][x100]:XX:XX:XX
Template

Line ia.sinc:685 addr16: [SI + simm8_16]  is mod=1 & r_m=4 & SI; simm8_16        { local tmp=SI+simm8_16; export tmp; }
0: Constructor line ia.sinc:685(id1020.12) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: SI : 1045  1: simm8_16 : 1046  
Pattern id=12 pattern=ins:[01xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: unique[f00:2] = INT_ADD register[18:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:693 addr16: [SI + imm16]  is mod=2 & r_m=4 & SI; imm16        { local tmp=SI+imm16; export tmp; }
0: Constructor line ia.sinc:693(id1020.20) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: SI : 1065  1: imm16 : 1066  
Pattern id=20 pattern=ins:[10xx][x100]:XX:XX:XX
Template
	0: unique[1900:2] = INT_ADD register[18:2], [handle:space][[handle:offset]:2]

Line ia.sinc:678 addr16: [DI]		is mod=0 & r_m=5 & DI			{ export DI; }
0: Constructor line ia.sinc:678(id1020.5) printpiece=[[,  A, ]]
Operands 0: DI : 1030  
Pattern id=5 pattern=ins:[00xx][x101]:XX:XX:XX
Template

Line ia.sinc:686 addr16: [DI + simm8_16]  is mod=1 & r_m=5 & DI; simm8_16        { local tmp=DI+simm8_16; export tmp; }
0: Constructor line ia.sinc:686(id1020.13) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: DI : 1047  1: simm8_16 : 1048  
Pattern id=13 pattern=ins:[01xx][x101]:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: unique[1000:2] = INT_ADD register[1c:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:694 addr16: [DI + imm16]  is mod=2 & r_m=5 & DI; imm16        { local tmp=DI+imm16; export tmp; }
0: Constructor line ia.sinc:694(id1020.21) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: DI : 1067  1: imm16 : 1068  
Pattern id=21 pattern=ins:[10xx][x101]:XX:XX:XX
Template
	0: unique[1a00:2] = INT_ADD register[1c:2], [handle:space][[handle:offset]:2]

Line ia.sinc:679 addr16: [imm16]		is mod=0 & r_m=6; imm16			{ export *[const]:2 imm16; }
0: Constructor line ia.sinc:679(id1020.6) printpiece=[[,  A, ]]
Operands 0: imm16 : 1031  
Pattern id=6 pattern=ins:[00xx][x110]:XX:XX:XX
Template

Line ia.sinc:687 addr16: [BP + simm8_16]  is mod=1 & r_m=6 & BP; simm8_16        { local tmp=BP+simm8_16; export tmp; }
0: Constructor line ia.sinc:687(id1020.14) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: BP : 1049  1: simm8_16 : 1050  
Pattern id=14 pattern=ins:[01xx][x110]:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: unique[1100:2] = INT_ADD register[14:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:695 addr16: [BP + imm16]  is mod=2 & r_m=6 & BP; imm16        { local tmp=BP+imm16; export tmp; }
0: Constructor line ia.sinc:695(id1020.22) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: BP : 1069  1: imm16 : 1070  
Pattern id=22 pattern=ins:[10xx][x110]:XX:XX:XX
Template
	0: unique[1b00:2] = INT_ADD register[14:2], [handle:space][[handle:offset]:2]

Line ia.sinc:680 addr16: [BX]		is mod=0 & r_m=7 & BX			{ export BX; }
0: Constructor line ia.sinc:680(id1020.7) printpiece=[[,  A, ]]
Operands 0: BX : 1032  
Pattern id=7 pattern=ins:[00xx][x111]:XX:XX:XX
Template

Line ia.sinc:688 addr16: [BX + simm8_16]  is mod=1 & r_m=7 & BX; simm8_16        { local tmp=BX+simm8_16; export tmp; }
0: Constructor line ia.sinc:688(id1020.15) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: BX : 1051  1: simm8_16 : 1052  
Pattern id=15 pattern=ins:[01xx][x111]:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: unique[1200:2] = INT_ADD register[c:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:696 addr16: [BX + imm16]  is mod=2 & r_m=7 & BX; imm16        { local tmp=BX+imm16; export tmp; }
0: Constructor line ia.sinc:696(id1020.23) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: BX : 1071  1: imm16 : 1072  
Pattern id=23 pattern=ins:[10xx][x111]:XX:XX:XX
Template
	0: unique[1c00:2] = INT_ADD register[c:2], [handle:space][[handle:offset]:2]

Line ia.sinc:708 addr32: [imm32]							is mod=0 & r_m=4; index=4 & base=5; imm32    { export *[const]:4 imm32; }
0: Constructor line ia.sinc:708(id1073.9) printpiece=[[,  A, ]]
Operands 0: imm32 : 1089  
Pattern id=9 pattern=ins:[00xx][x100]:[xx10]5:XX:XX
Template

Line ia.sinc:706 addr32: [Base]							is mod=0 & r_m=4; index=4 & Base             { export Base; }
1: Constructor line ia.sinc:706(id1073.7) printpiece=[[,  A, ]]
Operands 0: Base : 1085  
Pattern id=7 pattern=ins:[00xx][x100]:[xx10][0xxx]:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:707 addr32: [Index*ss + imm32]				is mod=0 & r_m=4; Index & base=5 & ss; imm32 { local tmp=imm32+Index*ss; export tmp; }
2: Constructor line ia.sinc:707(id1073.8) printpiece=[[,  A, *,  B,  , +,  ,  C, ]]
Operands 0: Index : 1086  1: ss : 1087  2: imm32 : 1088  
Pattern id=8 pattern=ins:[00xx][x100]:X[x101]:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2080:[handle:size]] = INT_MULT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	2: unique[2180:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[2080:[handle:size]]

Line ia.sinc:705 addr32: [Base + Index*ss]				is mod=0 & r_m=4; Index & Base & ss          { local tmp=Base+Index*ss; export tmp; }
3: Constructor line ia.sinc:705(id1073.6) printpiece=[[,  B,  , +,  ,  A, *,  C, ]]
Operands 0: Index : 1083  1: Base : 1082  2: ss : 1084  
Pattern id=6 pattern=ins:[00xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[1f00:[handle:size]] = INT_MULT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[2000:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[1f00:[handle:size]]

Line ia.sinc:699 addr32: [Rmr32]							is mod=0 & Rmr32  							 { export Rmr32; }
4: Constructor line ia.sinc:699(id1073.0) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1074  
Pattern id=0 pattern=ins:[00xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:704 addr32: [imm32]							is mod=0 & r_m=5; imm32                      { export *[const]:4 imm32; }
0: Constructor line ia.sinc:704(id1073.5) printpiece=[[,  A, ]]
Operands 0: imm32 : 1081  
Pattern id=5 pattern=ins:[00xx][x101]:XX:XX:XX
Template

Line ia.sinc:699 addr32: [Rmr32]							is mod=0 & Rmr32  							 { export Rmr32; }
1: Constructor line ia.sinc:699(id1073.0) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1074  
Pattern id=0 pattern=ins:[00xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:701 addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0			 { export Rmr32; }
0: Constructor line ia.sinc:701(id1073.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1077  
Pattern id=2 pattern=ins:[01xx][x000]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:700 addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32       			 { local tmp=Rmr32+simm8_32; export tmp; }
1: Constructor line ia.sinc:700(id1073.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1075  1: simm8_32 : 1076  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1d00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:701 addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0			 { export Rmr32; }
0: Constructor line ia.sinc:701(id1073.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1077  
Pattern id=2 pattern=ins:[01xx][x001]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:700 addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32       			 { local tmp=Rmr32+simm8_32; export tmp; }
1: Constructor line ia.sinc:700(id1073.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1075  1: simm8_32 : 1076  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1d00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:701 addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0			 { export Rmr32; }
0: Constructor line ia.sinc:701(id1073.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1077  
Pattern id=2 pattern=ins:[01xx][x010]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:700 addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32       			 { local tmp=Rmr32+simm8_32; export tmp; }
1: Constructor line ia.sinc:700(id1073.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1075  1: simm8_32 : 1076  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1d00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:701 addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0			 { export Rmr32; }
0: Constructor line ia.sinc:701(id1073.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1077  
Pattern id=2 pattern=ins:[01xx][x011]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:700 addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32       			 { local tmp=Rmr32+simm8_32; export tmp; }
1: Constructor line ia.sinc:700(id1073.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1075  1: simm8_32 : 1076  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1d00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:712 addr32: [Base]							is mod=1 & r_m=4; index=4 & Base; simm8=0    { export Base; }
0: Constructor line ia.sinc:712(id1073.13) printpiece=[[,  A, ]]
Operands 0: Base : 1099  
Pattern id=13 pattern=ins:[01xx][x100]:[xx10][0xxx]:00:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:710 addr32: [Base + simm8_32]				is mod=1 & r_m=4; index=4 & Base; simm8_32   { local tmp=simm8_32+Base; export tmp; }
1: Constructor line ia.sinc:710(id1073.11) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Base : 1094  1: simm8_32 : 1095  
Pattern id=11 pattern=ins:[01xx][x100]:[xx10][0xxx]:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[2500:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:711 addr32: [Base + Index*ss]				is mod=1 & r_m=4; Index & Base & ss; simm8=0 { local tmp=Base+Index*ss; export tmp; }
2: Constructor line ia.sinc:711(id1073.12) printpiece=[[,  B,  , +,  ,  A, *,  C, ]]
Operands 0: Index : 1097  1: Base : 1096  2: ss : 1098  
Pattern id=12 pattern=ins:[01xx][x100]:XX:00:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2580:[handle:size]] = INT_MULT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[2680:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[2580:[handle:size]]

Line ia.sinc:709 addr32: [Base + Index*ss + simm8_32]	is mod=1 & r_m=4; Index & Base & ss; simm8_32    { local tmp=simm8_32+Base+Index*ss; export tmp; }
3: Constructor line ia.sinc:709(id1073.10) printpiece=[[,  B,  , +,  ,  A, *,  C,  , +,  ,  D, ]]
Operands 0: Index : 1091  1: Base : 1090  2: ss : 1092  3: simm8_32 : 1093  
Pattern id=10 pattern=ins:[01xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]
	3: unique[2280:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[2300:[handle:size]] = INT_MULT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	5: unique[2400:[handle:size]] = INT_ADD unique[2280:[handle:size]], unique[2300:[handle:size]]

Line ia.sinc:700 addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32       			 { local tmp=Rmr32+simm8_32; export tmp; }
4: Constructor line ia.sinc:700(id1073.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1075  1: simm8_32 : 1076  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1d00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:701 addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0			 { export Rmr32; }
0: Constructor line ia.sinc:701(id1073.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1077  
Pattern id=2 pattern=ins:[01xx][x101]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:700 addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32       			 { local tmp=Rmr32+simm8_32; export tmp; }
1: Constructor line ia.sinc:700(id1073.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1075  1: simm8_32 : 1076  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1d00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:701 addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0			 { export Rmr32; }
0: Constructor line ia.sinc:701(id1073.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1077  
Pattern id=2 pattern=ins:[01xx][x110]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:700 addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32       			 { local tmp=Rmr32+simm8_32; export tmp; }
1: Constructor line ia.sinc:700(id1073.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1075  1: simm8_32 : 1076  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1d00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:701 addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0			 { export Rmr32; }
0: Constructor line ia.sinc:701(id1073.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1077  
Pattern id=2 pattern=ins:[01xx][x111]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:700 addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32       			 { local tmp=Rmr32+simm8_32; export tmp; }
1: Constructor line ia.sinc:700(id1073.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1075  1: simm8_32 : 1076  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[1d00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:703 addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0           { export Rmr32; }
0: Constructor line ia.sinc:703(id1073.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1080  
Pattern id=4 pattern=ins:[10xx][x000]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:702 addr32: [Rmr32 + imm32]					is mod=2 & Rmr32; imm32                      { local tmp=Rmr32+imm32; export tmp; }
1: Constructor line ia.sinc:702(id1073.3) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1078  1: imm32 : 1079  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1e00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:703 addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0           { export Rmr32; }
0: Constructor line ia.sinc:703(id1073.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1080  
Pattern id=4 pattern=ins:[10xx][x001]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:702 addr32: [Rmr32 + imm32]					is mod=2 & Rmr32; imm32                      { local tmp=Rmr32+imm32; export tmp; }
1: Constructor line ia.sinc:702(id1073.3) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1078  1: imm32 : 1079  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1e00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:703 addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0           { export Rmr32; }
0: Constructor line ia.sinc:703(id1073.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1080  
Pattern id=4 pattern=ins:[10xx][x010]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:702 addr32: [Rmr32 + imm32]					is mod=2 & Rmr32; imm32                      { local tmp=Rmr32+imm32; export tmp; }
1: Constructor line ia.sinc:702(id1073.3) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1078  1: imm32 : 1079  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1e00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:703 addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0           { export Rmr32; }
0: Constructor line ia.sinc:703(id1073.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1080  
Pattern id=4 pattern=ins:[10xx][x011]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:702 addr32: [Rmr32 + imm32]					is mod=2 & Rmr32; imm32                      { local tmp=Rmr32+imm32; export tmp; }
1: Constructor line ia.sinc:702(id1073.3) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1078  1: imm32 : 1079  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1e00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:716 addr32: [Base]							is mod=2 & r_m=4; index=4 & Base; imm32=0    { export Base; }
0: Constructor line ia.sinc:716(id1073.17) printpiece=[[,  A, ]]
Operands 0: Base : 1109  
Pattern id=17 pattern=ins:[10xx][x100]:[xx10][0xxx]:00:00:00:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:714 addr32: [Base + imm32]					is mod=2 & r_m=4; index=4 & Base; imm32      { local tmp=imm32+Base; export tmp; }
1: Constructor line ia.sinc:714(id1073.15) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Base : 1104  1: imm32 : 1105  
Pattern id=15 pattern=ins:[10xx][x100]:[xx10][0xxx]:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[2980:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:715 addr32: [Base + Index*ss]				is mod=2 & r_m=4; Index & Base & ss; imm32=0 { local tmp=Base+Index*ss; export tmp; }
2: Constructor line ia.sinc:715(id1073.16) printpiece=[[,  B,  , +,  ,  A, *,  C, ]]
Operands 0: Index : 1107  1: Base : 1106  2: ss : 1108  
Pattern id=16 pattern=ins:[10xx][x100]:XX:00:00:00:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2a00:[handle:size]] = INT_MULT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[2b00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], unique[2a00:[handle:size]]

Line ia.sinc:713 addr32: [Base + Index*ss + imm32]		is mod=2 & r_m=4; Index & Base & ss; imm32   { local tmp=imm32+Base+Index*ss; export tmp; }
3: Constructor line ia.sinc:713(id1073.14) printpiece=[[,  B,  , +,  ,  A, *,  C,  , +,  ,  D, ]]
Operands 0: Index : 1101  1: Base : 1100  2: ss : 1102  3: imm32 : 1103  
Pattern id=14 pattern=ins:[10xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]
	2: unique[2700:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	3: unique[2780:[handle:size]] = INT_MULT [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]
	4: unique[2880:[handle:size]] = INT_ADD unique[2700:[handle:size]], unique[2780:[handle:size]]

Line ia.sinc:702 addr32: [Rmr32 + imm32]					is mod=2 & Rmr32; imm32                      { local tmp=Rmr32+imm32; export tmp; }
4: Constructor line ia.sinc:702(id1073.3) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1078  1: imm32 : 1079  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1e00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:703 addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0           { export Rmr32; }
0: Constructor line ia.sinc:703(id1073.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1080  
Pattern id=4 pattern=ins:[10xx][x101]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:702 addr32: [Rmr32 + imm32]					is mod=2 & Rmr32; imm32                      { local tmp=Rmr32+imm32; export tmp; }
1: Constructor line ia.sinc:702(id1073.3) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1078  1: imm32 : 1079  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1e00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:703 addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0           { export Rmr32; }
0: Constructor line ia.sinc:703(id1073.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1080  
Pattern id=4 pattern=ins:[10xx][x110]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:702 addr32: [Rmr32 + imm32]					is mod=2 & Rmr32; imm32                      { local tmp=Rmr32+imm32; export tmp; }
1: Constructor line ia.sinc:702(id1073.3) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1078  1: imm32 : 1079  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1e00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:703 addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0           { export Rmr32; }
0: Constructor line ia.sinc:703(id1073.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 1080  
Pattern id=4 pattern=ins:[10xx][x111]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:702 addr32: [Rmr32 + imm32]					is mod=2 & Rmr32; imm32                      { local tmp=Rmr32+imm32; export tmp; }
1: Constructor line ia.sinc:702(id1073.3) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 1078  1: imm32 : 1079  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[1e00:[handle:size]] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:749 currentCS: CS is protectedMode=0 & CS { tmp:4 = (inst_next >> 4) & 0xf000; CS = tmp:2; export CS; }
0: Constructor line ia.sinc:749(id1110.0) printpiece=[ A]
Operands 0: CS : 1111  
Pattern id=0 pattern=ctx:SS:[xxx0]X:XX:XX:XX
Template
	0: unique[2b80:4] = INT_RIGHT const[[next]:4], const[4:4]
	1: unique[2c80:4] = INT_AND unique[2b80:4], const[f000:4]
	2: register[102:2] = SUBPIECE unique[2c80:4], const[0:4]

Line ia.sinc:750 currentCS: CS is protectedMode=1 & CS { tmp:4 = (inst_next >> 16) & 0xffff; CS = tmp:2; export CS; }
0: Constructor line ia.sinc:750(id1110.1) printpiece=[ A]
Operands 0: CS : 1112  
Pattern id=1 pattern=ctx:SS:[xxx1]X:XX:XX:XX
Template
	0: unique[2d80:4] = INT_RIGHT const[[next]:4], const[10:4]
	1: unique[2e80:4] = INT_AND unique[2d80:4], const[ffff:4]
	2: register[102:2] = SUBPIECE unique[2e80:4], const[0:4]

Line ia.sinc:752 segWide: is segover=0		        { export 0:$(SIZE); }
0: Constructor line ia.sinc:752(id1113.0) printpiece=[]
Operands 
Pattern id=0 pattern=ctx:SS:[000x]X:XX:XX:XX
Template

Line ia.sinc:753 segWide: CS: is segover=1 & CS	{ export 0:$(SIZE); }
0: Constructor line ia.sinc:753(id1113.1) printpiece=[ A, :]
Operands 0: CS : 1114  
Pattern id=1 pattern=ctx:SS:[001x]X:XX:XX:XX
Template

Line ia.sinc:754 segWide: SS: is segover=2 & SS	{ export 0:$(SIZE); }
0: Constructor line ia.sinc:754(id1113.2) printpiece=[ A, :]
Operands 0: SS : 1115  
Pattern id=2 pattern=ctx:SS:[010x]X:XX:XX:XX
Template

Line ia.sinc:755 segWide: DS: is segover=3 & DS	{ export 0:$(SIZE); }
0: Constructor line ia.sinc:755(id1113.3) printpiece=[ A, :]
Operands 0: DS : 1116  
Pattern id=3 pattern=ctx:SS:[011x]X:XX:XX:XX
Template

Line ia.sinc:756 segWide: ES: is segover=4 & ES	{ export 0:$(SIZE); }
0: Constructor line ia.sinc:756(id1113.4) printpiece=[ A, :]
Operands 0: ES : 1117  
Pattern id=4 pattern=ctx:SS:[100x]X:XX:XX:XX
Template

Line ia.sinc:757 segWide: FS: is segover=5 & FS	{ export FS_OFFSET; }
0: Constructor line ia.sinc:757(id1113.5) printpiece=[ A, :]
Operands 0: FS : 1118  
Pattern id=5 pattern=ctx:SS:[101x]X:XX:XX:XX
Template

Line ia.sinc:758 segWide: GS: is segover=6 & GS	{ export GS_OFFSET; }
0: Constructor line ia.sinc:758(id1113.6) printpiece=[ A, :]
Operands 0: GS : 1119  
Pattern id=6 pattern=ctx:SS:[110x]X:XX:XX:XX
Template

Line ia.sinc:760 seg16: 	   is segover=0			{ export DS; }
0: Constructor line ia.sinc:760(id1120.0) printpiece=[]
Operands 
Pattern id=0 pattern=ctx:SS:[000x]X:XX:XX:XX
Template

Line ia.sinc:761 seg16: currentCS: is segover=1 & currentCS	{ export currentCS; }
0: Constructor line ia.sinc:761(id1120.1) printpiece=[ A, :]
Operands 0: currentCS : 1121  
Pattern id=1 pattern=ctx:SS:[001x]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:762 seg16: SS: is segover=2 & SS	{ export SS; }
0: Constructor line ia.sinc:762(id1120.2) printpiece=[ A, :]
Operands 0: SS : 1122  
Pattern id=2 pattern=ctx:SS:[010x]X:XX:XX:XX
Template

Line ia.sinc:763 seg16: DS: is segover=3 & DS	{ export DS; }
0: Constructor line ia.sinc:763(id1120.3) printpiece=[ A, :]
Operands 0: DS : 1123  
Pattern id=3 pattern=ctx:SS:[011x]X:XX:XX:XX
Template

Line ia.sinc:764 seg16: ES: is segover=4 & ES	{ export ES; }
0: Constructor line ia.sinc:764(id1120.4) printpiece=[ A, :]
Operands 0: ES : 1124  
Pattern id=4 pattern=ctx:SS:[100x]X:XX:XX:XX
Template

Line ia.sinc:765 seg16: FS: is segover=5 & FS	{ export FS; }
0: Constructor line ia.sinc:765(id1120.5) printpiece=[ A, :]
Operands 0: FS : 1125  
Pattern id=5 pattern=ctx:SS:[101x]X:XX:XX:XX
Template

Line ia.sinc:766 seg16: GS: is segover=6 & GS	{ export GS; }
0: Constructor line ia.sinc:766(id1120.6) printpiece=[ A, :]
Operands 0: GS : 1126  
Pattern id=6 pattern=ctx:SS:[110x]X:XX:XX:XX
Template

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
0: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
0: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:768 Mem16: addr16	is (segover=0 & mod=0 & r_m=2) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
0: Constructor line ia.sinc:768(id1127.0) printpiece=[ A]
Operands 0: addr16 : 1128  
Pattern id=0 pattern=cmb:(ctx:SS:[000x]X:XX:XX:XX,ins:[00xx][x010]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3000:4] = CALLOTHER const[0:4], register[104:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
1: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:770 Mem16: addr16	is (segover=0 & mod=1 & r_m=2) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
0: Constructor line ia.sinc:770(id1127.2) printpiece=[ A]
Operands 0: addr16 : 1130  
Pattern id=2 pattern=cmb:(ctx:SS:[000x]X:XX:XX:XX,ins:[01xx][x010]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3200:4] = CALLOTHER const[0:4], register[104:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
1: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:773 Mem16: addr16   is (segover=0 & mod=2 & r_m=2) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
0: Constructor line ia.sinc:773(id1127.5) printpiece=[ A]
Operands 0: addr16 : 1133  
Pattern id=5 pattern=cmb:(ctx:SS:[000x]X:XX:XX:XX,ins:[10xx][x010]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3500:4] = CALLOTHER const[0:4], register[104:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
1: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
0: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:769 Mem16: addr16	is (segover=0 & mod=0 & r_m=3) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
0: Constructor line ia.sinc:769(id1127.1) printpiece=[ A]
Operands 0: addr16 : 1129  
Pattern id=1 pattern=cmb:(ctx:SS:[000x]X:XX:XX:XX,ins:[00xx][x011]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3100:4] = CALLOTHER const[0:4], register[104:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
1: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:771 Mem16: addr16	is (segover=0 & mod=1 & r_m=3) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
0: Constructor line ia.sinc:771(id1127.3) printpiece=[ A]
Operands 0: addr16 : 1131  
Pattern id=3 pattern=cmb:(ctx:SS:[000x]X:XX:XX:XX,ins:[01xx][x011]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3300:4] = CALLOTHER const[0:4], register[104:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
1: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:774 Mem16: addr16   is (segover=0 & mod=2 & r_m=3) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
0: Constructor line ia.sinc:774(id1127.6) printpiece=[ A]
Operands 0: addr16 : 1134  
Pattern id=6 pattern=cmb:(ctx:SS:[000x]X:XX:XX:XX,ins:[10xx][x011]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3600:4] = CALLOTHER const[0:4], register[104:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
1: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
0: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
0: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
0: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:772 Mem16: addr16  	is (segover=0 & mod=1 & r_m=6) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
0: Constructor line ia.sinc:772(id1127.4) printpiece=[ A]
Operands 0: addr16 : 1132  
Pattern id=4 pattern=cmb:(ctx:SS:[000x]X:XX:XX:XX,ins:[01xx][x110]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3400:4] = CALLOTHER const[0:4], register[104:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
1: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:775 Mem16: addr16  	is (segover=0 & mod=2 & r_m=6) ... & addr16   { tmp:$(SIZE) = segment(SS,addr16); export tmp; }
0: Constructor line ia.sinc:775(id1127.7) printpiece=[ A]
Operands 0: addr16 : 1135  
Pattern id=7 pattern=cmb:(ctx:SS:[000x]X:XX:XX:XX,ins:[10xx][x110]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]
	1: unique[3700:4] = CALLOTHER const[0:4], register[104:2], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
1: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:776 Mem16: seg16^addr16	is seg16; addr16							 	   { tmp:$(SIZE) = segment(seg16,addr16); export tmp; }
0: Constructor line ia.sinc:776(id1127.8) printpiece=[ A,  B]
Operands 0: seg16 : 1136  1: addr16 : 1137  
Pattern id=8 pattern=always
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:778 Mem: Mem16 is addrsize=0 & Mem16             { export Mem16; }
0: Constructor line ia.sinc:778(id1138.0) printpiece=[ A]
Operands 0: Mem16 : 1139  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:789 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide & highseg=1; addr32 	{ tmp:$(SIZE) = segWide + zext(addr32); export tmp; }
0: Constructor line ia.sinc:789(id1138.2) printpiece=[ A,  B]
Operands 0: segWide : 1142  1: addr32 : 1143  
Pattern id=2 pattern=ctx:X[x100]:[1xxx]X:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3980:4] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:787 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide; addr32       		{ export addr32; }
1: Constructor line ia.sinc:787(id1138.1) printpiece=[ A,  B]
Operands 0: segWide : 1140  1: addr32 : 1141  
Pattern id=1 pattern=ctx:X[x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:789 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide & highseg=1; addr32 	{ tmp:$(SIZE) = segWide + zext(addr32); export tmp; }
0: Constructor line ia.sinc:789(id1138.2) printpiece=[ A,  B]
Operands 0: segWide : 1142  1: addr32 : 1143  
Pattern id=2 pattern=ctx:X[x101]:[1xxx]X:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3980:4] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:787 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide; addr32       		{ export addr32; }
1: Constructor line ia.sinc:787(id1138.1) printpiece=[ A,  B]
Operands 0: segWide : 1140  1: addr32 : 1141  
Pattern id=1 pattern=ctx:X[x101]:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:789 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide & highseg=1; addr32 	{ tmp:$(SIZE) = segWide + zext(addr32); export tmp; }
0: Constructor line ia.sinc:789(id1138.2) printpiece=[ A,  B]
Operands 0: segWide : 1142  1: addr32 : 1143  
Pattern id=2 pattern=ctx:X[x110]:[1xxx]X:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3980:4] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:787 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide; addr32       		{ export addr32; }
1: Constructor line ia.sinc:787(id1138.1) printpiece=[ A,  B]
Operands 0: segWide : 1140  1: addr32 : 1141  
Pattern id=1 pattern=ctx:X[x110]:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:789 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide & highseg=1; addr32 	{ tmp:$(SIZE) = segWide + zext(addr32); export tmp; }
0: Constructor line ia.sinc:789(id1138.2) printpiece=[ A,  B]
Operands 0: segWide : 1142  1: addr32 : 1143  
Pattern id=2 pattern=ctx:X[x111]:[1xxx]X:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]
	2: unique[3980:4] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:787 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide; addr32       		{ export addr32; }
1: Constructor line ia.sinc:787(id1138.1) printpiece=[ A,  B]
Operands 0: segWide : 1140  1: addr32 : 1141  
Pattern id=1 pattern=ctx:X[x111]:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:791 rel8: reloc is simm8        [ reloc=inst_next+simm8; ] { export *[ram]:$(SIZE) reloc; }
0: Constructor line ia.sinc:791(id1144.0) printpiece=[ B]
Operands 0: simm8 : 1146  1: reloc : 1145  
Pattern id=0 pattern=always
Template

Line ia.sinc:792 rel16: reloc is simm16      [ reloc=((inst_next >> 16) << 16) | ((inst_next + simm16) & 0xFFFF); ] { export *[ram]:$(SIZE) reloc; }
0: Constructor line ia.sinc:792(id1147.0) printpiece=[ B]
Operands 0: simm16 : 1149  1: reloc : 1148  
Pattern id=0 pattern=always
Template

Line ia.sinc:793 rel32: reloc is simm32      [ reloc=inst_next+simm32; ] { export *[ram]:$(SIZE) reloc; }
0: Constructor line ia.sinc:793(id1150.0) printpiece=[ B]
Operands 0: simm32 : 1152  1: reloc : 1151  
Pattern id=0 pattern=always
Template

Line ia.sinc:796 m8:   "byte ptr" Mem   	is Mem      { export *:1 Mem; }
0: Constructor line ia.sinc:796(id1153.0) printpiece=[byte ptr,  ,  A]
Operands 0: Mem : 1154  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:797 m16:  "word ptr" Mem  	is Mem      { export *:2 Mem; }
0: Constructor line ia.sinc:797(id1155.0) printpiece=[word ptr,  ,  A]
Operands 0: Mem : 1156  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:798 m32:  "dword ptr" Mem  	is Mem      { export *:4 Mem; }
0: Constructor line ia.sinc:798(id1157.0) printpiece=[dword ptr,  ,  A]
Operands 0: Mem : 1158  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:799 m64:  "qword ptr" Mem  	is Mem      { export *:8 Mem; }
0: Constructor line ia.sinc:799(id1159.0) printpiece=[qword ptr,  ,  A]
Operands 0: Mem : 1160  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:801 m128: "xmmword ptr" Mem	is Mem      { export *:16 Mem; }
0: Constructor line ia.sinc:801(id1161.0) printpiece=[xmmword ptr,  ,  A]
Operands 0: Mem : 1162  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:802 m256: "ymmword ptr" Mem	is Mem      { export *:32 Mem; }
0: Constructor line ia.sinc:802(id1163.0) printpiece=[ymmword ptr,  ,  A]
Operands 0: Mem : 1164  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:806 spec_m16: "word ptr "^Mem    is Mem      { export *:2 Mem; }
0: Constructor line ia.sinc:806(id1165.0) printpiece=[word ptr ,  A]
Operands 0: Mem : 1166  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:807 spec_m32: "dword ptr "^Mem    is Mem      { export *:4 Mem; }
0: Constructor line ia.sinc:807(id1167.0) printpiece=[dword ptr ,  A]
Operands 0: Mem : 1168  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:808 spec_m64: "qword ptr "^Mem    is Mem      { export *:8 Mem; }
0: Constructor line ia.sinc:808(id1169.0) printpiece=[qword ptr ,  A]
Operands 0: Mem : 1170  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:809 spec_m80: "tword ptr "^Mem    is Mem      { export *:10 Mem; }
0: Constructor line ia.sinc:809(id1171.0) printpiece=[tword ptr ,  A]
Operands 0: Mem : 1172  
Pattern id=0 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:820 vaddr32x: [Xmm_vsib*ss + simm32_32]				is mod=0 & r_m=4; Xmm_vsib & base=5 & ss;	simm32_32	{ }
0: Constructor line ia.sinc:820(id1173.1) printpiece=[[,  A, *,  B,  , +,  ,  C, ]]
Operands 0: Xmm_vsib : 1177  1: ss : 1178  2: simm32_32 : 1179  
Pattern id=1 pattern=ins:[00xx][x100]:X[x101]:XX:XX
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:819 vaddr32x: [Base + Xmm_vsib*ss]					is mod=0 & r_m=4; Xmm_vsib & Base & ss					{ }
1: Constructor line ia.sinc:819(id1173.0) printpiece=[[,  B,  , +,  ,  A, *,  C, ]]
Operands 0: Xmm_vsib : 1175  1: Base : 1174  2: ss : 1176  
Pattern id=0 pattern=ins:[00xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:821 vaddr32x: [Base + Xmm_vsib*ss + simm8_32]		is mod=1 & r_m=4; Xmm_vsib & Base & ss;		simm8_32	{ }
0: Constructor line ia.sinc:821(id1173.2) printpiece=[[,  B,  , +,  ,  A, *,  C,  , +,  ,  D, ]]
Operands 0: Xmm_vsib : 1181  1: Base : 1180  2: ss : 1182  3: simm8_32 : 1183  
Pattern id=2 pattern=ins:[01xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]

Line ia.sinc:822 vaddr32x: [Base + Xmm_vsib*ss + simm32_32]		is mod=2 & r_m=4; Xmm_vsib & Base & ss;		simm32_32	{ }
0: Constructor line ia.sinc:822(id1173.3) printpiece=[[,  B,  , +,  ,  A, *,  C,  , +,  ,  D, ]]
Operands 0: Xmm_vsib : 1185  1: Base : 1184  2: ss : 1186  3: simm32_32 : 1187  
Pattern id=3 pattern=ins:[10xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]

Line ia.sinc:825 vaddr32y: [Ymm_vsib*ss + simm32_32]				is mod=0 & r_m=4; Ymm_vsib & base=5 & ss;	simm32_32	{ }
0: Constructor line ia.sinc:825(id1188.1) printpiece=[[,  A, *,  B,  , +,  ,  C, ]]
Operands 0: Ymm_vsib : 1192  1: ss : 1193  2: simm32_32 : 1194  
Pattern id=1 pattern=ins:[00xx][x100]:X[x101]:XX:XX
Template
	0: MULTIEQUAL const[2:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:824 vaddr32y: [Base + Ymm_vsib*ss]					is mod=0 & r_m=4; Ymm_vsib & Base & ss					{ }
1: Constructor line ia.sinc:824(id1188.0) printpiece=[[,  B,  , +,  ,  A, *,  C, ]]
Operands 0: Ymm_vsib : 1190  1: Base : 1189  2: ss : 1191  
Pattern id=0 pattern=ins:[00xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line ia.sinc:826 vaddr32y: [Base + Ymm_vsib*ss + simm8_32]		is mod=1 & r_m=4; Ymm_vsib & Base & ss;		simm8_32	{ }
0: Constructor line ia.sinc:826(id1188.2) printpiece=[[,  B,  , +,  ,  A, *,  C,  , +,  ,  D, ]]
Operands 0: Ymm_vsib : 1196  1: Base : 1195  2: ss : 1197  3: simm8_32 : 1198  
Pattern id=2 pattern=ins:[01xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]

Line ia.sinc:827 vaddr32y: [Base + Ymm_vsib*ss + simm32_32]		is mod=2 & r_m=4; Ymm_vsib & Base & ss;		simm32_32	{ }
0: Constructor line ia.sinc:827(id1188.3) printpiece=[[,  B,  , +,  ,  A, *,  C,  , +,  ,  D, ]]
Operands 0: Ymm_vsib : 1200  1: Base : 1199  2: ss : 1201  3: simm32_32 : 1202  
Pattern id=3 pattern=ins:[10xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]

Line ia.sinc:843 vMem32x: segWide^vaddr32x	is addrsize=1 & segWide & highseg=1; vaddr32x 		{ }
0: Constructor line ia.sinc:843(id1203.1) printpiece=[ A,  B]
Operands 0: segWide : 1206  1: vaddr32x : 1207  
Pattern id=1 pattern=cmb:(ctx:X[x1xx]:[1xxx]X:XX:XX,ins:X[x100]:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:842 vMem32x: segWide^vaddr32x	is addrsize=1 & segWide; vaddr32x       			{ }
1: Constructor line ia.sinc:842(id1203.0) printpiece=[ A,  B]
Operands 0: segWide : 1204  1: vaddr32x : 1205  
Pattern id=0 pattern=cmb:(ctx:X[x1xx]:XX:XX:XX,ins:X[x100]:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:846 vMem32y: segWide^vaddr32y	is addrsize=1 & segWide & highseg=1; vaddr32y 		{ }
0: Constructor line ia.sinc:846(id1208.1) printpiece=[ A,  B]
Operands 0: segWide : 1211  1: vaddr32y : 1212  
Pattern id=1 pattern=cmb:(ctx:X[x1xx]:[1xxx]X:XX:XX,ins:X[x100]:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:845 vMem32y: segWide^vaddr32y	is addrsize=1 & segWide; vaddr32y       			{ }
1: Constructor line ia.sinc:845(id1208.0) printpiece=[ A,  B]
Operands 0: segWide : 1209  1: vaddr32y : 1210  
Pattern id=0 pattern=cmb:(ctx:X[x1xx]:XX:XX:XX,ins:X[x100]:XX:XX:XX)
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line ia.sinc:877 d_vm32x: "dword ptr "^vMem32x is vMem32x { }
0: Constructor line ia.sinc:877(id1213.0) printpiece=[dword ptr ,  A]
Operands 0: vMem32x : 1214  
Pattern id=0 pattern=cmb:(ctx:X[x1xx]:XX:XX:XX,ins:X[x100]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:878 d_vm32y: "dword ptr "^vMem32y is vMem32y { }
0: Constructor line ia.sinc:878(id1215.0) printpiece=[dword ptr ,  A]
Operands 0: vMem32y : 1216  
Pattern id=0 pattern=cmb:(ctx:X[x1xx]:XX:XX:XX,ins:X[x100]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:886 q_vm32x: "qword ptr "^vMem32x is vMem32x { }
0: Constructor line ia.sinc:886(id1217.0) printpiece=[qword ptr ,  A]
Operands 0: vMem32x : 1218  
Pattern id=0 pattern=cmb:(ctx:X[x1xx]:XX:XX:XX,ins:X[x100]:XX:XX:XX)
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:894 Reg32_m8:     Rmr32     is mod=3 & Rmr32                     { export Rmr32; }
0: Constructor line ia.sinc:894(id1219.0) printpiece=[ A]
Operands 0: Rmr32 : 1220  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:895 Reg32_m8:     m8        is m8                                { local tmp:4 = zext(m8); export tmp; }
1: Constructor line ia.sinc:895(id1219.1) printpiece=[ A]
Operands 0: m8 : 1221  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4100:4] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:896 Reg32_m16:    Rmr32     is mod=3 & Rmr32                     { export Rmr32; }
0: Constructor line ia.sinc:896(id1222.0) printpiece=[ A]
Operands 0: Rmr32 : 1223  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:897 Reg32_m16:    m16       is m16                               { local tmp:4 = zext(m16); export tmp; }
1: Constructor line ia.sinc:897(id1222.1) printpiece=[ A]
Operands 0: m16 : 1224  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4200:4] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:902 XmmReg2_m8:   XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
0: Constructor line ia.sinc:902(id1225.0) printpiece=[ A]
Operands 0: XmmReg2 : 1226  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:903 XmmReg2_m8:   m8        is m8                                { local tmp:16 = zext(m8); export tmp; }
1: Constructor line ia.sinc:903(id1225.1) printpiece=[ A]
Operands 0: m8 : 1227  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4300:10] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:904 XmmReg2_m16:  XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
0: Constructor line ia.sinc:904(id1228.0) printpiece=[ A]
Operands 0: XmmReg2 : 1229  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:905 XmmReg2_m16:  m16       is m16                               { local tmp:16 = zext(m16); export tmp; }
1: Constructor line ia.sinc:905(id1228.1) printpiece=[ A]
Operands 0: m16 : 1230  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4400:10] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:906 XmmReg2_m32:  XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
0: Constructor line ia.sinc:906(id1231.0) printpiece=[ A]
Operands 0: XmmReg2 : 1232  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:907 XmmReg2_m32:  m32       is m32                               { local tmp:16 = zext(m32); export tmp; }
1: Constructor line ia.sinc:907(id1231.1) printpiece=[ A]
Operands 0: m32 : 1233  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4500:10] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:908 XmmReg2_m64:  XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
0: Constructor line ia.sinc:908(id1234.0) printpiece=[ A]
Operands 0: XmmReg2 : 1235  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:909 XmmReg2_m64:  m64       is m64                               { local tmp:16 = zext(m64); export tmp; }
1: Constructor line ia.sinc:909(id1234.1) printpiece=[ A]
Operands 0: m64 : 1236  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4600:10] = INT_ZEXT [handle:space][[handle:offset]:[handle:size]]

Line ia.sinc:910 XmmReg2_m128: XmmReg2   is mod=3 & XmmReg2                   { export XmmReg2; }
0: Constructor line ia.sinc:910(id1237.0) printpiece=[ A]
Operands 0: XmmReg2 : 1238  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:911 XmmReg2_m128: m128      is m128                              { export m128; }
1: Constructor line ia.sinc:911(id1237.1) printpiece=[ A]
Operands 0: m128 : 1239  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:913 YmmReg2_m256: YmmReg2   is mod=3 & YmmReg2                   { export YmmReg2; }
0: Constructor line ia.sinc:913(id1240.0) printpiece=[ A]
Operands 0: YmmReg2 : 1241  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:914 YmmReg2_m256: m256      is m256                              { export m256; }
1: Constructor line ia.sinc:914(id1240.1) printpiece=[ A]
Operands 0: m256 : 1242  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:916 moffs8: seg16^[imm16]   is addrsize=0 & seg16 & imm16                   { tmp:$(SIZE) = segment(seg16,imm16:2); export *:1 tmp; }
0: Constructor line ia.sinc:916(id1243.0) printpiece=[ A, [,  B, ]]
Operands 0: seg16 : 1244  1: imm16 : 1245  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4700:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:2]

Line ia.sinc:917 moffs8: segWide^[imm32]   is addrsize=1 & highseg=1 & segWide & imm32   { tmp:$(SIZE) = segWide + imm32; export *:1 tmp; }
0: Constructor line ia.sinc:917(id1243.1) printpiece=[ A, [,  B, ]]
Operands 0: segWide : 1246  1: imm32 : 1247  
Pattern id=1 pattern=ctx:X[x1xx]:[1xxx]X:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4880:4] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:4]

Line ia.sinc:918 moffs8: segWide^[imm32]   is addrsize=1 & segWide & imm32               { export *:1 imm32; }
1: Constructor line ia.sinc:918(id1243.2) printpiece=[ A, [,  B, ]]
Operands 0: segWide : 1248  1: imm32 : 1249  
Pattern id=2 pattern=ctx:X[x1xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:923 moffs16: seg16^[imm16]  is addrsize=0 & seg16 & imm16                   { tmp:$(SIZE) = segment(seg16,imm16:2); export *:2 tmp; }
0: Constructor line ia.sinc:923(id1250.0) printpiece=[ A, [,  B, ]]
Operands 0: seg16 : 1251  1: imm16 : 1252  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4a80:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:2]

Line ia.sinc:924 moffs16: segWide^[imm32]  is addrsize=1 & highseg=1 & segWide & imm32   { tmp:$(SIZE) = segWide + imm32; export *:2 tmp; }
0: Constructor line ia.sinc:924(id1250.1) printpiece=[ A, [,  B, ]]
Operands 0: segWide : 1253  1: imm32 : 1254  
Pattern id=1 pattern=ctx:X[x1xx]:[1xxx]X:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4c00:4] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:4]

Line ia.sinc:925 moffs16: segWide^[imm32]  is addrsize=1 & segWide & imm32               { export *:2 imm32; }
1: Constructor line ia.sinc:925(id1250.2) printpiece=[ A, [,  B, ]]
Operands 0: segWide : 1255  1: imm32 : 1256  
Pattern id=2 pattern=ctx:X[x1xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:931 moffs32: seg16^[imm16]  is addrsize=0 & seg16 & imm16                   { tmp:$(SIZE) = segment(seg16,imm16:2); export *:4 tmp; }
0: Constructor line ia.sinc:931(id1257.0) printpiece=[ A, [,  B, ]]
Operands 0: seg16 : 1258  1: imm16 : 1259  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[4e00:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:2]

Line ia.sinc:933 moffs32: segWide^[imm32]  is addrsize=1 & highseg=1 & segWide & imm32   { tmp:$(SIZE) = segWide + imm32; export *:4 tmp; }
0: Constructor line ia.sinc:933(id1257.2) printpiece=[ A, [,  B, ]]
Operands 0: segWide : 1262  1: imm32 : 1263  
Pattern id=2 pattern=ctx:X[x1xx]:[1xxx]X:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[5000:4] = INT_ADD [handle:space][[handle:offset]:[handle:size]], [handle:space][[handle:offset]:4]

Line ia.sinc:932 moffs32: segWide^[imm32]  is addrsize=1 & segWide & imm32               { export *:4 imm32; }
1: Constructor line ia.sinc:932(id1257.1) printpiece=[ A, [,  B, ]]
Operands 0: segWide : 1260  1: imm32 : 1261  
Pattern id=1 pattern=ctx:X[x1xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:946 dseSI1: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); SI = SI + 1-2*zext(DF); export *:1 tmp; }
0: Constructor line ia.sinc:946(id1264.0) printpiece=[ A,  B]
Operands 0: seg16 : 1265  1: SI : 1266  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[5180:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], register[18:2]
	2: unique[5200:2] = INT_ADD register[18:2], const[1:2]
	3: unique[5280:2] = INT_ZEXT register[20a:1]
	4: unique[5300:2] = INT_MULT const[2:2], unique[5280:2]
	5: register[18:2] = INT_SUB unique[5200:2], unique[5300:2]

Line ia.sinc:947 dseSI1: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; ESI = ESI + 1-2*zext(DF); export *:1 tmp; }
0: Constructor line ia.sinc:947(id1264.1) printpiece=[ A,  B]
Operands 0: segWide : 1267  1: ESI : 1268  
Pattern id=1 pattern=ctx:X[x1xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[5480:4] = COPY register[18:4]
	2: unique[5500:4] = INT_ADD register[18:4], const[1:4]
	3: unique[5580:4] = INT_ZEXT register[20a:1]
	4: unique[5600:4] = INT_MULT const[2:4], unique[5580:4]
	5: register[18:4] = INT_SUB unique[5500:4], unique[5600:4]

Line ia.sinc:948 dseSI2: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); SI = SI + 2-4*zext(DF); export *:2 tmp; }
0: Constructor line ia.sinc:948(id1269.0) printpiece=[ A,  B]
Operands 0: seg16 : 1270  1: SI : 1271  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[5800:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], register[18:2]
	2: unique[5880:2] = INT_ADD register[18:2], const[2:2]
	3: unique[5900:2] = INT_ZEXT register[20a:1]
	4: unique[5980:2] = INT_MULT const[4:2], unique[5900:2]
	5: register[18:2] = INT_SUB unique[5880:2], unique[5980:2]

Line ia.sinc:949 dseSI2: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; ESI = ESI + 2-4*zext(DF); export *:2 tmp; }
0: Constructor line ia.sinc:949(id1269.1) printpiece=[ A,  B]
Operands 0: segWide : 1272  1: ESI : 1273  
Pattern id=1 pattern=ctx:X[x1xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[5b00:4] = COPY register[18:4]
	2: unique[5b80:4] = INT_ADD register[18:4], const[2:4]
	3: unique[5c00:4] = INT_ZEXT register[20a:1]
	4: unique[5c80:4] = INT_MULT const[4:4], unique[5c00:4]
	5: register[18:4] = INT_SUB unique[5b80:4], unique[5c80:4]

Line ia.sinc:950 dseSI4: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); SI = SI + 4-8*zext(DF); export *:4 tmp; }
0: Constructor line ia.sinc:950(id1274.0) printpiece=[ A,  B]
Operands 0: seg16 : 1275  1: SI : 1276  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[5e80:4] = CALLOTHER const[0:4], [handle:space][[handle:offset]:[handle:size]], register[18:2]
	2: unique[5f00:2] = INT_ADD register[18:2], const[4:2]
	3: unique[5f80:2] = INT_ZEXT register[20a:1]
	4: unique[6000:2] = INT_MULT const[8:2], unique[5f80:2]
	5: register[18:2] = INT_SUB unique[5f00:2], unique[6000:2]

Line ia.sinc:951 dseSI4: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; ESI = ESI + 4-8*zext(DF); export *:4 tmp; }
0: Constructor line ia.sinc:951(id1274.1) printpiece=[ A,  B]
Operands 0: segWide : 1277  1: ESI : 1278  
Pattern id=1 pattern=ctx:X[x1xx]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[6180:4] = COPY register[18:4]
	2: unique[6200:4] = INT_ADD register[18:4], const[4:4]
	3: unique[6280:4] = INT_ZEXT register[20a:1]
	4: unique[6300:4] = INT_MULT const[8:4], unique[6280:4]
	5: register[18:4] = INT_SUB unique[6200:4], unique[6300:4]

Line ia.sinc:952 eseDI1: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); DI = DI + 1-2*zext(DF); export *:1 tmp; }
0: Constructor line ia.sinc:952(id1279.0) printpiece=[ A, :,  B]
Operands 0: ES : 1280  1: DI : 1281  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: unique[6500:4] = CALLOTHER const[0:4], register[100:2], register[1c:2]
	1: unique[6580:2] = INT_ADD register[1c:2], const[1:2]
	2: unique[6600:2] = INT_ZEXT register[20a:1]
	3: unique[6680:2] = INT_MULT const[2:2], unique[6600:2]
	4: register[1c:2] = INT_SUB unique[6580:2], unique[6680:2]

Line ia.sinc:953 eseDI1: ES:EDI      is addrsize=1 & ES & EDI    { tmp:4 = EDI; EDI=EDI+1-2*zext(DF); export *:1 tmp; }
0: Constructor line ia.sinc:953(id1279.1) printpiece=[ A, :,  B]
Operands 0: ES : 1282  1: EDI : 1283  
Pattern id=1 pattern=ctx:X[x1xx]:XX:XX:XX
Template
	0: unique[6800:4] = COPY register[1c:4]
	1: unique[6880:4] = INT_ADD register[1c:4], const[1:4]
	2: unique[6900:4] = INT_ZEXT register[20a:1]
	3: unique[6980:4] = INT_MULT const[2:4], unique[6900:4]
	4: register[1c:4] = INT_SUB unique[6880:4], unique[6980:4]

Line ia.sinc:954 eseDI2: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); DI = DI + 2-4*zext(DF); export *:2 tmp; }
0: Constructor line ia.sinc:954(id1284.0) printpiece=[ A, :,  B]
Operands 0: ES : 1285  1: DI : 1286  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: unique[6b80:4] = CALLOTHER const[0:4], register[100:2], register[1c:2]
	1: unique[6c00:2] = INT_ADD register[1c:2], const[2:2]
	2: unique[6c80:2] = INT_ZEXT register[20a:1]
	3: unique[6d00:2] = INT_MULT const[4:2], unique[6c80:2]
	4: register[1c:2] = INT_SUB unique[6c00:2], unique[6d00:2]

Line ia.sinc:955 eseDI2: ES:EDI      is addrsize=1 & ES & EDI    { tmp:4 = EDI; EDI=EDI+2-4*zext(DF); export *:2 tmp; }
0: Constructor line ia.sinc:955(id1284.1) printpiece=[ A, :,  B]
Operands 0: ES : 1287  1: EDI : 1288  
Pattern id=1 pattern=ctx:X[x1xx]:XX:XX:XX
Template
	0: unique[6e80:4] = COPY register[1c:4]
	1: unique[6f00:4] = INT_ADD register[1c:4], const[2:4]
	2: unique[6f80:4] = INT_ZEXT register[20a:1]
	3: unique[7000:4] = INT_MULT const[4:4], unique[6f80:4]
	4: register[1c:4] = INT_SUB unique[6f00:4], unique[7000:4]

Line ia.sinc:956 eseDI4: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); DI = DI + 4-8*zext(DF); export *:4 tmp; }
0: Constructor line ia.sinc:956(id1289.0) printpiece=[ A, :,  B]
Operands 0: ES : 1290  1: DI : 1291  
Pattern id=0 pattern=ctx:X[x0xx]:XX:XX:XX
Template
	0: unique[7200:4] = CALLOTHER const[0:4], register[100:2], register[1c:2]
	1: unique[7280:2] = INT_ADD register[1c:2], const[4:2]
	2: unique[7300:2] = INT_ZEXT register[20a:1]
	3: unique[7380:2] = INT_MULT const[8:2], unique[7300:2]
	4: register[1c:2] = INT_SUB unique[7280:2], unique[7380:2]

Line ia.sinc:957 eseDI4: ES:EDI      is addrsize=1 & ES & EDI    { tmp:4 = EDI; EDI=EDI+4-8*zext(DF); export *:4 tmp; }
0: Constructor line ia.sinc:957(id1289.1) printpiece=[ A, :,  B]
Operands 0: ES : 1292  1: EDI : 1293  
Pattern id=1 pattern=ctx:X[x1xx]:XX:XX:XX
Template
	0: unique[7500:4] = COPY register[1c:4]
	1: unique[7580:4] = INT_ADD register[1c:4], const[4:4]
	2: unique[7600:4] = INT_ZEXT register[20a:1]
	3: unique[7680:4] = INT_MULT const[8:4], unique[7600:4]
	4: register[1c:4] = INT_SUB unique[7580:4], unique[7680:4]

Line ia.sinc:976 rm8: Rmr8   is mod=3 & Rmr8     { export Rmr8; }
0: Constructor line ia.sinc:976(id1294.0) printpiece=[ A]
Operands 0: Rmr8 : 1295  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:977 rm8: "byte ptr" Mem    is  Mem             { export *:1 Mem; }
1: Constructor line ia.sinc:977(id1294.1) printpiece=[byte ptr,  ,  A]
Operands 0: Mem : 1296  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:979 spec_rm8: Rmr8 				is mod=3 & Rmr8		{ export Rmr8; }
0: Constructor line ia.sinc:979(id1297.0) printpiece=[ A]
Operands 0: Rmr8 : 1298  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:980 spec_rm8: "byte ptr "^Mem 	is	Mem				{ export *:1 Mem; }
1: Constructor line ia.sinc:980(id1297.1) printpiece=[byte ptr ,  A]
Operands 0: Mem : 1299  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:982 rm16: Rmr16 is mod=3 & Rmr16    { export Rmr16; }
0: Constructor line ia.sinc:982(id1300.0) printpiece=[ A]
Operands 0: Rmr16 : 1301  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:983 rm16: "word ptr" Mem   is Mem              { export *:2 Mem; }
1: Constructor line ia.sinc:983(id1300.1) printpiece=[word ptr,  ,  A]
Operands 0: Mem : 1302  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:985 spec_rm16: Rmr16				is mod=3 & Rmr16		{ export Rmr16; }
0: Constructor line ia.sinc:985(id1303.0) printpiece=[ A]
Operands 0: Rmr16 : 1304  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:986 spec_rm16: "word ptr "^Mem	is Mem				{ export *:2 Mem; }
1: Constructor line ia.sinc:986(id1303.1) printpiece=[word ptr ,  A]
Operands 0: Mem : 1305  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:988 rm32: Rmr32 is mod=3 & Rmr32    { export Rmr32; }
0: Constructor line ia.sinc:988(id1306.0) printpiece=[ A]
Operands 0: Rmr32 : 1307  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:989 rm32: "dword ptr" Mem   is Mem              { export *:4 Mem; }
1: Constructor line ia.sinc:989(id1306.1) printpiece=[dword ptr,  ,  A]
Operands 0: Mem : 1308  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:991 spec_rm32: Rmr32				is mod=3 & Rmr32		{ export Rmr32; }
0: Constructor line ia.sinc:991(id1309.0) printpiece=[ A]
Operands 0: Rmr32 : 1310  
Pattern id=0 pattern=ins:[11xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:992 spec_rm32: "dword ptr "^Mem	is Mem				{ export *:4 Mem; }
1: Constructor line ia.sinc:992(id1309.1) printpiece=[dword ptr ,  A]
Operands 0: Mem : 1311  
Pattern id=1 pattern=always
Template
	0: MULTIEQUAL const[0:4]

Line ia.sinc:1002 n1: one	is epsilon			[ one = 1; ] { export *[const]:1 one; }
0: Constructor line ia.sinc:1002(id1312.0) printpiece=[ A]
Operands 0: one : 1313  
Pattern id=0 pattern=always
Template

Line ia.sinc:1015 check_Reg32_dest:	is epsilon	{ }
0: Constructor line ia.sinc:1015(id1314.0) printpiece=[]
Operands 
Pattern id=0 pattern=always
Template

Line ia.sinc:1016 check_Rmr32_dest:	is epsilon	{ }
0: Constructor line ia.sinc:1016(id1315.0) printpiece=[]
Operands 
Pattern id=0 pattern=always
Template

Line ia.sinc:1017 check_EAX_dest:		is epsilon  { }
0: Constructor line ia.sinc:1017(id1316.0) printpiece=[]
Operands 
Pattern id=0 pattern=always
Template

Line ia.sinc:1018 check_EDX_dest:		is epsilon  { }
0: Constructor line ia.sinc:1018(id1317.0) printpiece=[]
Operands 
Pattern id=0 pattern=always
Template

Line ia.sinc:1019 check_vexVVVV_r32_dest: is epsilon {  }
0: Constructor line ia.sinc:1019(id1318.0) printpiece=[]
Operands 
Pattern id=0 pattern=always
Template

Line ia.sinc:1021 check_rm32_dest:	is epsilon	{ }
0: Constructor line ia.sinc:1021(id1319.0) printpiece=[]
Operands 
Pattern id=0 pattern=always
Template

Line ia.sinc:1024 ptr1616: reloc is protectedMode=0 & imm16; j16		[ reloc = j16*0x10 + imm16; ] { CS = j16; export *[ram]:4 reloc; }
0: Constructor line ia.sinc:1024(id1320.0) printpiece=[ C]
Operands 0: imm16 : 1322  1: j16 : 1323  2: reloc : 1321  
Pattern id=0 pattern=ctx:SS:[xxx0]X:XX:XX:XX
Template
	0: register[102:2] = COPY [handle:space][[handle:offset]:2]

Line ia.sinc:1025 ptr1616: reloc is protectedMode=1 & imm16; j16		[ reloc = j16*0x10000 + imm16; ] { CS = j16; export *[ram]:4 reloc; }
0: Constructor line ia.sinc:1025(id1320.1) printpiece=[ C]
Operands 0: imm16 : 1325  1: j16 : 1326  2: reloc : 1324  
Pattern id=1 pattern=ctx:SS:[xxx1]X:XX:XX:XX
Template
	0: register[102:2] = COPY [handle:space][[handle:offset]:2]

Line ia.sinc:1026 ptr1632: j16":"imm32 is imm32; j16	{ CS = j16; export *:4 imm32; }
0: Constructor line ia.sinc:1026(id1327.0) printpiece=[ B, :,  A]
Operands 0: imm32 : 1329  1: j16 : 1328  
Pattern id=0 pattern=always
Template
	0: register[102:2] = COPY [handle:space][[handle:offset]:2]

Line ia.sinc:1030 cc: "O" is cond=0           { export OF; }
0: Constructor line ia.sinc:1030(id1330.0) printpiece=[O]
Operands 
Pattern id=0 pattern=ins:X0:XX:XX:XX
Template

Line ia.sinc:1031 cc: "NO" is cond=1          { local tmp = !OF; export tmp; }
0: Constructor line ia.sinc:1031(id1330.1) printpiece=[NO]
Operands 
Pattern id=1 pattern=ins:X1:XX:XX:XX
Template
	0: unique[7d80:1] = BOOL_NEGATE register[20b:1]

Line ia.sinc:1032 cc: "C" is cond=2           { export CF; }
0: Constructor line ia.sinc:1032(id1330.2) printpiece=[C]
Operands 
Pattern id=2 pattern=ins:X2:XX:XX:XX
Template

Line ia.sinc:1033 cc: "NC" is cond=3          { local tmp = !CF; export tmp; }
0: Constructor line ia.sinc:1033(id1330.3) printpiece=[NC]
Operands 
Pattern id=3 pattern=ins:X3:XX:XX:XX
Template
	0: unique[7e80:1] = BOOL_NEGATE register[200:1]

Line ia.sinc:1034 cc: "Z" is cond=4           { export ZF; }
0: Constructor line ia.sinc:1034(id1330.4) printpiece=[Z]
Operands 
Pattern id=4 pattern=ins:X4:XX:XX:XX
Template

Line ia.sinc:1035 cc: "NZ" is cond=5          { local tmp = !ZF; export tmp; }
0: Constructor line ia.sinc:1035(id1330.5) printpiece=[NZ]
Operands 
Pattern id=5 pattern=ins:X5:XX:XX:XX
Template
	0: unique[7f80:1] = BOOL_NEGATE register[206:1]

Line ia.sinc:1036 cc: "BE" is cond=6          { local tmp = CF || ZF; export tmp; }
0: Constructor line ia.sinc:1036(id1330.6) printpiece=[BE]
Operands 
Pattern id=6 pattern=ins:X6:XX:XX:XX
Template
	0: unique[8080:1] = BOOL_OR register[200:1], register[206:1]

Line ia.sinc:1037 cc: "A" is cond=7           { local tmp = !(CF || ZF); export tmp; }
0: Constructor line ia.sinc:1037(id1330.7) printpiece=[A]
Operands 
Pattern id=7 pattern=ins:X7:XX:XX:XX
Template
	0: unique[8100:1] = BOOL_OR register[200:1], register[206:1]
	1: unique[8200:1] = BOOL_NEGATE unique[8100:1]

Line ia.sinc:1038 cc: "S" is cond=8           { export SF; }
0: Constructor line ia.sinc:1038(id1330.8) printpiece=[S]
Operands 
Pattern id=8 pattern=ins:X8:XX:XX:XX
Template

Line ia.sinc:1039 cc: "NS" is cond=9          { local tmp = !SF; export tmp; }
0: Constructor line ia.sinc:1039(id1330.9) printpiece=[NS]
Operands 
Pattern id=9 pattern=ins:X9:XX:XX:XX
Template
	0: unique[8300:1] = BOOL_NEGATE register[207:1]

Line ia.sinc:1040 cc: "P" is cond=10          { export PF; }
0: Constructor line ia.sinc:1040(id1330.10) printpiece=[P]
Operands 
Pattern id=10 pattern=ins:XA:XX:XX:XX
Template

Line ia.sinc:1041 cc: "NP" is cond=11         { local tmp = !PF; export tmp; }
0: Constructor line ia.sinc:1041(id1330.11) printpiece=[NP]
Operands 
Pattern id=11 pattern=ins:XB:XX:XX:XX
Template
	0: unique[8400:1] = BOOL_NEGATE register[202:1]

Line ia.sinc:1042 cc: "L" is cond=12          { local tmp = OF != SF; export tmp; }
0: Constructor line ia.sinc:1042(id1330.12) printpiece=[L]
Operands 
Pattern id=12 pattern=ins:XC:XX:XX:XX
Template
	0: unique[8500:1] = INT_NOTEQUAL register[20b:1], register[207:1]

Line ia.sinc:1043 cc: "GE" is cond=13         { local tmp = OF == SF; export tmp; }
0: Constructor line ia.sinc:1043(id1330.13) printpiece=[GE]
Operands 
Pattern id=13 pattern=ins:XD:XX:XX:XX
Template
	0: unique[8600:1] = INT_EQUAL register[20b:1], register[207:1]

Line ia.sinc:1044 cc: "LE" is cond=14         { local tmp = ZF || (OF != SF); export tmp; }
0: Constructor line ia.sinc:1044(id1330.14) printpiece=[LE]
Operands 
Pattern id=14 pattern=ins:XE:XX:XX:XX
Template
	0: unique[8680:1] = INT_NOTEQUAL register[20b:1], register[207:1]
	1: unique[8780:1] = BOOL_OR register[206:1], unique[8680:1]

Line ia.sinc:1045 cc: "G" is cond=15          { local tmp = !ZF && (OF == SF); export tmp; }
0: Constructor line ia.sinc:1045(id1330.15) printpiece=[G]
Operands 
Pattern id=15 pattern=ins:XF:XX:XX:XX
Template
	0: unique[8800:1] = BOOL_NEGATE register[206:1]
	1: unique[8880:1] = INT_EQUAL register[20b:1], register[207:1]
	2: unique[8980:1] = BOOL_AND unique[8800:1], unique[8880:1]

Line ia.sinc:1053 rep:        is repprefx=0 & repneprefx=0			{ }
0: Constructor line ia.sinc:1053(id1331.2) printpiece=[]
Operands 
Pattern id=2 pattern=ctx:SS:X[00xx]:XX:XX:XX
Template

Line ia.sinc:1048 rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=0  { if (CX==0) goto inst_next; CX=CX-1; }
0: Constructor line ia.sinc:1048(id1331.0) printpiece=[.REP]
Operands 
Pattern id=0 pattern=ctx:X[x0xx]:X[01xx]:XX:XX
Template
	0: unique[8a00:1] = INT_EQUAL register[4:2], const[0:2]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[8a00:1]
	2: register[4:2] = INT_SUB register[4:2], const[1:2]

Line ia.sinc:1049 rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=1  { if (ECX==0) goto inst_next; ECX=ECX-1; }
0: Constructor line ia.sinc:1049(id1331.1) printpiece=[.REP]
Operands 
Pattern id=1 pattern=ctx:X[x1xx]:X[01xx]:XX:XX
Template
	0: unique[8b00:1] = INT_EQUAL register[4:4], const[0:4]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[8b00:1]
	2: register[4:4] = INT_SUB register[4:4], const[1:4]

Line ia.sinc:1048 rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=0  { if (CX==0) goto inst_next; CX=CX-1; }
0: Constructor line ia.sinc:1048(id1331.0) printpiece=[.REP]
Operands 
Pattern id=0 pattern=ctx:X[x0xx]:X[10xx]:XX:XX
Template
	0: unique[8a00:1] = INT_EQUAL register[4:2], const[0:2]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[8a00:1]
	2: register[4:2] = INT_SUB register[4:2], const[1:2]

Line ia.sinc:1049 rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=1  { if (ECX==0) goto inst_next; ECX=ECX-1; }
0: Constructor line ia.sinc:1049(id1331.1) printpiece=[.REP]
Operands 
Pattern id=1 pattern=ctx:X[x1xx]:X[10xx]:XX:XX
Template
	0: unique[8b00:1] = INT_EQUAL register[4:4], const[0:4]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[8b00:1]
	2: register[4:4] = INT_SUB register[4:4], const[1:4]

Line ia.sinc:1056 reptail:	is repprefx=0 & repneprefx=0			{ }
0: Constructor line ia.sinc:1056(id1332.1) printpiece=[]
Operands 
Pattern id=1 pattern=ctx:SS:X[00xx]:XX:XX:XX
Template

Line ia.sinc:1055 reptail:	is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1))			{ goto inst_start; }
0: Constructor line ia.sinc:1055(id1332.0) printpiece=[]
Operands 
Pattern id=0 pattern=ctx:SS:X[01xx]:XX:XX:XX
Template
	0: BRANCH [curspace][[start]:[curspace_size]]

Line ia.sinc:1055 reptail:	is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1))			{ goto inst_start; }
0: Constructor line ia.sinc:1055(id1332.0) printpiece=[]
Operands 
Pattern id=0 pattern=ctx:SS:X[10xx]:XX:XX:XX
Template
	0: BRANCH [curspace][[start]:[curspace_size]]

Line ia.sinc:1068 repe:           is repprefx=0 & repneprefx=0    { }
0: Constructor line ia.sinc:1068(id1333.4) printpiece=[]
Operands 
Pattern id=4 pattern=ctx:SS:X[00xx]:XX:XX:XX
Template

Line ia.sinc:1058 repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=0  { if (CX==0) goto inst_next; CX=CX-1; }
0: Constructor line ia.sinc:1058(id1333.0) printpiece=[.REPE]
Operands 
Pattern id=0 pattern=ctx:X[x0xx]:X[01xx]:XX:XX
Template
	0: unique[8c00:1] = INT_EQUAL register[4:2], const[0:2]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[8c00:1]
	2: register[4:2] = INT_SUB register[4:2], const[1:2]

Line ia.sinc:1059 repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=1  { if (ECX==0) goto inst_next; ECX=ECX-1; }
0: Constructor line ia.sinc:1059(id1333.1) printpiece=[.REPE]
Operands 
Pattern id=1 pattern=ctx:X[x1xx]:X[01xx]:XX:XX
Template
	0: unique[8d00:1] = INT_EQUAL register[4:4], const[0:4]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[8d00:1]
	2: register[4:4] = INT_SUB register[4:4], const[1:4]

Line ia.sinc:1063 repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=0    { if (CX==0) goto inst_next; CX=CX-1; }
0: Constructor line ia.sinc:1063(id1333.2) printpiece=[.REPNE]
Operands 
Pattern id=2 pattern=ctx:X[x0xx]:X[10xx]:XX:XX
Template
	0: unique[8e00:1] = INT_EQUAL register[4:2], const[0:2]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[8e00:1]
	2: register[4:2] = INT_SUB register[4:2], const[1:2]

Line ia.sinc:1064 repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=1    { if (ECX==0) goto inst_next; ECX=ECX-1; }
0: Constructor line ia.sinc:1064(id1333.3) printpiece=[.REPNE]
Operands 
Pattern id=3 pattern=ctx:X[x1xx]:X[10xx]:XX:XX
Template
	0: unique[8f00:1] = INT_EQUAL register[4:4], const[0:4]
	1: CBRANCH [curspace][[next]:[curspace_size]], unique[8f00:1]
	2: register[4:4] = INT_SUB register[4:4], const[1:4]

Line ia.sinc:1072 repetail:   is repprefx=0 & repneprefx=0           { }
0: Constructor line ia.sinc:1072(id1334.2) printpiece=[]
Operands 
Pattern id=2 pattern=ctx:SS:X[00xx]:XX:XX:XX
Template

Line ia.sinc:1070 repetail:   is repprefx=1 & repneprefx=0           { if (ZF) goto inst_start; }
0: Constructor line ia.sinc:1070(id1334.0) printpiece=[]
Operands 
Pattern id=0 pattern=ctx:SS:X[01xx]:XX:XX:XX
Template
	0: CBRANCH [curspace][[start]:[curspace_size]], register[206:1]

Line ia.sinc:1071 repetail:   is repneprefx=1 & repprefx=0           { if (!ZF) goto inst_start; }
0: Constructor line ia.sinc:1071(id1334.1) printpiece=[]
Operands 
Pattern id=1 pattern=ctx:SS:X[10xx]:XX:XX:XX
Template
	0: unique[9000:1] = BOOL_NEGATE register[206:1]
	1: CBRANCH [curspace][[start]:[curspace_size]], unique[9000:1]

Line ia.sinc:1631 Suffix3D: imm8        is imm8 [ suffix3D=imm8; ] { }
0: Constructor line ia.sinc:1631(id1381.0) printpiece=[ A]
Operands 0: imm8 : 1382  
Pattern id=0 pattern=always
Template

Line ia.sinc:2463 enterFrames: low5 is low5 { tmp:1 = low5; export tmp; }
0: Constructor line ia.sinc:2463(id1683.0) printpiece=[ A]
Operands 0: low5 : 1684  
Pattern id=0 pattern=always
Template
	0: unique[23d00:1] = COPY [handle:space][[handle:offset]:1]

Line ia.sinc:4804 XmmCondPD: "EQ"      is imm8=0     { 
	xmmTmp1_Qa = zext( xmmTmp1_Qa f== xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( xmmTmp1_Qb f== xmmTmp2_Qb ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:4804(id2709.0) printpiece=[EQ]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template
	0: unique[52b00:1] = FLOAT_EQUAL register[1400:8], register[1410:8]
	1: unique[52b80:8] = INT_ZEXT unique[52b00:1]
	2: register[1400:8] = INT_MULT unique[52b80:8], const[ffffffffffffffff:8]
	3: unique[52c80:1] = FLOAT_EQUAL register[1408:8], register[1418:8]
	4: unique[52d00:8] = INT_ZEXT unique[52c80:1]
	5: register[1408:8] = INT_MULT unique[52d00:8], const[ffffffffffffffff:8]

Line ia.sinc:4845 XmmCondPD:	     is imm8     {
	xmmTmp1_Qa = cmppd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
	xmmTmp1_Qb = cmppd(xmmTmp1_Qb, xmmTmp2_Qb, imm8:1);
}
1: Constructor line ia.sinc:4845(id2709.8) printpiece=[]
Operands 0: imm8 : 2711  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[66:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]
	1: register[1408:8] = CALLOTHER const[66:4], register[1408:8], register[1418:8], [handle:space][[handle:offset]:1]

Line ia.sinc:4809 XmmCondPD: "LT"      is imm8=1     { 
	xmmTmp1_Qa = zext( xmmTmp1_Qa f< xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( xmmTmp1_Qb f< xmmTmp2_Qb ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:4809(id2709.1) printpiece=[LT]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template
	0: unique[52e00:1] = FLOAT_LESS register[1400:8], register[1410:8]
	1: unique[52e80:8] = INT_ZEXT unique[52e00:1]
	2: register[1400:8] = INT_MULT unique[52e80:8], const[ffffffffffffffff:8]
	3: unique[52f80:1] = FLOAT_LESS register[1408:8], register[1418:8]
	4: unique[53000:8] = INT_ZEXT unique[52f80:1]
	5: register[1408:8] = INT_MULT unique[53000:8], const[ffffffffffffffff:8]

Line ia.sinc:4845 XmmCondPD:	     is imm8     {
	xmmTmp1_Qa = cmppd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
	xmmTmp1_Qb = cmppd(xmmTmp1_Qb, xmmTmp2_Qb, imm8:1);
}
1: Constructor line ia.sinc:4845(id2709.8) printpiece=[]
Operands 0: imm8 : 2711  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[66:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]
	1: register[1408:8] = CALLOTHER const[66:4], register[1408:8], register[1418:8], [handle:space][[handle:offset]:1]

Line ia.sinc:4814 XmmCondPD: "LE"      is imm8=2     {
    xmmTmp1_Qa = zext( xmmTmp1_Qa f<= xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( xmmTmp1_Qb f<= xmmTmp2_Qb ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:4814(id2709.2) printpiece=[LE]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template
	0: unique[53100:1] = FLOAT_LESSEQUAL register[1400:8], register[1410:8]
	1: unique[53180:8] = INT_ZEXT unique[53100:1]
	2: register[1400:8] = INT_MULT unique[53180:8], const[ffffffffffffffff:8]
	3: unique[53280:1] = FLOAT_LESSEQUAL register[1408:8], register[1418:8]
	4: unique[53300:8] = INT_ZEXT unique[53280:1]
	5: register[1408:8] = INT_MULT unique[53300:8], const[ffffffffffffffff:8]

Line ia.sinc:4845 XmmCondPD:	     is imm8     {
	xmmTmp1_Qa = cmppd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
	xmmTmp1_Qb = cmppd(xmmTmp1_Qb, xmmTmp2_Qb, imm8:1);
}
1: Constructor line ia.sinc:4845(id2709.8) printpiece=[]
Operands 0: imm8 : 2711  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[66:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]
	1: register[1408:8] = CALLOTHER const[66:4], register[1408:8], register[1418:8], [handle:space][[handle:offset]:1]

Line ia.sinc:4819 XmmCondPD: "UNORD"   is imm8=3     {
    xmmTmp1_Qa = zext( nan(xmmTmp1_Qa) || nan(xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( nan(xmmTmp1_Qb) || nan(xmmTmp2_Qb) ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:4819(id2709.3) printpiece=[UNORD]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template
	0: unique[53400:1] = FLOAT_NAN register[1400:8]
	1: unique[53480:1] = FLOAT_NAN register[1410:8]
	2: unique[53500:1] = BOOL_OR unique[53400:1], unique[53480:1]
	3: unique[53580:8] = INT_ZEXT unique[53500:1]
	4: register[1400:8] = INT_MULT unique[53580:8], const[ffffffffffffffff:8]
	5: unique[53680:1] = FLOAT_NAN register[1408:8]
	6: unique[53700:1] = FLOAT_NAN register[1418:8]
	7: unique[53780:1] = BOOL_OR unique[53680:1], unique[53700:1]
	8: unique[53800:8] = INT_ZEXT unique[53780:1]
	9: register[1408:8] = INT_MULT unique[53800:8], const[ffffffffffffffff:8]

Line ia.sinc:4845 XmmCondPD:	     is imm8     {
	xmmTmp1_Qa = cmppd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
	xmmTmp1_Qb = cmppd(xmmTmp1_Qb, xmmTmp2_Qb, imm8:1);
}
1: Constructor line ia.sinc:4845(id2709.8) printpiece=[]
Operands 0: imm8 : 2711  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[66:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]
	1: register[1408:8] = CALLOTHER const[66:4], register[1408:8], register[1418:8], [handle:space][[handle:offset]:1]

Line ia.sinc:4824 XmmCondPD: "NEQ"     is imm8=4     {
    xmmTmp1_Qa = zext( xmmTmp1_Qa f!= xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( xmmTmp1_Qb f!= xmmTmp2_Qb ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:4824(id2709.4) printpiece=[NEQ]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template
	0: unique[53900:1] = FLOAT_NOTEQUAL register[1400:8], register[1410:8]
	1: unique[53980:8] = INT_ZEXT unique[53900:1]
	2: register[1400:8] = INT_MULT unique[53980:8], const[ffffffffffffffff:8]
	3: unique[53a80:1] = FLOAT_NOTEQUAL register[1408:8], register[1418:8]
	4: unique[53b00:8] = INT_ZEXT unique[53a80:1]
	5: register[1408:8] = INT_MULT unique[53b00:8], const[ffffffffffffffff:8]

Line ia.sinc:4845 XmmCondPD:	     is imm8     {
	xmmTmp1_Qa = cmppd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
	xmmTmp1_Qb = cmppd(xmmTmp1_Qb, xmmTmp2_Qb, imm8:1);
}
1: Constructor line ia.sinc:4845(id2709.8) printpiece=[]
Operands 0: imm8 : 2711  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[66:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]
	1: register[1408:8] = CALLOTHER const[66:4], register[1408:8], register[1418:8], [handle:space][[handle:offset]:1]

Line ia.sinc:4829 XmmCondPD: "NLT"     is imm8=5     {
    xmmTmp1_Qa = zext( !(xmmTmp1_Qa f< xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( !(xmmTmp1_Qb f< xmmTmp2_Qb) ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:4829(id2709.5) printpiece=[NLT]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template
	0: unique[53c00:1] = FLOAT_LESS register[1400:8], register[1410:8]
	1: unique[53c80:1] = BOOL_NEGATE unique[53c00:1]
	2: unique[53d00:8] = INT_ZEXT unique[53c80:1]
	3: register[1400:8] = INT_MULT unique[53d00:8], const[ffffffffffffffff:8]
	4: unique[53e00:1] = FLOAT_LESS register[1408:8], register[1418:8]
	5: unique[53e80:1] = BOOL_NEGATE unique[53e00:1]
	6: unique[53f00:8] = INT_ZEXT unique[53e80:1]
	7: register[1408:8] = INT_MULT unique[53f00:8], const[ffffffffffffffff:8]

Line ia.sinc:4845 XmmCondPD:	     is imm8     {
	xmmTmp1_Qa = cmppd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
	xmmTmp1_Qb = cmppd(xmmTmp1_Qb, xmmTmp2_Qb, imm8:1);
}
1: Constructor line ia.sinc:4845(id2709.8) printpiece=[]
Operands 0: imm8 : 2711  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[66:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]
	1: register[1408:8] = CALLOTHER const[66:4], register[1408:8], register[1418:8], [handle:space][[handle:offset]:1]

Line ia.sinc:4834 XmmCondPD: "NLE"     is imm8=6     {
    xmmTmp1_Qa = zext( !(xmmTmp1_Qa f<= xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( !(xmmTmp1_Qb f<= xmmTmp2_Qb) ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:4834(id2709.6) printpiece=[NLE]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template
	0: unique[54000:1] = FLOAT_LESSEQUAL register[1400:8], register[1410:8]
	1: unique[54080:1] = BOOL_NEGATE unique[54000:1]
	2: unique[54100:8] = INT_ZEXT unique[54080:1]
	3: register[1400:8] = INT_MULT unique[54100:8], const[ffffffffffffffff:8]
	4: unique[54200:1] = FLOAT_LESSEQUAL register[1408:8], register[1418:8]
	5: unique[54280:1] = BOOL_NEGATE unique[54200:1]
	6: unique[54300:8] = INT_ZEXT unique[54280:1]
	7: register[1408:8] = INT_MULT unique[54300:8], const[ffffffffffffffff:8]

Line ia.sinc:4845 XmmCondPD:	     is imm8     {
	xmmTmp1_Qa = cmppd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
	xmmTmp1_Qb = cmppd(xmmTmp1_Qb, xmmTmp2_Qb, imm8:1);
}
1: Constructor line ia.sinc:4845(id2709.8) printpiece=[]
Operands 0: imm8 : 2711  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[66:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]
	1: register[1408:8] = CALLOTHER const[66:4], register[1408:8], register[1418:8], [handle:space][[handle:offset]:1]

Line ia.sinc:4839 XmmCondPD: "ORD"     is imm8=7     {
    xmmTmp1_Qa = zext( !(nan(xmmTmp1_Qa) || nan(xmmTmp2_Qa)) ) * 0xFFFFFFFFFFFFFFFF;   
    xmmTmp1_Qb = zext( !(nan(xmmTmp1_Qb) || nan(xmmTmp2_Qb)) ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:4839(id2709.7) printpiece=[ORD]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template
	0: unique[54400:1] = FLOAT_NAN register[1400:8]
	1: unique[54480:1] = FLOAT_NAN register[1410:8]
	2: unique[54500:1] = BOOL_OR unique[54400:1], unique[54480:1]
	3: unique[54580:1] = BOOL_NEGATE unique[54500:1]
	4: unique[54600:8] = INT_ZEXT unique[54580:1]
	5: register[1400:8] = INT_MULT unique[54600:8], const[ffffffffffffffff:8]
	6: unique[54700:1] = FLOAT_NAN register[1408:8]
	7: unique[54780:1] = FLOAT_NAN register[1418:8]
	8: unique[54800:1] = BOOL_OR unique[54700:1], unique[54780:1]
	9: unique[54880:1] = BOOL_NEGATE unique[54800:1]
	10: unique[54900:8] = INT_ZEXT unique[54880:1]
	11: register[1408:8] = INT_MULT unique[54900:8], const[ffffffffffffffff:8]

Line ia.sinc:4845 XmmCondPD:	     is imm8     {
	xmmTmp1_Qa = cmppd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
	xmmTmp1_Qb = cmppd(xmmTmp1_Qb, xmmTmp2_Qb, imm8:1);
}
1: Constructor line ia.sinc:4845(id2709.8) printpiece=[]
Operands 0: imm8 : 2711  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[66:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]
	1: register[1408:8] = CALLOTHER const[66:4], register[1408:8], register[1418:8], [handle:space][[handle:offset]:1]

Line ia.sinc:4852 CMPPD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4852(id2712.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line ia.sinc:4853 CMPPD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4853(id2712.1) printpiece=[, ,  A]
Operands 0: imm8 : 2713  
Pattern id=1 pattern=always
Template

Line ia.sinc:4852 CMPPD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4852(id2712.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:01:XX:XX:XX
Template

Line ia.sinc:4853 CMPPD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4853(id2712.1) printpiece=[, ,  A]
Operands 0: imm8 : 2713  
Pattern id=1 pattern=always
Template

Line ia.sinc:4852 CMPPD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4852(id2712.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:02:XX:XX:XX
Template

Line ia.sinc:4853 CMPPD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4853(id2712.1) printpiece=[, ,  A]
Operands 0: imm8 : 2713  
Pattern id=1 pattern=always
Template

Line ia.sinc:4852 CMPPD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4852(id2712.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:03:XX:XX:XX
Template

Line ia.sinc:4853 CMPPD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4853(id2712.1) printpiece=[, ,  A]
Operands 0: imm8 : 2713  
Pattern id=1 pattern=always
Template

Line ia.sinc:4852 CMPPD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4852(id2712.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:04:XX:XX:XX
Template

Line ia.sinc:4853 CMPPD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4853(id2712.1) printpiece=[, ,  A]
Operands 0: imm8 : 2713  
Pattern id=1 pattern=always
Template

Line ia.sinc:4852 CMPPD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4852(id2712.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:05:XX:XX:XX
Template

Line ia.sinc:4853 CMPPD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4853(id2712.1) printpiece=[, ,  A]
Operands 0: imm8 : 2713  
Pattern id=1 pattern=always
Template

Line ia.sinc:4852 CMPPD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4852(id2712.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:06:XX:XX:XX
Template

Line ia.sinc:4853 CMPPD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4853(id2712.1) printpiece=[, ,  A]
Operands 0: imm8 : 2713  
Pattern id=1 pattern=always
Template

Line ia.sinc:4852 CMPPD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4852(id2712.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:07:XX:XX:XX
Template

Line ia.sinc:4853 CMPPD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4853(id2712.1) printpiece=[, ,  A]
Operands 0: imm8 : 2713  
Pattern id=1 pattern=always
Template

Line ia.sinc:4886 XmmCondPS: "EQ"      is imm8=0     { 
	xmmTmp1_Da = zext( xmmTmp1_Da f== xmmTmp2_Da ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( xmmTmp1_Db f== xmmTmp2_Db ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( xmmTmp1_Dc f== xmmTmp2_Dc ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( xmmTmp1_Dd f== xmmTmp2_Dd ) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:4886(id2722.0) printpiece=[EQ]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template
	0: unique[54c80:1] = FLOAT_EQUAL register[1400:4], register[1410:4]
	1: unique[54d00:4] = INT_ZEXT unique[54c80:1]
	2: register[1400:4] = INT_MULT unique[54d00:4], const[ffffffff:4]
	3: unique[54e00:1] = FLOAT_EQUAL register[1404:4], register[1414:4]
	4: unique[54e80:4] = INT_ZEXT unique[54e00:1]
	5: register[1404:4] = INT_MULT unique[54e80:4], const[ffffffff:4]
	6: unique[54f80:1] = FLOAT_EQUAL register[1408:4], register[1418:4]
	7: unique[55000:4] = INT_ZEXT unique[54f80:1]
	8: register[1408:4] = INT_MULT unique[55000:4], const[ffffffff:4]
	9: unique[55100:1] = FLOAT_EQUAL register[140c:4], register[141c:4]
	10: unique[55180:4] = INT_ZEXT unique[55100:1]
	11: register[140c:4] = INT_MULT unique[55180:4], const[ffffffff:4]

Line ia.sinc:4943 XmmCondPS:	     is imm8     {
	xmmTmp1_Da = cmpps(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
	xmmTmp1_Db = cmpps(xmmTmp1_Db, xmmTmp2_Db, imm8:1);
	xmmTmp1_Dc = cmpps(xmmTmp1_Dc, xmmTmp2_Dc, imm8:1);
	xmmTmp1_Dd = cmpps(xmmTmp1_Dd, xmmTmp2_Dd, imm8:1);
}
1: Constructor line ia.sinc:4943(id2722.8) printpiece=[]
Operands 0: imm8 : 2724  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[67:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]
	1: register[1404:4] = CALLOTHER const[67:4], register[1404:4], register[1414:4], [handle:space][[handle:offset]:1]
	2: register[1408:4] = CALLOTHER const[67:4], register[1408:4], register[1418:4], [handle:space][[handle:offset]:1]
	3: register[140c:4] = CALLOTHER const[67:4], register[140c:4], register[141c:4], [handle:space][[handle:offset]:1]

Line ia.sinc:4893 XmmCondPS: "LT"      is imm8=1     { 
	xmmTmp1_Da = zext( xmmTmp1_Da f< xmmTmp2_Da ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( xmmTmp1_Db f< xmmTmp2_Db ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( xmmTmp1_Dc f< xmmTmp2_Dc ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( xmmTmp1_Dd f< xmmTmp2_Dd ) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:4893(id2722.1) printpiece=[LT]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template
	0: unique[55280:1] = FLOAT_LESS register[1400:4], register[1410:4]
	1: unique[55300:4] = INT_ZEXT unique[55280:1]
	2: register[1400:4] = INT_MULT unique[55300:4], const[ffffffff:4]
	3: unique[55400:1] = FLOAT_LESS register[1404:4], register[1414:4]
	4: unique[55480:4] = INT_ZEXT unique[55400:1]
	5: register[1404:4] = INT_MULT unique[55480:4], const[ffffffff:4]
	6: unique[55580:1] = FLOAT_LESS register[1408:4], register[1418:4]
	7: unique[55600:4] = INT_ZEXT unique[55580:1]
	8: register[1408:4] = INT_MULT unique[55600:4], const[ffffffff:4]
	9: unique[55700:1] = FLOAT_LESS register[140c:4], register[141c:4]
	10: unique[55780:4] = INT_ZEXT unique[55700:1]
	11: register[140c:4] = INT_MULT unique[55780:4], const[ffffffff:4]

Line ia.sinc:4943 XmmCondPS:	     is imm8     {
	xmmTmp1_Da = cmpps(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
	xmmTmp1_Db = cmpps(xmmTmp1_Db, xmmTmp2_Db, imm8:1);
	xmmTmp1_Dc = cmpps(xmmTmp1_Dc, xmmTmp2_Dc, imm8:1);
	xmmTmp1_Dd = cmpps(xmmTmp1_Dd, xmmTmp2_Dd, imm8:1);
}
1: Constructor line ia.sinc:4943(id2722.8) printpiece=[]
Operands 0: imm8 : 2724  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[67:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]
	1: register[1404:4] = CALLOTHER const[67:4], register[1404:4], register[1414:4], [handle:space][[handle:offset]:1]
	2: register[1408:4] = CALLOTHER const[67:4], register[1408:4], register[1418:4], [handle:space][[handle:offset]:1]
	3: register[140c:4] = CALLOTHER const[67:4], register[140c:4], register[141c:4], [handle:space][[handle:offset]:1]

Line ia.sinc:4900 XmmCondPS: "LE"      is imm8=2     {
    xmmTmp1_Da = zext( xmmTmp1_Da f<= xmmTmp2_Da ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( xmmTmp1_Db f<= xmmTmp2_Db ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( xmmTmp1_Dc f<= xmmTmp2_Dc ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( xmmTmp1_Dd f<= xmmTmp2_Dd ) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:4900(id2722.2) printpiece=[LE]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template
	0: unique[55880:1] = FLOAT_LESSEQUAL register[1400:4], register[1410:4]
	1: unique[55900:4] = INT_ZEXT unique[55880:1]
	2: register[1400:4] = INT_MULT unique[55900:4], const[ffffffff:4]
	3: unique[55a00:1] = FLOAT_LESSEQUAL register[1404:4], register[1414:4]
	4: unique[55a80:4] = INT_ZEXT unique[55a00:1]
	5: register[1404:4] = INT_MULT unique[55a80:4], const[ffffffff:4]
	6: unique[55b80:1] = FLOAT_LESSEQUAL register[1408:4], register[1418:4]
	7: unique[55c00:4] = INT_ZEXT unique[55b80:1]
	8: register[1408:4] = INT_MULT unique[55c00:4], const[ffffffff:4]
	9: unique[55d00:1] = FLOAT_LESSEQUAL register[140c:4], register[141c:4]
	10: unique[55d80:4] = INT_ZEXT unique[55d00:1]
	11: register[140c:4] = INT_MULT unique[55d80:4], const[ffffffff:4]

Line ia.sinc:4943 XmmCondPS:	     is imm8     {
	xmmTmp1_Da = cmpps(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
	xmmTmp1_Db = cmpps(xmmTmp1_Db, xmmTmp2_Db, imm8:1);
	xmmTmp1_Dc = cmpps(xmmTmp1_Dc, xmmTmp2_Dc, imm8:1);
	xmmTmp1_Dd = cmpps(xmmTmp1_Dd, xmmTmp2_Dd, imm8:1);
}
1: Constructor line ia.sinc:4943(id2722.8) printpiece=[]
Operands 0: imm8 : 2724  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[67:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]
	1: register[1404:4] = CALLOTHER const[67:4], register[1404:4], register[1414:4], [handle:space][[handle:offset]:1]
	2: register[1408:4] = CALLOTHER const[67:4], register[1408:4], register[1418:4], [handle:space][[handle:offset]:1]
	3: register[140c:4] = CALLOTHER const[67:4], register[140c:4], register[141c:4], [handle:space][[handle:offset]:1]

Line ia.sinc:4907 XmmCondPS: "UNORD"   is imm8=3     {
    xmmTmp1_Da = zext( nan(xmmTmp1_Da) || nan(xmmTmp2_Da) ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( nan(xmmTmp1_Db) || nan(xmmTmp2_Db) ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( nan(xmmTmp1_Dc) || nan(xmmTmp2_Dc) ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( nan(xmmTmp1_Dd) || nan(xmmTmp2_Dd) ) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:4907(id2722.3) printpiece=[UNORD]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template
	0: unique[55e80:1] = FLOAT_NAN register[1400:4]
	1: unique[55f00:1] = FLOAT_NAN register[1410:4]
	2: unique[55f80:1] = BOOL_OR unique[55e80:1], unique[55f00:1]
	3: unique[56000:4] = INT_ZEXT unique[55f80:1]
	4: register[1400:4] = INT_MULT unique[56000:4], const[ffffffff:4]
	5: unique[56100:1] = FLOAT_NAN register[1404:4]
	6: unique[56180:1] = FLOAT_NAN register[1414:4]
	7: unique[56200:1] = BOOL_OR unique[56100:1], unique[56180:1]
	8: unique[56280:4] = INT_ZEXT unique[56200:1]
	9: register[1404:4] = INT_MULT unique[56280:4], const[ffffffff:4]
	10: unique[56380:1] = FLOAT_NAN register[1408:4]
	11: unique[56400:1] = FLOAT_NAN register[1418:4]
	12: unique[56480:1] = BOOL_OR unique[56380:1], unique[56400:1]
	13: unique[56500:4] = INT_ZEXT unique[56480:1]
	14: register[1408:4] = INT_MULT unique[56500:4], const[ffffffff:4]
	15: unique[56600:1] = FLOAT_NAN register[140c:4]
	16: unique[56680:1] = FLOAT_NAN register[141c:4]
	17: unique[56700:1] = BOOL_OR unique[56600:1], unique[56680:1]
	18: unique[56780:4] = INT_ZEXT unique[56700:1]
	19: register[140c:4] = INT_MULT unique[56780:4], const[ffffffff:4]

Line ia.sinc:4943 XmmCondPS:	     is imm8     {
	xmmTmp1_Da = cmpps(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
	xmmTmp1_Db = cmpps(xmmTmp1_Db, xmmTmp2_Db, imm8:1);
	xmmTmp1_Dc = cmpps(xmmTmp1_Dc, xmmTmp2_Dc, imm8:1);
	xmmTmp1_Dd = cmpps(xmmTmp1_Dd, xmmTmp2_Dd, imm8:1);
}
1: Constructor line ia.sinc:4943(id2722.8) printpiece=[]
Operands 0: imm8 : 2724  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[67:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]
	1: register[1404:4] = CALLOTHER const[67:4], register[1404:4], register[1414:4], [handle:space][[handle:offset]:1]
	2: register[1408:4] = CALLOTHER const[67:4], register[1408:4], register[1418:4], [handle:space][[handle:offset]:1]
	3: register[140c:4] = CALLOTHER const[67:4], register[140c:4], register[141c:4], [handle:space][[handle:offset]:1]

Line ia.sinc:4914 XmmCondPS: "NEQ"     is imm8=4     {
    xmmTmp1_Da = zext( xmmTmp1_Da f!= xmmTmp2_Da ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( xmmTmp1_Db f!= xmmTmp2_Db ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( xmmTmp1_Dc f!= xmmTmp2_Dc ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( xmmTmp1_Dd f!= xmmTmp2_Dd ) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:4914(id2722.4) printpiece=[NEQ]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template
	0: unique[56880:1] = FLOAT_NOTEQUAL register[1400:4], register[1410:4]
	1: unique[56900:4] = INT_ZEXT unique[56880:1]
	2: register[1400:4] = INT_MULT unique[56900:4], const[ffffffff:4]
	3: unique[56a00:1] = FLOAT_NOTEQUAL register[1404:4], register[1414:4]
	4: unique[56a80:4] = INT_ZEXT unique[56a00:1]
	5: register[1404:4] = INT_MULT unique[56a80:4], const[ffffffff:4]
	6: unique[56b80:1] = FLOAT_NOTEQUAL register[1408:4], register[1418:4]
	7: unique[56c00:4] = INT_ZEXT unique[56b80:1]
	8: register[1408:4] = INT_MULT unique[56c00:4], const[ffffffff:4]
	9: unique[56d00:1] = FLOAT_NOTEQUAL register[140c:4], register[141c:4]
	10: unique[56d80:4] = INT_ZEXT unique[56d00:1]
	11: register[140c:4] = INT_MULT unique[56d80:4], const[ffffffff:4]

Line ia.sinc:4943 XmmCondPS:	     is imm8     {
	xmmTmp1_Da = cmpps(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
	xmmTmp1_Db = cmpps(xmmTmp1_Db, xmmTmp2_Db, imm8:1);
	xmmTmp1_Dc = cmpps(xmmTmp1_Dc, xmmTmp2_Dc, imm8:1);
	xmmTmp1_Dd = cmpps(xmmTmp1_Dd, xmmTmp2_Dd, imm8:1);
}
1: Constructor line ia.sinc:4943(id2722.8) printpiece=[]
Operands 0: imm8 : 2724  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[67:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]
	1: register[1404:4] = CALLOTHER const[67:4], register[1404:4], register[1414:4], [handle:space][[handle:offset]:1]
	2: register[1408:4] = CALLOTHER const[67:4], register[1408:4], register[1418:4], [handle:space][[handle:offset]:1]
	3: register[140c:4] = CALLOTHER const[67:4], register[140c:4], register[141c:4], [handle:space][[handle:offset]:1]

Line ia.sinc:4921 XmmCondPS: "NLT"     is imm8=5     {
    xmmTmp1_Da = zext( !(xmmTmp1_Da f< xmmTmp2_Da) ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( !(xmmTmp1_Db f< xmmTmp2_Db) ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( !(xmmTmp1_Dc f< xmmTmp2_Dc) ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( !(xmmTmp1_Dd f< xmmTmp2_Dd) ) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:4921(id2722.5) printpiece=[NLT]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template
	0: unique[56e80:1] = FLOAT_LESS register[1400:4], register[1410:4]
	1: unique[56f00:1] = BOOL_NEGATE unique[56e80:1]
	2: unique[56f80:4] = INT_ZEXT unique[56f00:1]
	3: register[1400:4] = INT_MULT unique[56f80:4], const[ffffffff:4]
	4: unique[57080:1] = FLOAT_LESS register[1404:4], register[1414:4]
	5: unique[57100:1] = BOOL_NEGATE unique[57080:1]
	6: unique[57180:4] = INT_ZEXT unique[57100:1]
	7: register[1404:4] = INT_MULT unique[57180:4], const[ffffffff:4]
	8: unique[57280:1] = FLOAT_LESS register[1408:4], register[1418:4]
	9: unique[57300:1] = BOOL_NEGATE unique[57280:1]
	10: unique[57380:4] = INT_ZEXT unique[57300:1]
	11: register[1408:4] = INT_MULT unique[57380:4], const[ffffffff:4]
	12: unique[57480:1] = FLOAT_LESS register[140c:4], register[141c:4]
	13: unique[57500:1] = BOOL_NEGATE unique[57480:1]
	14: unique[57580:4] = INT_ZEXT unique[57500:1]
	15: register[140c:4] = INT_MULT unique[57580:4], const[ffffffff:4]

Line ia.sinc:4943 XmmCondPS:	     is imm8     {
	xmmTmp1_Da = cmpps(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
	xmmTmp1_Db = cmpps(xmmTmp1_Db, xmmTmp2_Db, imm8:1);
	xmmTmp1_Dc = cmpps(xmmTmp1_Dc, xmmTmp2_Dc, imm8:1);
	xmmTmp1_Dd = cmpps(xmmTmp1_Dd, xmmTmp2_Dd, imm8:1);
}
1: Constructor line ia.sinc:4943(id2722.8) printpiece=[]
Operands 0: imm8 : 2724  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[67:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]
	1: register[1404:4] = CALLOTHER const[67:4], register[1404:4], register[1414:4], [handle:space][[handle:offset]:1]
	2: register[1408:4] = CALLOTHER const[67:4], register[1408:4], register[1418:4], [handle:space][[handle:offset]:1]
	3: register[140c:4] = CALLOTHER const[67:4], register[140c:4], register[141c:4], [handle:space][[handle:offset]:1]

Line ia.sinc:4928 XmmCondPS: "NLE"     is imm8=6     {
    xmmTmp1_Da = zext( !(xmmTmp1_Da f<= xmmTmp2_Da) ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( !(xmmTmp1_Db f<= xmmTmp2_Db) ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( !(xmmTmp1_Dc f<= xmmTmp2_Dc) ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( !(xmmTmp1_Dd f<= xmmTmp2_Dd) ) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:4928(id2722.6) printpiece=[NLE]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template
	0: unique[57680:1] = FLOAT_LESSEQUAL register[1400:4], register[1410:4]
	1: unique[57700:1] = BOOL_NEGATE unique[57680:1]
	2: unique[57780:4] = INT_ZEXT unique[57700:1]
	3: register[1400:4] = INT_MULT unique[57780:4], const[ffffffff:4]
	4: unique[57880:1] = FLOAT_LESSEQUAL register[1404:4], register[1414:4]
	5: unique[57900:1] = BOOL_NEGATE unique[57880:1]
	6: unique[57980:4] = INT_ZEXT unique[57900:1]
	7: register[1404:4] = INT_MULT unique[57980:4], const[ffffffff:4]
	8: unique[57a80:1] = FLOAT_LESSEQUAL register[1408:4], register[1418:4]
	9: unique[57b00:1] = BOOL_NEGATE unique[57a80:1]
	10: unique[57b80:4] = INT_ZEXT unique[57b00:1]
	11: register[1408:4] = INT_MULT unique[57b80:4], const[ffffffff:4]
	12: unique[57c80:1] = FLOAT_LESSEQUAL register[140c:4], register[141c:4]
	13: unique[57d00:1] = BOOL_NEGATE unique[57c80:1]
	14: unique[57d80:4] = INT_ZEXT unique[57d00:1]
	15: register[140c:4] = INT_MULT unique[57d80:4], const[ffffffff:4]

Line ia.sinc:4943 XmmCondPS:	     is imm8     {
	xmmTmp1_Da = cmpps(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
	xmmTmp1_Db = cmpps(xmmTmp1_Db, xmmTmp2_Db, imm8:1);
	xmmTmp1_Dc = cmpps(xmmTmp1_Dc, xmmTmp2_Dc, imm8:1);
	xmmTmp1_Dd = cmpps(xmmTmp1_Dd, xmmTmp2_Dd, imm8:1);
}
1: Constructor line ia.sinc:4943(id2722.8) printpiece=[]
Operands 0: imm8 : 2724  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[67:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]
	1: register[1404:4] = CALLOTHER const[67:4], register[1404:4], register[1414:4], [handle:space][[handle:offset]:1]
	2: register[1408:4] = CALLOTHER const[67:4], register[1408:4], register[1418:4], [handle:space][[handle:offset]:1]
	3: register[140c:4] = CALLOTHER const[67:4], register[140c:4], register[141c:4], [handle:space][[handle:offset]:1]

Line ia.sinc:4935 XmmCondPS: "ORD"     is imm8=7     {
    xmmTmp1_Da = zext( !(nan(xmmTmp1_Da) || nan(xmmTmp2_Da)) ) * 0xFFFFFFFF;   
    xmmTmp1_Db = zext( !(nan(xmmTmp1_Db) || nan(xmmTmp2_Db)) ) * 0xFFFFFFFF;   
    xmmTmp1_Dc = zext( !(nan(xmmTmp1_Dc) || nan(xmmTmp2_Dc)) ) * 0xFFFFFFFF;   
    xmmTmp1_Dd = zext( !(nan(xmmTmp1_Dd) || nan(xmmTmp2_Dd)) ) * 0xFFFFFFFF;
}
0: Constructor line ia.sinc:4935(id2722.7) printpiece=[ORD]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template
	0: unique[57e80:1] = FLOAT_NAN register[1400:4]
	1: unique[57f00:1] = FLOAT_NAN register[1410:4]
	2: unique[57f80:1] = BOOL_OR unique[57e80:1], unique[57f00:1]
	3: unique[58000:1] = BOOL_NEGATE unique[57f80:1]
	4: unique[58080:4] = INT_ZEXT unique[58000:1]
	5: register[1400:4] = INT_MULT unique[58080:4], const[ffffffff:4]
	6: unique[58180:1] = FLOAT_NAN register[1404:4]
	7: unique[58200:1] = FLOAT_NAN register[1414:4]
	8: unique[58280:1] = BOOL_OR unique[58180:1], unique[58200:1]
	9: unique[58300:1] = BOOL_NEGATE unique[58280:1]
	10: unique[58380:4] = INT_ZEXT unique[58300:1]
	11: register[1404:4] = INT_MULT unique[58380:4], const[ffffffff:4]
	12: unique[58480:1] = FLOAT_NAN register[1408:4]
	13: unique[58500:1] = FLOAT_NAN register[1418:4]
	14: unique[58580:1] = BOOL_OR unique[58480:1], unique[58500:1]
	15: unique[58600:1] = BOOL_NEGATE unique[58580:1]
	16: unique[58680:4] = INT_ZEXT unique[58600:1]
	17: register[1408:4] = INT_MULT unique[58680:4], const[ffffffff:4]
	18: unique[58780:1] = FLOAT_NAN register[140c:4]
	19: unique[58800:1] = FLOAT_NAN register[141c:4]
	20: unique[58880:1] = BOOL_OR unique[58780:1], unique[58800:1]
	21: unique[58900:1] = BOOL_NEGATE unique[58880:1]
	22: unique[58980:4] = INT_ZEXT unique[58900:1]
	23: register[140c:4] = INT_MULT unique[58980:4], const[ffffffff:4]

Line ia.sinc:4943 XmmCondPS:	     is imm8     {
	xmmTmp1_Da = cmpps(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
	xmmTmp1_Db = cmpps(xmmTmp1_Db, xmmTmp2_Db, imm8:1);
	xmmTmp1_Dc = cmpps(xmmTmp1_Dc, xmmTmp2_Dc, imm8:1);
	xmmTmp1_Dd = cmpps(xmmTmp1_Dd, xmmTmp2_Dd, imm8:1);
}
1: Constructor line ia.sinc:4943(id2722.8) printpiece=[]
Operands 0: imm8 : 2724  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[67:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]
	1: register[1404:4] = CALLOTHER const[67:4], register[1404:4], register[1414:4], [handle:space][[handle:offset]:1]
	2: register[1408:4] = CALLOTHER const[67:4], register[1408:4], register[1418:4], [handle:space][[handle:offset]:1]
	3: register[140c:4] = CALLOTHER const[67:4], register[140c:4], register[141c:4], [handle:space][[handle:offset]:1]

Line ia.sinc:4952 CMPPS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4952(id2725.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line ia.sinc:4953 CMPPS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4953(id2725.1) printpiece=[, ,  A]
Operands 0: imm8 : 2726  
Pattern id=1 pattern=always
Template

Line ia.sinc:4952 CMPPS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4952(id2725.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:01:XX:XX:XX
Template

Line ia.sinc:4953 CMPPS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4953(id2725.1) printpiece=[, ,  A]
Operands 0: imm8 : 2726  
Pattern id=1 pattern=always
Template

Line ia.sinc:4952 CMPPS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4952(id2725.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:02:XX:XX:XX
Template

Line ia.sinc:4953 CMPPS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4953(id2725.1) printpiece=[, ,  A]
Operands 0: imm8 : 2726  
Pattern id=1 pattern=always
Template

Line ia.sinc:4952 CMPPS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4952(id2725.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:03:XX:XX:XX
Template

Line ia.sinc:4953 CMPPS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4953(id2725.1) printpiece=[, ,  A]
Operands 0: imm8 : 2726  
Pattern id=1 pattern=always
Template

Line ia.sinc:4952 CMPPS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4952(id2725.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:04:XX:XX:XX
Template

Line ia.sinc:4953 CMPPS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4953(id2725.1) printpiece=[, ,  A]
Operands 0: imm8 : 2726  
Pattern id=1 pattern=always
Template

Line ia.sinc:4952 CMPPS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4952(id2725.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:05:XX:XX:XX
Template

Line ia.sinc:4953 CMPPS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4953(id2725.1) printpiece=[, ,  A]
Operands 0: imm8 : 2726  
Pattern id=1 pattern=always
Template

Line ia.sinc:4952 CMPPS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4952(id2725.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:06:XX:XX:XX
Template

Line ia.sinc:4953 CMPPS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4953(id2725.1) printpiece=[, ,  A]
Operands 0: imm8 : 2726  
Pattern id=1 pattern=always
Template

Line ia.sinc:4952 CMPPS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:4952(id2725.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:07:XX:XX:XX
Template

Line ia.sinc:4953 CMPPS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:4953(id2725.1) printpiece=[, ,  A]
Operands 0: imm8 : 2726  
Pattern id=1 pattern=always
Template

Line ia.sinc:4998 XmmCondSD: "EQ"      is imm8=0     { 
	xmmTmp1_Qa = zext( xmmTmp1_Qa f== xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:4998(id2735.0) printpiece=[EQ]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template
	0: unique[58f00:1] = FLOAT_EQUAL register[1400:8], register[1410:8]
	1: unique[58f80:8] = INT_ZEXT unique[58f00:1]
	2: register[1400:8] = INT_MULT unique[58f80:8], const[ffffffffffffffff:8]

Line ia.sinc:5032 XmmCondSD:	     is imm8     {
	xmmTmp1_Qa = cmpsd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
}
1: Constructor line ia.sinc:5032(id2735.8) printpiece=[]
Operands 0: imm8 : 2737  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[68:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]

Line ia.sinc:5002 XmmCondSD: "LT"      is imm8=1     { 
	xmmTmp1_Qa = zext( xmmTmp1_Qa f< xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:5002(id2735.1) printpiece=[LT]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template
	0: unique[59080:1] = FLOAT_LESS register[1400:8], register[1410:8]
	1: unique[59100:8] = INT_ZEXT unique[59080:1]
	2: register[1400:8] = INT_MULT unique[59100:8], const[ffffffffffffffff:8]

Line ia.sinc:5032 XmmCondSD:	     is imm8     {
	xmmTmp1_Qa = cmpsd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
}
1: Constructor line ia.sinc:5032(id2735.8) printpiece=[]
Operands 0: imm8 : 2737  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[68:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]

Line ia.sinc:5006 XmmCondSD: "LE"      is imm8=2     {
    xmmTmp1_Qa = zext( xmmTmp1_Qa f<= xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:5006(id2735.2) printpiece=[LE]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template
	0: unique[59200:1] = FLOAT_LESSEQUAL register[1400:8], register[1410:8]
	1: unique[59280:8] = INT_ZEXT unique[59200:1]
	2: register[1400:8] = INT_MULT unique[59280:8], const[ffffffffffffffff:8]

Line ia.sinc:5032 XmmCondSD:	     is imm8     {
	xmmTmp1_Qa = cmpsd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
}
1: Constructor line ia.sinc:5032(id2735.8) printpiece=[]
Operands 0: imm8 : 2737  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[68:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]

Line ia.sinc:5010 XmmCondSD: "UNORD"   is imm8=3     {
    xmmTmp1_Qa = zext( nan(xmmTmp1_Qa) || nan(xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:5010(id2735.3) printpiece=[UNORD]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template
	0: unique[59380:1] = FLOAT_NAN register[1400:8]
	1: unique[59400:1] = FLOAT_NAN register[1410:8]
	2: unique[59480:1] = BOOL_OR unique[59380:1], unique[59400:1]
	3: unique[59500:8] = INT_ZEXT unique[59480:1]
	4: register[1400:8] = INT_MULT unique[59500:8], const[ffffffffffffffff:8]

Line ia.sinc:5032 XmmCondSD:	     is imm8     {
	xmmTmp1_Qa = cmpsd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
}
1: Constructor line ia.sinc:5032(id2735.8) printpiece=[]
Operands 0: imm8 : 2737  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[68:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]

Line ia.sinc:5014 XmmCondSD: "NEQ"     is imm8=4     {
    xmmTmp1_Qa = zext( xmmTmp1_Qa f!= xmmTmp2_Qa ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:5014(id2735.4) printpiece=[NEQ]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template
	0: unique[59600:1] = FLOAT_NOTEQUAL register[1400:8], register[1410:8]
	1: unique[59680:8] = INT_ZEXT unique[59600:1]
	2: register[1400:8] = INT_MULT unique[59680:8], const[ffffffffffffffff:8]

Line ia.sinc:5032 XmmCondSD:	     is imm8     {
	xmmTmp1_Qa = cmpsd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
}
1: Constructor line ia.sinc:5032(id2735.8) printpiece=[]
Operands 0: imm8 : 2737  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[68:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]

Line ia.sinc:5018 XmmCondSD: "NLT"     is imm8=5     {
    xmmTmp1_Qa = zext( !(xmmTmp1_Qa f< xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:5018(id2735.5) printpiece=[NLT]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template
	0: unique[59780:1] = FLOAT_LESS register[1400:8], register[1410:8]
	1: unique[59800:1] = BOOL_NEGATE unique[59780:1]
	2: unique[59880:8] = INT_ZEXT unique[59800:1]
	3: register[1400:8] = INT_MULT unique[59880:8], const[ffffffffffffffff:8]

Line ia.sinc:5032 XmmCondSD:	     is imm8     {
	xmmTmp1_Qa = cmpsd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
}
1: Constructor line ia.sinc:5032(id2735.8) printpiece=[]
Operands 0: imm8 : 2737  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[68:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]

Line ia.sinc:5022 XmmCondSD: "NLE"     is imm8=6     {
    xmmTmp1_Qa = zext( !(xmmTmp1_Qa f<= xmmTmp2_Qa) ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:5022(id2735.6) printpiece=[NLE]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template
	0: unique[59980:1] = FLOAT_LESSEQUAL register[1400:8], register[1410:8]
	1: unique[59a00:1] = BOOL_NEGATE unique[59980:1]
	2: unique[59a80:8] = INT_ZEXT unique[59a00:1]
	3: register[1400:8] = INT_MULT unique[59a80:8], const[ffffffffffffffff:8]

Line ia.sinc:5032 XmmCondSD:	     is imm8     {
	xmmTmp1_Qa = cmpsd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
}
1: Constructor line ia.sinc:5032(id2735.8) printpiece=[]
Operands 0: imm8 : 2737  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[68:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]

Line ia.sinc:5026 XmmCondSD: "ORD"     is imm8=7     {
    xmmTmp1_Qa = zext( !(nan(xmmTmp1_Qa) || nan(xmmTmp2_Qa)) ) * 0xFFFFFFFFFFFFFFFF;   
}
0: Constructor line ia.sinc:5026(id2735.7) printpiece=[ORD]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template
	0: unique[59b80:1] = FLOAT_NAN register[1400:8]
	1: unique[59c00:1] = FLOAT_NAN register[1410:8]
	2: unique[59c80:1] = BOOL_OR unique[59b80:1], unique[59c00:1]
	3: unique[59d00:1] = BOOL_NEGATE unique[59c80:1]
	4: unique[59d80:8] = INT_ZEXT unique[59d00:1]
	5: register[1400:8] = INT_MULT unique[59d80:8], const[ffffffffffffffff:8]

Line ia.sinc:5032 XmmCondSD:	     is imm8     {
	xmmTmp1_Qa = cmpsd(xmmTmp1_Qa, xmmTmp2_Qa, imm8:1);
}
1: Constructor line ia.sinc:5032(id2735.8) printpiece=[]
Operands 0: imm8 : 2737  
Pattern id=8 pattern=always
Template
	0: register[1400:8] = CALLOTHER const[68:4], register[1400:8], register[1410:8], [handle:space][[handle:offset]:1]

Line ia.sinc:5038 CMPSD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5038(id2738.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line ia.sinc:5039 CMPSD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5039(id2738.1) printpiece=[, ,  A]
Operands 0: imm8 : 2739  
Pattern id=1 pattern=always
Template

Line ia.sinc:5038 CMPSD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5038(id2738.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:01:XX:XX:XX
Template

Line ia.sinc:5039 CMPSD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5039(id2738.1) printpiece=[, ,  A]
Operands 0: imm8 : 2739  
Pattern id=1 pattern=always
Template

Line ia.sinc:5038 CMPSD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5038(id2738.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:02:XX:XX:XX
Template

Line ia.sinc:5039 CMPSD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5039(id2738.1) printpiece=[, ,  A]
Operands 0: imm8 : 2739  
Pattern id=1 pattern=always
Template

Line ia.sinc:5038 CMPSD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5038(id2738.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:03:XX:XX:XX
Template

Line ia.sinc:5039 CMPSD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5039(id2738.1) printpiece=[, ,  A]
Operands 0: imm8 : 2739  
Pattern id=1 pattern=always
Template

Line ia.sinc:5038 CMPSD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5038(id2738.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:04:XX:XX:XX
Template

Line ia.sinc:5039 CMPSD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5039(id2738.1) printpiece=[, ,  A]
Operands 0: imm8 : 2739  
Pattern id=1 pattern=always
Template

Line ia.sinc:5038 CMPSD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5038(id2738.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:05:XX:XX:XX
Template

Line ia.sinc:5039 CMPSD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5039(id2738.1) printpiece=[, ,  A]
Operands 0: imm8 : 2739  
Pattern id=1 pattern=always
Template

Line ia.sinc:5038 CMPSD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5038(id2738.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:06:XX:XX:XX
Template

Line ia.sinc:5039 CMPSD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5039(id2738.1) printpiece=[, ,  A]
Operands 0: imm8 : 2739  
Pattern id=1 pattern=always
Template

Line ia.sinc:5038 CMPSD_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5038(id2738.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:07:XX:XX:XX
Template

Line ia.sinc:5039 CMPSD_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5039(id2738.1) printpiece=[, ,  A]
Operands 0: imm8 : 2739  
Pattern id=1 pattern=always
Template

Line ia.sinc:5059 XmmCondSS: "EQ"      is imm8=0     { 
	xmmTmp1_Da = zext( xmmTmp1_Da f== xmmTmp2_Da ) * 0xFFFFFFFF;   
}
0: Constructor line ia.sinc:5059(id2748.0) printpiece=[EQ]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template
	0: unique[59f00:1] = FLOAT_EQUAL register[1400:4], register[1410:4]
	1: unique[59f80:4] = INT_ZEXT unique[59f00:1]
	2: register[1400:4] = INT_MULT unique[59f80:4], const[ffffffff:4]

Line ia.sinc:5093 XmmCondSS:	     is imm8     {
	xmmTmp1_Da = cmpss(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
}
1: Constructor line ia.sinc:5093(id2748.8) printpiece=[]
Operands 0: imm8 : 2750  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[69:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]

Line ia.sinc:5063 XmmCondSS: "LT"      is imm8=1     { 
	xmmTmp1_Da = zext( xmmTmp1_Da f< xmmTmp2_Da ) * 0xFFFFFFFF;   
}
0: Constructor line ia.sinc:5063(id2748.1) printpiece=[LT]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template
	0: unique[5a080:1] = FLOAT_LESS register[1400:4], register[1410:4]
	1: unique[5a100:4] = INT_ZEXT unique[5a080:1]
	2: register[1400:4] = INT_MULT unique[5a100:4], const[ffffffff:4]

Line ia.sinc:5093 XmmCondSS:	     is imm8     {
	xmmTmp1_Da = cmpss(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
}
1: Constructor line ia.sinc:5093(id2748.8) printpiece=[]
Operands 0: imm8 : 2750  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[69:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]

Line ia.sinc:5067 XmmCondSS: "LE"      is imm8=2     {
    xmmTmp1_Da = zext( xmmTmp1_Da f<= xmmTmp2_Da ) * 0xFFFFFFFF;   
}
0: Constructor line ia.sinc:5067(id2748.2) printpiece=[LE]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template
	0: unique[5a200:1] = FLOAT_LESSEQUAL register[1400:4], register[1410:4]
	1: unique[5a280:4] = INT_ZEXT unique[5a200:1]
	2: register[1400:4] = INT_MULT unique[5a280:4], const[ffffffff:4]

Line ia.sinc:5093 XmmCondSS:	     is imm8     {
	xmmTmp1_Da = cmpss(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
}
1: Constructor line ia.sinc:5093(id2748.8) printpiece=[]
Operands 0: imm8 : 2750  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[69:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]

Line ia.sinc:5071 XmmCondSS: "UNORD"   is imm8=3     {
    xmmTmp1_Da = zext( nan(xmmTmp1_Da) || nan(xmmTmp2_Da) ) * 0xFFFFFFFF;   
}
0: Constructor line ia.sinc:5071(id2748.3) printpiece=[UNORD]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template
	0: unique[5a380:1] = FLOAT_NAN register[1400:4]
	1: unique[5a400:1] = FLOAT_NAN register[1410:4]
	2: unique[5a480:1] = BOOL_OR unique[5a380:1], unique[5a400:1]
	3: unique[5a500:4] = INT_ZEXT unique[5a480:1]
	4: register[1400:4] = INT_MULT unique[5a500:4], const[ffffffff:4]

Line ia.sinc:5093 XmmCondSS:	     is imm8     {
	xmmTmp1_Da = cmpss(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
}
1: Constructor line ia.sinc:5093(id2748.8) printpiece=[]
Operands 0: imm8 : 2750  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[69:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]

Line ia.sinc:5075 XmmCondSS: "NEQ"     is imm8=4     {
    xmmTmp1_Da = zext( xmmTmp1_Da f!= xmmTmp2_Da ) * 0xFFFFFFFF;   
}
0: Constructor line ia.sinc:5075(id2748.4) printpiece=[NEQ]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template
	0: unique[5a600:1] = FLOAT_NOTEQUAL register[1400:4], register[1410:4]
	1: unique[5a680:4] = INT_ZEXT unique[5a600:1]
	2: register[1400:4] = INT_MULT unique[5a680:4], const[ffffffff:4]

Line ia.sinc:5093 XmmCondSS:	     is imm8     {
	xmmTmp1_Da = cmpss(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
}
1: Constructor line ia.sinc:5093(id2748.8) printpiece=[]
Operands 0: imm8 : 2750  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[69:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]

Line ia.sinc:5079 XmmCondSS: "NLT"     is imm8=5     {
    xmmTmp1_Da = zext( !(xmmTmp1_Da f< xmmTmp2_Da) ) * 0xFFFFFFFF;   
}
0: Constructor line ia.sinc:5079(id2748.5) printpiece=[NLT]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template
	0: unique[5a780:1] = FLOAT_LESS register[1400:4], register[1410:4]
	1: unique[5a800:1] = BOOL_NEGATE unique[5a780:1]
	2: unique[5a880:4] = INT_ZEXT unique[5a800:1]
	3: register[1400:4] = INT_MULT unique[5a880:4], const[ffffffff:4]

Line ia.sinc:5093 XmmCondSS:	     is imm8     {
	xmmTmp1_Da = cmpss(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
}
1: Constructor line ia.sinc:5093(id2748.8) printpiece=[]
Operands 0: imm8 : 2750  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[69:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]

Line ia.sinc:5083 XmmCondSS: "NLE"     is imm8=6     {
    xmmTmp1_Da = zext( !(xmmTmp1_Da f<= xmmTmp2_Da) ) * 0xFFFFFFFF;   
}
0: Constructor line ia.sinc:5083(id2748.6) printpiece=[NLE]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template
	0: unique[5a980:1] = FLOAT_LESSEQUAL register[1400:4], register[1410:4]
	1: unique[5aa00:1] = BOOL_NEGATE unique[5a980:1]
	2: unique[5aa80:4] = INT_ZEXT unique[5aa00:1]
	3: register[1400:4] = INT_MULT unique[5aa80:4], const[ffffffff:4]

Line ia.sinc:5093 XmmCondSS:	     is imm8     {
	xmmTmp1_Da = cmpss(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
}
1: Constructor line ia.sinc:5093(id2748.8) printpiece=[]
Operands 0: imm8 : 2750  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[69:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]

Line ia.sinc:5087 XmmCondSS: "ORD"     is imm8=7     {
    xmmTmp1_Da = zext( !(nan(xmmTmp1_Da) || nan(xmmTmp2_Da)) ) * 0xFFFFFFFF;   
}
0: Constructor line ia.sinc:5087(id2748.7) printpiece=[ORD]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template
	0: unique[5ab80:1] = FLOAT_NAN register[1400:4]
	1: unique[5ac00:1] = FLOAT_NAN register[1410:4]
	2: unique[5ac80:1] = BOOL_OR unique[5ab80:1], unique[5ac00:1]
	3: unique[5ad00:1] = BOOL_NEGATE unique[5ac80:1]
	4: unique[5ad80:4] = INT_ZEXT unique[5ad00:1]
	5: register[1400:4] = INT_MULT unique[5ad80:4], const[ffffffff:4]

Line ia.sinc:5093 XmmCondSS:	     is imm8     {
	xmmTmp1_Da = cmpss(xmmTmp1_Da, xmmTmp2_Da, imm8:1);
}
1: Constructor line ia.sinc:5093(id2748.8) printpiece=[]
Operands 0: imm8 : 2750  
Pattern id=8 pattern=always
Template
	0: register[1400:4] = CALLOTHER const[69:4], register[1400:4], register[1410:4], [handle:space][[handle:offset]:1]

Line ia.sinc:5099 CMPSS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5099(id2751.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line ia.sinc:5100 CMPSS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5100(id2751.1) printpiece=[, ,  A]
Operands 0: imm8 : 2752  
Pattern id=1 pattern=always
Template

Line ia.sinc:5099 CMPSS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5099(id2751.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:01:XX:XX:XX
Template

Line ia.sinc:5100 CMPSS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5100(id2751.1) printpiece=[, ,  A]
Operands 0: imm8 : 2752  
Pattern id=1 pattern=always
Template

Line ia.sinc:5099 CMPSS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5099(id2751.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:02:XX:XX:XX
Template

Line ia.sinc:5100 CMPSS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5100(id2751.1) printpiece=[, ,  A]
Operands 0: imm8 : 2752  
Pattern id=1 pattern=always
Template

Line ia.sinc:5099 CMPSS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5099(id2751.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:03:XX:XX:XX
Template

Line ia.sinc:5100 CMPSS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5100(id2751.1) printpiece=[, ,  A]
Operands 0: imm8 : 2752  
Pattern id=1 pattern=always
Template

Line ia.sinc:5099 CMPSS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5099(id2751.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:04:XX:XX:XX
Template

Line ia.sinc:5100 CMPSS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5100(id2751.1) printpiece=[, ,  A]
Operands 0: imm8 : 2752  
Pattern id=1 pattern=always
Template

Line ia.sinc:5099 CMPSS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5099(id2751.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:05:XX:XX:XX
Template

Line ia.sinc:5100 CMPSS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5100(id2751.1) printpiece=[, ,  A]
Operands 0: imm8 : 2752  
Pattern id=1 pattern=always
Template

Line ia.sinc:5099 CMPSS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5099(id2751.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:06:XX:XX:XX
Template

Line ia.sinc:5100 CMPSS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5100(id2751.1) printpiece=[, ,  A]
Operands 0: imm8 : 2752  
Pattern id=1 pattern=always
Template

Line ia.sinc:5099 CMPSS_OPERAND:           is imm8<8 { }
0: Constructor line ia.sinc:5099(id2751.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:07:XX:XX:XX
Template

Line ia.sinc:5100 CMPSS_OPERAND: ", "^imm8 is imm8   { }
1: Constructor line ia.sinc:5100(id2751.1) printpiece=[, ,  A]
Operands 0: imm8 : 2752  
Pattern id=1 pattern=always
Template

Line ia.sinc:7183 Order0: order0  is imm8 [ order0 = ( imm8       & 0x3); ] { export *[const]:1 order0; }
0: Constructor line ia.sinc:7183(id3516.0) printpiece=[ B]
Operands 0: imm8 : 3518  1: order0 : 3517  
Pattern id=0 pattern=always
Template

Line ia.sinc:7184 Order1: order1  is imm8 [ order1 = ((imm8 >> 2) & 0x3); ] { export *[const]:1 order1; }
0: Constructor line ia.sinc:7184(id3519.0) printpiece=[ B]
Operands 0: imm8 : 3521  1: order1 : 3520  
Pattern id=0 pattern=always
Template

Line ia.sinc:7185 Order2: order2  is imm8 [ order2 = ((imm8 >> 4) & 0x3); ] { export *[const]:1 order2; }
0: Constructor line ia.sinc:7185(id3522.0) printpiece=[ B]
Operands 0: imm8 : 3524  1: order2 : 3523  
Pattern id=0 pattern=always
Template

Line ia.sinc:7186 Order3: order3  is imm8 [ order3 = ((imm8 >> 6) & 0x3); ] { export *[const]:1 order3; }
0: Constructor line ia.sinc:7186(id3525.0) printpiece=[ B]
Operands 0: imm8 : 3527  1: order3 : 3526  
Pattern id=0 pattern=always
Template

Line avx.sinc:216 VCMPPD_mon: "VCMPEQPD" is imm8=0x0 { }
0: Constructor line avx.sinc:216(id4531.0) printpiece=[VCMPEQPD]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:218 VCMPPD_mon: "VCMPLTPD" is imm8=0x1 { }
0: Constructor line avx.sinc:218(id4531.1) printpiece=[VCMPLTPD]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:220 VCMPPD_mon: "VCMPLEPD" is imm8=0x2 { }
0: Constructor line avx.sinc:220(id4531.2) printpiece=[VCMPLEPD]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:222 VCMPPD_mon: "VCMPUNORDPD" is imm8=0x3 { }
0: Constructor line avx.sinc:222(id4531.3) printpiece=[VCMPUNORDPD]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:224 VCMPPD_mon: "VCMPNEQPD" is imm8=0x4 { }
0: Constructor line avx.sinc:224(id4531.4) printpiece=[VCMPNEQPD]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:226 VCMPPD_mon: "VCMPNLTPD" is imm8=0x5 { }
0: Constructor line avx.sinc:226(id4531.5) printpiece=[VCMPNLTPD]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:228 VCMPPD_mon: "VCMPNLEPD" is imm8=0x6 { }
0: Constructor line avx.sinc:228(id4531.6) printpiece=[VCMPNLEPD]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:230 VCMPPD_mon: "VCMPORDPD" is imm8=0x7 { }
0: Constructor line avx.sinc:230(id4531.7) printpiece=[VCMPORDPD]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:232 VCMPPD_mon: "VCMPEQ_UQPD" is imm8=0x8 { }
0: Constructor line avx.sinc:232(id4531.8) printpiece=[VCMPEQ_UQPD]
Operands 
Pattern id=8 pattern=ins:08:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:234 VCMPPD_mon: "VCMPNGEPD" is imm8=0x9 { }
0: Constructor line avx.sinc:234(id4531.9) printpiece=[VCMPNGEPD]
Operands 
Pattern id=9 pattern=ins:09:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:236 VCMPPD_mon: "VCMPNGTPD" is imm8=0xa { }
0: Constructor line avx.sinc:236(id4531.10) printpiece=[VCMPNGTPD]
Operands 
Pattern id=10 pattern=ins:0A:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:238 VCMPPD_mon: "VCMPFALSEPD" is imm8=0xb { }
0: Constructor line avx.sinc:238(id4531.11) printpiece=[VCMPFALSEPD]
Operands 
Pattern id=11 pattern=ins:0B:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:240 VCMPPD_mon: "VCMPNEQ_OQPD" is imm8=0xc { }
0: Constructor line avx.sinc:240(id4531.12) printpiece=[VCMPNEQ_OQPD]
Operands 
Pattern id=12 pattern=ins:0C:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:242 VCMPPD_mon: "VCMPGEPD" is imm8=0xd { }
0: Constructor line avx.sinc:242(id4531.13) printpiece=[VCMPGEPD]
Operands 
Pattern id=13 pattern=ins:0D:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:244 VCMPPD_mon: "VCMPGTPD" is imm8=0xe { }
0: Constructor line avx.sinc:244(id4531.14) printpiece=[VCMPGTPD]
Operands 
Pattern id=14 pattern=ins:0E:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:246 VCMPPD_mon: "VCMPTRUEPD" is imm8=0xf { }
0: Constructor line avx.sinc:246(id4531.15) printpiece=[VCMPTRUEPD]
Operands 
Pattern id=15 pattern=ins:0F:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:248 VCMPPD_mon: "VCMPEQ_OSPD" is imm8=0x10 { }
0: Constructor line avx.sinc:248(id4531.16) printpiece=[VCMPEQ_OSPD]
Operands 
Pattern id=16 pattern=ins:10:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:250 VCMPPD_mon: "VCMPLT_OQPD" is imm8=0x11 { }
0: Constructor line avx.sinc:250(id4531.17) printpiece=[VCMPLT_OQPD]
Operands 
Pattern id=17 pattern=ins:11:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:252 VCMPPD_mon: "VCMPLE_OQPD" is imm8=0x12 { }
0: Constructor line avx.sinc:252(id4531.18) printpiece=[VCMPLE_OQPD]
Operands 
Pattern id=18 pattern=ins:12:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:254 VCMPPD_mon: "VCMPUNORD_SPD" is imm8=0x13 { }
0: Constructor line avx.sinc:254(id4531.19) printpiece=[VCMPUNORD_SPD]
Operands 
Pattern id=19 pattern=ins:13:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:256 VCMPPD_mon: "VCMPNEQ_USPD" is imm8=0x14 { }
0: Constructor line avx.sinc:256(id4531.20) printpiece=[VCMPNEQ_USPD]
Operands 
Pattern id=20 pattern=ins:14:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:258 VCMPPD_mon: "VCMPNLT_UQPD" is imm8=0x15 { }
0: Constructor line avx.sinc:258(id4531.21) printpiece=[VCMPNLT_UQPD]
Operands 
Pattern id=21 pattern=ins:15:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:260 VCMPPD_mon: "VCMPNLE_UQPD" is imm8=0x16 { }
0: Constructor line avx.sinc:260(id4531.22) printpiece=[VCMPNLE_UQPD]
Operands 
Pattern id=22 pattern=ins:16:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:262 VCMPPD_mon: "VCMPORD_SPD" is imm8=0x17 { }
0: Constructor line avx.sinc:262(id4531.23) printpiece=[VCMPORD_SPD]
Operands 
Pattern id=23 pattern=ins:17:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:264 VCMPPD_mon: "VCMPEQ_USPD" is imm8=0x18 { }
0: Constructor line avx.sinc:264(id4531.24) printpiece=[VCMPEQ_USPD]
Operands 
Pattern id=24 pattern=ins:18:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:266 VCMPPD_mon: "VCMPNGE_UQPD" is imm8=0x19 { }
0: Constructor line avx.sinc:266(id4531.25) printpiece=[VCMPNGE_UQPD]
Operands 
Pattern id=25 pattern=ins:19:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:268 VCMPPD_mon: "VCMPNGT_UQPD" is imm8=0x1a { }
0: Constructor line avx.sinc:268(id4531.26) printpiece=[VCMPNGT_UQPD]
Operands 
Pattern id=26 pattern=ins:1A:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:270 VCMPPD_mon: "VCMPFALSE_OSPD" is imm8=0x1b { }
0: Constructor line avx.sinc:270(id4531.27) printpiece=[VCMPFALSE_OSPD]
Operands 
Pattern id=27 pattern=ins:1B:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:272 VCMPPD_mon: "VCMPNEQ_OSPD" is imm8=0x1c { }
0: Constructor line avx.sinc:272(id4531.28) printpiece=[VCMPNEQ_OSPD]
Operands 
Pattern id=28 pattern=ins:1C:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:274 VCMPPD_mon: "VCMPGE_OQPD" is imm8=0x1d { }
0: Constructor line avx.sinc:274(id4531.29) printpiece=[VCMPGE_OQPD]
Operands 
Pattern id=29 pattern=ins:1D:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:276 VCMPPD_mon: "VCMPGT_OQPD" is imm8=0x1e { }
0: Constructor line avx.sinc:276(id4531.30) printpiece=[VCMPGT_OQPD]
Operands 
Pattern id=30 pattern=ins:1E:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:278 VCMPPD_mon: "VCMPTRUE_USPD" is imm8=0x1f { }
0: Constructor line avx.sinc:278(id4531.31) printpiece=[VCMPTRUE_USPD]
Operands 
Pattern id=31 pattern=ins:1F:XX:XX:XX
Template

Line avx.sinc:280 VCMPPD_mon: "VCMPPD" is imm8 { }
1: Constructor line avx.sinc:280(id4531.32) printpiece=[VCMPPD]
Operands 0: imm8 : 4533  
Pattern id=32 pattern=always
Template

Line avx.sinc:217 VCMPPD_op: "" is imm8=0x0 { export 0x0:1; }
0: Constructor line avx.sinc:217(id4532.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:219 VCMPPD_op: "" is imm8=0x1 { export 0x1:1; }
0: Constructor line avx.sinc:219(id4532.1) printpiece=[]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:221 VCMPPD_op: "" is imm8=0x2 { export 0x2:1; }
0: Constructor line avx.sinc:221(id4532.2) printpiece=[]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:223 VCMPPD_op: "" is imm8=0x3 { export 0x3:1; }
0: Constructor line avx.sinc:223(id4532.3) printpiece=[]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:225 VCMPPD_op: "" is imm8=0x4 { export 0x4:1; }
0: Constructor line avx.sinc:225(id4532.4) printpiece=[]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:227 VCMPPD_op: "" is imm8=0x5 { export 0x5:1; }
0: Constructor line avx.sinc:227(id4532.5) printpiece=[]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:229 VCMPPD_op: "" is imm8=0x6 { export 0x6:1; }
0: Constructor line avx.sinc:229(id4532.6) printpiece=[]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:231 VCMPPD_op: "" is imm8=0x7 { export 0x7:1; }
0: Constructor line avx.sinc:231(id4532.7) printpiece=[]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:233 VCMPPD_op: "" is imm8=0x8 { export 0x8:1; }
0: Constructor line avx.sinc:233(id4532.8) printpiece=[]
Operands 
Pattern id=8 pattern=ins:08:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:235 VCMPPD_op: "" is imm8=0x9 { export 0x9:1; }
0: Constructor line avx.sinc:235(id4532.9) printpiece=[]
Operands 
Pattern id=9 pattern=ins:09:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:237 VCMPPD_op: "" is imm8=0xa { export 0xa:1; }
0: Constructor line avx.sinc:237(id4532.10) printpiece=[]
Operands 
Pattern id=10 pattern=ins:0A:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:239 VCMPPD_op: "" is imm8=0xb { export 0xb:1; }
0: Constructor line avx.sinc:239(id4532.11) printpiece=[]
Operands 
Pattern id=11 pattern=ins:0B:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:241 VCMPPD_op: "" is imm8=0xc { export 0xc:1; }
0: Constructor line avx.sinc:241(id4532.12) printpiece=[]
Operands 
Pattern id=12 pattern=ins:0C:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:243 VCMPPD_op: "" is imm8=0xd { export 0xd:1; }
0: Constructor line avx.sinc:243(id4532.13) printpiece=[]
Operands 
Pattern id=13 pattern=ins:0D:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:245 VCMPPD_op: "" is imm8=0xe { export 0xe:1; }
0: Constructor line avx.sinc:245(id4532.14) printpiece=[]
Operands 
Pattern id=14 pattern=ins:0E:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:247 VCMPPD_op: "" is imm8=0xf { export 0xf:1; }
0: Constructor line avx.sinc:247(id4532.15) printpiece=[]
Operands 
Pattern id=15 pattern=ins:0F:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:249 VCMPPD_op: "" is imm8=0x10 { export 0x10:1; }
0: Constructor line avx.sinc:249(id4532.16) printpiece=[]
Operands 
Pattern id=16 pattern=ins:10:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:251 VCMPPD_op: "" is imm8=0x11 { export 0x11:1; }
0: Constructor line avx.sinc:251(id4532.17) printpiece=[]
Operands 
Pattern id=17 pattern=ins:11:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:253 VCMPPD_op: "" is imm8=0x12 { export 0x12:1; }
0: Constructor line avx.sinc:253(id4532.18) printpiece=[]
Operands 
Pattern id=18 pattern=ins:12:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:255 VCMPPD_op: "" is imm8=0x13 { export 0x13:1; }
0: Constructor line avx.sinc:255(id4532.19) printpiece=[]
Operands 
Pattern id=19 pattern=ins:13:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:257 VCMPPD_op: "" is imm8=0x14 { export 0x14:1; }
0: Constructor line avx.sinc:257(id4532.20) printpiece=[]
Operands 
Pattern id=20 pattern=ins:14:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:259 VCMPPD_op: "" is imm8=0x15 { export 0x15:1; }
0: Constructor line avx.sinc:259(id4532.21) printpiece=[]
Operands 
Pattern id=21 pattern=ins:15:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:261 VCMPPD_op: "" is imm8=0x16 { export 0x16:1; }
0: Constructor line avx.sinc:261(id4532.22) printpiece=[]
Operands 
Pattern id=22 pattern=ins:16:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:263 VCMPPD_op: "" is imm8=0x17 { export 0x17:1; }
0: Constructor line avx.sinc:263(id4532.23) printpiece=[]
Operands 
Pattern id=23 pattern=ins:17:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:265 VCMPPD_op: "" is imm8=0x18 { export 0x18:1; }
0: Constructor line avx.sinc:265(id4532.24) printpiece=[]
Operands 
Pattern id=24 pattern=ins:18:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:267 VCMPPD_op: "" is imm8=0x19 { export 0x19:1; }
0: Constructor line avx.sinc:267(id4532.25) printpiece=[]
Operands 
Pattern id=25 pattern=ins:19:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:269 VCMPPD_op: "" is imm8=0x1a { export 0x1a:1; }
0: Constructor line avx.sinc:269(id4532.26) printpiece=[]
Operands 
Pattern id=26 pattern=ins:1A:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:271 VCMPPD_op: "" is imm8=0x1b { export 0x1b:1; }
0: Constructor line avx.sinc:271(id4532.27) printpiece=[]
Operands 
Pattern id=27 pattern=ins:1B:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:273 VCMPPD_op: "" is imm8=0x1c { export 0x1c:1; }
0: Constructor line avx.sinc:273(id4532.28) printpiece=[]
Operands 
Pattern id=28 pattern=ins:1C:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:275 VCMPPD_op: "" is imm8=0x1d { export 0x1d:1; }
0: Constructor line avx.sinc:275(id4532.29) printpiece=[]
Operands 
Pattern id=29 pattern=ins:1D:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:277 VCMPPD_op: "" is imm8=0x1e { export 0x1e:1; }
0: Constructor line avx.sinc:277(id4532.30) printpiece=[]
Operands 
Pattern id=30 pattern=ins:1E:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:279 VCMPPD_op: "" is imm8=0x1f { export 0x1f:1; }
0: Constructor line avx.sinc:279(id4532.31) printpiece=[]
Operands 
Pattern id=31 pattern=ins:1F:XX:XX:XX
Template

Line avx.sinc:281 VCMPPD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:281(id4532.32) printpiece=[, ,  A]
Operands 0: imm8 : 4534  
Pattern id=32 pattern=always
Template

Line avx.sinc:298 VCMPPS_mon: "VCMPEQPS" is imm8=0x0 { }
0: Constructor line avx.sinc:298(id4549.0) printpiece=[VCMPEQPS]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:300 VCMPPS_mon: "VCMPLTPS" is imm8=0x1 { }
0: Constructor line avx.sinc:300(id4549.1) printpiece=[VCMPLTPS]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:302 VCMPPS_mon: "VCMPLEPS" is imm8=0x2 { }
0: Constructor line avx.sinc:302(id4549.2) printpiece=[VCMPLEPS]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:304 VCMPPS_mon: "VCMPUNORDPS" is imm8=0x3 { }
0: Constructor line avx.sinc:304(id4549.3) printpiece=[VCMPUNORDPS]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:306 VCMPPS_mon: "VCMPNEQPS" is imm8=0x4 { }
0: Constructor line avx.sinc:306(id4549.4) printpiece=[VCMPNEQPS]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:308 VCMPPS_mon: "VCMPNLTPS" is imm8=0x5 { }
0: Constructor line avx.sinc:308(id4549.5) printpiece=[VCMPNLTPS]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:310 VCMPPS_mon: "VCMPNLEPS" is imm8=0x6 { }
0: Constructor line avx.sinc:310(id4549.6) printpiece=[VCMPNLEPS]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:312 VCMPPS_mon: "VCMPORDPS" is imm8=0x7 { }
0: Constructor line avx.sinc:312(id4549.7) printpiece=[VCMPORDPS]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:314 VCMPPS_mon: "VCMPEQ_UQPS" is imm8=0x8 { }
0: Constructor line avx.sinc:314(id4549.8) printpiece=[VCMPEQ_UQPS]
Operands 
Pattern id=8 pattern=ins:08:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:316 VCMPPS_mon: "VCMPNGEPS" is imm8=0x9 { }
0: Constructor line avx.sinc:316(id4549.9) printpiece=[VCMPNGEPS]
Operands 
Pattern id=9 pattern=ins:09:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:318 VCMPPS_mon: "VCMPNGTPS" is imm8=0xa { }
0: Constructor line avx.sinc:318(id4549.10) printpiece=[VCMPNGTPS]
Operands 
Pattern id=10 pattern=ins:0A:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:320 VCMPPS_mon: "VCMPFALSEPS" is imm8=0xb { }
0: Constructor line avx.sinc:320(id4549.11) printpiece=[VCMPFALSEPS]
Operands 
Pattern id=11 pattern=ins:0B:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:322 VCMPPS_mon: "VCMPNEQ_OQPS" is imm8=0xc { }
0: Constructor line avx.sinc:322(id4549.12) printpiece=[VCMPNEQ_OQPS]
Operands 
Pattern id=12 pattern=ins:0C:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:324 VCMPPS_mon: "VCMPGEPS" is imm8=0xd { }
0: Constructor line avx.sinc:324(id4549.13) printpiece=[VCMPGEPS]
Operands 
Pattern id=13 pattern=ins:0D:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:326 VCMPPS_mon: "VCMPGTPS" is imm8=0xe { }
0: Constructor line avx.sinc:326(id4549.14) printpiece=[VCMPGTPS]
Operands 
Pattern id=14 pattern=ins:0E:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:328 VCMPPS_mon: "VCMPTRUEPS" is imm8=0xf { }
0: Constructor line avx.sinc:328(id4549.15) printpiece=[VCMPTRUEPS]
Operands 
Pattern id=15 pattern=ins:0F:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:330 VCMPPS_mon: "VCMPEQ_OSPS" is imm8=0x10 { }
0: Constructor line avx.sinc:330(id4549.16) printpiece=[VCMPEQ_OSPS]
Operands 
Pattern id=16 pattern=ins:10:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:332 VCMPPS_mon: "VCMPLT_OQPS" is imm8=0x11 { }
0: Constructor line avx.sinc:332(id4549.17) printpiece=[VCMPLT_OQPS]
Operands 
Pattern id=17 pattern=ins:11:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:334 VCMPPS_mon: "VCMPLE_OQPS" is imm8=0x12 { }
0: Constructor line avx.sinc:334(id4549.18) printpiece=[VCMPLE_OQPS]
Operands 
Pattern id=18 pattern=ins:12:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:336 VCMPPS_mon: "VCMPUNORD_SPS" is imm8=0x13 { }
0: Constructor line avx.sinc:336(id4549.19) printpiece=[VCMPUNORD_SPS]
Operands 
Pattern id=19 pattern=ins:13:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:338 VCMPPS_mon: "VCMPNEQ_USPS" is imm8=0x14 { }
0: Constructor line avx.sinc:338(id4549.20) printpiece=[VCMPNEQ_USPS]
Operands 
Pattern id=20 pattern=ins:14:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:340 VCMPPS_mon: "VCMPNLT_UQPS" is imm8=0x15 { }
0: Constructor line avx.sinc:340(id4549.21) printpiece=[VCMPNLT_UQPS]
Operands 
Pattern id=21 pattern=ins:15:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:342 VCMPPS_mon: "VCMPNLE_UQPS" is imm8=0x16 { }
0: Constructor line avx.sinc:342(id4549.22) printpiece=[VCMPNLE_UQPS]
Operands 
Pattern id=22 pattern=ins:16:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:344 VCMPPS_mon: "VCMPORD_SPS" is imm8=0x17 { }
0: Constructor line avx.sinc:344(id4549.23) printpiece=[VCMPORD_SPS]
Operands 
Pattern id=23 pattern=ins:17:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:346 VCMPPS_mon: "VCMPEQ_USPS" is imm8=0x18 { }
0: Constructor line avx.sinc:346(id4549.24) printpiece=[VCMPEQ_USPS]
Operands 
Pattern id=24 pattern=ins:18:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:348 VCMPPS_mon: "VCMPNGE_UQPS" is imm8=0x19 { }
0: Constructor line avx.sinc:348(id4549.25) printpiece=[VCMPNGE_UQPS]
Operands 
Pattern id=25 pattern=ins:19:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:350 VCMPPS_mon: "VCMPNGT_UQPS" is imm8=0x1a { }
0: Constructor line avx.sinc:350(id4549.26) printpiece=[VCMPNGT_UQPS]
Operands 
Pattern id=26 pattern=ins:1A:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:352 VCMPPS_mon: "VCMPFALSE_OSPS" is imm8=0x1b { }
0: Constructor line avx.sinc:352(id4549.27) printpiece=[VCMPFALSE_OSPS]
Operands 
Pattern id=27 pattern=ins:1B:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:354 VCMPPS_mon: "VCMPNEQ_OSPS" is imm8=0x1c { }
0: Constructor line avx.sinc:354(id4549.28) printpiece=[VCMPNEQ_OSPS]
Operands 
Pattern id=28 pattern=ins:1C:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:356 VCMPPS_mon: "VCMPGE_OQPS" is imm8=0x1d { }
0: Constructor line avx.sinc:356(id4549.29) printpiece=[VCMPGE_OQPS]
Operands 
Pattern id=29 pattern=ins:1D:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:358 VCMPPS_mon: "VCMPGT_OQPS" is imm8=0x1e { }
0: Constructor line avx.sinc:358(id4549.30) printpiece=[VCMPGT_OQPS]
Operands 
Pattern id=30 pattern=ins:1E:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:360 VCMPPS_mon: "VCMPTRUE_USPS" is imm8=0x1f { }
0: Constructor line avx.sinc:360(id4549.31) printpiece=[VCMPTRUE_USPS]
Operands 
Pattern id=31 pattern=ins:1F:XX:XX:XX
Template

Line avx.sinc:362 VCMPPS_mon: "VCMPPS" is imm8 { }
1: Constructor line avx.sinc:362(id4549.32) printpiece=[VCMPPS]
Operands 0: imm8 : 4551  
Pattern id=32 pattern=always
Template

Line avx.sinc:299 VCMPPS_op: "" is imm8=0x0 { export 0x0:1; }
0: Constructor line avx.sinc:299(id4550.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:301 VCMPPS_op: "" is imm8=0x1 { export 0x1:1; }
0: Constructor line avx.sinc:301(id4550.1) printpiece=[]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:303 VCMPPS_op: "" is imm8=0x2 { export 0x2:1; }
0: Constructor line avx.sinc:303(id4550.2) printpiece=[]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:305 VCMPPS_op: "" is imm8=0x3 { export 0x3:1; }
0: Constructor line avx.sinc:305(id4550.3) printpiece=[]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:307 VCMPPS_op: "" is imm8=0x4 { export 0x4:1; }
0: Constructor line avx.sinc:307(id4550.4) printpiece=[]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:309 VCMPPS_op: "" is imm8=0x5 { export 0x5:1; }
0: Constructor line avx.sinc:309(id4550.5) printpiece=[]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:311 VCMPPS_op: "" is imm8=0x6 { export 0x6:1; }
0: Constructor line avx.sinc:311(id4550.6) printpiece=[]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:313 VCMPPS_op: "" is imm8=0x7 { export 0x7:1; }
0: Constructor line avx.sinc:313(id4550.7) printpiece=[]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:315 VCMPPS_op: "" is imm8=0x8 { export 0x8:1; }
0: Constructor line avx.sinc:315(id4550.8) printpiece=[]
Operands 
Pattern id=8 pattern=ins:08:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:317 VCMPPS_op: "" is imm8=0x9 { export 0x9:1; }
0: Constructor line avx.sinc:317(id4550.9) printpiece=[]
Operands 
Pattern id=9 pattern=ins:09:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:319 VCMPPS_op: "" is imm8=0xa { export 0xa:1; }
0: Constructor line avx.sinc:319(id4550.10) printpiece=[]
Operands 
Pattern id=10 pattern=ins:0A:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:321 VCMPPS_op: "" is imm8=0xb { export 0xb:1; }
0: Constructor line avx.sinc:321(id4550.11) printpiece=[]
Operands 
Pattern id=11 pattern=ins:0B:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:323 VCMPPS_op: "" is imm8=0xc { export 0xc:1; }
0: Constructor line avx.sinc:323(id4550.12) printpiece=[]
Operands 
Pattern id=12 pattern=ins:0C:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:325 VCMPPS_op: "" is imm8=0xd { export 0xd:1; }
0: Constructor line avx.sinc:325(id4550.13) printpiece=[]
Operands 
Pattern id=13 pattern=ins:0D:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:327 VCMPPS_op: "" is imm8=0xe { export 0xe:1; }
0: Constructor line avx.sinc:327(id4550.14) printpiece=[]
Operands 
Pattern id=14 pattern=ins:0E:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:329 VCMPPS_op: "" is imm8=0xf { export 0xf:1; }
0: Constructor line avx.sinc:329(id4550.15) printpiece=[]
Operands 
Pattern id=15 pattern=ins:0F:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:331 VCMPPS_op: "" is imm8=0x10 { export 0x10:1; }
0: Constructor line avx.sinc:331(id4550.16) printpiece=[]
Operands 
Pattern id=16 pattern=ins:10:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:333 VCMPPS_op: "" is imm8=0x11 { export 0x11:1; }
0: Constructor line avx.sinc:333(id4550.17) printpiece=[]
Operands 
Pattern id=17 pattern=ins:11:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:335 VCMPPS_op: "" is imm8=0x12 { export 0x12:1; }
0: Constructor line avx.sinc:335(id4550.18) printpiece=[]
Operands 
Pattern id=18 pattern=ins:12:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:337 VCMPPS_op: "" is imm8=0x13 { export 0x13:1; }
0: Constructor line avx.sinc:337(id4550.19) printpiece=[]
Operands 
Pattern id=19 pattern=ins:13:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:339 VCMPPS_op: "" is imm8=0x14 { export 0x14:1; }
0: Constructor line avx.sinc:339(id4550.20) printpiece=[]
Operands 
Pattern id=20 pattern=ins:14:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:341 VCMPPS_op: "" is imm8=0x15 { export 0x15:1; }
0: Constructor line avx.sinc:341(id4550.21) printpiece=[]
Operands 
Pattern id=21 pattern=ins:15:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:343 VCMPPS_op: "" is imm8=0x16 { export 0x16:1; }
0: Constructor line avx.sinc:343(id4550.22) printpiece=[]
Operands 
Pattern id=22 pattern=ins:16:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:345 VCMPPS_op: "" is imm8=0x17 { export 0x17:1; }
0: Constructor line avx.sinc:345(id4550.23) printpiece=[]
Operands 
Pattern id=23 pattern=ins:17:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:347 VCMPPS_op: "" is imm8=0x18 { export 0x18:1; }
0: Constructor line avx.sinc:347(id4550.24) printpiece=[]
Operands 
Pattern id=24 pattern=ins:18:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:349 VCMPPS_op: "" is imm8=0x19 { export 0x19:1; }
0: Constructor line avx.sinc:349(id4550.25) printpiece=[]
Operands 
Pattern id=25 pattern=ins:19:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:351 VCMPPS_op: "" is imm8=0x1a { export 0x1a:1; }
0: Constructor line avx.sinc:351(id4550.26) printpiece=[]
Operands 
Pattern id=26 pattern=ins:1A:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:353 VCMPPS_op: "" is imm8=0x1b { export 0x1b:1; }
0: Constructor line avx.sinc:353(id4550.27) printpiece=[]
Operands 
Pattern id=27 pattern=ins:1B:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:355 VCMPPS_op: "" is imm8=0x1c { export 0x1c:1; }
0: Constructor line avx.sinc:355(id4550.28) printpiece=[]
Operands 
Pattern id=28 pattern=ins:1C:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:357 VCMPPS_op: "" is imm8=0x1d { export 0x1d:1; }
0: Constructor line avx.sinc:357(id4550.29) printpiece=[]
Operands 
Pattern id=29 pattern=ins:1D:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:359 VCMPPS_op: "" is imm8=0x1e { export 0x1e:1; }
0: Constructor line avx.sinc:359(id4550.30) printpiece=[]
Operands 
Pattern id=30 pattern=ins:1E:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:361 VCMPPS_op: "" is imm8=0x1f { export 0x1f:1; }
0: Constructor line avx.sinc:361(id4550.31) printpiece=[]
Operands 
Pattern id=31 pattern=ins:1F:XX:XX:XX
Template

Line avx.sinc:363 VCMPPS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:363(id4550.32) printpiece=[, ,  A]
Operands 0: imm8 : 4552  
Pattern id=32 pattern=always
Template

Line avx.sinc:380 VCMPSD_mon: "VCMPEQSD" is imm8=0x0 { }
0: Constructor line avx.sinc:380(id4567.0) printpiece=[VCMPEQSD]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:382 VCMPSD_mon: "VCMPLTSD" is imm8=0x1 { }
0: Constructor line avx.sinc:382(id4567.1) printpiece=[VCMPLTSD]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:384 VCMPSD_mon: "VCMPLESD" is imm8=0x2 { }
0: Constructor line avx.sinc:384(id4567.2) printpiece=[VCMPLESD]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:386 VCMPSD_mon: "VCMPUNORDSD" is imm8=0x3 { }
0: Constructor line avx.sinc:386(id4567.3) printpiece=[VCMPUNORDSD]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:388 VCMPSD_mon: "VCMPNEQSD" is imm8=0x4 { }
0: Constructor line avx.sinc:388(id4567.4) printpiece=[VCMPNEQSD]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:390 VCMPSD_mon: "VCMPNLTSD" is imm8=0x5 { }
0: Constructor line avx.sinc:390(id4567.5) printpiece=[VCMPNLTSD]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:392 VCMPSD_mon: "VCMPNLESD" is imm8=0x6 { }
0: Constructor line avx.sinc:392(id4567.6) printpiece=[VCMPNLESD]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:394 VCMPSD_mon: "VCMPORDSD" is imm8=0x7 { }
0: Constructor line avx.sinc:394(id4567.7) printpiece=[VCMPORDSD]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:396 VCMPSD_mon: "VCMPEQ_UQSD" is imm8=0x8 { }
0: Constructor line avx.sinc:396(id4567.8) printpiece=[VCMPEQ_UQSD]
Operands 
Pattern id=8 pattern=ins:08:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:398 VCMPSD_mon: "VCMPNGESD" is imm8=0x9 { }
0: Constructor line avx.sinc:398(id4567.9) printpiece=[VCMPNGESD]
Operands 
Pattern id=9 pattern=ins:09:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:400 VCMPSD_mon: "VCMPNGTSD" is imm8=0xa { }
0: Constructor line avx.sinc:400(id4567.10) printpiece=[VCMPNGTSD]
Operands 
Pattern id=10 pattern=ins:0A:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:402 VCMPSD_mon: "VCMPFALSESD" is imm8=0xb { }
0: Constructor line avx.sinc:402(id4567.11) printpiece=[VCMPFALSESD]
Operands 
Pattern id=11 pattern=ins:0B:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:404 VCMPSD_mon: "VCMPNEQ_OQSD" is imm8=0xc { }
0: Constructor line avx.sinc:404(id4567.12) printpiece=[VCMPNEQ_OQSD]
Operands 
Pattern id=12 pattern=ins:0C:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:406 VCMPSD_mon: "VCMPGESD" is imm8=0xd { }
0: Constructor line avx.sinc:406(id4567.13) printpiece=[VCMPGESD]
Operands 
Pattern id=13 pattern=ins:0D:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:408 VCMPSD_mon: "VCMPGTSD" is imm8=0xe { }
0: Constructor line avx.sinc:408(id4567.14) printpiece=[VCMPGTSD]
Operands 
Pattern id=14 pattern=ins:0E:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:410 VCMPSD_mon: "VCMPTRUESD" is imm8=0xf { }
0: Constructor line avx.sinc:410(id4567.15) printpiece=[VCMPTRUESD]
Operands 
Pattern id=15 pattern=ins:0F:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:412 VCMPSD_mon: "VCMPEQ_OSSD" is imm8=0x10 { }
0: Constructor line avx.sinc:412(id4567.16) printpiece=[VCMPEQ_OSSD]
Operands 
Pattern id=16 pattern=ins:10:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:414 VCMPSD_mon: "VCMPLT_OQSD" is imm8=0x11 { }
0: Constructor line avx.sinc:414(id4567.17) printpiece=[VCMPLT_OQSD]
Operands 
Pattern id=17 pattern=ins:11:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:416 VCMPSD_mon: "VCMPLE_OQSD" is imm8=0x12 { }
0: Constructor line avx.sinc:416(id4567.18) printpiece=[VCMPLE_OQSD]
Operands 
Pattern id=18 pattern=ins:12:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:418 VCMPSD_mon: "VCMPUNORD_SSD" is imm8=0x13 { }
0: Constructor line avx.sinc:418(id4567.19) printpiece=[VCMPUNORD_SSD]
Operands 
Pattern id=19 pattern=ins:13:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:420 VCMPSD_mon: "VCMPNEQ_USSD" is imm8=0x14 { }
0: Constructor line avx.sinc:420(id4567.20) printpiece=[VCMPNEQ_USSD]
Operands 
Pattern id=20 pattern=ins:14:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:422 VCMPSD_mon: "VCMPNLT_UQSD" is imm8=0x15 { }
0: Constructor line avx.sinc:422(id4567.21) printpiece=[VCMPNLT_UQSD]
Operands 
Pattern id=21 pattern=ins:15:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:424 VCMPSD_mon: "VCMPNLE_UQSD" is imm8=0x16 { }
0: Constructor line avx.sinc:424(id4567.22) printpiece=[VCMPNLE_UQSD]
Operands 
Pattern id=22 pattern=ins:16:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:426 VCMPSD_mon: "VCMPORD_SSD" is imm8=0x17 { }
0: Constructor line avx.sinc:426(id4567.23) printpiece=[VCMPORD_SSD]
Operands 
Pattern id=23 pattern=ins:17:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:428 VCMPSD_mon: "VCMPEQ_USSD" is imm8=0x18 { }
0: Constructor line avx.sinc:428(id4567.24) printpiece=[VCMPEQ_USSD]
Operands 
Pattern id=24 pattern=ins:18:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:430 VCMPSD_mon: "VCMPNGE_UQSD" is imm8=0x19 { }
0: Constructor line avx.sinc:430(id4567.25) printpiece=[VCMPNGE_UQSD]
Operands 
Pattern id=25 pattern=ins:19:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:432 VCMPSD_mon: "VCMPNGT_UQSD" is imm8=0x1a { }
0: Constructor line avx.sinc:432(id4567.26) printpiece=[VCMPNGT_UQSD]
Operands 
Pattern id=26 pattern=ins:1A:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:434 VCMPSD_mon: "VCMPFALSE_OSSD" is imm8=0x1b { }
0: Constructor line avx.sinc:434(id4567.27) printpiece=[VCMPFALSE_OSSD]
Operands 
Pattern id=27 pattern=ins:1B:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:436 VCMPSD_mon: "VCMPNEQ_OSSD" is imm8=0x1c { }
0: Constructor line avx.sinc:436(id4567.28) printpiece=[VCMPNEQ_OSSD]
Operands 
Pattern id=28 pattern=ins:1C:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:438 VCMPSD_mon: "VCMPGE_OQSD" is imm8=0x1d { }
0: Constructor line avx.sinc:438(id4567.29) printpiece=[VCMPGE_OQSD]
Operands 
Pattern id=29 pattern=ins:1D:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:440 VCMPSD_mon: "VCMPGT_OQSD" is imm8=0x1e { }
0: Constructor line avx.sinc:440(id4567.30) printpiece=[VCMPGT_OQSD]
Operands 
Pattern id=30 pattern=ins:1E:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:442 VCMPSD_mon: "VCMPTRUE_USSD" is imm8=0x1f { }
0: Constructor line avx.sinc:442(id4567.31) printpiece=[VCMPTRUE_USSD]
Operands 
Pattern id=31 pattern=ins:1F:XX:XX:XX
Template

Line avx.sinc:444 VCMPSD_mon: "VCMPSD" is imm8 { }
1: Constructor line avx.sinc:444(id4567.32) printpiece=[VCMPSD]
Operands 0: imm8 : 4569  
Pattern id=32 pattern=always
Template

Line avx.sinc:381 VCMPSD_op: "" is imm8=0x0 { export 0x0:1; }
0: Constructor line avx.sinc:381(id4568.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:383 VCMPSD_op: "" is imm8=0x1 { export 0x1:1; }
0: Constructor line avx.sinc:383(id4568.1) printpiece=[]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:385 VCMPSD_op: "" is imm8=0x2 { export 0x2:1; }
0: Constructor line avx.sinc:385(id4568.2) printpiece=[]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:387 VCMPSD_op: "" is imm8=0x3 { export 0x3:1; }
0: Constructor line avx.sinc:387(id4568.3) printpiece=[]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:389 VCMPSD_op: "" is imm8=0x4 { export 0x4:1; }
0: Constructor line avx.sinc:389(id4568.4) printpiece=[]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:391 VCMPSD_op: "" is imm8=0x5 { export 0x5:1; }
0: Constructor line avx.sinc:391(id4568.5) printpiece=[]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:393 VCMPSD_op: "" is imm8=0x6 { export 0x6:1; }
0: Constructor line avx.sinc:393(id4568.6) printpiece=[]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:395 VCMPSD_op: "" is imm8=0x7 { export 0x7:1; }
0: Constructor line avx.sinc:395(id4568.7) printpiece=[]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:397 VCMPSD_op: "" is imm8=0x8 { export 0x8:1; }
0: Constructor line avx.sinc:397(id4568.8) printpiece=[]
Operands 
Pattern id=8 pattern=ins:08:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:399 VCMPSD_op: "" is imm8=0x9 { export 0x9:1; }
0: Constructor line avx.sinc:399(id4568.9) printpiece=[]
Operands 
Pattern id=9 pattern=ins:09:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:401 VCMPSD_op: "" is imm8=0xa { export 0xa:1; }
0: Constructor line avx.sinc:401(id4568.10) printpiece=[]
Operands 
Pattern id=10 pattern=ins:0A:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:403 VCMPSD_op: "" is imm8=0xb { export 0xb:1; }
0: Constructor line avx.sinc:403(id4568.11) printpiece=[]
Operands 
Pattern id=11 pattern=ins:0B:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:405 VCMPSD_op: "" is imm8=0xc { export 0xc:1; }
0: Constructor line avx.sinc:405(id4568.12) printpiece=[]
Operands 
Pattern id=12 pattern=ins:0C:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:407 VCMPSD_op: "" is imm8=0xd { export 0xd:1; }
0: Constructor line avx.sinc:407(id4568.13) printpiece=[]
Operands 
Pattern id=13 pattern=ins:0D:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:409 VCMPSD_op: "" is imm8=0xe { export 0xe:1; }
0: Constructor line avx.sinc:409(id4568.14) printpiece=[]
Operands 
Pattern id=14 pattern=ins:0E:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:411 VCMPSD_op: "" is imm8=0xf { export 0xf:1; }
0: Constructor line avx.sinc:411(id4568.15) printpiece=[]
Operands 
Pattern id=15 pattern=ins:0F:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:413 VCMPSD_op: "" is imm8=0x10 { export 0x10:1; }
0: Constructor line avx.sinc:413(id4568.16) printpiece=[]
Operands 
Pattern id=16 pattern=ins:10:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:415 VCMPSD_op: "" is imm8=0x11 { export 0x11:1; }
0: Constructor line avx.sinc:415(id4568.17) printpiece=[]
Operands 
Pattern id=17 pattern=ins:11:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:417 VCMPSD_op: "" is imm8=0x12 { export 0x12:1; }
0: Constructor line avx.sinc:417(id4568.18) printpiece=[]
Operands 
Pattern id=18 pattern=ins:12:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:419 VCMPSD_op: "" is imm8=0x13 { export 0x13:1; }
0: Constructor line avx.sinc:419(id4568.19) printpiece=[]
Operands 
Pattern id=19 pattern=ins:13:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:421 VCMPSD_op: "" is imm8=0x14 { export 0x14:1; }
0: Constructor line avx.sinc:421(id4568.20) printpiece=[]
Operands 
Pattern id=20 pattern=ins:14:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:423 VCMPSD_op: "" is imm8=0x15 { export 0x15:1; }
0: Constructor line avx.sinc:423(id4568.21) printpiece=[]
Operands 
Pattern id=21 pattern=ins:15:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:425 VCMPSD_op: "" is imm8=0x16 { export 0x16:1; }
0: Constructor line avx.sinc:425(id4568.22) printpiece=[]
Operands 
Pattern id=22 pattern=ins:16:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:427 VCMPSD_op: "" is imm8=0x17 { export 0x17:1; }
0: Constructor line avx.sinc:427(id4568.23) printpiece=[]
Operands 
Pattern id=23 pattern=ins:17:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:429 VCMPSD_op: "" is imm8=0x18 { export 0x18:1; }
0: Constructor line avx.sinc:429(id4568.24) printpiece=[]
Operands 
Pattern id=24 pattern=ins:18:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:431 VCMPSD_op: "" is imm8=0x19 { export 0x19:1; }
0: Constructor line avx.sinc:431(id4568.25) printpiece=[]
Operands 
Pattern id=25 pattern=ins:19:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:433 VCMPSD_op: "" is imm8=0x1a { export 0x1a:1; }
0: Constructor line avx.sinc:433(id4568.26) printpiece=[]
Operands 
Pattern id=26 pattern=ins:1A:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:435 VCMPSD_op: "" is imm8=0x1b { export 0x1b:1; }
0: Constructor line avx.sinc:435(id4568.27) printpiece=[]
Operands 
Pattern id=27 pattern=ins:1B:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:437 VCMPSD_op: "" is imm8=0x1c { export 0x1c:1; }
0: Constructor line avx.sinc:437(id4568.28) printpiece=[]
Operands 
Pattern id=28 pattern=ins:1C:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:439 VCMPSD_op: "" is imm8=0x1d { export 0x1d:1; }
0: Constructor line avx.sinc:439(id4568.29) printpiece=[]
Operands 
Pattern id=29 pattern=ins:1D:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:441 VCMPSD_op: "" is imm8=0x1e { export 0x1e:1; }
0: Constructor line avx.sinc:441(id4568.30) printpiece=[]
Operands 
Pattern id=30 pattern=ins:1E:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:443 VCMPSD_op: "" is imm8=0x1f { export 0x1f:1; }
0: Constructor line avx.sinc:443(id4568.31) printpiece=[]
Operands 
Pattern id=31 pattern=ins:1F:XX:XX:XX
Template

Line avx.sinc:445 VCMPSD_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:445(id4568.32) printpiece=[, ,  A]
Operands 0: imm8 : 4570  
Pattern id=32 pattern=always
Template

Line avx.sinc:455 VCMPSS_mon: "VCMPEQSS" is imm8=0x0 { }
0: Constructor line avx.sinc:455(id4579.0) printpiece=[VCMPEQSS]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:457 VCMPSS_mon: "VCMPLTSS" is imm8=0x1 { }
0: Constructor line avx.sinc:457(id4579.1) printpiece=[VCMPLTSS]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:459 VCMPSS_mon: "VCMPLESS" is imm8=0x2 { }
0: Constructor line avx.sinc:459(id4579.2) printpiece=[VCMPLESS]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:461 VCMPSS_mon: "VCMPUNORDSS" is imm8=0x3 { }
0: Constructor line avx.sinc:461(id4579.3) printpiece=[VCMPUNORDSS]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:463 VCMPSS_mon: "VCMPNEQSS" is imm8=0x4 { }
0: Constructor line avx.sinc:463(id4579.4) printpiece=[VCMPNEQSS]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:465 VCMPSS_mon: "VCMPNLTSS" is imm8=0x5 { }
0: Constructor line avx.sinc:465(id4579.5) printpiece=[VCMPNLTSS]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:467 VCMPSS_mon: "VCMPNLESS" is imm8=0x6 { }
0: Constructor line avx.sinc:467(id4579.6) printpiece=[VCMPNLESS]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:469 VCMPSS_mon: "VCMPORDSS" is imm8=0x7 { }
0: Constructor line avx.sinc:469(id4579.7) printpiece=[VCMPORDSS]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:471 VCMPSS_mon: "VCMPEQ_UQSS" is imm8=0x8 { }
0: Constructor line avx.sinc:471(id4579.8) printpiece=[VCMPEQ_UQSS]
Operands 
Pattern id=8 pattern=ins:08:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:473 VCMPSS_mon: "VCMPNGESS" is imm8=0x9 { }
0: Constructor line avx.sinc:473(id4579.9) printpiece=[VCMPNGESS]
Operands 
Pattern id=9 pattern=ins:09:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:475 VCMPSS_mon: "VCMPNGTSS" is imm8=0xa { }
0: Constructor line avx.sinc:475(id4579.10) printpiece=[VCMPNGTSS]
Operands 
Pattern id=10 pattern=ins:0A:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:477 VCMPSS_mon: "VCMPFALSESS" is imm8=0xb { }
0: Constructor line avx.sinc:477(id4579.11) printpiece=[VCMPFALSESS]
Operands 
Pattern id=11 pattern=ins:0B:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:479 VCMPSS_mon: "VCMPNEQ_OQSS" is imm8=0xc { }
0: Constructor line avx.sinc:479(id4579.12) printpiece=[VCMPNEQ_OQSS]
Operands 
Pattern id=12 pattern=ins:0C:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:481 VCMPSS_mon: "VCMPGESS" is imm8=0xd { }
0: Constructor line avx.sinc:481(id4579.13) printpiece=[VCMPGESS]
Operands 
Pattern id=13 pattern=ins:0D:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:483 VCMPSS_mon: "VCMPGTSS" is imm8=0xe { }
0: Constructor line avx.sinc:483(id4579.14) printpiece=[VCMPGTSS]
Operands 
Pattern id=14 pattern=ins:0E:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:485 VCMPSS_mon: "VCMPTRUESS" is imm8=0xf { }
0: Constructor line avx.sinc:485(id4579.15) printpiece=[VCMPTRUESS]
Operands 
Pattern id=15 pattern=ins:0F:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:487 VCMPSS_mon: "VCMPEQ_OSSS" is imm8=0x10 { }
0: Constructor line avx.sinc:487(id4579.16) printpiece=[VCMPEQ_OSSS]
Operands 
Pattern id=16 pattern=ins:10:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:489 VCMPSS_mon: "VCMPLT_OQSS" is imm8=0x11 { }
0: Constructor line avx.sinc:489(id4579.17) printpiece=[VCMPLT_OQSS]
Operands 
Pattern id=17 pattern=ins:11:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:491 VCMPSS_mon: "VCMPLE_OQSS" is imm8=0x12 { }
0: Constructor line avx.sinc:491(id4579.18) printpiece=[VCMPLE_OQSS]
Operands 
Pattern id=18 pattern=ins:12:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:493 VCMPSS_mon: "VCMPUNORD_SSS" is imm8=0x13 { }
0: Constructor line avx.sinc:493(id4579.19) printpiece=[VCMPUNORD_SSS]
Operands 
Pattern id=19 pattern=ins:13:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:495 VCMPSS_mon: "VCMPNEQ_USSS" is imm8=0x14 { }
0: Constructor line avx.sinc:495(id4579.20) printpiece=[VCMPNEQ_USSS]
Operands 
Pattern id=20 pattern=ins:14:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:497 VCMPSS_mon: "VCMPNLT_UQSS" is imm8=0x15 { }
0: Constructor line avx.sinc:497(id4579.21) printpiece=[VCMPNLT_UQSS]
Operands 
Pattern id=21 pattern=ins:15:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:499 VCMPSS_mon: "VCMPNLE_UQSS" is imm8=0x16 { }
0: Constructor line avx.sinc:499(id4579.22) printpiece=[VCMPNLE_UQSS]
Operands 
Pattern id=22 pattern=ins:16:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:501 VCMPSS_mon: "VCMPORD_SSS" is imm8=0x17 { }
0: Constructor line avx.sinc:501(id4579.23) printpiece=[VCMPORD_SSS]
Operands 
Pattern id=23 pattern=ins:17:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:503 VCMPSS_mon: "VCMPEQ_USSS" is imm8=0x18 { }
0: Constructor line avx.sinc:503(id4579.24) printpiece=[VCMPEQ_USSS]
Operands 
Pattern id=24 pattern=ins:18:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:505 VCMPSS_mon: "VCMPNGE_UQSS" is imm8=0x19 { }
0: Constructor line avx.sinc:505(id4579.25) printpiece=[VCMPNGE_UQSS]
Operands 
Pattern id=25 pattern=ins:19:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:507 VCMPSS_mon: "VCMPNGT_UQSS" is imm8=0x1a { }
0: Constructor line avx.sinc:507(id4579.26) printpiece=[VCMPNGT_UQSS]
Operands 
Pattern id=26 pattern=ins:1A:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:509 VCMPSS_mon: "VCMPFALSE_OSSS" is imm8=0x1b { }
0: Constructor line avx.sinc:509(id4579.27) printpiece=[VCMPFALSE_OSSS]
Operands 
Pattern id=27 pattern=ins:1B:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:511 VCMPSS_mon: "VCMPNEQ_OSSS" is imm8=0x1c { }
0: Constructor line avx.sinc:511(id4579.28) printpiece=[VCMPNEQ_OSSS]
Operands 
Pattern id=28 pattern=ins:1C:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:513 VCMPSS_mon: "VCMPGE_OQSS" is imm8=0x1d { }
0: Constructor line avx.sinc:513(id4579.29) printpiece=[VCMPGE_OQSS]
Operands 
Pattern id=29 pattern=ins:1D:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:515 VCMPSS_mon: "VCMPGT_OQSS" is imm8=0x1e { }
0: Constructor line avx.sinc:515(id4579.30) printpiece=[VCMPGT_OQSS]
Operands 
Pattern id=30 pattern=ins:1E:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:517 VCMPSS_mon: "VCMPTRUE_USSS" is imm8=0x1f { }
0: Constructor line avx.sinc:517(id4579.31) printpiece=[VCMPTRUE_USSS]
Operands 
Pattern id=31 pattern=ins:1F:XX:XX:XX
Template

Line avx.sinc:519 VCMPSS_mon: "VCMPSS" is imm8 { }
1: Constructor line avx.sinc:519(id4579.32) printpiece=[VCMPSS]
Operands 0: imm8 : 4581  
Pattern id=32 pattern=always
Template

Line avx.sinc:456 VCMPSS_op: "" is imm8=0x0 { export 0x0:1; }
0: Constructor line avx.sinc:456(id4580.0) printpiece=[]
Operands 
Pattern id=0 pattern=ins:00:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:458 VCMPSS_op: "" is imm8=0x1 { export 0x1:1; }
0: Constructor line avx.sinc:458(id4580.1) printpiece=[]
Operands 
Pattern id=1 pattern=ins:01:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:460 VCMPSS_op: "" is imm8=0x2 { export 0x2:1; }
0: Constructor line avx.sinc:460(id4580.2) printpiece=[]
Operands 
Pattern id=2 pattern=ins:02:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:462 VCMPSS_op: "" is imm8=0x3 { export 0x3:1; }
0: Constructor line avx.sinc:462(id4580.3) printpiece=[]
Operands 
Pattern id=3 pattern=ins:03:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:464 VCMPSS_op: "" is imm8=0x4 { export 0x4:1; }
0: Constructor line avx.sinc:464(id4580.4) printpiece=[]
Operands 
Pattern id=4 pattern=ins:04:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:466 VCMPSS_op: "" is imm8=0x5 { export 0x5:1; }
0: Constructor line avx.sinc:466(id4580.5) printpiece=[]
Operands 
Pattern id=5 pattern=ins:05:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:468 VCMPSS_op: "" is imm8=0x6 { export 0x6:1; }
0: Constructor line avx.sinc:468(id4580.6) printpiece=[]
Operands 
Pattern id=6 pattern=ins:06:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:470 VCMPSS_op: "" is imm8=0x7 { export 0x7:1; }
0: Constructor line avx.sinc:470(id4580.7) printpiece=[]
Operands 
Pattern id=7 pattern=ins:07:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:472 VCMPSS_op: "" is imm8=0x8 { export 0x8:1; }
0: Constructor line avx.sinc:472(id4580.8) printpiece=[]
Operands 
Pattern id=8 pattern=ins:08:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:474 VCMPSS_op: "" is imm8=0x9 { export 0x9:1; }
0: Constructor line avx.sinc:474(id4580.9) printpiece=[]
Operands 
Pattern id=9 pattern=ins:09:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:476 VCMPSS_op: "" is imm8=0xa { export 0xa:1; }
0: Constructor line avx.sinc:476(id4580.10) printpiece=[]
Operands 
Pattern id=10 pattern=ins:0A:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:478 VCMPSS_op: "" is imm8=0xb { export 0xb:1; }
0: Constructor line avx.sinc:478(id4580.11) printpiece=[]
Operands 
Pattern id=11 pattern=ins:0B:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:480 VCMPSS_op: "" is imm8=0xc { export 0xc:1; }
0: Constructor line avx.sinc:480(id4580.12) printpiece=[]
Operands 
Pattern id=12 pattern=ins:0C:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:482 VCMPSS_op: "" is imm8=0xd { export 0xd:1; }
0: Constructor line avx.sinc:482(id4580.13) printpiece=[]
Operands 
Pattern id=13 pattern=ins:0D:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:484 VCMPSS_op: "" is imm8=0xe { export 0xe:1; }
0: Constructor line avx.sinc:484(id4580.14) printpiece=[]
Operands 
Pattern id=14 pattern=ins:0E:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:486 VCMPSS_op: "" is imm8=0xf { export 0xf:1; }
0: Constructor line avx.sinc:486(id4580.15) printpiece=[]
Operands 
Pattern id=15 pattern=ins:0F:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:488 VCMPSS_op: "" is imm8=0x10 { export 0x10:1; }
0: Constructor line avx.sinc:488(id4580.16) printpiece=[]
Operands 
Pattern id=16 pattern=ins:10:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:490 VCMPSS_op: "" is imm8=0x11 { export 0x11:1; }
0: Constructor line avx.sinc:490(id4580.17) printpiece=[]
Operands 
Pattern id=17 pattern=ins:11:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:492 VCMPSS_op: "" is imm8=0x12 { export 0x12:1; }
0: Constructor line avx.sinc:492(id4580.18) printpiece=[]
Operands 
Pattern id=18 pattern=ins:12:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:494 VCMPSS_op: "" is imm8=0x13 { export 0x13:1; }
0: Constructor line avx.sinc:494(id4580.19) printpiece=[]
Operands 
Pattern id=19 pattern=ins:13:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:496 VCMPSS_op: "" is imm8=0x14 { export 0x14:1; }
0: Constructor line avx.sinc:496(id4580.20) printpiece=[]
Operands 
Pattern id=20 pattern=ins:14:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:498 VCMPSS_op: "" is imm8=0x15 { export 0x15:1; }
0: Constructor line avx.sinc:498(id4580.21) printpiece=[]
Operands 
Pattern id=21 pattern=ins:15:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:500 VCMPSS_op: "" is imm8=0x16 { export 0x16:1; }
0: Constructor line avx.sinc:500(id4580.22) printpiece=[]
Operands 
Pattern id=22 pattern=ins:16:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:502 VCMPSS_op: "" is imm8=0x17 { export 0x17:1; }
0: Constructor line avx.sinc:502(id4580.23) printpiece=[]
Operands 
Pattern id=23 pattern=ins:17:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:504 VCMPSS_op: "" is imm8=0x18 { export 0x18:1; }
0: Constructor line avx.sinc:504(id4580.24) printpiece=[]
Operands 
Pattern id=24 pattern=ins:18:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:506 VCMPSS_op: "" is imm8=0x19 { export 0x19:1; }
0: Constructor line avx.sinc:506(id4580.25) printpiece=[]
Operands 
Pattern id=25 pattern=ins:19:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:508 VCMPSS_op: "" is imm8=0x1a { export 0x1a:1; }
0: Constructor line avx.sinc:508(id4580.26) printpiece=[]
Operands 
Pattern id=26 pattern=ins:1A:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:510 VCMPSS_op: "" is imm8=0x1b { export 0x1b:1; }
0: Constructor line avx.sinc:510(id4580.27) printpiece=[]
Operands 
Pattern id=27 pattern=ins:1B:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:512 VCMPSS_op: "" is imm8=0x1c { export 0x1c:1; }
0: Constructor line avx.sinc:512(id4580.28) printpiece=[]
Operands 
Pattern id=28 pattern=ins:1C:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:514 VCMPSS_op: "" is imm8=0x1d { export 0x1d:1; }
0: Constructor line avx.sinc:514(id4580.29) printpiece=[]
Operands 
Pattern id=29 pattern=ins:1D:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:516 VCMPSS_op: "" is imm8=0x1e { export 0x1e:1; }
0: Constructor line avx.sinc:516(id4580.30) printpiece=[]
Operands 
Pattern id=30 pattern=ins:1E:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line avx.sinc:518 VCMPSS_op: "" is imm8=0x1f { export 0x1f:1; }
0: Constructor line avx.sinc:518(id4580.31) printpiece=[]
Operands 
Pattern id=31 pattern=ins:1F:XX:XX:XX
Template

Line avx.sinc:520 VCMPSS_op: ", "^imm8 is imm8 { export *[const]:1 imm8; }
1: Constructor line avx.sinc:520(id4580.32) printpiece=[, ,  A]
Operands 0: imm8 : 4582  
Pattern id=32 pattern=always
Template

Line mpx.sinc:37 bndmk_addr32: [imm32]							is mod=0 & r_m=4; index=4 & base=5; imm32		{ tmp:4 = 0; export tmp; }
0: Constructor line mpx.sinc:37(id7028.9) printpiece=[[,  A, ]]
Operands 0: imm32 : 7044  
Pattern id=9 pattern=ins:[00xx][x100]:[xx10]5:XX:XX
Template
	0: unique[cb700:4] = COPY const[0:4]

Line mpx.sinc:35 bndmk_addr32: [Base]							is mod=0 & r_m=4; index=4 & Base				{ export Base; }
1: Constructor line mpx.sinc:35(id7028.7) printpiece=[[,  A, ]]
Operands 0: Base : 7040  
Pattern id=7 pattern=ins:[00xx][x100]:[xx10][0xxx]:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:36 bndmk_addr32: [imm32 + Index*ss]				is mod=0 & r_m=4; Index & base=5 & ss; imm32	{ tmp:4 = 0; export tmp; }
2: Constructor line mpx.sinc:36(id7028.8) printpiece=[[,  C,  , +,  ,  A, *,  B, ]]
Operands 0: Index : 7042  1: ss : 7043  2: imm32 : 7041  
Pattern id=8 pattern=ins:[00xx][x100]:X[x101]:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: unique[cb680:4] = COPY const[0:4]

Line mpx.sinc:34 bndmk_addr32: [Base + Index*ss]					is mod=0 & r_m=4; Index & Base & ss				{ export Base; }
3: Constructor line mpx.sinc:34(id7028.6) printpiece=[[,  B,  , +,  ,  A, *,  C, ]]
Operands 0: Index : 7038  1: Base : 7037  2: ss : 7039  
Pattern id=6 pattern=ins:[00xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line mpx.sinc:28 bndmk_addr32: [Rmr32]							is mod=0 & Rmr32								{ export Rmr32; }
4: Constructor line mpx.sinc:28(id7028.0) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7029  
Pattern id=0 pattern=ins:[00xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:33 bndmk_addr32: [imm32]							is mod=0 & r_m=5; imm32							{ tmp:4 = 0; export tmp; }
0: Constructor line mpx.sinc:33(id7028.5) printpiece=[[,  A, ]]
Operands 0: imm32 : 7036  
Pattern id=5 pattern=ins:[00xx][x101]:XX:XX:XX
Template
	0: unique[cb600:4] = COPY const[0:4]

Line mpx.sinc:28 bndmk_addr32: [Rmr32]							is mod=0 & Rmr32								{ export Rmr32; }
1: Constructor line mpx.sinc:28(id7028.0) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7029  
Pattern id=0 pattern=ins:[00xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:30 bndmk_addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0				{ export Rmr32; }
0: Constructor line mpx.sinc:30(id7028.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7032  
Pattern id=2 pattern=ins:[01xx][x000]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:29 bndmk_addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32						{ export Rmr32; }
1: Constructor line mpx.sinc:29(id7028.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 7030  1: simm8_32 : 7031  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line mpx.sinc:30 bndmk_addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0				{ export Rmr32; }
0: Constructor line mpx.sinc:30(id7028.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7032  
Pattern id=2 pattern=ins:[01xx][x001]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:29 bndmk_addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32						{ export Rmr32; }
1: Constructor line mpx.sinc:29(id7028.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 7030  1: simm8_32 : 7031  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line mpx.sinc:30 bndmk_addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0				{ export Rmr32; }
0: Constructor line mpx.sinc:30(id7028.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7032  
Pattern id=2 pattern=ins:[01xx][x010]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:29 bndmk_addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32						{ export Rmr32; }
1: Constructor line mpx.sinc:29(id7028.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 7030  1: simm8_32 : 7031  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line mpx.sinc:30 bndmk_addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0				{ export Rmr32; }
0: Constructor line mpx.sinc:30(id7028.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7032  
Pattern id=2 pattern=ins:[01xx][x011]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:29 bndmk_addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32						{ export Rmr32; }
1: Constructor line mpx.sinc:29(id7028.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 7030  1: simm8_32 : 7031  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line mpx.sinc:41 bndmk_addr32: [Base]							is mod=1 & r_m=4; index=4 & Base; simm8=0		{ export Base; }
0: Constructor line mpx.sinc:41(id7028.13) printpiece=[[,  A, ]]
Operands 0: Base : 7054  
Pattern id=13 pattern=ins:[01xx][x100]:[xx10][0xxx]:00:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:39 bndmk_addr32: [Base + simm8_32]					is mod=1 & r_m=4; index=4 & Base; simm8_32		{ export Base; }
1: Constructor line mpx.sinc:39(id7028.11) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Base : 7049  1: simm8_32 : 7050  
Pattern id=11 pattern=ins:[01xx][x100]:[xx10][0xxx]:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line mpx.sinc:40 bndmk_addr32: [Base + Index*ss]					is mod=1 & r_m=4; Index & Base & ss; simm8=0	{ export Base; }
2: Constructor line mpx.sinc:40(id7028.12) printpiece=[[,  B,  , +,  ,  A, *,  C, ]]
Operands 0: Index : 7052  1: Base : 7051  2: ss : 7053  
Pattern id=12 pattern=ins:[01xx][x100]:XX:00:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line mpx.sinc:38 bndmk_addr32: [Base + Index*ss + simm8_32]		is mod=1 & r_m=4; Index & Base & ss; simm8_32	{ export Base; }
3: Constructor line mpx.sinc:38(id7028.10) printpiece=[[,  B,  , +,  ,  A, *,  C,  , +,  ,  D, ]]
Operands 0: Index : 7046  1: Base : 7045  2: ss : 7047  3: simm8_32 : 7048  
Pattern id=10 pattern=ins:[01xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[3:4]
	1: MULTIEQUAL const[0:4]
	2: MULTIEQUAL const[1:4]

Line mpx.sinc:29 bndmk_addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32						{ export Rmr32; }
4: Constructor line mpx.sinc:29(id7028.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 7030  1: simm8_32 : 7031  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line mpx.sinc:30 bndmk_addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0				{ export Rmr32; }
0: Constructor line mpx.sinc:30(id7028.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7032  
Pattern id=2 pattern=ins:[01xx][x101]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:29 bndmk_addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32						{ export Rmr32; }
1: Constructor line mpx.sinc:29(id7028.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 7030  1: simm8_32 : 7031  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line mpx.sinc:30 bndmk_addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0				{ export Rmr32; }
0: Constructor line mpx.sinc:30(id7028.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7032  
Pattern id=2 pattern=ins:[01xx][x110]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:29 bndmk_addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32						{ export Rmr32; }
1: Constructor line mpx.sinc:29(id7028.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 7030  1: simm8_32 : 7031  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line mpx.sinc:30 bndmk_addr32: [Rmr32]							is mod=1 & r_m!=4 & Rmr32; simm8=0				{ export Rmr32; }
0: Constructor line mpx.sinc:30(id7028.2) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7032  
Pattern id=2 pattern=ins:[01xx][x111]:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:29 bndmk_addr32: [Rmr32 + simm8_32]				is mod=1 & Rmr32; simm8_32						{ export Rmr32; }
1: Constructor line mpx.sinc:29(id7028.1) printpiece=[[,  A,  , +,  ,  B, ]]
Operands 0: Rmr32 : 7030  1: simm8_32 : 7031  
Pattern id=1 pattern=ins:[01xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[1:4]
	1: MULTIEQUAL const[0:4]

Line mpx.sinc:32 bndmk_addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0				{ export Rmr32; }
0: Constructor line mpx.sinc:32(id7028.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7035  
Pattern id=4 pattern=ins:[10xx][x000]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:31 bndmk_addr32: [imm32 + Rmr32]					is mod=2 & Rmr32; imm32							{ export Rmr32; }
1: Constructor line mpx.sinc:31(id7028.3) printpiece=[[,  B,  , +,  ,  A, ]]
Operands 0: Rmr32 : 7034  1: imm32 : 7033  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:32 bndmk_addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0				{ export Rmr32; }
0: Constructor line mpx.sinc:32(id7028.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7035  
Pattern id=4 pattern=ins:[10xx][x001]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:31 bndmk_addr32: [imm32 + Rmr32]					is mod=2 & Rmr32; imm32							{ export Rmr32; }
1: Constructor line mpx.sinc:31(id7028.3) printpiece=[[,  B,  , +,  ,  A, ]]
Operands 0: Rmr32 : 7034  1: imm32 : 7033  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:32 bndmk_addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0				{ export Rmr32; }
0: Constructor line mpx.sinc:32(id7028.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7035  
Pattern id=4 pattern=ins:[10xx][x010]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:31 bndmk_addr32: [imm32 + Rmr32]					is mod=2 & Rmr32; imm32							{ export Rmr32; }
1: Constructor line mpx.sinc:31(id7028.3) printpiece=[[,  B,  , +,  ,  A, ]]
Operands 0: Rmr32 : 7034  1: imm32 : 7033  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:32 bndmk_addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0				{ export Rmr32; }
0: Constructor line mpx.sinc:32(id7028.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7035  
Pattern id=4 pattern=ins:[10xx][x011]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:31 bndmk_addr32: [imm32 + Rmr32]					is mod=2 & Rmr32; imm32							{ export Rmr32; }
1: Constructor line mpx.sinc:31(id7028.3) printpiece=[[,  B,  , +,  ,  A, ]]
Operands 0: Rmr32 : 7034  1: imm32 : 7033  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:45 bndmk_addr32: [Base]							is mod=2 & r_m=4; index=4 & Base; imm32=0		{ export Base; }
0: Constructor line mpx.sinc:45(id7028.17) printpiece=[[,  A, ]]
Operands 0: Base : 7064  
Pattern id=17 pattern=ins:[10xx][x100]:[xx10][0xxx]:00:00:00:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:43 bndmk_addr32: [imm32 + Base]					is mod=2 & r_m=4; index=4 & Base; imm32			{ export Base; }
1: Constructor line mpx.sinc:43(id7028.15) printpiece=[[,  B,  , +,  ,  A, ]]
Operands 0: Base : 7060  1: imm32 : 7059  
Pattern id=15 pattern=ins:[10xx][x100]:[xx10][0xxx]:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:44 bndmk_addr32: [Base + Index*ss]					is mod=2 & r_m=4; Index & Base & ss; imm32=0	{ export Base; }
2: Constructor line mpx.sinc:44(id7028.16) printpiece=[[,  B,  , +,  ,  A, *,  C, ]]
Operands 0: Index : 7062  1: Base : 7061  2: ss : 7063  
Pattern id=16 pattern=ins:[10xx][x100]:XX:00:00:00:00:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line mpx.sinc:42 bndmk_addr32: [imm32 + Base + Index*ss]			is mod=2 & r_m=4; Index & Base & ss; imm32		{ export Base; }
3: Constructor line mpx.sinc:42(id7028.14) printpiece=[[,  D,  , +,  ,  B,  , +,  ,  A, *,  C, ]]
Operands 0: Index : 7057  1: Base : 7056  2: ss : 7058  3: imm32 : 7055  
Pattern id=14 pattern=ins:[10xx][x100]:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
	1: MULTIEQUAL const[1:4]

Line mpx.sinc:31 bndmk_addr32: [imm32 + Rmr32]					is mod=2 & Rmr32; imm32							{ export Rmr32; }
4: Constructor line mpx.sinc:31(id7028.3) printpiece=[[,  B,  , +,  ,  A, ]]
Operands 0: Rmr32 : 7034  1: imm32 : 7033  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:32 bndmk_addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0				{ export Rmr32; }
0: Constructor line mpx.sinc:32(id7028.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7035  
Pattern id=4 pattern=ins:[10xx][x101]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:31 bndmk_addr32: [imm32 + Rmr32]					is mod=2 & Rmr32; imm32							{ export Rmr32; }
1: Constructor line mpx.sinc:31(id7028.3) printpiece=[[,  B,  , +,  ,  A, ]]
Operands 0: Rmr32 : 7034  1: imm32 : 7033  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:32 bndmk_addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0				{ export Rmr32; }
0: Constructor line mpx.sinc:32(id7028.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7035  
Pattern id=4 pattern=ins:[10xx][x110]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:31 bndmk_addr32: [imm32 + Rmr32]					is mod=2 & Rmr32; imm32							{ export Rmr32; }
1: Constructor line mpx.sinc:31(id7028.3) printpiece=[[,  B,  , +,  ,  A, ]]
Operands 0: Rmr32 : 7034  1: imm32 : 7033  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:32 bndmk_addr32: [Rmr32]							is mod=2 & r_m!=4 & Rmr32; imm32=0				{ export Rmr32; }
0: Constructor line mpx.sinc:32(id7028.4) printpiece=[[,  A, ]]
Operands 0: Rmr32 : 7035  
Pattern id=4 pattern=ins:[10xx][x111]:00:00:00:00:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]

Line mpx.sinc:31 bndmk_addr32: [imm32 + Rmr32]					is mod=2 & Rmr32; imm32							{ export Rmr32; }
1: Constructor line mpx.sinc:31(id7028.3) printpiece=[[,  B,  , +,  ,  A, ]]
Operands 0: Rmr32 : 7034  1: imm32 : 7033  
Pattern id=3 pattern=ins:[10xx]X:XX:XX:XX
Template
	0: MULTIEQUAL const[0:4]
